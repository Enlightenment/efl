import elm_general;
import efl_input_types;

function Efl.Ui.Scrollable_On_Show_Region
{
   params {
      @in obj: Efl.Canvas.Object;
      @in region: Eina.Rectangle;
   }
};

enum Elm.Activate
{
   [[ Used in 'Virtual' function @Elm.Widget.activate. ]]
   default = 0, [[Activate default]]
   up, [[Activate up]]
   down, [[Activate down]]
   right, [[Activate right]]
   left, [[Activate left]]
   back, [[Activate back]]
}

struct @extern Elm.Theme; [[Elementary theme]]

abstract Elm.Widget (Efl.Canvas.Group, Elm.Interface.Atspi_Accessible,
                     Elm.Interface.Atspi_Component, Efl.Ui.Focus.User,
                     Efl.Ui.Focus.Object, Efl.Ui.Base, Efl.Ui.Cursor)
{
   [[Elementary widget abstract class]]
   legacy_prefix: elm_widget;
   eo_prefix: elm_obj_widget;
   event_prefix: elm_widget;
   data: Elm_Widget_Smart_Data;
   methods {
      @property resize_object @protected {
         [[This is the internal canvas object managed by a widget.

           This property is protected as it is meant for widget implementations
           only, to set and access the internal canvas object. Do use this
           function unless you're implementing a widget.
         ]]
         set {
            [[Sets the new resize object for this widget.]]
         }
         values {
            sobj: Efl.Canvas.Object @nullable;
               [[A canvas object (often a $Efl.Canvas.Layout object).]]
         }
      }
      @property disabled {
         [[Whether the widget is enabled (accepts and reacts to user inputs).

           Each widget may handle the disabled state differently, but overall
           disabled widgets shall not respond to any input events. This is
           $false by default, meaning the widget is enabled.
         ]]
         set {
            [[Enables or disables this widget.

              Disabling a widget will disable all its children recursively,
              but only this widget will be marked as disabled internally.
            ]]
         }
         get {
            [[Returns whether the widget is disabled.

              This will return $true if any widget in the parent hierarchy
              is disabled. Re-enabling that parent may in turn change the
              disabled state of this widget.
            ]]
         }
         values {
            disabled: bool(false); [[$true if the widget is disabled.]]
         }
      }
      @property style {
         [[The widget style to use.

           Styles define different look and feel for widgets, and may provide
           different parts for layout-based widgets. Styles vary from widget
           to widget and may be defined by other themes by means of extensions
           and overlays.

           The style can only be set before @Efl.Object.finalize, which means
           at construction time of the object (inside $efl_add in C).
         ]]
         set @protected {
            [[Can only be called during construction, before finalize.]]
            return: Efl.Ui.Theme.Apply(0);
               [[Whether the style was successfully applied or not, see
                 the values of @Efl.Ui.Theme.Apply for more information.]]
         }
         get {
            [[Returns the current style of a widget.]]
         }
         values {
            style: string;
               [[Name of the style to use. Refer to each widget's documentation
                 for the available style names, or to the themes in use.]]
         }
      }
      widget_event @protected {
         [[Virtual function handling input events on the widget.

           This method should return $true if the event has been processed.
           Only key down, key up and pointer wheel events will be propagated
           through this function.

           It is common for the event to be also marked as processed as in
           @Efl.Input.Event.processed, if this operation was successful. This
           makes sure other widgets will not also process this input event.
         ]]
         params {
            @in eo_event: const(ptr(Efl.Event));
               [[EO event struct with an Efl.Input.Event as info.]]
            @in source: Efl.Canvas.Object;
               [[Source object where the event originated. Often same as this.]]
         }
         return: bool; [[$true on success, $false otherwise]]
         legacy: null;
      }
      @property orientation_mode_disabled {
         [[Whether the widget's automatic orientation is disabled or not.

           Orientation mode is used for widgets to change their style or send
           signals based on the canvas rotation (i.e. the window orientation).
           If the orientation mode is enabled, the widget will emit signals
           such as "elm,state,orient,N" where $N is one of 0, 90, 180, 270,
           depending on the window orientation. Such signals may be handled by
           the theme in order to provide a different look for the widget based
           on the canvas orientation.

           By default orientation mode is enabled, which means this property
           is $false.
         ]]
         values {
            disabled: bool(false); [[$true if the orientation mode is disabled.]]
         }
      }
      // FIXME: This property may be simply removed from EO (replaced by focus manager stuff)
      @property focus {
         [[Whether the object is focused for inputs.

           If an object is focused it will be the first to receive keyboard
           inputs. Only visible, non-disabled objects can be focused.

           Focus can be disabled by setting @.focus_allow to $false.
         ]]
         set {
            [[Set or unsets the focus on this widget.

              Note: When you set focus to this object, if it can handle focus,
              will take the focus away from the one who had it previously and
              will, for now on, be the one receiving input events. Unsetting
              focus will remove the focus from this object, passing it back to
              the previous element as defined by the focus manager policy.
            ]]
         }
         get {
            [[Gets whether this object is currently focused.]]
         }
         values {
            focus: bool(false); [[Whether the object is focused.]]
         }
      }
      // FIXME: focus_allow? can_focus? focusable?
      @property focus_allow {
         [[The ability for a widget to be focused.

           Unfocusable objects do nothing when programmatically focused. The
           nearest focusable parent object the one really getting focus. Also,
           when they receive mouse input, they will get the event, but not take
           away the focus from where it was previously.

           Note: Objects which are meant to be interacted with by input events
           are created able to be focused, by default. All the others are not.

           This property's default value depends on the widget (eg. a box is
           not focusable, but a button is).
         ]]
         set {
            legacy: elm_widget_can_focus_set;
         }
         get {
            legacy: elm_widget_can_focus_get;
         }
         values {
            can_focus: bool; [[Whether the object is focusable.]]
         }
      }
      @property widget_parent @protected {
         [[The internal parent of this widget.

           @Elm.Widget objects have a parent hierarchy that may differ slightly
           from their @Efl.Object or @Efl.Canvas.Object hierarchy. This is
           meant for internal handling.

           See also @.widget_top.
         ]]
         set {}
         get {
            legacy: elm_widget_parent_get; /* internal in legacy */
         }
         values {
            parent: Elm.Widget @nullable; [[Widget parent object]]
         }
      }
      @property widget_top {
         [[Root widget in the widget hierarchy.

           This returns the top widget, in terms of widget hierarchy. This is
           usually a window ($Efl.Ui.Win). This function walks the list of
           @.widget_parent.

           If this widget has no parent (in terms of widget hierarchy) this
           will return $null.

           Note: This may not be a display manager window in case of nested
           canvases. If a "real" window is required, then you might want to
           verify that the returned object is a $Efl.Ui.Win_Inlined, and then
           get $Efl.Ui.Win_Inlined.inlined_parent to find an object in the
           master window.

           See also @.widget_parent.
         ]]
         get {
            legacy: elm_widget_top_get; /* internal in legacy */
         }
         values {
            top: Elm.Widget; [[Top widget, usually a window.]]
         }
      }

      /* Theme API: Not bound to EO */
      @property theme @beta {
      	 [[Widget theme]]
         values {
            th: ptr(Elm.Theme) @nullable; [[Elementary theme]]
         }
      }
      @property theme_object @beta {
      	 [[Theme object property]]
         set {
            return: Efl.Ui.Theme.Apply; [[Theme apply]]
         }
         values {
            edj: Efl.Canvas.Object; [[Edje object]]
            wname: string; [[Widget name]]
            welement: string; [[Widget element]]
            wstyle: string; [[Widget style]]
         }
      }

      /* Accessibility */
      @property access_info {
         [[Accessibility information]]
         values {
            txt: string @nullable; [[Accessibility text description]]
         }
      }

      /* Drag API */
      @property drag_lock_x {
         [[Drag lock on X axis]]
         values {
            lock: bool; [[$true if drag is locked on X axis, $false otherwise]]
         }
      }
      @property drag_lock_y {
         [[Lock the Y axis from being dragged]]
         values {
            lock: bool; [[$true if the Y axis is locked, $false otherwise]]
         }
      }
      @property drag_child_locked_x {
      	 [[Drag child locked X axis]]
         get {
            return: int; [[FIXME]]
         }
      }
      @property drag_child_locked_y {
         [[Drag child locked Y axis property]]
         get {
            return: int; [[FIXME]]
         }
      }

      /* Translation & Text API. */
      translate @protected {
         [[Virtual function handling language changes.]]
         return: bool; [[$true on success, $false otherwise]]
         legacy: null;
      }
      @property domain_part_text_translatable {
         [[Translate domain text part property]]
         set {
         }
         values {
            part: string; [[Part name]]
            domain: string; [[Domain]]
            translatable: bool; [[$true if translatable, $false otherwise]]
         }
      }
      @property part_text {
         [[Part text property]]
         keys {
            part: string; [[Part name]]
         }
         values {
            label: string; [[Label]]
         }
      }
      translatable_part_text_get @const {
         [[Get translatable part text]]
         return: string; [[Part text]]
         params {
            @in part: string; [[Part name]]
         }
      }
      @property domain_translatable_part_text {
         [[Domain translatable text part property]]
         set {
         }
         values {
            part: string; [[Part name]]
            domain: string; [[Domain name]]
            label: string; [[Label]]
         }
      }
      part_text_translate {
         [[Translate part text]]
         return: string; [[Translated text]]
         params {
            @in part: string; [[Part name]]
            @in text: string; [[Text]]
         }
      }

      /* Internal hooks. */
      widget_sub_object_add @protected {
         [[Virtual function handling sub objects being added.

           Sub objects can be any canvas object, not necessarily widgets.

           See also @.widget_parent.
         ]]
         params {
            @in sub_obj: Efl.Canvas.Object;
               [[Sub object to be added. Not necessarily a widget itself.]]
         }
         return: bool; [[Indicates if the operation succeeded.]]
         legacy: elm_widget_sub_object_add;
      }
      widget_sub_object_del @protected {
         [[Virtual function handling sub objects being removed.

           Sub objects can be any canvas object, not necessarily widgets.

           See also @.widget_parent.
         ]]
         params {
            @in sub_obj: Efl.Canvas.Object;
               [[Sub object to be removed. Should be a child of this widget.]]
         }
         return: bool; [[Indicates if the operation succeeded.]]
         legacy: elm_widget_sub_object_del;
      }
      on_orientation_update @protected {
         [[Virtual function handling canvas orientation changes.

           This method will be called recursively from the top widget (the
           window) to all the children objects whenever the window rotation
           is changed. The given $rotation will be one of 0, 90, 180, 270 or
           the special value -1 if @.orientation_mode_disabled is $true.

           If @.orientation_mode_disabled is $false, the default implementation
           will emit the signal "elm,state,orient,$R" will be emitted (where $R
           is the rotation angle in degrees).

           Note: This function may be called even if the orientation has not
           actually changed, like when a widget needs to be reconfigured.

           See also @Efl.Orientation.orientation.set.
         ]]
         params {
            rotation: int; [[Orientation in degrees: 0, 90, 180, 270 or -1 if
               @.orientation_mode_disabled is $true.]]
         }
      }
      on_disabled_update @protected {
         [[Virtual function called when the widget becomes disabled.

           This may be triggered even if this widget is not disabled, as the
           parent widget could be disabled and propagate its state.
         ]]
         params {
            disabled: bool; [[The new value of @.disabled.]]
         }
         return: bool; [[Indicates if the operation succeeded.]]
      }
      theme_apply {
         [['Virtual' function on the widget being re-themed.]]
         return: Efl.Ui.Theme.Apply; [[Theme apply]]
      }
      activate {
         [['Virtual' function to activate widget.]]
         params {
            @in act: Elm.Activate; [[Activate]]
         }
         return: bool; [[$true on success, $false otherwise]]
         legacy: null; /* the legacy API has not the same number of parameter to we don't generate it. */
      }
      access {
         [['Virtual' function on the widget being set access.]]
         params {
            @in acs: bool; [[$true if access is set, $false otherwise]]
         }
         legacy: null;
      }
      on_focus {
         [['Virtual' function handling focus in/out events on the widget]]
         params {
            @in item: Elm.Widget.Item @nullable; [[Widget]]
         }
         return: bool; [[$true if this widget can handle focus, $false otherwise]]
      }
      on_focus_region {
         [['Virtual' function returning an inner area of a widget that should be brought into the visible area of a broader viewport, may this context arise.]]
         params {
            @out x: int; [[X coordinate]]
            @out y: int; [[Y coordinate]]
            @out w: int; [[Width]]
            @out h: int; [[Height]]
         }
         return: bool; [[$true on success, $false otherwise]]
      }

      /* Scroll API. */
      @property on_show_region_hook {
         [[Region hook on show property]]
         set {}
         values {
            func: Efl.Ui.Scrollable_On_Show_Region @nullable; [[Region hook function]]
         }
      }
      @property item_loop_enabled {
         [[Control item loop feature.]]
         values {
            enable: bool; [[$true if item loop is enabled, $false otherwise]]
         }
      }
      @property scroll_freeze {
         [[Scroll freeze property]]
         get {
            return: int; [[FIXME]]
         }
      }
      @property scroll_hold {
         [[Scroll hold property]]
         get {
            return: int; [[FIXME]]
         }
      }
      scroll_hold_push {
         [[Push scroll hold]]
      }
      show_region_set {
         [[Set show region]]
         params {
            @in x: int; [[X coordinate]]
            @in y: int; [[Y coordinate]]
            @in w: int; [[Width]]
            @in h: int; [[Height]]
            @in forceshow: bool; [[$true if show should be forced, $false otherwise]]
         }
      }
      show_region_get @const {
         [[Get show region]]
         params {
            @out x: int @optional; [[X coordinate]]
            @out y: int @optional; [[Y coordinate]]
            @out w: int @optional; [[Width]]
            @out h: int @optional; [[Height]]
         }
      }
      scroll_hold_pop {
         [[Pop scroller hold]]
      }
      scroll_freeze_push {
         [[Push scroller freeze]]
      }
      scroll_freeze_pop {
         [[Pop scroller freeze]]
      }

      /* Old focus API. FIXME: Needs massive clean up! */
      @property focus_region {
         [[Focus region property]]
         get {
            return: bool; [[$true on success, $false otherwise]]
         }
         values {
            x: int; [[X coordinate]]
            y: int; [[Y coordinate]]
            w: int; [[Width]]
            h: int; [[Height]]
         }
      }
      @property focus_order {
         [[Focus order property]]
         get {
            return: uint; [[FIXME]]
         }
      }
      focus_next_object_set {
         [[Set the next object with specific focus direction.

           @since 1.8]]
         params {
            @in next: Efl.Canvas.Object @nullable; [[Focus next object]]
            @in dir: Elm.Focus_Direction; [[Focus direction]]
         }
      }
      focus_next_object_get @const {
         [[Get the next object with specific focus direction.

           @since 1.8]]
         return: Efl.Canvas.Object; [[Focus next object]]
         params {
            @in dir: Elm.Focus_Direction; [[Focus direction]]
         }
      }
      focus_next_item_set {
         [[Set the next object item with specific focus direction.

           @since 1.16]]
         params {
            @in next_item: Elm.Widget.Item @nullable; [[Focus next object item]]
            @in dir: Elm.Focus_Direction; [[Focus direction]]
         }
      }
      focus_next_item_get @const {
         [[Get the next object item with specific focus direction.

           @since 1.16]]
         return: Elm.Widget.Item; [[Focus next object item]]
         params {
            @in dir: Elm.Focus_Direction; [[Focus direction]]
         }
      }
      focus_custom_chain_prepend {
         [[Prepend object to custom focus chain.

           Note: If @"relative_child" equal to $null or not in custom chain,
           the object will be added in begin.

           Note: On focus cycle, only will be evaluated children of this container.]]
         params {
            @in child: Efl.Canvas.Object; [[The child to be added in custom chain.]]
            @in relative_child: Efl.Canvas.Object @optional; [[The relative object to position the child.]]
         }
      }
      focus_highlight_geometry_get @const {
         [[Get the focus highlight geometry of widget.]]
         params {
            @out x: int; [[X coordinate]]
            @out y: int; [[Y coordinate]]
            @out w: int; [[Width]]
            @out h: int; [[Height]]
         }
      }
      focus_cycle {
         [[Give focus to next object with specific focus direction in
           object tree.]]
         params {
            @in dir: Elm.Focus_Direction; [[Direction to move the focus.]]
         }
      }
      focus_direction @pure_virtual {
         [['Virtual' function handling passing focus to sub-objects given a direction, in degrees.]]
         params {
            @in base: const(Efl.Canvas.Object); [[Base object]]
            @in degree: double; [[Degree]]
            @out direction: Efl.Canvas.Object; [[Direction]]
            @out direction_item: Elm.Widget.Item; [[Direction item]]
            @out weight: double; [[Weight]]
         }
         return: bool; [[$true on success, $false otherwise]]
      }
      focus_next_manager_is {
         [['Virtual' function which checks if handling of passing focus to sub-objects is supported by widget.]]
         return: bool; [[$true on success, $false otherwise]]
      }
      focused_object_clear {
         [[Clear focused object]]
      }
      focus_direction_go {
         [[Go in focus direction]]
         return: bool; [[$true on success, $false otherwise]]
         params {
            @in degree: double; [[Degree]]
         }
      }
      focus_next_get @const {
         [[Get next focus item]]
         return: bool; [[$true on success, $false otherwise]]
         params {
            @in dir: Elm.Focus_Direction; [[Focus direction]]
            @out next: Efl.Canvas.Object; [[Next object]]
            @out next_item: Elm.Widget.Item; [[Next item]]
         }
      }
      focus_restore {
         [[Restore the focus state of the sub-tree.

         This API will restore the focus state of the sub-tree to the latest
         state. If a sub-tree is unfocused and wants to get back to the latest
         focus state, this API will be helpful.]]
      }
      focus_custom_chain_unset {
         [[Unset a custom focus chain on a given Elementary widget.

           Any focus chain previously set is removed entirely after this call.]]
      }
      focus_steal {
         [[Steal focus]]
         params {
            @in item: Elm.Widget.Item @nullable; [[Widget to steal focus from]]
         }
      }
      focus_hide_handle {
         [[Handle hide focus]]
      }
      focus_next @pure_virtual {
         [['Virtual' function handling passing focus to sub-objects.]]
         params {
            @in dir: Elm.Focus_Direction; [[Focus direction]]
            @out next: Efl.Canvas.Object; [[Next object]]
            @out next_item: Elm.Widget.Item; [[Next item]]
         }
         return: bool; [[$true on success, $false otherwise]]
      }
      focus_mouse_up_handle {
         [[Handle focus mouse up]]
         legacy: null;
      }
      focus_direction_get @const {
         [[Get focus direction]]
         return: bool; [[$true on success, $false otherwise]]
         params {
            @in base: const(Efl.Canvas.Object); [[Base]]
            @in degree: double; [[Degree]]
            @out direction: Efl.Canvas.Object; [[Direction]]
            @out direction_item: Elm.Widget.Item; [[Direction item]]
            @out weight: double; [[Weight]]
         }
      }
      focus_region_show @const {
         [[Show focus region]]
      }
      focus_disabled_handle {
         [[Handle disable widget focus]]
      }
      focus_custom_chain_append {
         [[Append object to custom focus chain.

           Note: If @"relative_child" equal to $null or not in custom chain,
           the object will be added in end.

           Note: On focus cycle, only will be evaluated children of this container.]]
         params {
            @in child: Efl.Canvas.Object; [[The child to be added in custom chain.]]
            @in relative_child: Efl.Canvas.Object @optional; [[The relative object to position the child.]]
         }
      }
      @property focus_move_policy {
         [[The widget's focus move policy.]]
         values {
            policy: Efl.Ui.Focus.Move_Policy; [[Focus move policy]]
         }
      }
      @property focus_move_policy_automatic {
         [[Control the widget's focus_move_policy mode setting.

           @since 1.18]]
         values {
            automatic: bool; [[$true to follow system focus move policy change, $false otherwise]]
         }
      }
      focus_reconfigure {
         [[@since 1.18]]
      }
      @property focus_custom_chain {
         [[A custom chain of objects to pass focus.

           Note: On focus cycle, only will be evaluated children of this container.]]
         set {
            [[This function overwrites any previous custom focus chain within
              the list of objects. The previous list will be deleted and this list
              will be managed by elementary. After it is set, don't modify it.]]
            values {
               objs: list<Efl.Canvas.Object>; [[Chain of objects to pass focus]]
            }
         }
         get {
            values {
               objs: const(list<Efl.Canvas.Object>); [[Chain of objects]]
            }
         }
      }
      @property focused_item {
         get {
            [[Get the focused widget item.]]
            return: Elm.Widget.Item; [[Focused item]]
         }
      }
      @property focused_object {
         [[Current focused object in object tree.]]
         get {
            return: Efl.Canvas.Object; [[Current focused or $null, if there is no focused object.]]
         }
      }

      /* Other focus APIs */
      @property focus_highlight_style {
         [[Control the widget focus highlight style.]]
         set {
            return: bool; [[$true on success, $false otherwise.]]
         }
         get {
         }
         values {
            style: string; [[The name of the focus highlight style.]]
         }
      }
      @property focus_region_show_mode {
         [[Control the focus_region_show mode.]]
         values {
            mode: Elm.Focus.Region.Show_Mode; [[Focus region show mode]]
         }
      }

      /* Focus Manager API */
      focus_register {
         [[Register focus with focus manager]]
         params {
            manager : Efl.Ui.Focus.Manager; [[The manager to register against]]
            logical : Efl.Ui.Focus.Object; [[The logical parent to use]]
            @inout logical_flag : bool; [[reference to the flag indicating if the should be logical or not change this flag to the value you have it registered]]
         }
         return : bool; [[return $true or $false if the registration was successfull or not]]
      }
      focus_manager_factory {
         [[If the widget needs a manager, this function is called

           It can be used and overriden to inject your own manager or set custom options on the manager
         ]]
         params {
            root : Efl.Ui.Focus.Object; [[the logical root to use in the manager.]]
         }
         return : Efl.Ui.Focus.Manager;
      }
      focus_direction_manager_is @protected {
         [['Virtual' function which checks if handling of passing focus to sub-objects in given direction is supported by widget.]]
         return: bool; [[$true on success, $false otherwise]]
         legacy: null;
      }
   }
   implements {
      class.constructor;
      Efl.Object.constructor;
      Efl.Object.finalize;
      Efl.Object.destructor;
      Efl.Object.provider_find;
      Efl.Object.debug_name_override;
      Efl.Gfx.color { set; }
      Efl.Gfx.visible { set; }
      Efl.Gfx.position { set; }
      Efl.Gfx.size { set; }
      Efl.Canvas.Object.clip { set; }
      Efl.Canvas.Object.no_render { set; }
      Efl.Canvas.Object.is_frame_object { set; }
      Efl.Canvas.Group.group_calculate;
      Efl.Canvas.Group.group_member_del;
      Efl.Canvas.Group.group_member_add;
      Elm.Interface.Atspi_Accessible.name { get; }
      Elm.Interface.Atspi_Accessible.state_set { get; }
      Elm.Interface.Atspi_Accessible.children { get; }
      Elm.Interface.Atspi_Accessible.parent { get; }
      Elm.Interface.Atspi_Accessible.attributes { get; }
      Elm.Interface.Atspi_Component.focus_grab;
      Efl.Ui.Focus.User.manager { get; }
      Efl.Ui.Focus.User.parent { get; }
      Efl.Ui.Focus.Object.focus_geometry { get; }
      Efl.Ui.Focus.Object.focus { set; }
      Efl.Ui.Base.scale { get; set; }
      Efl.Ui.Base.mirrored { get; set; }
      Efl.Ui.Base.mirrored_automatic { get; set; }
      Efl.Ui.Cursor.cursor { get; set; }
      Efl.Ui.Cursor.cursor_style { get; set; }
      Efl.Ui.Cursor.cursor_theme_search_enabled { get; set; }
   }
   events {
      moved; [[Called when widget moved]]
      focused; [[Called when widget was focused]]
      unfocused; [[Called when widget was unfocused]]
      language,changed; [[Called when widget language changed]]
      access,changed; [[Called when accessibility changed]]
   }
}
