/*
 * ------------------------------------------------------------------------------
 * This is an automatically generated file using a python script.
 * ($EFL_HOME/src/utils/evas/generate_gl_thread_api.py)
 * Recommend that you modify data files ($EFL_HOME/src/utils/evas/gl_api_def.txt)
 * and make use of scripts if you need to fix them.
 * ------------------------------------------------------------------------------
 */

/*
 * void
 * glActiveTexture(GLenum texture);
 */

typedef void(*GL_TH_FNTYPE(glActiveTexture))(GLenum texture);

typedef struct
{
   GL_TH_FNTYPE(glActiveTexture) orig_func;
   GLenum texture;

} GL_TH_ST(glActiveTexture);

static void
GL_TH_CB(glActiveTexture)(void *data)
{
   GL_TH_ST(glActiveTexture) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glActiveTexture))thread_data->orig_func)
      (thread_data->texture);

}

void
GL_TH_FN(glActiveTexture)(GL_TH_DP, GLenum texture)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glActiveTexture) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glActiveTexture))orig_func)
           (texture);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glActiveTexture) *) + sizeof(GL_TH_ST(glActiveTexture)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glActiveTexture) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->texture = texture;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glActiveTexture),
                              thread_mode);
}

/*
 * void
 * glAttachShader(GLuint program, GLuint shader);
 */

typedef void(*GL_TH_FNTYPE(glAttachShader))(GLuint program, GLuint shader);

typedef struct
{
   GL_TH_FNTYPE(glAttachShader) orig_func;
   GLuint program;
   GLuint shader;

} GL_TH_ST(glAttachShader);

static void
GL_TH_CB(glAttachShader)(void *data)
{
   GL_TH_ST(glAttachShader) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glAttachShader))thread_data->orig_func)
      (thread_data->program,
       thread_data->shader);

}

void
GL_TH_FN(glAttachShader)(GL_TH_DP, GLuint program, GLuint shader)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glAttachShader) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glAttachShader))orig_func)
           (program, shader);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glAttachShader) *) + sizeof(GL_TH_ST(glAttachShader)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glAttachShader) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->program = program;
   thread_data->shader = shader;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glAttachShader),
                              thread_mode);
}

/*
 * void
 * glBindAttribLocation(GLuint program, GLuint index, const char* name);
 */

typedef void(*GL_TH_FNTYPE(glBindAttribLocation))(GLuint program, GLuint index, const char* name);

typedef struct
{
   GL_TH_FNTYPE(glBindAttribLocation) orig_func;
   GLuint program;
   GLuint index;
   const char* name;

} GL_TH_ST(glBindAttribLocation);

static void
GL_TH_CB(glBindAttribLocation)(void *data)
{
   GL_TH_ST(glBindAttribLocation) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindAttribLocation))thread_data->orig_func)
      (thread_data->program,
       thread_data->index,
       thread_data->name);

}

void
GL_TH_FN(glBindAttribLocation)(GL_TH_DP, GLuint program, GLuint index, const char* name)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindAttribLocation) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindAttribLocation))orig_func)
           (program, index, name);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindAttribLocation) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->index = index;
   thread_data->name = name;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindAttribLocation),
                              thread_mode);
}

/*
 * void
 * glBindBuffer(GLenum target, GLuint buffer);
 */

typedef void(*GL_TH_FNTYPE(glBindBuffer))(GLenum target, GLuint buffer);

typedef struct
{
   GL_TH_FNTYPE(glBindBuffer) orig_func;
   GLenum target;
   GLuint buffer;

} GL_TH_ST(glBindBuffer);

static void
GL_TH_CB(glBindBuffer)(void *data)
{
   GL_TH_ST(glBindBuffer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindBuffer))thread_data->orig_func)
      (thread_data->target,
       thread_data->buffer);

}

void
GL_TH_FN(glBindBuffer)(GL_TH_DP, GLenum target, GLuint buffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindBuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindBuffer))orig_func)
           (target, buffer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindBuffer) *) + sizeof(GL_TH_ST(glBindBuffer)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glBindBuffer) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->buffer = buffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindBuffer),
                              thread_mode);
}

/*
 * void
 * glBindFramebuffer(GLenum target, GLuint framebuffer);
 */

typedef void(*GL_TH_FNTYPE(glBindFramebuffer))(GLenum target, GLuint framebuffer);

typedef struct
{
   GL_TH_FNTYPE(glBindFramebuffer) orig_func;
   GLenum target;
   GLuint framebuffer;

} GL_TH_ST(glBindFramebuffer);

static void
GL_TH_CB(glBindFramebuffer)(void *data)
{
   GL_TH_ST(glBindFramebuffer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindFramebuffer))thread_data->orig_func)
      (thread_data->target,
       thread_data->framebuffer);

}

void
GL_TH_FN(glBindFramebuffer)(GL_TH_DP, GLenum target, GLuint framebuffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindFramebuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindFramebuffer))orig_func)
           (target, framebuffer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindFramebuffer) *) + sizeof(GL_TH_ST(glBindFramebuffer)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glBindFramebuffer) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->framebuffer = framebuffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindFramebuffer),
                              thread_mode);
}

/*
 * void
 * glBindRenderbuffer(GLenum target, GLuint renderbuffer);
 */

typedef void(*GL_TH_FNTYPE(glBindRenderbuffer))(GLenum target, GLuint renderbuffer);

typedef struct
{
   GL_TH_FNTYPE(glBindRenderbuffer) orig_func;
   GLenum target;
   GLuint renderbuffer;

} GL_TH_ST(glBindRenderbuffer);

static void
GL_TH_CB(glBindRenderbuffer)(void *data)
{
   GL_TH_ST(glBindRenderbuffer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindRenderbuffer))thread_data->orig_func)
      (thread_data->target,
       thread_data->renderbuffer);

}

void
GL_TH_FN(glBindRenderbuffer)(GL_TH_DP, GLenum target, GLuint renderbuffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindRenderbuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindRenderbuffer))orig_func)
           (target, renderbuffer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindRenderbuffer) *) + sizeof(GL_TH_ST(glBindRenderbuffer)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glBindRenderbuffer) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->renderbuffer = renderbuffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindRenderbuffer),
                              thread_mode);
}

/*
 * void
 * glBindTexture(GLenum target, GLuint texture);
 */

typedef void(*GL_TH_FNTYPE(glBindTexture))(GLenum target, GLuint texture);

typedef struct
{
   GL_TH_FNTYPE(glBindTexture) orig_func;
   GLenum target;
   GLuint texture;

} GL_TH_ST(glBindTexture);

static void
GL_TH_CB(glBindTexture)(void *data)
{
   GL_TH_ST(glBindTexture) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindTexture))thread_data->orig_func)
      (thread_data->target,
       thread_data->texture);

}

void
GL_TH_FN(glBindTexture)(GL_TH_DP, GLenum target, GLuint texture)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindTexture) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindTexture))orig_func)
           (target, texture);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindTexture) *) + sizeof(GL_TH_ST(glBindTexture)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glBindTexture) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->texture = texture;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindTexture),
                              thread_mode);
}

/*
 * void
 * glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
 */

typedef void(*GL_TH_FNTYPE(glBlendColor))(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);

typedef struct
{
   GL_TH_FNTYPE(glBlendColor) orig_func;
   GLclampf red;
   GLclampf green;
   GLclampf blue;
   GLclampf alpha;

} GL_TH_ST(glBlendColor);

static void
GL_TH_CB(glBlendColor)(void *data)
{
   GL_TH_ST(glBlendColor) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBlendColor))thread_data->orig_func)
      (thread_data->red,
       thread_data->green,
       thread_data->blue,
       thread_data->alpha);

}

void
GL_TH_FN(glBlendColor)(GL_TH_DP, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBlendColor) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBlendColor))orig_func)
           (red, green, blue, alpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBlendColor) *) + sizeof(GL_TH_ST(glBlendColor)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glBlendColor) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->red = red;
   thread_data->green = green;
   thread_data->blue = blue;
   thread_data->alpha = alpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBlendColor),
                              thread_mode);
}

/*
 * void
 * glBlendEquation(GLenum mode);
 */

typedef void(*GL_TH_FNTYPE(glBlendEquation))(GLenum mode);

typedef struct
{
   GL_TH_FNTYPE(glBlendEquation) orig_func;
   GLenum mode;

} GL_TH_ST(glBlendEquation);

static void
GL_TH_CB(glBlendEquation)(void *data)
{
   GL_TH_ST(glBlendEquation) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBlendEquation))thread_data->orig_func)
      (thread_data->mode);

}

void
GL_TH_FN(glBlendEquation)(GL_TH_DP, GLenum mode)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBlendEquation) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBlendEquation))orig_func)
           (mode);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBlendEquation) *) + sizeof(GL_TH_ST(glBlendEquation)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glBlendEquation) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->mode = mode;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBlendEquation),
                              thread_mode);
}

/*
 * void
 * glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
 */

typedef void(*GL_TH_FNTYPE(glBlendEquationSeparate))(GLenum modeRGB, GLenum modeAlpha);

typedef struct
{
   GL_TH_FNTYPE(glBlendEquationSeparate) orig_func;
   GLenum modeRGB;
   GLenum modeAlpha;

} GL_TH_ST(glBlendEquationSeparate);

static void
GL_TH_CB(glBlendEquationSeparate)(void *data)
{
   GL_TH_ST(glBlendEquationSeparate) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBlendEquationSeparate))thread_data->orig_func)
      (thread_data->modeRGB,
       thread_data->modeAlpha);

}

void
GL_TH_FN(glBlendEquationSeparate)(GL_TH_DP, GLenum modeRGB, GLenum modeAlpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBlendEquationSeparate) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBlendEquationSeparate))orig_func)
           (modeRGB, modeAlpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBlendEquationSeparate) *) + sizeof(GL_TH_ST(glBlendEquationSeparate)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glBlendEquationSeparate) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->modeRGB = modeRGB;
   thread_data->modeAlpha = modeAlpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBlendEquationSeparate),
                              thread_mode);
}

/*
 * void
 * glBlendFunc(GLenum sfactor, GLenum dfactor);
 */

typedef void(*GL_TH_FNTYPE(glBlendFunc))(GLenum sfactor, GLenum dfactor);

typedef struct
{
   GL_TH_FNTYPE(glBlendFunc) orig_func;
   GLenum sfactor;
   GLenum dfactor;

} GL_TH_ST(glBlendFunc);

static void
GL_TH_CB(glBlendFunc)(void *data)
{
   GL_TH_ST(glBlendFunc) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBlendFunc))thread_data->orig_func)
      (thread_data->sfactor,
       thread_data->dfactor);

}

void
GL_TH_FN(glBlendFunc)(GL_TH_DP, GLenum sfactor, GLenum dfactor)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBlendFunc) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBlendFunc))orig_func)
           (sfactor, dfactor);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBlendFunc) *) + sizeof(GL_TH_ST(glBlendFunc)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glBlendFunc) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->sfactor = sfactor;
   thread_data->dfactor = dfactor;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBlendFunc),
                              thread_mode);
}

/*
 * void
 * glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
 */

typedef void(*GL_TH_FNTYPE(glBlendFuncSeparate))(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);

typedef struct
{
   GL_TH_FNTYPE(glBlendFuncSeparate) orig_func;
   GLenum srcRGB;
   GLenum dstRGB;
   GLenum srcAlpha;
   GLenum dstAlpha;

} GL_TH_ST(glBlendFuncSeparate);

static void
GL_TH_CB(glBlendFuncSeparate)(void *data)
{
   GL_TH_ST(glBlendFuncSeparate) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBlendFuncSeparate))thread_data->orig_func)
      (thread_data->srcRGB,
       thread_data->dstRGB,
       thread_data->srcAlpha,
       thread_data->dstAlpha);

}

void
GL_TH_FN(glBlendFuncSeparate)(GL_TH_DP, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBlendFuncSeparate) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBlendFuncSeparate))orig_func)
           (srcRGB, dstRGB, srcAlpha, dstAlpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBlendFuncSeparate) *) + sizeof(GL_TH_ST(glBlendFuncSeparate)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glBlendFuncSeparate) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->srcRGB = srcRGB;
   thread_data->dstRGB = dstRGB;
   thread_data->srcAlpha = srcAlpha;
   thread_data->dstAlpha = dstAlpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBlendFuncSeparate),
                              thread_mode);
}

/*
 * void
 * glBufferData(GLenum target, GLsizeiptr size, const void* data, GLenum usage);
 */

typedef void(*GL_TH_FNTYPE(glBufferData))(GLenum target, GLsizeiptr size, const void* data, GLenum usage);

typedef struct
{
   GL_TH_FNTYPE(glBufferData) orig_func;
   GLenum target;
   GLsizeiptr size;
   const void* data;
   GLenum usage;

} GL_TH_ST(glBufferData);

static void
GL_TH_CB(glBufferData)(void *data)
{
   GL_TH_ST(glBufferData) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBufferData))thread_data->orig_func)
      (thread_data->target,
       thread_data->size,
       thread_data->data,
       thread_data->usage);

}

void
GL_TH_FN(glBufferData)(GL_TH_DP, GLenum target, GLsizeiptr size, const void* data, GLenum usage)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBufferData) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBufferData))orig_func)
           (target, size, data, usage);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBufferData) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->size = size;
   thread_data->data = data;
   thread_data->usage = usage;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBufferData),
                              thread_mode);
}

/*
 * void
 * glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void* data);
 */

typedef void(*GL_TH_FNTYPE(glBufferSubData))(GLenum target, GLintptr offset, GLsizeiptr size, const void* data);

typedef struct
{
   GL_TH_FNTYPE(glBufferSubData) orig_func;
   GLenum target;
   GLintptr offset;
   GLsizeiptr size;
   const void* data;

} GL_TH_ST(glBufferSubData);

static void
GL_TH_CB(glBufferSubData)(void *data)
{
   GL_TH_ST(glBufferSubData) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBufferSubData))thread_data->orig_func)
      (thread_data->target,
       thread_data->offset,
       thread_data->size,
       thread_data->data);

}

void
GL_TH_FN(glBufferSubData)(GL_TH_DP, GLenum target, GLintptr offset, GLsizeiptr size, const void* data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBufferSubData) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBufferSubData))orig_func)
           (target, offset, size, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBufferSubData) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->offset = offset;
   thread_data->size = size;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBufferSubData),
                              thread_mode);
}

/*
 * GLenum
 * glCheckFramebufferStatus(GLenum target);
 */

typedef GLenum(*GL_TH_FNTYPE(glCheckFramebufferStatus))(GLenum target);

typedef struct
{
   GL_TH_FNTYPE(glCheckFramebufferStatus) orig_func;
   GLenum return_value;
   GLenum target;

} GL_TH_ST(glCheckFramebufferStatus);

static void
GL_TH_CB(glCheckFramebufferStatus)(void *data)
{
   GL_TH_ST(glCheckFramebufferStatus) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glCheckFramebufferStatus))thread_data->orig_func)
      (thread_data->target);

}

GLenum
GL_TH_FN(glCheckFramebufferStatus)(GL_TH_DP, GLenum target)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCheckFramebufferStatus) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glCheckFramebufferStatus))orig_func)
           (target);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCheckFramebufferStatus) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCheckFramebufferStatus),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glClear(GLbitfield mask);
 */

typedef void(*GL_TH_FNTYPE(glClear))(GLbitfield mask);

typedef struct
{
   GL_TH_FNTYPE(glClear) orig_func;
   GLbitfield mask;

} GL_TH_ST(glClear);

static void
GL_TH_CB(glClear)(void *data)
{
   GL_TH_ST(glClear) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClear))thread_data->orig_func)
      (thread_data->mask);

}

void
GL_TH_FN(glClear)(GL_TH_DP, GLbitfield mask)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClear) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClear))orig_func)
           (mask);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClear) *) + sizeof(GL_TH_ST(glClear)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glClear) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->mask = mask;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClear),
                              thread_mode);
}

/*
 * void
 * glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
 */

typedef void(*GL_TH_FNTYPE(glClearColor))(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);

typedef struct
{
   GL_TH_FNTYPE(glClearColor) orig_func;
   GLclampf red;
   GLclampf green;
   GLclampf blue;
   GLclampf alpha;

} GL_TH_ST(glClearColor);

static void
GL_TH_CB(glClearColor)(void *data)
{
   GL_TH_ST(glClearColor) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClearColor))thread_data->orig_func)
      (thread_data->red,
       thread_data->green,
       thread_data->blue,
       thread_data->alpha);

}

void
GL_TH_FN(glClearColor)(GL_TH_DP, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClearColor) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClearColor))orig_func)
           (red, green, blue, alpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClearColor) *) + sizeof(GL_TH_ST(glClearColor)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glClearColor) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->red = red;
   thread_data->green = green;
   thread_data->blue = blue;
   thread_data->alpha = alpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClearColor),
                              thread_mode);
}

/*
 * void
 * glClearDepthf(GLclampf depth);
 */

typedef void(*GL_TH_FNTYPE(glClearDepthf))(GLclampf depth);

typedef struct
{
   GL_TH_FNTYPE(glClearDepthf) orig_func;
   GLclampf depth;

} GL_TH_ST(glClearDepthf);

static void
GL_TH_CB(glClearDepthf)(void *data)
{
   GL_TH_ST(glClearDepthf) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClearDepthf))thread_data->orig_func)
      (thread_data->depth);

}

void
GL_TH_FN(glClearDepthf)(GL_TH_DP, GLclampf depth)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClearDepthf) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClearDepthf))orig_func)
           (depth);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClearDepthf) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->depth = depth;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClearDepthf),
                              thread_mode);
}

/*
 * void
 * glClearStencil(GLint s);
 */

typedef void(*GL_TH_FNTYPE(glClearStencil))(GLint s);

typedef struct
{
   GL_TH_FNTYPE(glClearStencil) orig_func;
   GLint s;

} GL_TH_ST(glClearStencil);

static void
GL_TH_CB(glClearStencil)(void *data)
{
   GL_TH_ST(glClearStencil) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClearStencil))thread_data->orig_func)
      (thread_data->s);

}

void
GL_TH_FN(glClearStencil)(GL_TH_DP, GLint s)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClearStencil) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClearStencil))orig_func)
           (s);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClearStencil) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->s = s;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClearStencil),
                              thread_mode);
}

/*
 * void
 * glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
 */

typedef void(*GL_TH_FNTYPE(glColorMask))(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);

typedef struct
{
   GL_TH_FNTYPE(glColorMask) orig_func;
   GLboolean red;
   GLboolean green;
   GLboolean blue;
   GLboolean alpha;

} GL_TH_ST(glColorMask);

static void
GL_TH_CB(glColorMask)(void *data)
{
   GL_TH_ST(glColorMask) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glColorMask))thread_data->orig_func)
      (thread_data->red,
       thread_data->green,
       thread_data->blue,
       thread_data->alpha);

}

void
GL_TH_FN(glColorMask)(GL_TH_DP, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glColorMask) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glColorMask))orig_func)
           (red, green, blue, alpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glColorMask) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->red = red;
   thread_data->green = green;
   thread_data->blue = blue;
   thread_data->alpha = alpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glColorMask),
                              thread_mode);
}

/*
 * void
 * glCompileShader(GLuint shader);
 */

typedef void(*GL_TH_FNTYPE(glCompileShader))(GLuint shader);

typedef struct
{
   GL_TH_FNTYPE(glCompileShader) orig_func;
   GLuint shader;

} GL_TH_ST(glCompileShader);

static void
GL_TH_CB(glCompileShader)(void *data)
{
   GL_TH_ST(glCompileShader) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCompileShader))thread_data->orig_func)
      (thread_data->shader);

}

void
GL_TH_FN(glCompileShader)(GL_TH_DP, GLuint shader)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCompileShader) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCompileShader))orig_func)
           (shader);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCompileShader) *) + sizeof(GL_TH_ST(glCompileShader)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glCompileShader) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->shader = shader;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCompileShader),
                              thread_mode);
}

/*
 * void
 * glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data);
 */

typedef void(*GL_TH_FNTYPE(glCompressedTexImage2D))(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data);

typedef struct
{
   GL_TH_FNTYPE(glCompressedTexImage2D) orig_func;
   GLenum target;
   GLint level;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;
   GLint border;
   GLsizei imageSize;
   const void* data;
   GLCOMPRESSEDTEXIMAGE2D_VARIABLE_DECLARE /* TODO */

} GL_TH_ST(glCompressedTexImage2D);

static void
GL_TH_CB(glCompressedTexImage2D)(void *data)
{
   GL_TH_ST(glCompressedTexImage2D) *thread_data =
      *(void **)data;


   GLCOMPRESSEDTEXIMAGE2D_GLCALL_BEFORE; /* TODO */


   ((GL_TH_FNTYPE(glCompressedTexImage2D))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height,
       thread_data->border,
       thread_data->imageSize,
       thread_data->data);

   GLCOMPRESSEDTEXIMAGE2D_GLCALL_AFTER; /* TODO */

}

void
GL_TH_FN(glCompressedTexImage2D)(GL_TH_DP, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCompressedTexImage2D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCompressedTexImage2D))orig_func)
           (target, level, internalformat, width, height, border, imageSize, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCompressedTexImage2D) *) + sizeof(GL_TH_ST(glCompressedTexImage2D)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glCompressedTexImage2D) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->border = border;
   thread_data->imageSize = imageSize;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   GLCOMPRESSEDTEXIMAGE2D_VARIABLE_INIT; /* TODO */

   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   GLCOMPRESSEDTEXIMAGE2D_ASYNC_PREPARE; /* TODO */

finish:
   GLCOMPRESSEDTEXIMAGE2D_ENQUEUE_BEFORE; /* TODO */

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCompressedTexImage2D),
                              thread_mode);

   GLCOMPRESSEDTEXIMAGE2D_ENQUEUE_AFTER; /* TODO */
}

/*
 * void
 * glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);
 */

typedef void(*GL_TH_FNTYPE(glCompressedTexSubImage2D))(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);

typedef struct
{
   GL_TH_FNTYPE(glCompressedTexSubImage2D) orig_func;
   GLenum target;
   GLint level;
   GLint xoffset;
   GLint yoffset;
   GLsizei width;
   GLsizei height;
   GLenum format;
   GLsizei imageSize;
   const void* data;
   GLCOMPRESSEDTEXSUBIMAGE2D_VARIABLE_DECLARE /* TODO */

} GL_TH_ST(glCompressedTexSubImage2D);

static void
GL_TH_CB(glCompressedTexSubImage2D)(void *data)
{
   GL_TH_ST(glCompressedTexSubImage2D) *thread_data =
      *(void **)data;


   GLCOMPRESSEDTEXSUBIMAGE2D_GLCALL_BEFORE; /* TODO */


   ((GL_TH_FNTYPE(glCompressedTexSubImage2D))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->xoffset,
       thread_data->yoffset,
       thread_data->width,
       thread_data->height,
       thread_data->format,
       thread_data->imageSize,
       thread_data->data);

   GLCOMPRESSEDTEXSUBIMAGE2D_GLCALL_AFTER; /* TODO */

}

void
GL_TH_FN(glCompressedTexSubImage2D)(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCompressedTexSubImage2D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCompressedTexSubImage2D))orig_func)
           (target, level, xoffset, yoffset, width, height, format, imageSize, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCompressedTexSubImage2D) *) + sizeof(GL_TH_ST(glCompressedTexSubImage2D)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glCompressedTexSubImage2D) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->xoffset = xoffset;
   thread_data->yoffset = yoffset;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->format = format;
   thread_data->imageSize = imageSize;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   GLCOMPRESSEDTEXSUBIMAGE2D_VARIABLE_INIT; /* TODO */

   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   GLCOMPRESSEDTEXSUBIMAGE2D_ASYNC_PREPARE; /* TODO */

finish:
   GLCOMPRESSEDTEXSUBIMAGE2D_ENQUEUE_BEFORE; /* TODO */

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCompressedTexSubImage2D),
                              thread_mode);

   GLCOMPRESSEDTEXSUBIMAGE2D_ENQUEUE_AFTER; /* TODO */
}

/*
 * void
 * glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
 */

typedef void(*GL_TH_FNTYPE(glCopyTexImage2D))(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);

typedef struct
{
   GL_TH_FNTYPE(glCopyTexImage2D) orig_func;
   GLenum target;
   GLint level;
   GLenum internalformat;
   GLint x;
   GLint y;
   GLsizei width;
   GLsizei height;
   GLint border;

} GL_TH_ST(glCopyTexImage2D);

static void
GL_TH_CB(glCopyTexImage2D)(void *data)
{
   GL_TH_ST(glCopyTexImage2D) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCopyTexImage2D))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->internalformat,
       thread_data->x,
       thread_data->y,
       thread_data->width,
       thread_data->height,
       thread_data->border);

}

void
GL_TH_FN(glCopyTexImage2D)(GL_TH_DP, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCopyTexImage2D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCopyTexImage2D))orig_func)
           (target, level, internalformat, x, y, width, height, border);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCopyTexImage2D) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->internalformat = internalformat;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->border = border;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCopyTexImage2D),
                              thread_mode);
}

/*
 * void
 * glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
 */

typedef void(*GL_TH_FNTYPE(glCopyTexSubImage2D))(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);

typedef struct
{
   GL_TH_FNTYPE(glCopyTexSubImage2D) orig_func;
   GLenum target;
   GLint level;
   GLint xoffset;
   GLint yoffset;
   GLint x;
   GLint y;
   GLsizei width;
   GLsizei height;

} GL_TH_ST(glCopyTexSubImage2D);

static void
GL_TH_CB(glCopyTexSubImage2D)(void *data)
{
   GL_TH_ST(glCopyTexSubImage2D) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCopyTexSubImage2D))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->xoffset,
       thread_data->yoffset,
       thread_data->x,
       thread_data->y,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glCopyTexSubImage2D)(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCopyTexSubImage2D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCopyTexSubImage2D))orig_func)
           (target, level, xoffset, yoffset, x, y, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCopyTexSubImage2D) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->xoffset = xoffset;
   thread_data->yoffset = yoffset;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCopyTexSubImage2D),
                              thread_mode);
}

/*
 * GLuint
 * glCreateProgram(void);
 */

typedef GLuint(*GL_TH_FNTYPE(glCreateProgram))(void);

typedef struct
{
   GL_TH_FNTYPE(glCreateProgram) orig_func;
   GLuint return_value;

} GL_TH_ST(glCreateProgram);

static void
GL_TH_CB(glCreateProgram)(void *data)
{
   GL_TH_ST(glCreateProgram) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glCreateProgram))thread_data->orig_func)
      ();

}

GLuint
GL_TH_FN(glCreateProgram)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCreateProgram) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glCreateProgram))orig_func)
           ();
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCreateProgram) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCreateProgram),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLuint
 * glCreateShader(GLenum type);
 */

typedef GLuint(*GL_TH_FNTYPE(glCreateShader))(GLenum type);

typedef struct
{
   GL_TH_FNTYPE(glCreateShader) orig_func;
   GLuint return_value;
   GLenum type;

} GL_TH_ST(glCreateShader);

static void
GL_TH_CB(glCreateShader)(void *data)
{
   GL_TH_ST(glCreateShader) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glCreateShader))thread_data->orig_func)
      (thread_data->type);

}

GLuint
GL_TH_FN(glCreateShader)(GL_TH_DP, GLenum type)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCreateShader) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glCreateShader))orig_func)
           (type);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCreateShader) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->type = type;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCreateShader),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glCullFace(GLenum mode);
 */

typedef void(*GL_TH_FNTYPE(glCullFace))(GLenum mode);

typedef struct
{
   GL_TH_FNTYPE(glCullFace) orig_func;
   GLenum mode;

} GL_TH_ST(glCullFace);

static void
GL_TH_CB(glCullFace)(void *data)
{
   GL_TH_ST(glCullFace) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCullFace))thread_data->orig_func)
      (thread_data->mode);

}

void
GL_TH_FN(glCullFace)(GL_TH_DP, GLenum mode)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCullFace) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCullFace))orig_func)
           (mode);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCullFace) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCullFace),
                              thread_mode);
}

/*
 * void
 * glDeleteBuffers(GLsizei n, const GLuint* buffers);
 */

typedef void(*GL_TH_FNTYPE(glDeleteBuffers))(GLsizei n, const GLuint* buffers);

typedef struct
{
   GL_TH_FNTYPE(glDeleteBuffers) orig_func;
   GLsizei n;
   const GLuint* buffers;
   void *buffers_copied; /* COPIED */

} GL_TH_ST(glDeleteBuffers);

static void
GL_TH_CB(glDeleteBuffers)(void *data)
{
   GL_TH_ST(glDeleteBuffers) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteBuffers))thread_data->orig_func)
      (thread_data->n,
       thread_data->buffers);


   if (thread_data->buffers_copied)
     eina_mempool_free(_mp_delete_object, thread_data->buffers_copied);

}

void
GL_TH_FN(glDeleteBuffers)(GL_TH_DP, GLsizei n, const GLuint* buffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteBuffers) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteBuffers))orig_func)
           (n, buffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteBuffers) *) + sizeof(GL_TH_ST(glDeleteBuffers)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glDeleteBuffers) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->n = n;
   thread_data->buffers = buffers;
   thread_data->orig_func = orig_func;

   thread_data->buffers_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (buffers)
     {
        /* 1. check memory size */
        unsigned int copy_size = n * sizeof(GLuint);
        if (copy_size > _mp_delete_object_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->buffers_copied = eina_mempool_malloc(_mp_delete_object, copy_size);
        if (thread_data->buffers_copied)
          {
             memcpy(thread_data->buffers_copied, buffers, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->buffers = (const GLuint *)thread_data->buffers_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteBuffers),
                              thread_mode);
}

/*
 * void
 * glDeleteFramebuffers(GLsizei n, const GLuint* framebuffers);
 */

typedef void(*GL_TH_FNTYPE(glDeleteFramebuffers))(GLsizei n, const GLuint* framebuffers);

typedef struct
{
   GL_TH_FNTYPE(glDeleteFramebuffers) orig_func;
   GLsizei n;
   const GLuint* framebuffers;
   void *framebuffers_copied; /* COPIED */

} GL_TH_ST(glDeleteFramebuffers);

static void
GL_TH_CB(glDeleteFramebuffers)(void *data)
{
   GL_TH_ST(glDeleteFramebuffers) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteFramebuffers))thread_data->orig_func)
      (thread_data->n,
       thread_data->framebuffers);


   if (thread_data->framebuffers_copied)
     eina_mempool_free(_mp_delete_object, thread_data->framebuffers_copied);

}

void
GL_TH_FN(glDeleteFramebuffers)(GL_TH_DP, GLsizei n, const GLuint* framebuffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteFramebuffers) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteFramebuffers))orig_func)
           (n, framebuffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteFramebuffers) *) + sizeof(GL_TH_ST(glDeleteFramebuffers)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glDeleteFramebuffers) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->n = n;
   thread_data->framebuffers = framebuffers;
   thread_data->orig_func = orig_func;

   thread_data->framebuffers_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (framebuffers)
     {
        /* 1. check memory size */
        unsigned int copy_size = n * sizeof(GLuint);
        if (copy_size > _mp_delete_object_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->framebuffers_copied = eina_mempool_malloc(_mp_delete_object, copy_size);
        if (thread_data->framebuffers_copied)
          {
             memcpy(thread_data->framebuffers_copied, framebuffers, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->framebuffers = (const GLuint *)thread_data->framebuffers_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteFramebuffers),
                              thread_mode);
}

/*
 * void
 * glDeleteProgram(GLuint program);
 */

typedef void(*GL_TH_FNTYPE(glDeleteProgram))(GLuint program);

typedef struct
{
   GL_TH_FNTYPE(glDeleteProgram) orig_func;
   GLuint program;

} GL_TH_ST(glDeleteProgram);

static void
GL_TH_CB(glDeleteProgram)(void *data)
{
   GL_TH_ST(glDeleteProgram) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteProgram))thread_data->orig_func)
      (thread_data->program);

}

void
GL_TH_FN(glDeleteProgram)(GL_TH_DP, GLuint program)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteProgram) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteProgram))orig_func)
           (program);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteProgram) *) + sizeof(GL_TH_ST(glDeleteProgram)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glDeleteProgram) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->program = program;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteProgram),
                              thread_mode);
}

/*
 * void
 * glDeleteRenderbuffers(GLsizei n, const GLuint* renderbuffers);
 */

typedef void(*GL_TH_FNTYPE(glDeleteRenderbuffers))(GLsizei n, const GLuint* renderbuffers);

typedef struct
{
   GL_TH_FNTYPE(glDeleteRenderbuffers) orig_func;
   GLsizei n;
   const GLuint* renderbuffers;
   void *renderbuffers_copied; /* COPIED */

} GL_TH_ST(glDeleteRenderbuffers);

static void
GL_TH_CB(glDeleteRenderbuffers)(void *data)
{
   GL_TH_ST(glDeleteRenderbuffers) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteRenderbuffers))thread_data->orig_func)
      (thread_data->n,
       thread_data->renderbuffers);


   if (thread_data->renderbuffers_copied)
     eina_mempool_free(_mp_delete_object, thread_data->renderbuffers_copied);

}

void
GL_TH_FN(glDeleteRenderbuffers)(GL_TH_DP, GLsizei n, const GLuint* renderbuffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteRenderbuffers) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteRenderbuffers))orig_func)
           (n, renderbuffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteRenderbuffers) *) + sizeof(GL_TH_ST(glDeleteRenderbuffers)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glDeleteRenderbuffers) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->n = n;
   thread_data->renderbuffers = renderbuffers;
   thread_data->orig_func = orig_func;

   thread_data->renderbuffers_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (renderbuffers)
     {
        /* 1. check memory size */
        unsigned int copy_size = n * sizeof(GLuint);
        if (copy_size > _mp_delete_object_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->renderbuffers_copied = eina_mempool_malloc(_mp_delete_object, copy_size);
        if (thread_data->renderbuffers_copied)
          {
             memcpy(thread_data->renderbuffers_copied, renderbuffers, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->renderbuffers = (const GLuint *)thread_data->renderbuffers_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteRenderbuffers),
                              thread_mode);
}

/*
 * void
 * glDeleteShader(GLuint shader);
 */

typedef void(*GL_TH_FNTYPE(glDeleteShader))(GLuint shader);

typedef struct
{
   GL_TH_FNTYPE(glDeleteShader) orig_func;
   GLuint shader;

} GL_TH_ST(glDeleteShader);

static void
GL_TH_CB(glDeleteShader)(void *data)
{
   GL_TH_ST(glDeleteShader) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteShader))thread_data->orig_func)
      (thread_data->shader);

}

void
GL_TH_FN(glDeleteShader)(GL_TH_DP, GLuint shader)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteShader) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteShader))orig_func)
           (shader);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteShader) *) + sizeof(GL_TH_ST(glDeleteShader)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glDeleteShader) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->shader = shader;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteShader),
                              thread_mode);
}

/*
 * void
 * glDeleteTextures(GLsizei n, const GLuint* textures);
 */

typedef void(*GL_TH_FNTYPE(glDeleteTextures))(GLsizei n, const GLuint* textures);

typedef struct
{
   GL_TH_FNTYPE(glDeleteTextures) orig_func;
   GLsizei n;
   const GLuint* textures;
   void *textures_copied; /* COPIED */

} GL_TH_ST(glDeleteTextures);

static void
GL_TH_CB(glDeleteTextures)(void *data)
{
   GL_TH_ST(glDeleteTextures) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteTextures))thread_data->orig_func)
      (thread_data->n,
       thread_data->textures);


   if (thread_data->textures_copied)
     eina_mempool_free(_mp_delete_object, thread_data->textures_copied);

}

void
GL_TH_FN(glDeleteTextures)(GL_TH_DP, GLsizei n, const GLuint* textures)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteTextures) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteTextures))orig_func)
           (n, textures);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteTextures) *) + sizeof(GL_TH_ST(glDeleteTextures)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glDeleteTextures) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->n = n;
   thread_data->textures = textures;
   thread_data->orig_func = orig_func;

   thread_data->textures_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (textures)
     {
        /* 1. check memory size */
        unsigned int copy_size = n * sizeof(GLuint);
        if (copy_size > _mp_delete_object_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->textures_copied = eina_mempool_malloc(_mp_delete_object, copy_size);
        if (thread_data->textures_copied)
          {
             memcpy(thread_data->textures_copied, textures, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->textures = (const GLuint *)thread_data->textures_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteTextures),
                              thread_mode);
}

/*
 * void
 * glDepthFunc(GLenum func);
 */

typedef void(*GL_TH_FNTYPE(glDepthFunc))(GLenum func);

typedef struct
{
   GL_TH_FNTYPE(glDepthFunc) orig_func;
   GLenum func;

} GL_TH_ST(glDepthFunc);

static void
GL_TH_CB(glDepthFunc)(void *data)
{
   GL_TH_ST(glDepthFunc) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDepthFunc))thread_data->orig_func)
      (thread_data->func);

}

void
GL_TH_FN(glDepthFunc)(GL_TH_DP, GLenum func)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDepthFunc) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDepthFunc))orig_func)
           (func);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDepthFunc) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->func = func;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDepthFunc),
                              thread_mode);
}

/*
 * void
 * glDepthMask(GLboolean flag);
 */

typedef void(*GL_TH_FNTYPE(glDepthMask))(GLboolean flag);

typedef struct
{
   GL_TH_FNTYPE(glDepthMask) orig_func;
   GLboolean flag;

} GL_TH_ST(glDepthMask);

static void
GL_TH_CB(glDepthMask)(void *data)
{
   GL_TH_ST(glDepthMask) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDepthMask))thread_data->orig_func)
      (thread_data->flag);

}

void
GL_TH_FN(glDepthMask)(GL_TH_DP, GLboolean flag)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDepthMask) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDepthMask))orig_func)
           (flag);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDepthMask) *) + sizeof(GL_TH_ST(glDepthMask)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glDepthMask) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->flag = flag;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDepthMask),
                              thread_mode);
}

/*
 * void
 * glDepthRangef(GLclampf zNear, GLclampf zFar);
 */

typedef void(*GL_TH_FNTYPE(glDepthRangef))(GLclampf zNear, GLclampf zFar);

typedef struct
{
   GL_TH_FNTYPE(glDepthRangef) orig_func;
   GLclampf zNear;
   GLclampf zFar;

} GL_TH_ST(glDepthRangef);

static void
GL_TH_CB(glDepthRangef)(void *data)
{
   GL_TH_ST(glDepthRangef) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDepthRangef))thread_data->orig_func)
      (thread_data->zNear,
       thread_data->zFar);

}

void
GL_TH_FN(glDepthRangef)(GL_TH_DP, GLclampf zNear, GLclampf zFar)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDepthRangef) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDepthRangef))orig_func)
           (zNear, zFar);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDepthRangef) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->zNear = zNear;
   thread_data->zFar = zFar;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDepthRangef),
                              thread_mode);
}

/*
 * void
 * glDetachShader(GLuint program, GLuint shader);
 */

typedef void(*GL_TH_FNTYPE(glDetachShader))(GLuint program, GLuint shader);

typedef struct
{
   GL_TH_FNTYPE(glDetachShader) orig_func;
   GLuint program;
   GLuint shader;

} GL_TH_ST(glDetachShader);

static void
GL_TH_CB(glDetachShader)(void *data)
{
   GL_TH_ST(glDetachShader) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDetachShader))thread_data->orig_func)
      (thread_data->program,
       thread_data->shader);

}

void
GL_TH_FN(glDetachShader)(GL_TH_DP, GLuint program, GLuint shader)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDetachShader) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDetachShader))orig_func)
           (program, shader);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDetachShader) *) + sizeof(GL_TH_ST(glDetachShader)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glDetachShader) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->program = program;
   thread_data->shader = shader;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDetachShader),
                              thread_mode);
}

/*
 * void
 * glDisable(GLenum cap);
 */

typedef void(*GL_TH_FNTYPE(glDisable))(GLenum cap);

typedef struct
{
   GL_TH_FNTYPE(glDisable) orig_func;
   GLenum cap;

} GL_TH_ST(glDisable);

static void
GL_TH_CB(glDisable)(void *data)
{
   GL_TH_ST(glDisable) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDisable))thread_data->orig_func)
      (thread_data->cap);

}

void
GL_TH_FN(glDisable)(GL_TH_DP, GLenum cap)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDisable) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDisable))orig_func)
           (cap);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDisable) *) + sizeof(GL_TH_ST(glDisable)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glDisable) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_ENQUEUE;

   thread_data->cap = cap;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDisable),
                              thread_mode);
}

/*
 * void
 * glDisableVertexAttribArray(GLuint index);
 */

typedef void(*GL_TH_FNTYPE(glDisableVertexAttribArray))(GLuint index);

typedef struct
{
   GL_TH_FNTYPE(glDisableVertexAttribArray) orig_func;
   GLuint index;

} GL_TH_ST(glDisableVertexAttribArray);

static void
GL_TH_CB(glDisableVertexAttribArray)(void *data)
{
   GL_TH_ST(glDisableVertexAttribArray) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDisableVertexAttribArray))thread_data->orig_func)
      (thread_data->index);

}

void
GL_TH_FN(glDisableVertexAttribArray)(GL_TH_DP, GLuint index)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDisableVertexAttribArray) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDisableVertexAttribArray))orig_func)
           (index);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDisableVertexAttribArray) *) + sizeof(GL_TH_ST(glDisableVertexAttribArray)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glDisableVertexAttribArray) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_ENQUEUE;

   thread_data->index = index;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDisableVertexAttribArray),
                              thread_mode);
}

/*
 * void
 * glDrawArrays(GLenum mode, GLint first, GLsizei count);
 */

typedef void(*GL_TH_FNTYPE(glDrawArrays))(GLenum mode, GLint first, GLsizei count);

typedef struct
{
   GL_TH_FNTYPE(glDrawArrays) orig_func;
   GLenum mode;
   GLint first;
   GLsizei count;

} GL_TH_ST(glDrawArrays);

static void
GL_TH_CB(glDrawArrays)(void *data)
{
   GL_TH_ST(glDrawArrays) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawArrays))thread_data->orig_func)
      (thread_data->mode,
       thread_data->first,
       thread_data->count);

}

void
GL_TH_FN(glDrawArrays)(GL_TH_DP, GLenum mode, GLint first, GLsizei count)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawArrays) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawArrays))orig_func)
           (mode, first, count);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawArrays) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->first = first;
   thread_data->count = count;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawArrays),
                              thread_mode);
}

/*
 * void
 * glDrawElements(GLenum mode, GLsizei count, GLenum type, const void* indices);
 */

typedef void(*GL_TH_FNTYPE(glDrawElements))(GLenum mode, GLsizei count, GLenum type, const void* indices);

typedef struct
{
   GL_TH_FNTYPE(glDrawElements) orig_func;
   GLenum mode;
   GLsizei count;
   GLenum type;
   const void* indices;

} GL_TH_ST(glDrawElements);

static void
GL_TH_CB(glDrawElements)(void *data)
{
   GL_TH_ST(glDrawElements) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawElements))thread_data->orig_func)
      (thread_data->mode,
       thread_data->count,
       thread_data->type,
       thread_data->indices);

}

void
GL_TH_FN(glDrawElements)(GL_TH_DP, GLenum mode, GLsizei count, GLenum type, const void* indices)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawElements) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawElements))orig_func)
           (mode, count, type, indices);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawElements) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->count = count;
   thread_data->type = type;
   thread_data->indices = indices;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawElements),
                              thread_mode);
}

/*
 * void
 * glEnable(GLenum cap);
 */

typedef void(*GL_TH_FNTYPE(glEnable))(GLenum cap);

typedef struct
{
   GL_TH_FNTYPE(glEnable) orig_func;
   GLenum cap;

} GL_TH_ST(glEnable);

static void
GL_TH_CB(glEnable)(void *data)
{
   GL_TH_ST(glEnable) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glEnable))thread_data->orig_func)
      (thread_data->cap);

}

void
GL_TH_FN(glEnable)(GL_TH_DP, GLenum cap)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glEnable) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glEnable))orig_func)
           (cap);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glEnable) *) + sizeof(GL_TH_ST(glEnable)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glEnable) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_ENQUEUE;

   thread_data->cap = cap;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glEnable),
                              thread_mode);
}

/*
 * void
 * glEnableVertexAttribArray(GLuint index);
 */

typedef void(*GL_TH_FNTYPE(glEnableVertexAttribArray))(GLuint index);

typedef struct
{
   GL_TH_FNTYPE(glEnableVertexAttribArray) orig_func;
   GLuint index;

} GL_TH_ST(glEnableVertexAttribArray);

static void
GL_TH_CB(glEnableVertexAttribArray)(void *data)
{
   GL_TH_ST(glEnableVertexAttribArray) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glEnableVertexAttribArray))thread_data->orig_func)
      (thread_data->index);

}

void
GL_TH_FN(glEnableVertexAttribArray)(GL_TH_DP, GLuint index)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glEnableVertexAttribArray) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glEnableVertexAttribArray))orig_func)
           (index);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glEnableVertexAttribArray) *) + sizeof(GL_TH_ST(glEnableVertexAttribArray)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glEnableVertexAttribArray) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_ENQUEUE;

   thread_data->index = index;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glEnableVertexAttribArray),
                              thread_mode);
}

/*
 * void
 * glFinish(void);
 */

typedef void(*GL_TH_FNTYPE(glFinish))(void);

typedef struct
{
   GL_TH_FNTYPE(glFinish) orig_func;

} GL_TH_ST(glFinish);

static void
GL_TH_CB(glFinish)(void *data)
{
   GL_TH_ST(glFinish) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFinish))thread_data->orig_func)
      ();

}

void
GL_TH_FN(glFinish)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFinish) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFinish))orig_func)
           ();
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFinish) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFinish),
                              thread_mode);
}

/*
 * void
 * glFlush(void);
 */

typedef void(*GL_TH_FNTYPE(glFlush))(void);

typedef struct
{
   GL_TH_FNTYPE(glFlush) orig_func;

} GL_TH_ST(glFlush);

static void
GL_TH_CB(glFlush)(void *data)
{
   GL_TH_ST(glFlush) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFlush))thread_data->orig_func)
      ();

}

void
GL_TH_FN(glFlush)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFlush) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFlush))orig_func)
           ();
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFlush) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFlush),
                              thread_mode);
}

/*
 * void
 * glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
 */

typedef void(*GL_TH_FNTYPE(glFramebufferRenderbuffer))(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);

typedef struct
{
   GL_TH_FNTYPE(glFramebufferRenderbuffer) orig_func;
   GLenum target;
   GLenum attachment;
   GLenum renderbuffertarget;
   GLuint renderbuffer;

} GL_TH_ST(glFramebufferRenderbuffer);

static void
GL_TH_CB(glFramebufferRenderbuffer)(void *data)
{
   GL_TH_ST(glFramebufferRenderbuffer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFramebufferRenderbuffer))thread_data->orig_func)
      (thread_data->target,
       thread_data->attachment,
       thread_data->renderbuffertarget,
       thread_data->renderbuffer);

}

void
GL_TH_FN(glFramebufferRenderbuffer)(GL_TH_DP, GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFramebufferRenderbuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFramebufferRenderbuffer))orig_func)
           (target, attachment, renderbuffertarget, renderbuffer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFramebufferRenderbuffer) *) + sizeof(GL_TH_ST(glFramebufferRenderbuffer)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glFramebufferRenderbuffer) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->attachment = attachment;
   thread_data->renderbuffertarget = renderbuffertarget;
   thread_data->renderbuffer = renderbuffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFramebufferRenderbuffer),
                              thread_mode);
}

/*
 * void
 * glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
 */

typedef void(*GL_TH_FNTYPE(glFramebufferTexture2D))(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);

typedef struct
{
   GL_TH_FNTYPE(glFramebufferTexture2D) orig_func;
   GLenum target;
   GLenum attachment;
   GLenum textarget;
   GLuint texture;
   GLint level;

} GL_TH_ST(glFramebufferTexture2D);

static void
GL_TH_CB(glFramebufferTexture2D)(void *data)
{
   GL_TH_ST(glFramebufferTexture2D) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFramebufferTexture2D))thread_data->orig_func)
      (thread_data->target,
       thread_data->attachment,
       thread_data->textarget,
       thread_data->texture,
       thread_data->level);

}

void
GL_TH_FN(glFramebufferTexture2D)(GL_TH_DP, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFramebufferTexture2D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFramebufferTexture2D))orig_func)
           (target, attachment, textarget, texture, level);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFramebufferTexture2D) *) + sizeof(GL_TH_ST(glFramebufferTexture2D)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glFramebufferTexture2D) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->attachment = attachment;
   thread_data->textarget = textarget;
   thread_data->texture = texture;
   thread_data->level = level;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFramebufferTexture2D),
                              thread_mode);
}

/*
 * void
 * glFrontFace(GLenum mode);
 */

typedef void(*GL_TH_FNTYPE(glFrontFace))(GLenum mode);

typedef struct
{
   GL_TH_FNTYPE(glFrontFace) orig_func;
   GLenum mode;

} GL_TH_ST(glFrontFace);

static void
GL_TH_CB(glFrontFace)(void *data)
{
   GL_TH_ST(glFrontFace) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFrontFace))thread_data->orig_func)
      (thread_data->mode);

}

void
GL_TH_FN(glFrontFace)(GL_TH_DP, GLenum mode)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFrontFace) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFrontFace))orig_func)
           (mode);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFrontFace) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFrontFace),
                              thread_mode);
}

/*
 * void
 * glGenBuffers(GLsizei n, GLuint* buffers);
 */

typedef void(*GL_TH_FNTYPE(glGenBuffers))(GLsizei n, GLuint* buffers);

typedef struct
{
   GL_TH_FNTYPE(glGenBuffers) orig_func;
   GLsizei n;
   GLuint* buffers;

} GL_TH_ST(glGenBuffers);

static void
GL_TH_CB(glGenBuffers)(void *data)
{
   GL_TH_ST(glGenBuffers) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenBuffers))thread_data->orig_func)
      (thread_data->n,
       thread_data->buffers);

}

void
GL_TH_FN(glGenBuffers)(GL_TH_DP, GLsizei n, GLuint* buffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenBuffers) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenBuffers))orig_func)
           (n, buffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenBuffers) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->buffers = buffers;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenBuffers),
                              thread_mode);
}

/*
 * void
 * glGenerateMipmap(GLenum target);
 */

typedef void(*GL_TH_FNTYPE(glGenerateMipmap))(GLenum target);

typedef struct
{
   GL_TH_FNTYPE(glGenerateMipmap) orig_func;
   GLenum target;

} GL_TH_ST(glGenerateMipmap);

static void
GL_TH_CB(glGenerateMipmap)(void *data)
{
   GL_TH_ST(glGenerateMipmap) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenerateMipmap))thread_data->orig_func)
      (thread_data->target);

}

void
GL_TH_FN(glGenerateMipmap)(GL_TH_DP, GLenum target)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenerateMipmap) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenerateMipmap))orig_func)
           (target);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenerateMipmap) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenerateMipmap),
                              thread_mode);
}

/*
 * void
 * glGenFramebuffers(GLsizei n, GLuint* framebuffers);
 */

typedef void(*GL_TH_FNTYPE(glGenFramebuffers))(GLsizei n, GLuint* framebuffers);

typedef struct
{
   GL_TH_FNTYPE(glGenFramebuffers) orig_func;
   GLsizei n;
   GLuint* framebuffers;

} GL_TH_ST(glGenFramebuffers);

static void
GL_TH_CB(glGenFramebuffers)(void *data)
{
   GL_TH_ST(glGenFramebuffers) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenFramebuffers))thread_data->orig_func)
      (thread_data->n,
       thread_data->framebuffers);

}

void
GL_TH_FN(glGenFramebuffers)(GL_TH_DP, GLsizei n, GLuint* framebuffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenFramebuffers) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenFramebuffers))orig_func)
           (n, framebuffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenFramebuffers) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->framebuffers = framebuffers;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenFramebuffers),
                              thread_mode);
}

/*
 * void
 * glGenRenderbuffers(GLsizei n, GLuint* renderbuffers);
 */

typedef void(*GL_TH_FNTYPE(glGenRenderbuffers))(GLsizei n, GLuint* renderbuffers);

typedef struct
{
   GL_TH_FNTYPE(glGenRenderbuffers) orig_func;
   GLsizei n;
   GLuint* renderbuffers;

} GL_TH_ST(glGenRenderbuffers);

static void
GL_TH_CB(glGenRenderbuffers)(void *data)
{
   GL_TH_ST(glGenRenderbuffers) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenRenderbuffers))thread_data->orig_func)
      (thread_data->n,
       thread_data->renderbuffers);

}

void
GL_TH_FN(glGenRenderbuffers)(GL_TH_DP, GLsizei n, GLuint* renderbuffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenRenderbuffers) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenRenderbuffers))orig_func)
           (n, renderbuffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenRenderbuffers) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->renderbuffers = renderbuffers;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenRenderbuffers),
                              thread_mode);
}

/*
 * void
 * glGenTextures(GLsizei n, GLuint* textures);
 */

typedef void(*GL_TH_FNTYPE(glGenTextures))(GLsizei n, GLuint* textures);

typedef struct
{
   GL_TH_FNTYPE(glGenTextures) orig_func;
   GLsizei n;
   GLuint* textures;

} GL_TH_ST(glGenTextures);

static void
GL_TH_CB(glGenTextures)(void *data)
{
   GL_TH_ST(glGenTextures) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenTextures))thread_data->orig_func)
      (thread_data->n,
       thread_data->textures);

}

void
GL_TH_FN(glGenTextures)(GL_TH_DP, GLsizei n, GLuint* textures)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenTextures) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenTextures))orig_func)
           (n, textures);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenTextures) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->textures = textures;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenTextures),
                              thread_mode);
}

/*
 * void
 * glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name);
 */

typedef void(*GL_TH_FNTYPE(glGetActiveAttrib))(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name);

typedef struct
{
   GL_TH_FNTYPE(glGetActiveAttrib) orig_func;
   GLuint program;
   GLuint index;
   GLsizei bufsize;
   GLsizei* length;
   GLint* size;
   GLenum* type;
   char* name;

} GL_TH_ST(glGetActiveAttrib);

static void
GL_TH_CB(glGetActiveAttrib)(void *data)
{
   GL_TH_ST(glGetActiveAttrib) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetActiveAttrib))thread_data->orig_func)
      (thread_data->program,
       thread_data->index,
       thread_data->bufsize,
       thread_data->length,
       thread_data->size,
       thread_data->type,
       thread_data->name);

}

void
GL_TH_FN(glGetActiveAttrib)(GL_TH_DP, GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetActiveAttrib) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetActiveAttrib))orig_func)
           (program, index, bufsize, length, size, type, name);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetActiveAttrib) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->index = index;
   thread_data->bufsize = bufsize;
   thread_data->length = length;
   thread_data->size = size;
   thread_data->type = type;
   thread_data->name = name;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetActiveAttrib),
                              thread_mode);
}

/*
 * void
 * glGetActiveUniform(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name);
 */

typedef void(*GL_TH_FNTYPE(glGetActiveUniform))(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name);

typedef struct
{
   GL_TH_FNTYPE(glGetActiveUniform) orig_func;
   GLuint program;
   GLuint index;
   GLsizei bufsize;
   GLsizei* length;
   GLint* size;
   GLenum* type;
   char* name;

} GL_TH_ST(glGetActiveUniform);

static void
GL_TH_CB(glGetActiveUniform)(void *data)
{
   GL_TH_ST(glGetActiveUniform) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetActiveUniform))thread_data->orig_func)
      (thread_data->program,
       thread_data->index,
       thread_data->bufsize,
       thread_data->length,
       thread_data->size,
       thread_data->type,
       thread_data->name);

}

void
GL_TH_FN(glGetActiveUniform)(GL_TH_DP, GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetActiveUniform) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetActiveUniform))orig_func)
           (program, index, bufsize, length, size, type, name);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetActiveUniform) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->index = index;
   thread_data->bufsize = bufsize;
   thread_data->length = length;
   thread_data->size = size;
   thread_data->type = type;
   thread_data->name = name;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetActiveUniform),
                              thread_mode);
}

/*
 * void
 * glGetAttachedShaders(GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders);
 */

typedef void(*GL_TH_FNTYPE(glGetAttachedShaders))(GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders);

typedef struct
{
   GL_TH_FNTYPE(glGetAttachedShaders) orig_func;
   GLuint program;
   GLsizei maxcount;
   GLsizei* count;
   GLuint* shaders;

} GL_TH_ST(glGetAttachedShaders);

static void
GL_TH_CB(glGetAttachedShaders)(void *data)
{
   GL_TH_ST(glGetAttachedShaders) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetAttachedShaders))thread_data->orig_func)
      (thread_data->program,
       thread_data->maxcount,
       thread_data->count,
       thread_data->shaders);

}

void
GL_TH_FN(glGetAttachedShaders)(GL_TH_DP, GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetAttachedShaders) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetAttachedShaders))orig_func)
           (program, maxcount, count, shaders);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetAttachedShaders) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->maxcount = maxcount;
   thread_data->count = count;
   thread_data->shaders = shaders;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetAttachedShaders),
                              thread_mode);
}

/*
 * int
 * glGetAttribLocation(GLuint program, const char* name);
 */

typedef int(*GL_TH_FNTYPE(glGetAttribLocation))(GLuint program, const char* name);

typedef struct
{
   GL_TH_FNTYPE(glGetAttribLocation) orig_func;
   int return_value;
   GLuint program;
   const char* name;

} GL_TH_ST(glGetAttribLocation);

static void
GL_TH_CB(glGetAttribLocation)(void *data)
{
   GL_TH_ST(glGetAttribLocation) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glGetAttribLocation))thread_data->orig_func)
      (thread_data->program,
       thread_data->name);

}

int
GL_TH_FN(glGetAttribLocation)(GL_TH_DP, GLuint program, const char* name)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetAttribLocation) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glGetAttribLocation))orig_func)
           (program, name);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetAttribLocation) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->name = name;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetAttribLocation),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glGetBooleanv(GLenum pname, GLboolean* params);
 */

typedef void(*GL_TH_FNTYPE(glGetBooleanv))(GLenum pname, GLboolean* params);

typedef struct
{
   GL_TH_FNTYPE(glGetBooleanv) orig_func;
   GLenum pname;
   GLboolean* params;

} GL_TH_ST(glGetBooleanv);

static void
GL_TH_CB(glGetBooleanv)(void *data)
{
   GL_TH_ST(glGetBooleanv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetBooleanv))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetBooleanv)(GL_TH_DP, GLenum pname, GLboolean* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetBooleanv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetBooleanv))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetBooleanv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetBooleanv),
                              thread_mode);
}

/*
 * void
 * glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetBufferParameteriv))(GLenum target, GLenum pname, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetBufferParameteriv) orig_func;
   GLenum target;
   GLenum pname;
   GLint* params;

} GL_TH_ST(glGetBufferParameteriv);

static void
GL_TH_CB(glGetBufferParameteriv)(void *data)
{
   GL_TH_ST(glGetBufferParameteriv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetBufferParameteriv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetBufferParameteriv)(GL_TH_DP, GLenum target, GLenum pname, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetBufferParameteriv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetBufferParameteriv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetBufferParameteriv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetBufferParameteriv),
                              thread_mode);
}

/*
 * GLenum
 * glGetError(void);
 */

typedef GLenum(*GL_TH_FNTYPE(glGetError))(void);

typedef struct
{
   GL_TH_FNTYPE(glGetError) orig_func;
   GLenum return_value;

} GL_TH_ST(glGetError);

static void
GL_TH_CB(glGetError)(void *data)
{
   GL_TH_ST(glGetError) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glGetError))thread_data->orig_func)
      ();

}

GLenum
GL_TH_FN(glGetError)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetError) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glGetError))orig_func)
           ();
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetError) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetError),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glGetFloatv(GLenum pname, GLfloat* params);
 */

typedef void(*GL_TH_FNTYPE(glGetFloatv))(GLenum pname, GLfloat* params);

typedef struct
{
   GL_TH_FNTYPE(glGetFloatv) orig_func;
   GLenum pname;
   GLfloat* params;

} GL_TH_ST(glGetFloatv);

static void
GL_TH_CB(glGetFloatv)(void *data)
{
   GL_TH_ST(glGetFloatv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetFloatv))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetFloatv)(GL_TH_DP, GLenum pname, GLfloat* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetFloatv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetFloatv))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetFloatv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetFloatv),
                              thread_mode);
}

/*
 * void
 * glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetFramebufferAttachmentParameteriv))(GLenum target, GLenum attachment, GLenum pname, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetFramebufferAttachmentParameteriv) orig_func;
   GLenum target;
   GLenum attachment;
   GLenum pname;
   GLint* params;

} GL_TH_ST(glGetFramebufferAttachmentParameteriv);

static void
GL_TH_CB(glGetFramebufferAttachmentParameteriv)(void *data)
{
   GL_TH_ST(glGetFramebufferAttachmentParameteriv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetFramebufferAttachmentParameteriv))thread_data->orig_func)
      (thread_data->target,
       thread_data->attachment,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetFramebufferAttachmentParameteriv)(GL_TH_DP, GLenum target, GLenum attachment, GLenum pname, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetFramebufferAttachmentParameteriv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetFramebufferAttachmentParameteriv))orig_func)
           (target, attachment, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetFramebufferAttachmentParameteriv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->attachment = attachment;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetFramebufferAttachmentParameteriv),
                              thread_mode);
}

/*
 * void
 * glGetIntegerv(GLenum pname, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetIntegerv))(GLenum pname, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetIntegerv) orig_func;
   GLenum pname;
   GLint* params;

} GL_TH_ST(glGetIntegerv);

static void
GL_TH_CB(glGetIntegerv)(void *data)
{
   GL_TH_ST(glGetIntegerv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetIntegerv))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetIntegerv)(GL_TH_DP, GLenum pname, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetIntegerv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetIntegerv))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetIntegerv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetIntegerv),
                              thread_mode);
}

/*
 * void
 * glGetProgramiv(GLuint program, GLenum pname, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetProgramiv))(GLuint program, GLenum pname, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetProgramiv) orig_func;
   GLuint program;
   GLenum pname;
   GLint* params;

} GL_TH_ST(glGetProgramiv);

static void
GL_TH_CB(glGetProgramiv)(void *data)
{
   GL_TH_ST(glGetProgramiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetProgramiv))thread_data->orig_func)
      (thread_data->program,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetProgramiv)(GL_TH_DP, GLuint program, GLenum pname, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetProgramiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetProgramiv))orig_func)
           (program, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetProgramiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetProgramiv),
                              thread_mode);
}

/*
 * void
 * glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length, char* infolog);
 */

typedef void(*GL_TH_FNTYPE(glGetProgramInfoLog))(GLuint program, GLsizei bufsize, GLsizei* length, char* infolog);

typedef struct
{
   GL_TH_FNTYPE(glGetProgramInfoLog) orig_func;
   GLuint program;
   GLsizei bufsize;
   GLsizei* length;
   char* infolog;

} GL_TH_ST(glGetProgramInfoLog);

static void
GL_TH_CB(glGetProgramInfoLog)(void *data)
{
   GL_TH_ST(glGetProgramInfoLog) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetProgramInfoLog))thread_data->orig_func)
      (thread_data->program,
       thread_data->bufsize,
       thread_data->length,
       thread_data->infolog);

}

void
GL_TH_FN(glGetProgramInfoLog)(GL_TH_DP, GLuint program, GLsizei bufsize, GLsizei* length, char* infolog)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetProgramInfoLog) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetProgramInfoLog))orig_func)
           (program, bufsize, length, infolog);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetProgramInfoLog) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->bufsize = bufsize;
   thread_data->length = length;
   thread_data->infolog = infolog;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetProgramInfoLog),
                              thread_mode);
}

/*
 * void
 * glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetRenderbufferParameteriv))(GLenum target, GLenum pname, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetRenderbufferParameteriv) orig_func;
   GLenum target;
   GLenum pname;
   GLint* params;

} GL_TH_ST(glGetRenderbufferParameteriv);

static void
GL_TH_CB(glGetRenderbufferParameteriv)(void *data)
{
   GL_TH_ST(glGetRenderbufferParameteriv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetRenderbufferParameteriv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetRenderbufferParameteriv)(GL_TH_DP, GLenum target, GLenum pname, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetRenderbufferParameteriv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetRenderbufferParameteriv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetRenderbufferParameteriv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetRenderbufferParameteriv),
                              thread_mode);
}

/*
 * void
 * glGetShaderiv(GLuint shader, GLenum pname, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetShaderiv))(GLuint shader, GLenum pname, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetShaderiv) orig_func;
   GLuint shader;
   GLenum pname;
   GLint* params;

} GL_TH_ST(glGetShaderiv);

static void
GL_TH_CB(glGetShaderiv)(void *data)
{
   GL_TH_ST(glGetShaderiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetShaderiv))thread_data->orig_func)
      (thread_data->shader,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetShaderiv)(GL_TH_DP, GLuint shader, GLenum pname, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetShaderiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetShaderiv))orig_func)
           (shader, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetShaderiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->shader = shader;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetShaderiv),
                              thread_mode);
}

/*
 * void
 * glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei* length, char* infolog);
 */

typedef void(*GL_TH_FNTYPE(glGetShaderInfoLog))(GLuint shader, GLsizei bufsize, GLsizei* length, char* infolog);

typedef struct
{
   GL_TH_FNTYPE(glGetShaderInfoLog) orig_func;
   GLuint shader;
   GLsizei bufsize;
   GLsizei* length;
   char* infolog;

} GL_TH_ST(glGetShaderInfoLog);

static void
GL_TH_CB(glGetShaderInfoLog)(void *data)
{
   GL_TH_ST(glGetShaderInfoLog) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetShaderInfoLog))thread_data->orig_func)
      (thread_data->shader,
       thread_data->bufsize,
       thread_data->length,
       thread_data->infolog);

}

void
GL_TH_FN(glGetShaderInfoLog)(GL_TH_DP, GLuint shader, GLsizei bufsize, GLsizei* length, char* infolog)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetShaderInfoLog) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetShaderInfoLog))orig_func)
           (shader, bufsize, length, infolog);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetShaderInfoLog) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->shader = shader;
   thread_data->bufsize = bufsize;
   thread_data->length = length;
   thread_data->infolog = infolog;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetShaderInfoLog),
                              thread_mode);
}

/*
 * void
 * glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);
 */

typedef void(*GL_TH_FNTYPE(glGetShaderPrecisionFormat))(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);

typedef struct
{
   GL_TH_FNTYPE(glGetShaderPrecisionFormat) orig_func;
   GLenum shadertype;
   GLenum precisiontype;
   GLint* range;
   GLint* precision;

} GL_TH_ST(glGetShaderPrecisionFormat);

static void
GL_TH_CB(glGetShaderPrecisionFormat)(void *data)
{
   GL_TH_ST(glGetShaderPrecisionFormat) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetShaderPrecisionFormat))thread_data->orig_func)
      (thread_data->shadertype,
       thread_data->precisiontype,
       thread_data->range,
       thread_data->precision);

}

void
GL_TH_FN(glGetShaderPrecisionFormat)(GL_TH_DP, GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetShaderPrecisionFormat) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetShaderPrecisionFormat))orig_func)
           (shadertype, precisiontype, range, precision);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetShaderPrecisionFormat) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->shadertype = shadertype;
   thread_data->precisiontype = precisiontype;
   thread_data->range = range;
   thread_data->precision = precision;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetShaderPrecisionFormat),
                              thread_mode);
}

/*
 * void
 * glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei* length, char* source);
 */

typedef void(*GL_TH_FNTYPE(glGetShaderSource))(GLuint shader, GLsizei bufsize, GLsizei* length, char* source);

typedef struct
{
   GL_TH_FNTYPE(glGetShaderSource) orig_func;
   GLuint shader;
   GLsizei bufsize;
   GLsizei* length;
   char* source;

} GL_TH_ST(glGetShaderSource);

static void
GL_TH_CB(glGetShaderSource)(void *data)
{
   GL_TH_ST(glGetShaderSource) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetShaderSource))thread_data->orig_func)
      (thread_data->shader,
       thread_data->bufsize,
       thread_data->length,
       thread_data->source);

}

void
GL_TH_FN(glGetShaderSource)(GL_TH_DP, GLuint shader, GLsizei bufsize, GLsizei* length, char* source)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetShaderSource) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetShaderSource))orig_func)
           (shader, bufsize, length, source);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetShaderSource) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->shader = shader;
   thread_data->bufsize = bufsize;
   thread_data->length = length;
   thread_data->source = source;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetShaderSource),
                              thread_mode);
}

/*
 * const GLubyte*
 * glGetString(GLenum name);
 */

typedef const GLubyte*(*GL_TH_FNTYPE(glGetString))(GLenum name);

typedef struct
{
   GL_TH_FNTYPE(glGetString) orig_func;
   const GLubyte* return_value;
   GLenum name;

} GL_TH_ST(glGetString);

static void
GL_TH_CB(glGetString)(void *data)
{
   GL_TH_ST(glGetString) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glGetString))thread_data->orig_func)
      (thread_data->name);

}

const GLubyte*
GL_TH_FN(glGetString)(GL_TH_DP, GLenum name)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetString) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glGetString))orig_func)
           (name);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetString) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->name = name;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetString),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexParameterfv))(GLenum target, GLenum pname, GLfloat* params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexParameterfv) orig_func;
   GLenum target;
   GLenum pname;
   GLfloat* params;

} GL_TH_ST(glGetTexParameterfv);

static void
GL_TH_CB(glGetTexParameterfv)(void *data)
{
   GL_TH_ST(glGetTexParameterfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexParameterfv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexParameterfv)(GL_TH_DP, GLenum target, GLenum pname, GLfloat* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexParameterfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexParameterfv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexParameterfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexParameterfv),
                              thread_mode);
}

/*
 * void
 * glGetTexParameteriv(GLenum target, GLenum pname, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexParameteriv))(GLenum target, GLenum pname, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexParameteriv) orig_func;
   GLenum target;
   GLenum pname;
   GLint* params;

} GL_TH_ST(glGetTexParameteriv);

static void
GL_TH_CB(glGetTexParameteriv)(void *data)
{
   GL_TH_ST(glGetTexParameteriv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexParameteriv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexParameteriv)(GL_TH_DP, GLenum target, GLenum pname, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexParameteriv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexParameteriv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexParameteriv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexParameteriv),
                              thread_mode);
}

/*
 * void
 * glGetUniformfv(GLuint program, GLint location, GLfloat* params);
 */

typedef void(*GL_TH_FNTYPE(glGetUniformfv))(GLuint program, GLint location, GLfloat* params);

typedef struct
{
   GL_TH_FNTYPE(glGetUniformfv) orig_func;
   GLuint program;
   GLint location;
   GLfloat* params;

} GL_TH_ST(glGetUniformfv);

static void
GL_TH_CB(glGetUniformfv)(void *data)
{
   GL_TH_ST(glGetUniformfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetUniformfv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->params);

}

void
GL_TH_FN(glGetUniformfv)(GL_TH_DP, GLuint program, GLint location, GLfloat* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetUniformfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetUniformfv))orig_func)
           (program, location, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetUniformfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetUniformfv),
                              thread_mode);
}

/*
 * void
 * glGetUniformiv(GLuint program, GLint location, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetUniformiv))(GLuint program, GLint location, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetUniformiv) orig_func;
   GLuint program;
   GLint location;
   GLint* params;

} GL_TH_ST(glGetUniformiv);

static void
GL_TH_CB(glGetUniformiv)(void *data)
{
   GL_TH_ST(glGetUniformiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetUniformiv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->params);

}

void
GL_TH_FN(glGetUniformiv)(GL_TH_DP, GLuint program, GLint location, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetUniformiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetUniformiv))orig_func)
           (program, location, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetUniformiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetUniformiv),
                              thread_mode);
}

/*
 * int
 * glGetUniformLocation(GLuint program, const char* name);
 */

typedef int(*GL_TH_FNTYPE(glGetUniformLocation))(GLuint program, const char* name);

typedef struct
{
   GL_TH_FNTYPE(glGetUniformLocation) orig_func;
   int return_value;
   GLuint program;
   const char* name;

} GL_TH_ST(glGetUniformLocation);

static void
GL_TH_CB(glGetUniformLocation)(void *data)
{
   GL_TH_ST(glGetUniformLocation) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glGetUniformLocation))thread_data->orig_func)
      (thread_data->program,
       thread_data->name);

}

int
GL_TH_FN(glGetUniformLocation)(GL_TH_DP, GLuint program, const char* name)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetUniformLocation) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glGetUniformLocation))orig_func)
           (program, name);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetUniformLocation) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->name = name;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetUniformLocation),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params);
 */

typedef void(*GL_TH_FNTYPE(glGetVertexAttribfv))(GLuint index, GLenum pname, GLfloat* params);

typedef struct
{
   GL_TH_FNTYPE(glGetVertexAttribfv) orig_func;
   GLuint index;
   GLenum pname;
   GLfloat* params;

} GL_TH_ST(glGetVertexAttribfv);

static void
GL_TH_CB(glGetVertexAttribfv)(void *data)
{
   GL_TH_ST(glGetVertexAttribfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetVertexAttribfv))thread_data->orig_func)
      (thread_data->index,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetVertexAttribfv)(GL_TH_DP, GLuint index, GLenum pname, GLfloat* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetVertexAttribfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetVertexAttribfv))orig_func)
           (index, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetVertexAttribfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->index = index;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetVertexAttribfv),
                              thread_mode);
}

/*
 * void
 * glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetVertexAttribiv))(GLuint index, GLenum pname, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetVertexAttribiv) orig_func;
   GLuint index;
   GLenum pname;
   GLint* params;

} GL_TH_ST(glGetVertexAttribiv);

static void
GL_TH_CB(glGetVertexAttribiv)(void *data)
{
   GL_TH_ST(glGetVertexAttribiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetVertexAttribiv))thread_data->orig_func)
      (thread_data->index,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetVertexAttribiv)(GL_TH_DP, GLuint index, GLenum pname, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetVertexAttribiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetVertexAttribiv))orig_func)
           (index, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetVertexAttribiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->index = index;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetVertexAttribiv),
                              thread_mode);
}

/*
 * void
 * glGetVertexAttribPointerv(GLuint index, GLenum pname, void** pointer);
 */

typedef void(*GL_TH_FNTYPE(glGetVertexAttribPointerv))(GLuint index, GLenum pname, void** pointer);

typedef struct
{
   GL_TH_FNTYPE(glGetVertexAttribPointerv) orig_func;
   GLuint index;
   GLenum pname;
   void** pointer;

} GL_TH_ST(glGetVertexAttribPointerv);

static void
GL_TH_CB(glGetVertexAttribPointerv)(void *data)
{
   GL_TH_ST(glGetVertexAttribPointerv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetVertexAttribPointerv))thread_data->orig_func)
      (thread_data->index,
       thread_data->pname,
       thread_data->pointer);

}

void
GL_TH_FN(glGetVertexAttribPointerv)(GL_TH_DP, GLuint index, GLenum pname, void** pointer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetVertexAttribPointerv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetVertexAttribPointerv))orig_func)
           (index, pname, pointer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetVertexAttribPointerv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->index = index;
   thread_data->pname = pname;
   thread_data->pointer = pointer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetVertexAttribPointerv),
                              thread_mode);
}

/*
 * void
 * glHint(GLenum target, GLenum mode);
 */

typedef void(*GL_TH_FNTYPE(glHint))(GLenum target, GLenum mode);

typedef struct
{
   GL_TH_FNTYPE(glHint) orig_func;
   GLenum target;
   GLenum mode;

} GL_TH_ST(glHint);

static void
GL_TH_CB(glHint)(void *data)
{
   GL_TH_ST(glHint) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glHint))thread_data->orig_func)
      (thread_data->target,
       thread_data->mode);

}

void
GL_TH_FN(glHint)(GL_TH_DP, GLenum target, GLenum mode)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glHint) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glHint))orig_func)
           (target, mode);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glHint) *) + sizeof(GL_TH_ST(glHint)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glHint) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->mode = mode;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glHint),
                              thread_mode);
}

/*
 * GLboolean
 * glIsBuffer(GLuint buffer);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsBuffer))(GLuint buffer);

typedef struct
{
   GL_TH_FNTYPE(glIsBuffer) orig_func;
   GLboolean return_value;
   GLuint buffer;

} GL_TH_ST(glIsBuffer);

static void
GL_TH_CB(glIsBuffer)(void *data)
{
   GL_TH_ST(glIsBuffer) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsBuffer))thread_data->orig_func)
      (thread_data->buffer);

}

GLboolean
GL_TH_FN(glIsBuffer)(GL_TH_DP, GLuint buffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsBuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsBuffer))orig_func)
           (buffer);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsBuffer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->buffer = buffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsBuffer),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glIsEnabled(GLenum cap);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsEnabled))(GLenum cap);

typedef struct
{
   GL_TH_FNTYPE(glIsEnabled) orig_func;
   GLboolean return_value;
   GLenum cap;

} GL_TH_ST(glIsEnabled);

static void
GL_TH_CB(glIsEnabled)(void *data)
{
   GL_TH_ST(glIsEnabled) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsEnabled))thread_data->orig_func)
      (thread_data->cap);

}

GLboolean
GL_TH_FN(glIsEnabled)(GL_TH_DP, GLenum cap)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsEnabled) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsEnabled))orig_func)
           (cap);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsEnabled) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->cap = cap;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsEnabled),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glIsFramebuffer(GLuint framebuffer);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsFramebuffer))(GLuint framebuffer);

typedef struct
{
   GL_TH_FNTYPE(glIsFramebuffer) orig_func;
   GLboolean return_value;
   GLuint framebuffer;

} GL_TH_ST(glIsFramebuffer);

static void
GL_TH_CB(glIsFramebuffer)(void *data)
{
   GL_TH_ST(glIsFramebuffer) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsFramebuffer))thread_data->orig_func)
      (thread_data->framebuffer);

}

GLboolean
GL_TH_FN(glIsFramebuffer)(GL_TH_DP, GLuint framebuffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsFramebuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsFramebuffer))orig_func)
           (framebuffer);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsFramebuffer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->framebuffer = framebuffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsFramebuffer),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glIsProgram(GLuint program);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsProgram))(GLuint program);

typedef struct
{
   GL_TH_FNTYPE(glIsProgram) orig_func;
   GLboolean return_value;
   GLuint program;

} GL_TH_ST(glIsProgram);

static void
GL_TH_CB(glIsProgram)(void *data)
{
   GL_TH_ST(glIsProgram) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsProgram))thread_data->orig_func)
      (thread_data->program);

}

GLboolean
GL_TH_FN(glIsProgram)(GL_TH_DP, GLuint program)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsProgram) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsProgram))orig_func)
           (program);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsProgram) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsProgram),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glIsRenderbuffer(GLuint renderbuffer);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsRenderbuffer))(GLuint renderbuffer);

typedef struct
{
   GL_TH_FNTYPE(glIsRenderbuffer) orig_func;
   GLboolean return_value;
   GLuint renderbuffer;

} GL_TH_ST(glIsRenderbuffer);

static void
GL_TH_CB(glIsRenderbuffer)(void *data)
{
   GL_TH_ST(glIsRenderbuffer) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsRenderbuffer))thread_data->orig_func)
      (thread_data->renderbuffer);

}

GLboolean
GL_TH_FN(glIsRenderbuffer)(GL_TH_DP, GLuint renderbuffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsRenderbuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsRenderbuffer))orig_func)
           (renderbuffer);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsRenderbuffer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->renderbuffer = renderbuffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsRenderbuffer),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glIsShader(GLuint shader);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsShader))(GLuint shader);

typedef struct
{
   GL_TH_FNTYPE(glIsShader) orig_func;
   GLboolean return_value;
   GLuint shader;

} GL_TH_ST(glIsShader);

static void
GL_TH_CB(glIsShader)(void *data)
{
   GL_TH_ST(glIsShader) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsShader))thread_data->orig_func)
      (thread_data->shader);

}

GLboolean
GL_TH_FN(glIsShader)(GL_TH_DP, GLuint shader)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsShader) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsShader))orig_func)
           (shader);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsShader) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->shader = shader;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsShader),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glIsTexture(GLuint texture);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsTexture))(GLuint texture);

typedef struct
{
   GL_TH_FNTYPE(glIsTexture) orig_func;
   GLboolean return_value;
   GLuint texture;

} GL_TH_ST(glIsTexture);

static void
GL_TH_CB(glIsTexture)(void *data)
{
   GL_TH_ST(glIsTexture) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsTexture))thread_data->orig_func)
      (thread_data->texture);

}

GLboolean
GL_TH_FN(glIsTexture)(GL_TH_DP, GLuint texture)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsTexture) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsTexture))orig_func)
           (texture);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsTexture) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->texture = texture;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsTexture),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glLineWidth(GLfloat width);
 */

typedef void(*GL_TH_FNTYPE(glLineWidth))(GLfloat width);

typedef struct
{
   GL_TH_FNTYPE(glLineWidth) orig_func;
   GLfloat width;

} GL_TH_ST(glLineWidth);

static void
GL_TH_CB(glLineWidth)(void *data)
{
   GL_TH_ST(glLineWidth) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLineWidth))thread_data->orig_func)
      (thread_data->width);

}

void
GL_TH_FN(glLineWidth)(GL_TH_DP, GLfloat width)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLineWidth) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLineWidth))orig_func)
           (width);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLineWidth) *) + sizeof(GL_TH_ST(glLineWidth)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glLineWidth) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->width = width;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLineWidth),
                              thread_mode);
}

/*
 * void
 * glLinkProgram(GLuint program);
 */

typedef void(*GL_TH_FNTYPE(glLinkProgram))(GLuint program);

typedef struct
{
   GL_TH_FNTYPE(glLinkProgram) orig_func;
   GLuint program;

} GL_TH_ST(glLinkProgram);

static void
GL_TH_CB(glLinkProgram)(void *data)
{
   GL_TH_ST(glLinkProgram) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLinkProgram))thread_data->orig_func)
      (thread_data->program);

}

void
GL_TH_FN(glLinkProgram)(GL_TH_DP, GLuint program)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLinkProgram) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLinkProgram))orig_func)
           (program);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLinkProgram) *) + sizeof(GL_TH_ST(glLinkProgram)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glLinkProgram) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->program = program;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLinkProgram),
                              thread_mode);
}

/*
 * void
 * glPixelStorei(GLenum pname, GLint param);
 */

typedef void(*GL_TH_FNTYPE(glPixelStorei))(GLenum pname, GLint param);

typedef struct
{
   GL_TH_FNTYPE(glPixelStorei) orig_func;
   GLenum pname;
   GLint param;
   GLPIXELSTOREI_VARIABLE_DECLARE /* TODO */

} GL_TH_ST(glPixelStorei);

static void
GL_TH_CB(glPixelStorei)(void *data)
{
   GL_TH_ST(glPixelStorei) *thread_data =
      *(void **)data;


   GLPIXELSTOREI_GLCALL_BEFORE; /* TODO */


   ((GL_TH_FNTYPE(glPixelStorei))thread_data->orig_func)
      (thread_data->pname,
       thread_data->param);

   GLPIXELSTOREI_GLCALL_AFTER; /* TODO */

}

void
GL_TH_FN(glPixelStorei)(GL_TH_DP, GLenum pname, GLint param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPixelStorei) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPixelStorei))orig_func)
           (pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPixelStorei) *) + sizeof(GL_TH_ST(glPixelStorei)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glPixelStorei) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   GLPIXELSTOREI_VARIABLE_INIT; /* TODO */

   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   GLPIXELSTOREI_ASYNC_PREPARE; /* TODO */

finish:
   GLPIXELSTOREI_ENQUEUE_BEFORE; /* TODO */

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPixelStorei),
                              thread_mode);

   GLPIXELSTOREI_ENQUEUE_AFTER; /* TODO */
}

/*
 * void
 * glPolygonOffset(GLfloat factor, GLfloat units);
 */

typedef void(*GL_TH_FNTYPE(glPolygonOffset))(GLfloat factor, GLfloat units);

typedef struct
{
   GL_TH_FNTYPE(glPolygonOffset) orig_func;
   GLfloat factor;
   GLfloat units;

} GL_TH_ST(glPolygonOffset);

static void
GL_TH_CB(glPolygonOffset)(void *data)
{
   GL_TH_ST(glPolygonOffset) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPolygonOffset))thread_data->orig_func)
      (thread_data->factor,
       thread_data->units);

}

void
GL_TH_FN(glPolygonOffset)(GL_TH_DP, GLfloat factor, GLfloat units)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPolygonOffset) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPolygonOffset))orig_func)
           (factor, units);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPolygonOffset) *) + sizeof(GL_TH_ST(glPolygonOffset)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glPolygonOffset) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->factor = factor;
   thread_data->units = units;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPolygonOffset),
                              thread_mode);
}

/*
 * void
 * glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);
 */

typedef void(*GL_TH_FNTYPE(glReadPixels))(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);

typedef struct
{
   GL_TH_FNTYPE(glReadPixels) orig_func;
   GLint x;
   GLint y;
   GLsizei width;
   GLsizei height;
   GLenum format;
   GLenum type;
   void* pixels;

} GL_TH_ST(glReadPixels);

static void
GL_TH_CB(glReadPixels)(void *data)
{
   GL_TH_ST(glReadPixels) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glReadPixels))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->width,
       thread_data->height,
       thread_data->format,
       thread_data->type,
       thread_data->pixels);

}

void
GL_TH_FN(glReadPixels)(GL_TH_DP, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glReadPixels) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glReadPixels))orig_func)
           (x, y, width, height, format, type, pixels);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glReadPixels) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->format = format;
   thread_data->type = type;
   thread_data->pixels = pixels;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glReadPixels),
                              thread_mode);
}

/*
 * void
 * glReleaseShaderCompiler(void);
 */

typedef void(*GL_TH_FNTYPE(glReleaseShaderCompiler))(void);

typedef struct
{
   GL_TH_FNTYPE(glReleaseShaderCompiler) orig_func;

} GL_TH_ST(glReleaseShaderCompiler);

static void
GL_TH_CB(glReleaseShaderCompiler)(void *data)
{
   GL_TH_ST(glReleaseShaderCompiler) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glReleaseShaderCompiler))thread_data->orig_func)
      ();

}

void
GL_TH_FN(glReleaseShaderCompiler)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glReleaseShaderCompiler) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glReleaseShaderCompiler))orig_func)
           ();
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glReleaseShaderCompiler) *) + sizeof(GL_TH_ST(glReleaseShaderCompiler)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glReleaseShaderCompiler) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glReleaseShaderCompiler),
                              thread_mode);
}

/*
 * void
 * glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
 */

typedef void(*GL_TH_FNTYPE(glRenderbufferStorage))(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);

typedef struct
{
   GL_TH_FNTYPE(glRenderbufferStorage) orig_func;
   GLenum target;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;

} GL_TH_ST(glRenderbufferStorage);

static void
GL_TH_CB(glRenderbufferStorage)(void *data)
{
   GL_TH_ST(glRenderbufferStorage) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glRenderbufferStorage))thread_data->orig_func)
      (thread_data->target,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glRenderbufferStorage)(GL_TH_DP, GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glRenderbufferStorage) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glRenderbufferStorage))orig_func)
           (target, internalformat, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glRenderbufferStorage) *) + sizeof(GL_TH_ST(glRenderbufferStorage)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glRenderbufferStorage) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glRenderbufferStorage),
                              thread_mode);
}

/*
 * void
 * glSampleCoverage(GLclampf value, GLboolean invert);
 */

typedef void(*GL_TH_FNTYPE(glSampleCoverage))(GLclampf value, GLboolean invert);

typedef struct
{
   GL_TH_FNTYPE(glSampleCoverage) orig_func;
   GLclampf value;
   GLboolean invert;

} GL_TH_ST(glSampleCoverage);

static void
GL_TH_CB(glSampleCoverage)(void *data)
{
   GL_TH_ST(glSampleCoverage) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glSampleCoverage))thread_data->orig_func)
      (thread_data->value,
       thread_data->invert);

}

void
GL_TH_FN(glSampleCoverage)(GL_TH_DP, GLclampf value, GLboolean invert)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glSampleCoverage) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glSampleCoverage))orig_func)
           (value, invert);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glSampleCoverage) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->value = value;
   thread_data->invert = invert;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glSampleCoverage),
                              thread_mode);
}

/*
 * void
 * glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
 */

typedef void(*GL_TH_FNTYPE(glScissor))(GLint x, GLint y, GLsizei width, GLsizei height);

typedef struct
{
   GL_TH_FNTYPE(glScissor) orig_func;
   GLint x;
   GLint y;
   GLsizei width;
   GLsizei height;

} GL_TH_ST(glScissor);

static void
GL_TH_CB(glScissor)(void *data)
{
   GL_TH_ST(glScissor) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glScissor))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glScissor)(GL_TH_DP, GLint x, GLint y, GLsizei width, GLsizei height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glScissor) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glScissor))orig_func)
           (x, y, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glScissor) *) + sizeof(GL_TH_ST(glScissor)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glScissor) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glScissor),
                              thread_mode);
}

/*
 * void
 * glShaderBinary(GLsizei n, const GLuint* shaders, GLenum binaryformat, const void* binary, GLsizei length);
 */

typedef void(*GL_TH_FNTYPE(glShaderBinary))(GLsizei n, const GLuint* shaders, GLenum binaryformat, const void* binary, GLsizei length);

typedef struct
{
   GL_TH_FNTYPE(glShaderBinary) orig_func;
   GLsizei n;
   const GLuint* shaders;
   GLenum binaryformat;
   const void* binary;
   GLsizei length;

} GL_TH_ST(glShaderBinary);

static void
GL_TH_CB(glShaderBinary)(void *data)
{
   GL_TH_ST(glShaderBinary) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glShaderBinary))thread_data->orig_func)
      (thread_data->n,
       thread_data->shaders,
       thread_data->binaryformat,
       thread_data->binary,
       thread_data->length);

}

void
GL_TH_FN(glShaderBinary)(GL_TH_DP, GLsizei n, const GLuint* shaders, GLenum binaryformat, const void* binary, GLsizei length)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glShaderBinary) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glShaderBinary))orig_func)
           (n, shaders, binaryformat, binary, length);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glShaderBinary) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->shaders = shaders;
   thread_data->binaryformat = binaryformat;
   thread_data->binary = binary;
   thread_data->length = length;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glShaderBinary),
                              thread_mode);
}

/*
 * void
 * glShaderSource(GLuint shader, GLsizei count, const char* const * string, const GLint* length);
 */

typedef void(*GL_TH_FNTYPE(glShaderSource))(GLuint shader, GLsizei count, const char* const * string, const GLint* length);

typedef struct
{
   GL_TH_FNTYPE(glShaderSource) orig_func;
   GLuint shader;
   GLsizei count;
   const char* const * string;
   const GLint* length;
   GLSHADERSOURCE_VARIABLE_DECLARE /* TODO */

} GL_TH_ST(glShaderSource);

static void
GL_TH_CB(glShaderSource)(void *data)
{
   GL_TH_ST(glShaderSource) *thread_data =
      *(void **)data;


   GLSHADERSOURCE_GLCALL_BEFORE; /* TODO */


   ((GL_TH_FNTYPE(glShaderSource))thread_data->orig_func)
      (thread_data->shader,
       thread_data->count,
       thread_data->string,
       thread_data->length);

   GLSHADERSOURCE_GLCALL_AFTER; /* TODO */

}

void
GL_TH_FN(glShaderSource)(GL_TH_DP, GLuint shader, GLsizei count, const char* const * string, const GLint* length)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glShaderSource) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glShaderSource))orig_func)
           (shader, count, string, length);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glShaderSource) *) + sizeof(GL_TH_ST(glShaderSource)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glShaderSource) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->shader = shader;
   thread_data->count = count;
   thread_data->string = string;
   thread_data->length = length;
   thread_data->orig_func = orig_func;

   GLSHADERSOURCE_VARIABLE_INIT; /* TODO */

   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   GLSHADERSOURCE_ASYNC_PREPARE; /* TODO */

finish:
   GLSHADERSOURCE_ENQUEUE_BEFORE; /* TODO */

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glShaderSource),
                              thread_mode);

   GLSHADERSOURCE_ENQUEUE_AFTER; /* TODO */
}

/*
 * void
 * glStencilFunc(GLenum func, GLint ref, GLuint mask);
 */

typedef void(*GL_TH_FNTYPE(glStencilFunc))(GLenum func, GLint ref, GLuint mask);

typedef struct
{
   GL_TH_FNTYPE(glStencilFunc) orig_func;
   GLenum func;
   GLint ref;
   GLuint mask;

} GL_TH_ST(glStencilFunc);

static void
GL_TH_CB(glStencilFunc)(void *data)
{
   GL_TH_ST(glStencilFunc) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glStencilFunc))thread_data->orig_func)
      (thread_data->func,
       thread_data->ref,
       thread_data->mask);

}

void
GL_TH_FN(glStencilFunc)(GL_TH_DP, GLenum func, GLint ref, GLuint mask)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glStencilFunc) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glStencilFunc))orig_func)
           (func, ref, mask);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glStencilFunc) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->func = func;
   thread_data->ref = ref;
   thread_data->mask = mask;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glStencilFunc),
                              thread_mode);
}

/*
 * void
 * glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
 */

typedef void(*GL_TH_FNTYPE(glStencilFuncSeparate))(GLenum face, GLenum func, GLint ref, GLuint mask);

typedef struct
{
   GL_TH_FNTYPE(glStencilFuncSeparate) orig_func;
   GLenum face;
   GLenum func;
   GLint ref;
   GLuint mask;

} GL_TH_ST(glStencilFuncSeparate);

static void
GL_TH_CB(glStencilFuncSeparate)(void *data)
{
   GL_TH_ST(glStencilFuncSeparate) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glStencilFuncSeparate))thread_data->orig_func)
      (thread_data->face,
       thread_data->func,
       thread_data->ref,
       thread_data->mask);

}

void
GL_TH_FN(glStencilFuncSeparate)(GL_TH_DP, GLenum face, GLenum func, GLint ref, GLuint mask)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glStencilFuncSeparate) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glStencilFuncSeparate))orig_func)
           (face, func, ref, mask);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glStencilFuncSeparate) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->face = face;
   thread_data->func = func;
   thread_data->ref = ref;
   thread_data->mask = mask;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glStencilFuncSeparate),
                              thread_mode);
}

/*
 * void
 * glStencilMask(GLuint mask);
 */

typedef void(*GL_TH_FNTYPE(glStencilMask))(GLuint mask);

typedef struct
{
   GL_TH_FNTYPE(glStencilMask) orig_func;
   GLuint mask;

} GL_TH_ST(glStencilMask);

static void
GL_TH_CB(glStencilMask)(void *data)
{
   GL_TH_ST(glStencilMask) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glStencilMask))thread_data->orig_func)
      (thread_data->mask);

}

void
GL_TH_FN(glStencilMask)(GL_TH_DP, GLuint mask)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glStencilMask) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glStencilMask))orig_func)
           (mask);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glStencilMask) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mask = mask;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glStencilMask),
                              thread_mode);
}

/*
 * void
 * glStencilMaskSeparate(GLenum face, GLuint mask);
 */

typedef void(*GL_TH_FNTYPE(glStencilMaskSeparate))(GLenum face, GLuint mask);

typedef struct
{
   GL_TH_FNTYPE(glStencilMaskSeparate) orig_func;
   GLenum face;
   GLuint mask;

} GL_TH_ST(glStencilMaskSeparate);

static void
GL_TH_CB(glStencilMaskSeparate)(void *data)
{
   GL_TH_ST(glStencilMaskSeparate) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glStencilMaskSeparate))thread_data->orig_func)
      (thread_data->face,
       thread_data->mask);

}

void
GL_TH_FN(glStencilMaskSeparate)(GL_TH_DP, GLenum face, GLuint mask)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glStencilMaskSeparate) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glStencilMaskSeparate))orig_func)
           (face, mask);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glStencilMaskSeparate) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->face = face;
   thread_data->mask = mask;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glStencilMaskSeparate),
                              thread_mode);
}

/*
 * void
 * glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);
 */

typedef void(*GL_TH_FNTYPE(glStencilOp))(GLenum fail, GLenum zfail, GLenum zpass);

typedef struct
{
   GL_TH_FNTYPE(glStencilOp) orig_func;
   GLenum fail;
   GLenum zfail;
   GLenum zpass;

} GL_TH_ST(glStencilOp);

static void
GL_TH_CB(glStencilOp)(void *data)
{
   GL_TH_ST(glStencilOp) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glStencilOp))thread_data->orig_func)
      (thread_data->fail,
       thread_data->zfail,
       thread_data->zpass);

}

void
GL_TH_FN(glStencilOp)(GL_TH_DP, GLenum fail, GLenum zfail, GLenum zpass)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glStencilOp) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glStencilOp))orig_func)
           (fail, zfail, zpass);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glStencilOp) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->fail = fail;
   thread_data->zfail = zfail;
   thread_data->zpass = zpass;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glStencilOp),
                              thread_mode);
}

/*
 * void
 * glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
 */

typedef void(*GL_TH_FNTYPE(glStencilOpSeparate))(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);

typedef struct
{
   GL_TH_FNTYPE(glStencilOpSeparate) orig_func;
   GLenum face;
   GLenum fail;
   GLenum zfail;
   GLenum zpass;

} GL_TH_ST(glStencilOpSeparate);

static void
GL_TH_CB(glStencilOpSeparate)(void *data)
{
   GL_TH_ST(glStencilOpSeparate) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glStencilOpSeparate))thread_data->orig_func)
      (thread_data->face,
       thread_data->fail,
       thread_data->zfail,
       thread_data->zpass);

}

void
GL_TH_FN(glStencilOpSeparate)(GL_TH_DP, GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glStencilOpSeparate) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glStencilOpSeparate))orig_func)
           (face, fail, zfail, zpass);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glStencilOpSeparate) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->face = face;
   thread_data->fail = fail;
   thread_data->zfail = zfail;
   thread_data->zpass = zpass;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glStencilOpSeparate),
                              thread_mode);
}

/*
 * void
 * glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
 */

typedef void(*GL_TH_FNTYPE(glTexImage2D))(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);

typedef struct
{
   GL_TH_FNTYPE(glTexImage2D) orig_func;
   GLenum target;
   GLint level;
   GLint internalformat;
   GLsizei width;
   GLsizei height;
   GLint border;
   GLenum format;
   GLenum type;
   const void* pixels;
   GLTEXIMAGE2D_VARIABLE_DECLARE /* TODO */

} GL_TH_ST(glTexImage2D);

static void
GL_TH_CB(glTexImage2D)(void *data)
{
   GL_TH_ST(glTexImage2D) *thread_data =
      *(void **)data;


   GLTEXIMAGE2D_GLCALL_BEFORE; /* TODO */


   ((GL_TH_FNTYPE(glTexImage2D))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height,
       thread_data->border,
       thread_data->format,
       thread_data->type,
       thread_data->pixels);

   GLTEXIMAGE2D_GLCALL_AFTER; /* TODO */

}

void
GL_TH_FN(glTexImage2D)(GL_TH_DP, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexImage2D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexImage2D))orig_func)
           (target, level, internalformat, width, height, border, format, type, pixels);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexImage2D) *) + sizeof(GL_TH_ST(glTexImage2D)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glTexImage2D) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->border = border;
   thread_data->format = format;
   thread_data->type = type;
   thread_data->pixels = pixels;
   thread_data->orig_func = orig_func;

   GLTEXIMAGE2D_VARIABLE_INIT; /* TODO */

   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   GLTEXIMAGE2D_ASYNC_PREPARE; /* TODO */

finish:
   GLTEXIMAGE2D_ENQUEUE_BEFORE; /* TODO */

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexImage2D),
                              thread_mode);

   GLTEXIMAGE2D_ENQUEUE_AFTER; /* TODO */
}

/*
 * void
 * glTexParameterf(GLenum target, GLenum pname, GLfloat param);
 */

typedef void(*GL_TH_FNTYPE(glTexParameterf))(GLenum target, GLenum pname, GLfloat param);

typedef struct
{
   GL_TH_FNTYPE(glTexParameterf) orig_func;
   GLenum target;
   GLenum pname;
   GLfloat param;

} GL_TH_ST(glTexParameterf);

static void
GL_TH_CB(glTexParameterf)(void *data)
{
   GL_TH_ST(glTexParameterf) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexParameterf))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glTexParameterf)(GL_TH_DP, GLenum target, GLenum pname, GLfloat param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexParameterf) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexParameterf))orig_func)
           (target, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexParameterf) *) + sizeof(GL_TH_ST(glTexParameterf)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glTexParameterf) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexParameterf),
                              thread_mode);
}

/*
 * void
 * glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params);
 */

typedef void(*GL_TH_FNTYPE(glTexParameterfv))(GLenum target, GLenum pname, const GLfloat* params);

typedef struct
{
   GL_TH_FNTYPE(glTexParameterfv) orig_func;
   GLenum target;
   GLenum pname;
   const GLfloat* params;
   void *params_copied; /* COPIED */

} GL_TH_ST(glTexParameterfv);

static void
GL_TH_CB(glTexParameterfv)(void *data)
{
   GL_TH_ST(glTexParameterfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexParameterfv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);


   if (thread_data->params_copied)
     eina_mempool_free(_mp_default, thread_data->params_copied);

}

void
GL_TH_FN(glTexParameterfv)(GL_TH_DP, GLenum target, GLenum pname, const GLfloat* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexParameterfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexParameterfv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexParameterfv) *) + sizeof(GL_TH_ST(glTexParameterfv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glTexParameterfv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   thread_data->params_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (params)
     {
        /* 1. check memory size */
        unsigned int copy_size = sizeof(GLfloat);
        if (copy_size > _mp_default_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->params_copied = eina_mempool_malloc(_mp_default, copy_size);
        if (thread_data->params_copied)
          {
             memcpy(thread_data->params_copied, params, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->params = (const GLfloat *)thread_data->params_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexParameterfv),
                              thread_mode);
}

/*
 * void
 * glTexParameteri(GLenum target, GLenum pname, GLint param);
 */

typedef void(*GL_TH_FNTYPE(glTexParameteri))(GLenum target, GLenum pname, GLint param);

typedef struct
{
   GL_TH_FNTYPE(glTexParameteri) orig_func;
   GLenum target;
   GLenum pname;
   GLint param;

} GL_TH_ST(glTexParameteri);

static void
GL_TH_CB(glTexParameteri)(void *data)
{
   GL_TH_ST(glTexParameteri) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexParameteri))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glTexParameteri)(GL_TH_DP, GLenum target, GLenum pname, GLint param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexParameteri) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexParameteri))orig_func)
           (target, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexParameteri) *) + sizeof(GL_TH_ST(glTexParameteri)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glTexParameteri) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexParameteri),
                              thread_mode);
}

/*
 * void
 * glTexParameteriv(GLenum target, GLenum pname, const GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glTexParameteriv))(GLenum target, GLenum pname, const GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glTexParameteriv) orig_func;
   GLenum target;
   GLenum pname;
   const GLint* params;
   void *params_copied; /* COPIED */

} GL_TH_ST(glTexParameteriv);

static void
GL_TH_CB(glTexParameteriv)(void *data)
{
   GL_TH_ST(glTexParameteriv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexParameteriv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);


   if (thread_data->params_copied)
     eina_mempool_free(_mp_default, thread_data->params_copied);

}

void
GL_TH_FN(glTexParameteriv)(GL_TH_DP, GLenum target, GLenum pname, const GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexParameteriv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexParameteriv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexParameteriv) *) + sizeof(GL_TH_ST(glTexParameteriv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glTexParameteriv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   thread_data->params_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (params)
     {
        /* 1. check memory size */
        unsigned int copy_size = sizeof(GLint);
        if (copy_size > _mp_default_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->params_copied = eina_mempool_malloc(_mp_default, copy_size);
        if (thread_data->params_copied)
          {
             memcpy(thread_data->params_copied, params, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->params = (const GLint *)thread_data->params_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexParameteriv),
                              thread_mode);
}

/*
 * void
 * glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
 */

typedef void(*GL_TH_FNTYPE(glTexSubImage2D))(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);

typedef struct
{
   GL_TH_FNTYPE(glTexSubImage2D) orig_func;
   GLenum target;
   GLint level;
   GLint xoffset;
   GLint yoffset;
   GLsizei width;
   GLsizei height;
   GLenum format;
   GLenum type;
   const void* pixels;
   GLTEXSUBIMAGE2D_VARIABLE_DECLARE /* TODO */

} GL_TH_ST(glTexSubImage2D);

static void
GL_TH_CB(glTexSubImage2D)(void *data)
{
   GL_TH_ST(glTexSubImage2D) *thread_data =
      *(void **)data;


   GLTEXSUBIMAGE2D_GLCALL_BEFORE; /* TODO */


   ((GL_TH_FNTYPE(glTexSubImage2D))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->xoffset,
       thread_data->yoffset,
       thread_data->width,
       thread_data->height,
       thread_data->format,
       thread_data->type,
       thread_data->pixels);

   GLTEXSUBIMAGE2D_GLCALL_AFTER; /* TODO */

}

void
GL_TH_FN(glTexSubImage2D)(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexSubImage2D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexSubImage2D))orig_func)
           (target, level, xoffset, yoffset, width, height, format, type, pixels);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexSubImage2D) *) + sizeof(GL_TH_ST(glTexSubImage2D)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glTexSubImage2D) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->xoffset = xoffset;
   thread_data->yoffset = yoffset;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->format = format;
   thread_data->type = type;
   thread_data->pixels = pixels;
   thread_data->orig_func = orig_func;

   GLTEXSUBIMAGE2D_VARIABLE_INIT; /* TODO */

   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   GLTEXSUBIMAGE2D_ASYNC_PREPARE; /* TODO */

finish:
   GLTEXSUBIMAGE2D_ENQUEUE_BEFORE; /* TODO */

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexSubImage2D),
                              thread_mode);

   GLTEXSUBIMAGE2D_ENQUEUE_AFTER; /* TODO */
}

/*
 * void
 * glUniform1f(GLint location, GLfloat x);
 */

typedef void(*GL_TH_FNTYPE(glUniform1f))(GLint location, GLfloat x);

typedef struct
{
   GL_TH_FNTYPE(glUniform1f) orig_func;
   GLint location;
   GLfloat x;

} GL_TH_ST(glUniform1f);

static void
GL_TH_CB(glUniform1f)(void *data)
{
   GL_TH_ST(glUniform1f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform1f))thread_data->orig_func)
      (thread_data->location,
       thread_data->x);

}

void
GL_TH_FN(glUniform1f)(GL_TH_DP, GLint location, GLfloat x)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform1f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform1f))orig_func)
           (location, x);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform1f) *) + sizeof(GL_TH_ST(glUniform1f)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform1f) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->x = x;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform1f),
                              thread_mode);
}

/*
 * void
 * glUniform1fv(GLint location, GLsizei count, const GLfloat* v);
 */

typedef void(*GL_TH_FNTYPE(glUniform1fv))(GLint location, GLsizei count, const GLfloat* v);

typedef struct
{
   GL_TH_FNTYPE(glUniform1fv) orig_func;
   GLint location;
   GLsizei count;
   const GLfloat* v;
   void *v_copied; /* COPIED */

} GL_TH_ST(glUniform1fv);

static void
GL_TH_CB(glUniform1fv)(void *data)
{
   GL_TH_ST(glUniform1fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform1fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->v);


   if (thread_data->v_copied)
     eina_mempool_free(_mp_uniform, thread_data->v_copied);

}

void
GL_TH_FN(glUniform1fv)(GL_TH_DP, GLint location, GLsizei count, const GLfloat* v)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform1fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform1fv))orig_func)
           (location, count, v);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform1fv) *) + sizeof(GL_TH_ST(glUniform1fv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform1fv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->v = v;
   thread_data->orig_func = orig_func;

   thread_data->v_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (v)
     {
        /* 1. check memory size */
        unsigned int copy_size = 1 * count * sizeof(GLfloat);
        if (copy_size > _mp_uniform_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->v_copied = eina_mempool_malloc(_mp_uniform, copy_size);
        if (thread_data->v_copied)
          {
             memcpy(thread_data->v_copied, v, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->v = (const GLfloat *)thread_data->v_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform1fv),
                              thread_mode);
}

/*
 * void
 * glUniform1i(GLint location, GLint x);
 */

typedef void(*GL_TH_FNTYPE(glUniform1i))(GLint location, GLint x);

typedef struct
{
   GL_TH_FNTYPE(glUniform1i) orig_func;
   GLint location;
   GLint x;

} GL_TH_ST(glUniform1i);

static void
GL_TH_CB(glUniform1i)(void *data)
{
   GL_TH_ST(glUniform1i) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform1i))thread_data->orig_func)
      (thread_data->location,
       thread_data->x);

}

void
GL_TH_FN(glUniform1i)(GL_TH_DP, GLint location, GLint x)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform1i) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform1i))orig_func)
           (location, x);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform1i) *) + sizeof(GL_TH_ST(glUniform1i)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform1i) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->x = x;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform1i),
                              thread_mode);
}

/*
 * void
 * glUniform1iv(GLint location, GLsizei count, const GLint* v);
 */

typedef void(*GL_TH_FNTYPE(glUniform1iv))(GLint location, GLsizei count, const GLint* v);

typedef struct
{
   GL_TH_FNTYPE(glUniform1iv) orig_func;
   GLint location;
   GLsizei count;
   const GLint* v;
   void *v_copied; /* COPIED */

} GL_TH_ST(glUniform1iv);

static void
GL_TH_CB(glUniform1iv)(void *data)
{
   GL_TH_ST(glUniform1iv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform1iv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->v);


   if (thread_data->v_copied)
     eina_mempool_free(_mp_uniform, thread_data->v_copied);

}

void
GL_TH_FN(glUniform1iv)(GL_TH_DP, GLint location, GLsizei count, const GLint* v)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform1iv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform1iv))orig_func)
           (location, count, v);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform1iv) *) + sizeof(GL_TH_ST(glUniform1iv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform1iv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->v = v;
   thread_data->orig_func = orig_func;

   thread_data->v_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (v)
     {
        /* 1. check memory size */
        unsigned int copy_size = 1 * count * sizeof(GLint);
        if (copy_size > _mp_uniform_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->v_copied = eina_mempool_malloc(_mp_uniform, copy_size);
        if (thread_data->v_copied)
          {
             memcpy(thread_data->v_copied, v, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->v = (const GLint *)thread_data->v_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform1iv),
                              thread_mode);
}

/*
 * void
 * glUniform2f(GLint location, GLfloat x, GLfloat y);
 */

typedef void(*GL_TH_FNTYPE(glUniform2f))(GLint location, GLfloat x, GLfloat y);

typedef struct
{
   GL_TH_FNTYPE(glUniform2f) orig_func;
   GLint location;
   GLfloat x;
   GLfloat y;

} GL_TH_ST(glUniform2f);

static void
GL_TH_CB(glUniform2f)(void *data)
{
   GL_TH_ST(glUniform2f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform2f))thread_data->orig_func)
      (thread_data->location,
       thread_data->x,
       thread_data->y);

}

void
GL_TH_FN(glUniform2f)(GL_TH_DP, GLint location, GLfloat x, GLfloat y)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform2f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform2f))orig_func)
           (location, x, y);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform2f) *) + sizeof(GL_TH_ST(glUniform2f)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform2f) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform2f),
                              thread_mode);
}

/*
 * void
 * glUniform2fv(GLint location, GLsizei count, const GLfloat* v);
 */

typedef void(*GL_TH_FNTYPE(glUniform2fv))(GLint location, GLsizei count, const GLfloat* v);

typedef struct
{
   GL_TH_FNTYPE(glUniform2fv) orig_func;
   GLint location;
   GLsizei count;
   const GLfloat* v;
   void *v_copied; /* COPIED */

} GL_TH_ST(glUniform2fv);

static void
GL_TH_CB(glUniform2fv)(void *data)
{
   GL_TH_ST(glUniform2fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform2fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->v);


   if (thread_data->v_copied)
     eina_mempool_free(_mp_uniform, thread_data->v_copied);

}

void
GL_TH_FN(glUniform2fv)(GL_TH_DP, GLint location, GLsizei count, const GLfloat* v)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform2fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform2fv))orig_func)
           (location, count, v);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform2fv) *) + sizeof(GL_TH_ST(glUniform2fv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform2fv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->v = v;
   thread_data->orig_func = orig_func;

   thread_data->v_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (v)
     {
        /* 1. check memory size */
        unsigned int copy_size = 2 * count * sizeof(GLfloat);
        if (copy_size > _mp_uniform_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->v_copied = eina_mempool_malloc(_mp_uniform, copy_size);
        if (thread_data->v_copied)
          {
             memcpy(thread_data->v_copied, v, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->v = (const GLfloat *)thread_data->v_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform2fv),
                              thread_mode);
}

/*
 * void
 * glUniform2i(GLint location, GLint x, GLint y);
 */

typedef void(*GL_TH_FNTYPE(glUniform2i))(GLint location, GLint x, GLint y);

typedef struct
{
   GL_TH_FNTYPE(glUniform2i) orig_func;
   GLint location;
   GLint x;
   GLint y;

} GL_TH_ST(glUniform2i);

static void
GL_TH_CB(glUniform2i)(void *data)
{
   GL_TH_ST(glUniform2i) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform2i))thread_data->orig_func)
      (thread_data->location,
       thread_data->x,
       thread_data->y);

}

void
GL_TH_FN(glUniform2i)(GL_TH_DP, GLint location, GLint x, GLint y)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform2i) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform2i))orig_func)
           (location, x, y);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform2i) *) + sizeof(GL_TH_ST(glUniform2i)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform2i) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform2i),
                              thread_mode);
}

/*
 * void
 * glUniform2iv(GLint location, GLsizei count, const GLint* v);
 */

typedef void(*GL_TH_FNTYPE(glUniform2iv))(GLint location, GLsizei count, const GLint* v);

typedef struct
{
   GL_TH_FNTYPE(glUniform2iv) orig_func;
   GLint location;
   GLsizei count;
   const GLint* v;
   void *v_copied; /* COPIED */

} GL_TH_ST(glUniform2iv);

static void
GL_TH_CB(glUniform2iv)(void *data)
{
   GL_TH_ST(glUniform2iv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform2iv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->v);


   if (thread_data->v_copied)
     eina_mempool_free(_mp_uniform, thread_data->v_copied);

}

void
GL_TH_FN(glUniform2iv)(GL_TH_DP, GLint location, GLsizei count, const GLint* v)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform2iv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform2iv))orig_func)
           (location, count, v);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform2iv) *) + sizeof(GL_TH_ST(glUniform2iv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform2iv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->v = v;
   thread_data->orig_func = orig_func;

   thread_data->v_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (v)
     {
        /* 1. check memory size */
        unsigned int copy_size = 2 * count * sizeof(GLint);
        if (copy_size > _mp_uniform_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->v_copied = eina_mempool_malloc(_mp_uniform, copy_size);
        if (thread_data->v_copied)
          {
             memcpy(thread_data->v_copied, v, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->v = (const GLint *)thread_data->v_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform2iv),
                              thread_mode);
}

/*
 * void
 * glUniform3f(GLint location, GLfloat x, GLfloat y, GLfloat z);
 */

typedef void(*GL_TH_FNTYPE(glUniform3f))(GLint location, GLfloat x, GLfloat y, GLfloat z);

typedef struct
{
   GL_TH_FNTYPE(glUniform3f) orig_func;
   GLint location;
   GLfloat x;
   GLfloat y;
   GLfloat z;

} GL_TH_ST(glUniform3f);

static void
GL_TH_CB(glUniform3f)(void *data)
{
   GL_TH_ST(glUniform3f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform3f))thread_data->orig_func)
      (thread_data->location,
       thread_data->x,
       thread_data->y,
       thread_data->z);

}

void
GL_TH_FN(glUniform3f)(GL_TH_DP, GLint location, GLfloat x, GLfloat y, GLfloat z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform3f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform3f))orig_func)
           (location, x, y, z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform3f) *) + sizeof(GL_TH_ST(glUniform3f)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform3f) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform3f),
                              thread_mode);
}

/*
 * void
 * glUniform3fv(GLint location, GLsizei count, const GLfloat* v);
 */

typedef void(*GL_TH_FNTYPE(glUniform3fv))(GLint location, GLsizei count, const GLfloat* v);

typedef struct
{
   GL_TH_FNTYPE(glUniform3fv) orig_func;
   GLint location;
   GLsizei count;
   const GLfloat* v;
   void *v_copied; /* COPIED */

} GL_TH_ST(glUniform3fv);

static void
GL_TH_CB(glUniform3fv)(void *data)
{
   GL_TH_ST(glUniform3fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform3fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->v);


   if (thread_data->v_copied)
     eina_mempool_free(_mp_uniform, thread_data->v_copied);

}

void
GL_TH_FN(glUniform3fv)(GL_TH_DP, GLint location, GLsizei count, const GLfloat* v)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform3fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform3fv))orig_func)
           (location, count, v);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform3fv) *) + sizeof(GL_TH_ST(glUniform3fv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform3fv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->v = v;
   thread_data->orig_func = orig_func;

   thread_data->v_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (v)
     {
        /* 1. check memory size */
        unsigned int copy_size = 3 * count * sizeof(GLfloat);
        if (copy_size > _mp_uniform_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->v_copied = eina_mempool_malloc(_mp_uniform, copy_size);
        if (thread_data->v_copied)
          {
             memcpy(thread_data->v_copied, v, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->v = (const GLfloat *)thread_data->v_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform3fv),
                              thread_mode);
}

/*
 * void
 * glUniform3i(GLint location, GLint x, GLint y, GLint z);
 */

typedef void(*GL_TH_FNTYPE(glUniform3i))(GLint location, GLint x, GLint y, GLint z);

typedef struct
{
   GL_TH_FNTYPE(glUniform3i) orig_func;
   GLint location;
   GLint x;
   GLint y;
   GLint z;

} GL_TH_ST(glUniform3i);

static void
GL_TH_CB(glUniform3i)(void *data)
{
   GL_TH_ST(glUniform3i) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform3i))thread_data->orig_func)
      (thread_data->location,
       thread_data->x,
       thread_data->y,
       thread_data->z);

}

void
GL_TH_FN(glUniform3i)(GL_TH_DP, GLint location, GLint x, GLint y, GLint z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform3i) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform3i))orig_func)
           (location, x, y, z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform3i) *) + sizeof(GL_TH_ST(glUniform3i)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform3i) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform3i),
                              thread_mode);
}

/*
 * void
 * glUniform3iv(GLint location, GLsizei count, const GLint* v);
 */

typedef void(*GL_TH_FNTYPE(glUniform3iv))(GLint location, GLsizei count, const GLint* v);

typedef struct
{
   GL_TH_FNTYPE(glUniform3iv) orig_func;
   GLint location;
   GLsizei count;
   const GLint* v;
   void *v_copied; /* COPIED */

} GL_TH_ST(glUniform3iv);

static void
GL_TH_CB(glUniform3iv)(void *data)
{
   GL_TH_ST(glUniform3iv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform3iv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->v);


   if (thread_data->v_copied)
     eina_mempool_free(_mp_uniform, thread_data->v_copied);

}

void
GL_TH_FN(glUniform3iv)(GL_TH_DP, GLint location, GLsizei count, const GLint* v)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform3iv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform3iv))orig_func)
           (location, count, v);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform3iv) *) + sizeof(GL_TH_ST(glUniform3iv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform3iv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->v = v;
   thread_data->orig_func = orig_func;

   thread_data->v_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (v)
     {
        /* 1. check memory size */
        unsigned int copy_size = 3 * count * sizeof(GLint);
        if (copy_size > _mp_uniform_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->v_copied = eina_mempool_malloc(_mp_uniform, copy_size);
        if (thread_data->v_copied)
          {
             memcpy(thread_data->v_copied, v, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->v = (const GLint *)thread_data->v_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform3iv),
                              thread_mode);
}

/*
 * void
 * glUniform4f(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
 */

typedef void(*GL_TH_FNTYPE(glUniform4f))(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);

typedef struct
{
   GL_TH_FNTYPE(glUniform4f) orig_func;
   GLint location;
   GLfloat x;
   GLfloat y;
   GLfloat z;
   GLfloat w;

} GL_TH_ST(glUniform4f);

static void
GL_TH_CB(glUniform4f)(void *data)
{
   GL_TH_ST(glUniform4f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform4f))thread_data->orig_func)
      (thread_data->location,
       thread_data->x,
       thread_data->y,
       thread_data->z,
       thread_data->w);

}

void
GL_TH_FN(glUniform4f)(GL_TH_DP, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform4f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform4f))orig_func)
           (location, x, y, z, w);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform4f) *) + sizeof(GL_TH_ST(glUniform4f)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform4f) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->w = w;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform4f),
                              thread_mode);
}

/*
 * void
 * glUniform4fv(GLint location, GLsizei count, const GLfloat* v);
 */

typedef void(*GL_TH_FNTYPE(glUniform4fv))(GLint location, GLsizei count, const GLfloat* v);

typedef struct
{
   GL_TH_FNTYPE(glUniform4fv) orig_func;
   GLint location;
   GLsizei count;
   const GLfloat* v;
   void *v_copied; /* COPIED */

} GL_TH_ST(glUniform4fv);

static void
GL_TH_CB(glUniform4fv)(void *data)
{
   GL_TH_ST(glUniform4fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform4fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->v);


   if (thread_data->v_copied)
     eina_mempool_free(_mp_uniform, thread_data->v_copied);

}

void
GL_TH_FN(glUniform4fv)(GL_TH_DP, GLint location, GLsizei count, const GLfloat* v)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform4fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform4fv))orig_func)
           (location, count, v);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform4fv) *) + sizeof(GL_TH_ST(glUniform4fv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform4fv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->v = v;
   thread_data->orig_func = orig_func;

   thread_data->v_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (v)
     {
        /* 1. check memory size */
        unsigned int copy_size = 4 * count * sizeof(GLfloat);
        if (copy_size > _mp_uniform_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->v_copied = eina_mempool_malloc(_mp_uniform, copy_size);
        if (thread_data->v_copied)
          {
             memcpy(thread_data->v_copied, v, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->v = (const GLfloat *)thread_data->v_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform4fv),
                              thread_mode);
}

/*
 * void
 * glUniform4i(GLint location, GLint x, GLint y, GLint z, GLint w);
 */

typedef void(*GL_TH_FNTYPE(glUniform4i))(GLint location, GLint x, GLint y, GLint z, GLint w);

typedef struct
{
   GL_TH_FNTYPE(glUniform4i) orig_func;
   GLint location;
   GLint x;
   GLint y;
   GLint z;
   GLint w;

} GL_TH_ST(glUniform4i);

static void
GL_TH_CB(glUniform4i)(void *data)
{
   GL_TH_ST(glUniform4i) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform4i))thread_data->orig_func)
      (thread_data->location,
       thread_data->x,
       thread_data->y,
       thread_data->z,
       thread_data->w);

}

void
GL_TH_FN(glUniform4i)(GL_TH_DP, GLint location, GLint x, GLint y, GLint z, GLint w)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform4i) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform4i))orig_func)
           (location, x, y, z, w);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform4i) *) + sizeof(GL_TH_ST(glUniform4i)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform4i) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->w = w;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform4i),
                              thread_mode);
}

/*
 * void
 * glUniform4iv(GLint location, GLsizei count, const GLint* v);
 */

typedef void(*GL_TH_FNTYPE(glUniform4iv))(GLint location, GLsizei count, const GLint* v);

typedef struct
{
   GL_TH_FNTYPE(glUniform4iv) orig_func;
   GLint location;
   GLsizei count;
   const GLint* v;
   void *v_copied; /* COPIED */

} GL_TH_ST(glUniform4iv);

static void
GL_TH_CB(glUniform4iv)(void *data)
{
   GL_TH_ST(glUniform4iv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform4iv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->v);


   if (thread_data->v_copied)
     eina_mempool_free(_mp_uniform, thread_data->v_copied);

}

void
GL_TH_FN(glUniform4iv)(GL_TH_DP, GLint location, GLsizei count, const GLint* v)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform4iv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform4iv))orig_func)
           (location, count, v);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform4iv) *) + sizeof(GL_TH_ST(glUniform4iv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniform4iv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->v = v;
   thread_data->orig_func = orig_func;

   thread_data->v_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (v)
     {
        /* 1. check memory size */
        unsigned int copy_size = 4 * count * sizeof(GLint);
        if (copy_size > _mp_uniform_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->v_copied = eina_mempool_malloc(_mp_uniform, copy_size);
        if (thread_data->v_copied)
          {
             memcpy(thread_data->v_copied, v, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->v = (const GLint *)thread_data->v_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform4iv),
                              thread_mode);
}

/*
 * void
 * glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
 */

typedef void(*GL_TH_FNTYPE(glUniformMatrix2fv))(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);

typedef struct
{
   GL_TH_FNTYPE(glUniformMatrix2fv) orig_func;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat* value;
   void *value_copied; /* COPIED */

} GL_TH_ST(glUniformMatrix2fv);

static void
GL_TH_CB(glUniformMatrix2fv)(void *data)
{
   GL_TH_ST(glUniformMatrix2fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniformMatrix2fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);


   if (thread_data->value_copied)
     eina_mempool_free(_mp_uniform, thread_data->value_copied);

}

void
GL_TH_FN(glUniformMatrix2fv)(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniformMatrix2fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniformMatrix2fv))orig_func)
           (location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniformMatrix2fv) *) + sizeof(GL_TH_ST(glUniformMatrix2fv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniformMatrix2fv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   thread_data->value_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (value)
     {
        /* 1. check memory size */
        unsigned int copy_size = 4 * count * sizeof(GLfloat);
        if (copy_size > _mp_uniform_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->value_copied = eina_mempool_malloc(_mp_uniform, copy_size);
        if (thread_data->value_copied)
          {
             memcpy(thread_data->value_copied, value, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->value = (const GLfloat *)thread_data->value_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniformMatrix2fv),
                              thread_mode);
}

/*
 * void
 * glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
 */

typedef void(*GL_TH_FNTYPE(glUniformMatrix3fv))(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);

typedef struct
{
   GL_TH_FNTYPE(glUniformMatrix3fv) orig_func;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat* value;
   void *value_copied; /* COPIED */

} GL_TH_ST(glUniformMatrix3fv);

static void
GL_TH_CB(glUniformMatrix3fv)(void *data)
{
   GL_TH_ST(glUniformMatrix3fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniformMatrix3fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);


   if (thread_data->value_copied)
     eina_mempool_free(_mp_uniform, thread_data->value_copied);

}

void
GL_TH_FN(glUniformMatrix3fv)(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniformMatrix3fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniformMatrix3fv))orig_func)
           (location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniformMatrix3fv) *) + sizeof(GL_TH_ST(glUniformMatrix3fv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniformMatrix3fv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   thread_data->value_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (value)
     {
        /* 1. check memory size */
        unsigned int copy_size = 9 * count * sizeof(GLfloat);
        if (copy_size > _mp_uniform_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->value_copied = eina_mempool_malloc(_mp_uniform, copy_size);
        if (thread_data->value_copied)
          {
             memcpy(thread_data->value_copied, value, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->value = (const GLfloat *)thread_data->value_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniformMatrix3fv),
                              thread_mode);
}

/*
 * void
 * glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
 */

typedef void(*GL_TH_FNTYPE(glUniformMatrix4fv))(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);

typedef struct
{
   GL_TH_FNTYPE(glUniformMatrix4fv) orig_func;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat* value;
   void *value_copied; /* COPIED */

} GL_TH_ST(glUniformMatrix4fv);

static void
GL_TH_CB(glUniformMatrix4fv)(void *data)
{
   GL_TH_ST(glUniformMatrix4fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniformMatrix4fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);


   if (thread_data->value_copied)
     eina_mempool_free(_mp_uniform, thread_data->value_copied);

}

void
GL_TH_FN(glUniformMatrix4fv)(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniformMatrix4fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniformMatrix4fv))orig_func)
           (location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniformMatrix4fv) *) + sizeof(GL_TH_ST(glUniformMatrix4fv)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUniformMatrix4fv) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   thread_data->value_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (value)
     {
        /* 1. check memory size */
        unsigned int copy_size = 16 * count * sizeof(GLfloat);
        if (copy_size > _mp_uniform_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->value_copied = eina_mempool_malloc(_mp_uniform, copy_size);
        if (thread_data->value_copied)
          {
             memcpy(thread_data->value_copied, value, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->value = (const GLfloat *)thread_data->value_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniformMatrix4fv),
                              thread_mode);
}

/*
 * void
 * glUseProgram(GLuint program);
 */

typedef void(*GL_TH_FNTYPE(glUseProgram))(GLuint program);

typedef struct
{
   GL_TH_FNTYPE(glUseProgram) orig_func;
   GLuint program;

} GL_TH_ST(glUseProgram);

static void
GL_TH_CB(glUseProgram)(void *data)
{
   GL_TH_ST(glUseProgram) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUseProgram))thread_data->orig_func)
      (thread_data->program);

}

void
GL_TH_FN(glUseProgram)(GL_TH_DP, GLuint program)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUseProgram) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUseProgram))orig_func)
           (program);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUseProgram) *) + sizeof(GL_TH_ST(glUseProgram)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glUseProgram) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->program = program;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUseProgram),
                              thread_mode);
}

/*
 * void
 * glValidateProgram(GLuint program);
 */

typedef void(*GL_TH_FNTYPE(glValidateProgram))(GLuint program);

typedef struct
{
   GL_TH_FNTYPE(glValidateProgram) orig_func;
   GLuint program;

} GL_TH_ST(glValidateProgram);

static void
GL_TH_CB(glValidateProgram)(void *data)
{
   GL_TH_ST(glValidateProgram) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glValidateProgram))thread_data->orig_func)
      (thread_data->program);

}

void
GL_TH_FN(glValidateProgram)(GL_TH_DP, GLuint program)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glValidateProgram) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glValidateProgram))orig_func)
           (program);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glValidateProgram) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glValidateProgram),
                              thread_mode);
}

/*
 * void
 * glVertexAttrib1f(GLuint indx, GLfloat x);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttrib1f))(GLuint indx, GLfloat x);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttrib1f) orig_func;
   GLuint indx;
   GLfloat x;

} GL_TH_ST(glVertexAttrib1f);

static void
GL_TH_CB(glVertexAttrib1f)(void *data)
{
   GL_TH_ST(glVertexAttrib1f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttrib1f))thread_data->orig_func)
      (thread_data->indx,
       thread_data->x);

}

void
GL_TH_FN(glVertexAttrib1f)(GL_TH_DP, GLuint indx, GLfloat x)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttrib1f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttrib1f))orig_func)
           (indx, x);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttrib1f) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->indx = indx;
   thread_data->x = x;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttrib1f),
                              thread_mode);
}

/*
 * void
 * glVertexAttrib1fv(GLuint indx, const GLfloat* values);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttrib1fv))(GLuint indx, const GLfloat* values);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttrib1fv) orig_func;
   GLuint indx;
   const GLfloat* values;

} GL_TH_ST(glVertexAttrib1fv);

static void
GL_TH_CB(glVertexAttrib1fv)(void *data)
{
   GL_TH_ST(glVertexAttrib1fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttrib1fv))thread_data->orig_func)
      (thread_data->indx,
       thread_data->values);

}

void
GL_TH_FN(glVertexAttrib1fv)(GL_TH_DP, GLuint indx, const GLfloat* values)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttrib1fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttrib1fv))orig_func)
           (indx, values);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttrib1fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->indx = indx;
   thread_data->values = values;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttrib1fv),
                              thread_mode);
}

/*
 * void
 * glVertexAttrib2f(GLuint indx, GLfloat x, GLfloat y);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttrib2f))(GLuint indx, GLfloat x, GLfloat y);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttrib2f) orig_func;
   GLuint indx;
   GLfloat x;
   GLfloat y;

} GL_TH_ST(glVertexAttrib2f);

static void
GL_TH_CB(glVertexAttrib2f)(void *data)
{
   GL_TH_ST(glVertexAttrib2f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttrib2f))thread_data->orig_func)
      (thread_data->indx,
       thread_data->x,
       thread_data->y);

}

void
GL_TH_FN(glVertexAttrib2f)(GL_TH_DP, GLuint indx, GLfloat x, GLfloat y)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttrib2f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttrib2f))orig_func)
           (indx, x, y);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttrib2f) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->indx = indx;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttrib2f),
                              thread_mode);
}

/*
 * void
 * glVertexAttrib2fv(GLuint indx, const GLfloat* values);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttrib2fv))(GLuint indx, const GLfloat* values);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttrib2fv) orig_func;
   GLuint indx;
   const GLfloat* values;

} GL_TH_ST(glVertexAttrib2fv);

static void
GL_TH_CB(glVertexAttrib2fv)(void *data)
{
   GL_TH_ST(glVertexAttrib2fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttrib2fv))thread_data->orig_func)
      (thread_data->indx,
       thread_data->values);

}

void
GL_TH_FN(glVertexAttrib2fv)(GL_TH_DP, GLuint indx, const GLfloat* values)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttrib2fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttrib2fv))orig_func)
           (indx, values);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttrib2fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->indx = indx;
   thread_data->values = values;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttrib2fv),
                              thread_mode);
}

/*
 * void
 * glVertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttrib3f))(GLuint indx, GLfloat x, GLfloat y, GLfloat z);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttrib3f) orig_func;
   GLuint indx;
   GLfloat x;
   GLfloat y;
   GLfloat z;

} GL_TH_ST(glVertexAttrib3f);

static void
GL_TH_CB(glVertexAttrib3f)(void *data)
{
   GL_TH_ST(glVertexAttrib3f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttrib3f))thread_data->orig_func)
      (thread_data->indx,
       thread_data->x,
       thread_data->y,
       thread_data->z);

}

void
GL_TH_FN(glVertexAttrib3f)(GL_TH_DP, GLuint indx, GLfloat x, GLfloat y, GLfloat z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttrib3f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttrib3f))orig_func)
           (indx, x, y, z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttrib3f) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->indx = indx;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttrib3f),
                              thread_mode);
}

/*
 * void
 * glVertexAttrib3fv(GLuint indx, const GLfloat* values);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttrib3fv))(GLuint indx, const GLfloat* values);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttrib3fv) orig_func;
   GLuint indx;
   const GLfloat* values;

} GL_TH_ST(glVertexAttrib3fv);

static void
GL_TH_CB(glVertexAttrib3fv)(void *data)
{
   GL_TH_ST(glVertexAttrib3fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttrib3fv))thread_data->orig_func)
      (thread_data->indx,
       thread_data->values);

}

void
GL_TH_FN(glVertexAttrib3fv)(GL_TH_DP, GLuint indx, const GLfloat* values)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttrib3fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttrib3fv))orig_func)
           (indx, values);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttrib3fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->indx = indx;
   thread_data->values = values;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttrib3fv),
                              thread_mode);
}

/*
 * void
 * glVertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttrib4f))(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttrib4f) orig_func;
   GLuint indx;
   GLfloat x;
   GLfloat y;
   GLfloat z;
   GLfloat w;

} GL_TH_ST(glVertexAttrib4f);

static void
GL_TH_CB(glVertexAttrib4f)(void *data)
{
   GL_TH_ST(glVertexAttrib4f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttrib4f))thread_data->orig_func)
      (thread_data->indx,
       thread_data->x,
       thread_data->y,
       thread_data->z,
       thread_data->w);

}

void
GL_TH_FN(glVertexAttrib4f)(GL_TH_DP, GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttrib4f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttrib4f))orig_func)
           (indx, x, y, z, w);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttrib4f) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->indx = indx;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->w = w;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttrib4f),
                              thread_mode);
}

/*
 * void
 * glVertexAttrib4fv(GLuint indx, const GLfloat* values);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttrib4fv))(GLuint indx, const GLfloat* values);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttrib4fv) orig_func;
   GLuint indx;
   const GLfloat* values;

} GL_TH_ST(glVertexAttrib4fv);

static void
GL_TH_CB(glVertexAttrib4fv)(void *data)
{
   GL_TH_ST(glVertexAttrib4fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttrib4fv))thread_data->orig_func)
      (thread_data->indx,
       thread_data->values);

}

void
GL_TH_FN(glVertexAttrib4fv)(GL_TH_DP, GLuint indx, const GLfloat* values)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttrib4fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttrib4fv))orig_func)
           (indx, values);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttrib4fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->indx = indx;
   thread_data->values = values;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttrib4fv),
                              thread_mode);
}

/*
 * void
 * glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* ptr);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttribPointer))(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* ptr);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttribPointer) orig_func;
   GLuint indx;
   GLint size;
   GLenum type;
   GLboolean normalized;
   GLsizei stride;
   const void* ptr;

} GL_TH_ST(glVertexAttribPointer);

static void
GL_TH_CB(glVertexAttribPointer)(void *data)
{
   GL_TH_ST(glVertexAttribPointer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttribPointer))thread_data->orig_func)
      (thread_data->indx,
       thread_data->size,
       thread_data->type,
       thread_data->normalized,
       thread_data->stride,
       thread_data->ptr);

}

void
GL_TH_FN(glVertexAttribPointer)(GL_TH_DP, GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* ptr)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttribPointer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttribPointer))orig_func)
           (indx, size, type, normalized, stride, ptr);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttribPointer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->indx = indx;
   thread_data->size = size;
   thread_data->type = type;
   thread_data->normalized = normalized;
   thread_data->stride = stride;
   thread_data->ptr = ptr;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttribPointer),
                              thread_mode);
}

/*
 * void
 * glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
 */

typedef void(*GL_TH_FNTYPE(glViewport))(GLint x, GLint y, GLsizei width, GLsizei height);

typedef struct
{
   GL_TH_FNTYPE(glViewport) orig_func;
   GLint x;
   GLint y;
   GLsizei width;
   GLsizei height;

} GL_TH_ST(glViewport);

static void
GL_TH_CB(glViewport)(void *data)
{
   GL_TH_ST(glViewport) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glViewport))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glViewport)(GL_TH_DP, GLint x, GLint y, GLsizei width, GLsizei height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glViewport) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glViewport))orig_func)
           (x, y, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glViewport) *) + sizeof(GL_TH_ST(glViewport)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glViewport) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glViewport),
                              thread_mode);
}

/*
 * void
 * glEvasGLImageTargetTexture2DOES(GLenum target, EvasGLImage image);
 */

typedef void(*GL_TH_FNTYPE(glEvasGLImageTargetTexture2DOES))(GLenum target, EvasGLImage image);

typedef struct
{
   GL_TH_FNTYPE(glEvasGLImageTargetTexture2DOES) orig_func;
   GLenum target;
   EvasGLImage image;

} GL_TH_ST(glEvasGLImageTargetTexture2DOES);

static void
GL_TH_CB(glEvasGLImageTargetTexture2DOES)(void *data)
{
   GL_TH_ST(glEvasGLImageTargetTexture2DOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glEvasGLImageTargetTexture2DOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->image);

}

void
GL_TH_FN(glEvasGLImageTargetTexture2DOES)(GL_TH_DP, GLenum target, EvasGLImage image)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glEvasGLImageTargetTexture2DOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glEvasGLImageTargetTexture2DOES))orig_func)
           (target, image);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glEvasGLImageTargetTexture2DOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->image = image;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glEvasGLImageTargetTexture2DOES),
                              thread_mode);
}

/*
 * void
 * glEvasGLImageTargetRenderbufferStorageOES(GLenum target, EvasGLImage image);
 */

typedef void(*GL_TH_FNTYPE(glEvasGLImageTargetRenderbufferStorageOES))(GLenum target, EvasGLImage image);

typedef struct
{
   GL_TH_FNTYPE(glEvasGLImageTargetRenderbufferStorageOES) orig_func;
   GLenum target;
   EvasGLImage image;

} GL_TH_ST(glEvasGLImageTargetRenderbufferStorageOES);

static void
GL_TH_CB(glEvasGLImageTargetRenderbufferStorageOES)(void *data)
{
   GL_TH_ST(glEvasGLImageTargetRenderbufferStorageOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glEvasGLImageTargetRenderbufferStorageOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->image);

}

void
GL_TH_FN(glEvasGLImageTargetRenderbufferStorageOES)(GL_TH_DP, GLenum target, EvasGLImage image)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glEvasGLImageTargetRenderbufferStorageOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glEvasGLImageTargetRenderbufferStorageOES))orig_func)
           (target, image);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glEvasGLImageTargetRenderbufferStorageOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->image = image;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glEvasGLImageTargetRenderbufferStorageOES),
                              thread_mode);
}

/*
 * void
 * glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);
 */

typedef void(*GL_TH_FNTYPE(glGetProgramBinaryOES))(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);

typedef struct
{
   GL_TH_FNTYPE(glGetProgramBinaryOES) orig_func;
   GLuint program;
   GLsizei bufSize;
   GLsizei *length;
   GLenum *binaryFormat;
   void *binary;

} GL_TH_ST(glGetProgramBinaryOES);

static void
GL_TH_CB(glGetProgramBinaryOES)(void *data)
{
   GL_TH_ST(glGetProgramBinaryOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetProgramBinaryOES))thread_data->orig_func)
      (thread_data->program,
       thread_data->bufSize,
       thread_data->length,
       thread_data->binaryFormat,
       thread_data->binary);

}

void
GL_TH_FN(glGetProgramBinaryOES)(GL_TH_DP, GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetProgramBinaryOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetProgramBinaryOES))orig_func)
           (program, bufSize, length, binaryFormat, binary);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetProgramBinaryOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->bufSize = bufSize;
   thread_data->length = length;
   thread_data->binaryFormat = binaryFormat;
   thread_data->binary = binary;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetProgramBinaryOES),
                              thread_mode);
}

/*
 * void
 * glProgramBinaryOES(GLuint program, GLenum binaryFormat, const void *binary, GLint length);
 */

typedef void(*GL_TH_FNTYPE(glProgramBinaryOES))(GLuint program, GLenum binaryFormat, const void *binary, GLint length);

typedef struct
{
   GL_TH_FNTYPE(glProgramBinaryOES) orig_func;
   GLuint program;
   GLenum binaryFormat;
   const void *binary;
   GLint length;
   void *binary_copied; /* COPIED */

} GL_TH_ST(glProgramBinaryOES);

static void
GL_TH_CB(glProgramBinaryOES)(void *data)
{
   GL_TH_ST(glProgramBinaryOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramBinaryOES))thread_data->orig_func)
      (thread_data->program,
       thread_data->binaryFormat,
       thread_data->binary,
       thread_data->length);


   if (thread_data->binary_copied)
     eina_mempool_free(_mp_default, thread_data->binary_copied);

}

void
GL_TH_FN(glProgramBinaryOES)(GL_TH_DP, GLuint program, GLenum binaryFormat, const void *binary, GLint length)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramBinaryOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramBinaryOES))orig_func)
           (program, binaryFormat, binary, length);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramBinaryOES) *) + sizeof(GL_TH_ST(glProgramBinaryOES)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glProgramBinaryOES) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->program = program;
   thread_data->binaryFormat = binaryFormat;
   thread_data->binary = binary;
   thread_data->length = length;
   thread_data->orig_func = orig_func;

   thread_data->binary_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (binary)
     {
        /* 1. check memory size */
        unsigned int copy_size = length;
        if (copy_size > _mp_default_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->binary_copied = eina_mempool_malloc(_mp_default, copy_size);
        if (thread_data->binary_copied)
          {
             memcpy(thread_data->binary_copied, binary, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->binary = (const void  *)thread_data->binary_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramBinaryOES),
                              thread_mode);
}

/*
 * void *
 * glMapBufferOES(GLenum target, GLenum access);
 */

typedef void *(*GL_TH_FNTYPE(glMapBufferOES))(GLenum target, GLenum access);

typedef struct
{
   GL_TH_FNTYPE(glMapBufferOES) orig_func;
   void * return_value;
   GLenum target;
   GLenum access;

} GL_TH_ST(glMapBufferOES);

static void
GL_TH_CB(glMapBufferOES)(void *data)
{
   GL_TH_ST(glMapBufferOES) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glMapBufferOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->access);

}

void *
GL_TH_FN(glMapBufferOES)(GL_TH_DP, GLenum target, GLenum access)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMapBufferOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glMapBufferOES))orig_func)
           (target, access);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMapBufferOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->access = access;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMapBufferOES),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glUnmapBufferOES(GLenum target);
 */

typedef GLboolean(*GL_TH_FNTYPE(glUnmapBufferOES))(GLenum target);

typedef struct
{
   GL_TH_FNTYPE(glUnmapBufferOES) orig_func;
   GLboolean return_value;
   GLenum target;

} GL_TH_ST(glUnmapBufferOES);

static void
GL_TH_CB(glUnmapBufferOES)(void *data)
{
   GL_TH_ST(glUnmapBufferOES) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glUnmapBufferOES))thread_data->orig_func)
      (thread_data->target);

}

GLboolean
GL_TH_FN(glUnmapBufferOES)(GL_TH_DP, GLenum target)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUnmapBufferOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glUnmapBufferOES))orig_func)
           (target);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUnmapBufferOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUnmapBufferOES),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glGetBufferPointervOES(GLenum target, GLenum pname, void** params);
 */

typedef void(*GL_TH_FNTYPE(glGetBufferPointervOES))(GLenum target, GLenum pname, void** params);

typedef struct
{
   GL_TH_FNTYPE(glGetBufferPointervOES) orig_func;
   GLenum target;
   GLenum pname;
   void** params;

} GL_TH_ST(glGetBufferPointervOES);

static void
GL_TH_CB(glGetBufferPointervOES)(void *data)
{
   GL_TH_ST(glGetBufferPointervOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetBufferPointervOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetBufferPointervOES)(GL_TH_DP, GLenum target, GLenum pname, void** params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetBufferPointervOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetBufferPointervOES))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetBufferPointervOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetBufferPointervOES),
                              thread_mode);
}

/*
 * void
 * glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
 */

typedef void(*GL_TH_FNTYPE(glTexImage3DOES))(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);

typedef struct
{
   GL_TH_FNTYPE(glTexImage3DOES) orig_func;
   GLenum target;
   GLint level;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;
   GLsizei depth;
   GLint border;
   GLenum format;
   GLenum type;
   const void* pixels;

} GL_TH_ST(glTexImage3DOES);

static void
GL_TH_CB(glTexImage3DOES)(void *data)
{
   GL_TH_ST(glTexImage3DOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexImage3DOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height,
       thread_data->depth,
       thread_data->border,
       thread_data->format,
       thread_data->type,
       thread_data->pixels);

}

void
GL_TH_FN(glTexImage3DOES)(GL_TH_DP, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexImage3DOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexImage3DOES))orig_func)
           (target, level, internalformat, width, height, depth, border, format, type, pixels);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexImage3DOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->depth = depth;
   thread_data->border = border;
   thread_data->format = format;
   thread_data->type = type;
   thread_data->pixels = pixels;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexImage3DOES),
                              thread_mode);
}

/*
 * void
 * glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
 */

typedef void(*GL_TH_FNTYPE(glTexSubImage3DOES))(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);

typedef struct
{
   GL_TH_FNTYPE(glTexSubImage3DOES) orig_func;
   GLenum target;
   GLint level;
   GLint xoffset;
   GLint yoffset;
   GLint zoffset;
   GLsizei width;
   GLsizei height;
   GLsizei depth;
   GLenum format;
   GLenum type;
   const void* pixels;

} GL_TH_ST(glTexSubImage3DOES);

static void
GL_TH_CB(glTexSubImage3DOES)(void *data)
{
   GL_TH_ST(glTexSubImage3DOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexSubImage3DOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->xoffset,
       thread_data->yoffset,
       thread_data->zoffset,
       thread_data->width,
       thread_data->height,
       thread_data->depth,
       thread_data->format,
       thread_data->type,
       thread_data->pixels);

}

void
GL_TH_FN(glTexSubImage3DOES)(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexSubImage3DOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexSubImage3DOES))orig_func)
           (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexSubImage3DOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->xoffset = xoffset;
   thread_data->yoffset = yoffset;
   thread_data->zoffset = zoffset;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->depth = depth;
   thread_data->format = format;
   thread_data->type = type;
   thread_data->pixels = pixels;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexSubImage3DOES),
                              thread_mode);
}

/*
 * void
 * glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
 */

typedef void(*GL_TH_FNTYPE(glCopyTexSubImage3DOES))(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);

typedef struct
{
   GL_TH_FNTYPE(glCopyTexSubImage3DOES) orig_func;
   GLenum target;
   GLint level;
   GLint xoffset;
   GLint yoffset;
   GLint zoffset;
   GLint x;
   GLint y;
   GLsizei width;
   GLsizei height;

} GL_TH_ST(glCopyTexSubImage3DOES);

static void
GL_TH_CB(glCopyTexSubImage3DOES)(void *data)
{
   GL_TH_ST(glCopyTexSubImage3DOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCopyTexSubImage3DOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->xoffset,
       thread_data->yoffset,
       thread_data->zoffset,
       thread_data->x,
       thread_data->y,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glCopyTexSubImage3DOES)(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCopyTexSubImage3DOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCopyTexSubImage3DOES))orig_func)
           (target, level, xoffset, yoffset, zoffset, x, y, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCopyTexSubImage3DOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->xoffset = xoffset;
   thread_data->yoffset = yoffset;
   thread_data->zoffset = zoffset;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCopyTexSubImage3DOES),
                              thread_mode);
}

/*
 * void
 * glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data);
 */

typedef void(*GL_TH_FNTYPE(glCompressedTexImage3DOES))(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data);

typedef struct
{
   GL_TH_FNTYPE(glCompressedTexImage3DOES) orig_func;
   GLenum target;
   GLint level;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;
   GLsizei depth;
   GLint border;
   GLsizei imageSize;
   const void* data;

} GL_TH_ST(glCompressedTexImage3DOES);

static void
GL_TH_CB(glCompressedTexImage3DOES)(void *data)
{
   GL_TH_ST(glCompressedTexImage3DOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCompressedTexImage3DOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height,
       thread_data->depth,
       thread_data->border,
       thread_data->imageSize,
       thread_data->data);

}

void
GL_TH_FN(glCompressedTexImage3DOES)(GL_TH_DP, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCompressedTexImage3DOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCompressedTexImage3DOES))orig_func)
           (target, level, internalformat, width, height, depth, border, imageSize, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCompressedTexImage3DOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->depth = depth;
   thread_data->border = border;
   thread_data->imageSize = imageSize;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCompressedTexImage3DOES),
                              thread_mode);
}

/*
 * void
 * glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
 */

typedef void(*GL_TH_FNTYPE(glCompressedTexSubImage3DOES))(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);

typedef struct
{
   GL_TH_FNTYPE(glCompressedTexSubImage3DOES) orig_func;
   GLenum target;
   GLint level;
   GLint xoffset;
   GLint yoffset;
   GLint zoffset;
   GLsizei width;
   GLsizei height;
   GLsizei depth;
   GLenum format;
   GLsizei imageSize;
   const void* data;

} GL_TH_ST(glCompressedTexSubImage3DOES);

static void
GL_TH_CB(glCompressedTexSubImage3DOES)(void *data)
{
   GL_TH_ST(glCompressedTexSubImage3DOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCompressedTexSubImage3DOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->xoffset,
       thread_data->yoffset,
       thread_data->zoffset,
       thread_data->width,
       thread_data->height,
       thread_data->depth,
       thread_data->format,
       thread_data->imageSize,
       thread_data->data);

}

void
GL_TH_FN(glCompressedTexSubImage3DOES)(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCompressedTexSubImage3DOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCompressedTexSubImage3DOES))orig_func)
           (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCompressedTexSubImage3DOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->xoffset = xoffset;
   thread_data->yoffset = yoffset;
   thread_data->zoffset = zoffset;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->depth = depth;
   thread_data->format = format;
   thread_data->imageSize = imageSize;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCompressedTexSubImage3DOES),
                              thread_mode);
}

/*
 * void
 * glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
 */

typedef void(*GL_TH_FNTYPE(glFramebufferTexture3DOES))(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);

typedef struct
{
   GL_TH_FNTYPE(glFramebufferTexture3DOES) orig_func;
   GLenum target;
   GLenum attachment;
   GLenum textarget;
   GLuint texture;
   GLint level;
   GLint zoffset;

} GL_TH_ST(glFramebufferTexture3DOES);

static void
GL_TH_CB(glFramebufferTexture3DOES)(void *data)
{
   GL_TH_ST(glFramebufferTexture3DOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFramebufferTexture3DOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->attachment,
       thread_data->textarget,
       thread_data->texture,
       thread_data->level,
       thread_data->zoffset);

}

void
GL_TH_FN(glFramebufferTexture3DOES)(GL_TH_DP, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFramebufferTexture3DOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFramebufferTexture3DOES))orig_func)
           (target, attachment, textarget, texture, level, zoffset);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFramebufferTexture3DOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->attachment = attachment;
   thread_data->textarget = textarget;
   thread_data->texture = texture;
   thread_data->level = level;
   thread_data->zoffset = zoffset;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFramebufferTexture3DOES),
                              thread_mode);
}

/*
 * void
 * glGetPerfMonitorGroupsAMD(GLint* numGroups, GLsizei groupsSize, GLuint* groups);
 */

typedef void(*GL_TH_FNTYPE(glGetPerfMonitorGroupsAMD))(GLint* numGroups, GLsizei groupsSize, GLuint* groups);

typedef struct
{
   GL_TH_FNTYPE(glGetPerfMonitorGroupsAMD) orig_func;
   GLint* numGroups;
   GLsizei groupsSize;
   GLuint* groups;

} GL_TH_ST(glGetPerfMonitorGroupsAMD);

static void
GL_TH_CB(glGetPerfMonitorGroupsAMD)(void *data)
{
   GL_TH_ST(glGetPerfMonitorGroupsAMD) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetPerfMonitorGroupsAMD))thread_data->orig_func)
      (thread_data->numGroups,
       thread_data->groupsSize,
       thread_data->groups);

}

void
GL_TH_FN(glGetPerfMonitorGroupsAMD)(GL_TH_DP, GLint* numGroups, GLsizei groupsSize, GLuint* groups)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetPerfMonitorGroupsAMD) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetPerfMonitorGroupsAMD))orig_func)
           (numGroups, groupsSize, groups);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetPerfMonitorGroupsAMD) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->numGroups = numGroups;
   thread_data->groupsSize = groupsSize;
   thread_data->groups = groups;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetPerfMonitorGroupsAMD),
                              thread_mode);
}

/*
 * void
 * glGetPerfMonitorCountersAMD(GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters);
 */

typedef void(*GL_TH_FNTYPE(glGetPerfMonitorCountersAMD))(GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters);

typedef struct
{
   GL_TH_FNTYPE(glGetPerfMonitorCountersAMD) orig_func;
   GLuint group;
   GLint* numCounters;
   GLint* maxActiveCounters;
   GLsizei counterSize;
   GLuint* counters;

} GL_TH_ST(glGetPerfMonitorCountersAMD);

static void
GL_TH_CB(glGetPerfMonitorCountersAMD)(void *data)
{
   GL_TH_ST(glGetPerfMonitorCountersAMD) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetPerfMonitorCountersAMD))thread_data->orig_func)
      (thread_data->group,
       thread_data->numCounters,
       thread_data->maxActiveCounters,
       thread_data->counterSize,
       thread_data->counters);

}

void
GL_TH_FN(glGetPerfMonitorCountersAMD)(GL_TH_DP, GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetPerfMonitorCountersAMD) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetPerfMonitorCountersAMD))orig_func)
           (group, numCounters, maxActiveCounters, counterSize, counters);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetPerfMonitorCountersAMD) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->group = group;
   thread_data->numCounters = numCounters;
   thread_data->maxActiveCounters = maxActiveCounters;
   thread_data->counterSize = counterSize;
   thread_data->counters = counters;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetPerfMonitorCountersAMD),
                              thread_mode);
}

/*
 * void
 * glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei* length, char* groupString);
 */

typedef void(*GL_TH_FNTYPE(glGetPerfMonitorGroupStringAMD))(GLuint group, GLsizei bufSize, GLsizei* length, char* groupString);

typedef struct
{
   GL_TH_FNTYPE(glGetPerfMonitorGroupStringAMD) orig_func;
   GLuint group;
   GLsizei bufSize;
   GLsizei* length;
   char* groupString;

} GL_TH_ST(glGetPerfMonitorGroupStringAMD);

static void
GL_TH_CB(glGetPerfMonitorGroupStringAMD)(void *data)
{
   GL_TH_ST(glGetPerfMonitorGroupStringAMD) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetPerfMonitorGroupStringAMD))thread_data->orig_func)
      (thread_data->group,
       thread_data->bufSize,
       thread_data->length,
       thread_data->groupString);

}

void
GL_TH_FN(glGetPerfMonitorGroupStringAMD)(GL_TH_DP, GLuint group, GLsizei bufSize, GLsizei* length, char* groupString)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetPerfMonitorGroupStringAMD) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetPerfMonitorGroupStringAMD))orig_func)
           (group, bufSize, length, groupString);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetPerfMonitorGroupStringAMD) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->group = group;
   thread_data->bufSize = bufSize;
   thread_data->length = length;
   thread_data->groupString = groupString;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetPerfMonitorGroupStringAMD),
                              thread_mode);
}

/*
 * void
 * glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, char* counterString);
 */

typedef void(*GL_TH_FNTYPE(glGetPerfMonitorCounterStringAMD))(GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, char* counterString);

typedef struct
{
   GL_TH_FNTYPE(glGetPerfMonitorCounterStringAMD) orig_func;
   GLuint group;
   GLuint counter;
   GLsizei bufSize;
   GLsizei* length;
   char* counterString;

} GL_TH_ST(glGetPerfMonitorCounterStringAMD);

static void
GL_TH_CB(glGetPerfMonitorCounterStringAMD)(void *data)
{
   GL_TH_ST(glGetPerfMonitorCounterStringAMD) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetPerfMonitorCounterStringAMD))thread_data->orig_func)
      (thread_data->group,
       thread_data->counter,
       thread_data->bufSize,
       thread_data->length,
       thread_data->counterString);

}

void
GL_TH_FN(glGetPerfMonitorCounterStringAMD)(GL_TH_DP, GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, char* counterString)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetPerfMonitorCounterStringAMD) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetPerfMonitorCounterStringAMD))orig_func)
           (group, counter, bufSize, length, counterString);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetPerfMonitorCounterStringAMD) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->group = group;
   thread_data->counter = counter;
   thread_data->bufSize = bufSize;
   thread_data->length = length;
   thread_data->counterString = counterString;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetPerfMonitorCounterStringAMD),
                              thread_mode);
}

/*
 * void
 * glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, void* data);
 */

typedef void(*GL_TH_FNTYPE(glGetPerfMonitorCounterInfoAMD))(GLuint group, GLuint counter, GLenum pname, void* data);

typedef struct
{
   GL_TH_FNTYPE(glGetPerfMonitorCounterInfoAMD) orig_func;
   GLuint group;
   GLuint counter;
   GLenum pname;
   void* data;

} GL_TH_ST(glGetPerfMonitorCounterInfoAMD);

static void
GL_TH_CB(glGetPerfMonitorCounterInfoAMD)(void *data)
{
   GL_TH_ST(glGetPerfMonitorCounterInfoAMD) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetPerfMonitorCounterInfoAMD))thread_data->orig_func)
      (thread_data->group,
       thread_data->counter,
       thread_data->pname,
       thread_data->data);

}

void
GL_TH_FN(glGetPerfMonitorCounterInfoAMD)(GL_TH_DP, GLuint group, GLuint counter, GLenum pname, void* data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetPerfMonitorCounterInfoAMD) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetPerfMonitorCounterInfoAMD))orig_func)
           (group, counter, pname, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetPerfMonitorCounterInfoAMD) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->group = group;
   thread_data->counter = counter;
   thread_data->pname = pname;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetPerfMonitorCounterInfoAMD),
                              thread_mode);
}

/*
 * void
 * glGenPerfMonitorsAMD(GLsizei n, GLuint* monitors);
 */

typedef void(*GL_TH_FNTYPE(glGenPerfMonitorsAMD))(GLsizei n, GLuint* monitors);

typedef struct
{
   GL_TH_FNTYPE(glGenPerfMonitorsAMD) orig_func;
   GLsizei n;
   GLuint* monitors;

} GL_TH_ST(glGenPerfMonitorsAMD);

static void
GL_TH_CB(glGenPerfMonitorsAMD)(void *data)
{
   GL_TH_ST(glGenPerfMonitorsAMD) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenPerfMonitorsAMD))thread_data->orig_func)
      (thread_data->n,
       thread_data->monitors);

}

void
GL_TH_FN(glGenPerfMonitorsAMD)(GL_TH_DP, GLsizei n, GLuint* monitors)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenPerfMonitorsAMD) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenPerfMonitorsAMD))orig_func)
           (n, monitors);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenPerfMonitorsAMD) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->monitors = monitors;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenPerfMonitorsAMD),
                              thread_mode);
}

/*
 * void
 * glDeletePerfMonitorsAMD(GLsizei n, GLuint* monitors);
 */

typedef void(*GL_TH_FNTYPE(glDeletePerfMonitorsAMD))(GLsizei n, GLuint* monitors);

typedef struct
{
   GL_TH_FNTYPE(glDeletePerfMonitorsAMD) orig_func;
   GLsizei n;
   GLuint* monitors;

} GL_TH_ST(glDeletePerfMonitorsAMD);

static void
GL_TH_CB(glDeletePerfMonitorsAMD)(void *data)
{
   GL_TH_ST(glDeletePerfMonitorsAMD) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeletePerfMonitorsAMD))thread_data->orig_func)
      (thread_data->n,
       thread_data->monitors);

}

void
GL_TH_FN(glDeletePerfMonitorsAMD)(GL_TH_DP, GLsizei n, GLuint* monitors)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeletePerfMonitorsAMD) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeletePerfMonitorsAMD))orig_func)
           (n, monitors);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeletePerfMonitorsAMD) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->monitors = monitors;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeletePerfMonitorsAMD),
                              thread_mode);
}

/*
 * void
 * glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* countersList);
 */

typedef void(*GL_TH_FNTYPE(glSelectPerfMonitorCountersAMD))(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* countersList);

typedef struct
{
   GL_TH_FNTYPE(glSelectPerfMonitorCountersAMD) orig_func;
   GLuint monitor;
   GLboolean enable;
   GLuint group;
   GLint numCounters;
   GLuint* countersList;

} GL_TH_ST(glSelectPerfMonitorCountersAMD);

static void
GL_TH_CB(glSelectPerfMonitorCountersAMD)(void *data)
{
   GL_TH_ST(glSelectPerfMonitorCountersAMD) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glSelectPerfMonitorCountersAMD))thread_data->orig_func)
      (thread_data->monitor,
       thread_data->enable,
       thread_data->group,
       thread_data->numCounters,
       thread_data->countersList);

}

void
GL_TH_FN(glSelectPerfMonitorCountersAMD)(GL_TH_DP, GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* countersList)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glSelectPerfMonitorCountersAMD) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glSelectPerfMonitorCountersAMD))orig_func)
           (monitor, enable, group, numCounters, countersList);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glSelectPerfMonitorCountersAMD) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->monitor = monitor;
   thread_data->enable = enable;
   thread_data->group = group;
   thread_data->numCounters = numCounters;
   thread_data->countersList = countersList;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glSelectPerfMonitorCountersAMD),
                              thread_mode);
}

/*
 * void
 * glBeginPerfMonitorAMD(GLuint monitor);
 */

typedef void(*GL_TH_FNTYPE(glBeginPerfMonitorAMD))(GLuint monitor);

typedef struct
{
   GL_TH_FNTYPE(glBeginPerfMonitorAMD) orig_func;
   GLuint monitor;

} GL_TH_ST(glBeginPerfMonitorAMD);

static void
GL_TH_CB(glBeginPerfMonitorAMD)(void *data)
{
   GL_TH_ST(glBeginPerfMonitorAMD) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBeginPerfMonitorAMD))thread_data->orig_func)
      (thread_data->monitor);

}

void
GL_TH_FN(glBeginPerfMonitorAMD)(GL_TH_DP, GLuint monitor)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBeginPerfMonitorAMD) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBeginPerfMonitorAMD))orig_func)
           (monitor);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBeginPerfMonitorAMD) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->monitor = monitor;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBeginPerfMonitorAMD),
                              thread_mode);
}

/*
 * void
 * glEndPerfMonitorAMD(GLuint monitor);
 */

typedef void(*GL_TH_FNTYPE(glEndPerfMonitorAMD))(GLuint monitor);

typedef struct
{
   GL_TH_FNTYPE(glEndPerfMonitorAMD) orig_func;
   GLuint monitor;

} GL_TH_ST(glEndPerfMonitorAMD);

static void
GL_TH_CB(glEndPerfMonitorAMD)(void *data)
{
   GL_TH_ST(glEndPerfMonitorAMD) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glEndPerfMonitorAMD))thread_data->orig_func)
      (thread_data->monitor);

}

void
GL_TH_FN(glEndPerfMonitorAMD)(GL_TH_DP, GLuint monitor)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glEndPerfMonitorAMD) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glEndPerfMonitorAMD))orig_func)
           (monitor);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glEndPerfMonitorAMD) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->monitor = monitor;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glEndPerfMonitorAMD),
                              thread_mode);
}

/*
 * void
 * glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten);
 */

typedef void(*GL_TH_FNTYPE(glGetPerfMonitorCounterDataAMD))(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten);

typedef struct
{
   GL_TH_FNTYPE(glGetPerfMonitorCounterDataAMD) orig_func;
   GLuint monitor;
   GLenum pname;
   GLsizei dataSize;
   GLuint* data;
   GLint* bytesWritten;

} GL_TH_ST(glGetPerfMonitorCounterDataAMD);

static void
GL_TH_CB(glGetPerfMonitorCounterDataAMD)(void *data)
{
   GL_TH_ST(glGetPerfMonitorCounterDataAMD) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetPerfMonitorCounterDataAMD))thread_data->orig_func)
      (thread_data->monitor,
       thread_data->pname,
       thread_data->dataSize,
       thread_data->data,
       thread_data->bytesWritten);

}

void
GL_TH_FN(glGetPerfMonitorCounterDataAMD)(GL_TH_DP, GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetPerfMonitorCounterDataAMD) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetPerfMonitorCounterDataAMD))orig_func)
           (monitor, pname, dataSize, data, bytesWritten);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetPerfMonitorCounterDataAMD) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->monitor = monitor;
   thread_data->pname = pname;
   thread_data->dataSize = dataSize;
   thread_data->data = data;
   thread_data->bytesWritten = bytesWritten;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetPerfMonitorCounterDataAMD),
                              thread_mode);
}

/*
 * void
 * glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum* attachments);
 */

typedef void(*GL_TH_FNTYPE(glDiscardFramebufferEXT))(GLenum target, GLsizei numAttachments, const GLenum* attachments);

typedef struct
{
   GL_TH_FNTYPE(glDiscardFramebufferEXT) orig_func;
   GLenum target;
   GLsizei numAttachments;
   const GLenum* attachments;

} GL_TH_ST(glDiscardFramebufferEXT);

static void
GL_TH_CB(glDiscardFramebufferEXT)(void *data)
{
   GL_TH_ST(glDiscardFramebufferEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDiscardFramebufferEXT))thread_data->orig_func)
      (thread_data->target,
       thread_data->numAttachments,
       thread_data->attachments);

}

void
GL_TH_FN(glDiscardFramebufferEXT)(GL_TH_DP, GLenum target, GLsizei numAttachments, const GLenum* attachments)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDiscardFramebufferEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDiscardFramebufferEXT))orig_func)
           (target, numAttachments, attachments);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDiscardFramebufferEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->numAttachments = numAttachments;
   thread_data->attachments = attachments;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDiscardFramebufferEXT),
                              thread_mode);
}

/*
 * void
 * glMultiDrawArraysEXT(GLenum mode, GLint* first, GLsizei* count, GLsizei primcount);
 */

typedef void(*GL_TH_FNTYPE(glMultiDrawArraysEXT))(GLenum mode, GLint* first, GLsizei* count, GLsizei primcount);

typedef struct
{
   GL_TH_FNTYPE(glMultiDrawArraysEXT) orig_func;
   GLenum mode;
   GLint* first;
   GLsizei* count;
   GLsizei primcount;

} GL_TH_ST(glMultiDrawArraysEXT);

static void
GL_TH_CB(glMultiDrawArraysEXT)(void *data)
{
   GL_TH_ST(glMultiDrawArraysEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMultiDrawArraysEXT))thread_data->orig_func)
      (thread_data->mode,
       thread_data->first,
       thread_data->count,
       thread_data->primcount);

}

void
GL_TH_FN(glMultiDrawArraysEXT)(GL_TH_DP, GLenum mode, GLint* first, GLsizei* count, GLsizei primcount)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMultiDrawArraysEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMultiDrawArraysEXT))orig_func)
           (mode, first, count, primcount);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMultiDrawArraysEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->first = first;
   thread_data->count = count;
   thread_data->primcount = primcount;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMultiDrawArraysEXT),
                              thread_mode);
}

/*
 * void
 * glMultiDrawElementsEXT(GLenum mode, const GLsizei* count, GLenum type, const GLvoid** indices, GLsizei primcount);
 */

typedef void(*GL_TH_FNTYPE(glMultiDrawElementsEXT))(GLenum mode, const GLsizei* count, GLenum type, const GLvoid** indices, GLsizei primcount);

typedef struct
{
   GL_TH_FNTYPE(glMultiDrawElementsEXT) orig_func;
   GLenum mode;
   const GLsizei* count;
   GLenum type;
   const GLvoid** indices;
   GLsizei primcount;

} GL_TH_ST(glMultiDrawElementsEXT);

static void
GL_TH_CB(glMultiDrawElementsEXT)(void *data)
{
   GL_TH_ST(glMultiDrawElementsEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMultiDrawElementsEXT))thread_data->orig_func)
      (thread_data->mode,
       thread_data->count,
       thread_data->type,
       thread_data->indices,
       thread_data->primcount);

}

void
GL_TH_FN(glMultiDrawElementsEXT)(GL_TH_DP, GLenum mode, const GLsizei* count, GLenum type, const GLvoid** indices, GLsizei primcount)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMultiDrawElementsEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMultiDrawElementsEXT))orig_func)
           (mode, count, type, indices, primcount);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMultiDrawElementsEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->count = count;
   thread_data->type = type;
   thread_data->indices = indices;
   thread_data->primcount = primcount;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMultiDrawElementsEXT),
                              thread_mode);
}

/*
 * void
 * glDeleteFencesNV(GLsizei n, const GLuint* fences);
 */

typedef void(*GL_TH_FNTYPE(glDeleteFencesNV))(GLsizei n, const GLuint* fences);

typedef struct
{
   GL_TH_FNTYPE(glDeleteFencesNV) orig_func;
   GLsizei n;
   const GLuint* fences;

} GL_TH_ST(glDeleteFencesNV);

static void
GL_TH_CB(glDeleteFencesNV)(void *data)
{
   GL_TH_ST(glDeleteFencesNV) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteFencesNV))thread_data->orig_func)
      (thread_data->n,
       thread_data->fences);

}

void
GL_TH_FN(glDeleteFencesNV)(GL_TH_DP, GLsizei n, const GLuint* fences)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteFencesNV) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteFencesNV))orig_func)
           (n, fences);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteFencesNV) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->fences = fences;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteFencesNV),
                              thread_mode);
}

/*
 * void
 * glGenFencesNV(GLsizei n, GLuint* fences);
 */

typedef void(*GL_TH_FNTYPE(glGenFencesNV))(GLsizei n, GLuint* fences);

typedef struct
{
   GL_TH_FNTYPE(glGenFencesNV) orig_func;
   GLsizei n;
   GLuint* fences;

} GL_TH_ST(glGenFencesNV);

static void
GL_TH_CB(glGenFencesNV)(void *data)
{
   GL_TH_ST(glGenFencesNV) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenFencesNV))thread_data->orig_func)
      (thread_data->n,
       thread_data->fences);

}

void
GL_TH_FN(glGenFencesNV)(GL_TH_DP, GLsizei n, GLuint* fences)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenFencesNV) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenFencesNV))orig_func)
           (n, fences);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenFencesNV) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->fences = fences;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenFencesNV),
                              thread_mode);
}

/*
 * GLboolean
 * glIsFenceNV(GLuint fence);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsFenceNV))(GLuint fence);

typedef struct
{
   GL_TH_FNTYPE(glIsFenceNV) orig_func;
   GLboolean return_value;
   GLuint fence;

} GL_TH_ST(glIsFenceNV);

static void
GL_TH_CB(glIsFenceNV)(void *data)
{
   GL_TH_ST(glIsFenceNV) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsFenceNV))thread_data->orig_func)
      (thread_data->fence);

}

GLboolean
GL_TH_FN(glIsFenceNV)(GL_TH_DP, GLuint fence)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsFenceNV) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsFenceNV))orig_func)
           (fence);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsFenceNV) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->fence = fence;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsFenceNV),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glTestFenceNV(GLuint fence);
 */

typedef GLboolean(*GL_TH_FNTYPE(glTestFenceNV))(GLuint fence);

typedef struct
{
   GL_TH_FNTYPE(glTestFenceNV) orig_func;
   GLboolean return_value;
   GLuint fence;

} GL_TH_ST(glTestFenceNV);

static void
GL_TH_CB(glTestFenceNV)(void *data)
{
   GL_TH_ST(glTestFenceNV) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glTestFenceNV))thread_data->orig_func)
      (thread_data->fence);

}

GLboolean
GL_TH_FN(glTestFenceNV)(GL_TH_DP, GLuint fence)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTestFenceNV) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glTestFenceNV))orig_func)
           (fence);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTestFenceNV) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->fence = fence;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTestFenceNV),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glGetFenceivNV(GLuint fence, GLenum pname, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetFenceivNV))(GLuint fence, GLenum pname, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetFenceivNV) orig_func;
   GLuint fence;
   GLenum pname;
   GLint* params;

} GL_TH_ST(glGetFenceivNV);

static void
GL_TH_CB(glGetFenceivNV)(void *data)
{
   GL_TH_ST(glGetFenceivNV) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetFenceivNV))thread_data->orig_func)
      (thread_data->fence,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetFenceivNV)(GL_TH_DP, GLuint fence, GLenum pname, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetFenceivNV) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetFenceivNV))orig_func)
           (fence, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetFenceivNV) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->fence = fence;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetFenceivNV),
                              thread_mode);
}

/*
 * void
 * glFinishFenceNV(GLuint fence);
 */

typedef void(*GL_TH_FNTYPE(glFinishFenceNV))(GLuint fence);

typedef struct
{
   GL_TH_FNTYPE(glFinishFenceNV) orig_func;
   GLuint fence;

} GL_TH_ST(glFinishFenceNV);

static void
GL_TH_CB(glFinishFenceNV)(void *data)
{
   GL_TH_ST(glFinishFenceNV) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFinishFenceNV))thread_data->orig_func)
      (thread_data->fence);

}

void
GL_TH_FN(glFinishFenceNV)(GL_TH_DP, GLuint fence)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFinishFenceNV) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFinishFenceNV))orig_func)
           (fence);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFinishFenceNV) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->fence = fence;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFinishFenceNV),
                              thread_mode);
}

/*
 * void
 * glSetFenceNV(GLuint a, GLenum b);
 */

typedef void(*GL_TH_FNTYPE(glSetFenceNV))(GLuint a, GLenum b);

typedef struct
{
   GL_TH_FNTYPE(glSetFenceNV) orig_func;
   GLuint a;
   GLenum b;

} GL_TH_ST(glSetFenceNV);

static void
GL_TH_CB(glSetFenceNV)(void *data)
{
   GL_TH_ST(glSetFenceNV) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glSetFenceNV))thread_data->orig_func)
      (thread_data->a,
       thread_data->b);

}

void
GL_TH_FN(glSetFenceNV)(GL_TH_DP, GLuint a, GLenum b)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glSetFenceNV) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glSetFenceNV))orig_func)
           (a, b);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glSetFenceNV) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->a = a;
   thread_data->b = b;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glSetFenceNV),
                              thread_mode);
}

/*
 * void
 * glGetDriverControlsQCOM(GLint* num, GLsizei size, GLuint* driverControls);
 */

typedef void(*GL_TH_FNTYPE(glGetDriverControlsQCOM))(GLint* num, GLsizei size, GLuint* driverControls);

typedef struct
{
   GL_TH_FNTYPE(glGetDriverControlsQCOM) orig_func;
   GLint* num;
   GLsizei size;
   GLuint* driverControls;

} GL_TH_ST(glGetDriverControlsQCOM);

static void
GL_TH_CB(glGetDriverControlsQCOM)(void *data)
{
   GL_TH_ST(glGetDriverControlsQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetDriverControlsQCOM))thread_data->orig_func)
      (thread_data->num,
       thread_data->size,
       thread_data->driverControls);

}

void
GL_TH_FN(glGetDriverControlsQCOM)(GL_TH_DP, GLint* num, GLsizei size, GLuint* driverControls)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetDriverControlsQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetDriverControlsQCOM))orig_func)
           (num, size, driverControls);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetDriverControlsQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->num = num;
   thread_data->size = size;
   thread_data->driverControls = driverControls;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetDriverControlsQCOM),
                              thread_mode);
}

/*
 * void
 * glGetDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei* length, char* driverControlString);
 */

typedef void(*GL_TH_FNTYPE(glGetDriverControlStringQCOM))(GLuint driverControl, GLsizei bufSize, GLsizei* length, char* driverControlString);

typedef struct
{
   GL_TH_FNTYPE(glGetDriverControlStringQCOM) orig_func;
   GLuint driverControl;
   GLsizei bufSize;
   GLsizei* length;
   char* driverControlString;

} GL_TH_ST(glGetDriverControlStringQCOM);

static void
GL_TH_CB(glGetDriverControlStringQCOM)(void *data)
{
   GL_TH_ST(glGetDriverControlStringQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetDriverControlStringQCOM))thread_data->orig_func)
      (thread_data->driverControl,
       thread_data->bufSize,
       thread_data->length,
       thread_data->driverControlString);

}

void
GL_TH_FN(glGetDriverControlStringQCOM)(GL_TH_DP, GLuint driverControl, GLsizei bufSize, GLsizei* length, char* driverControlString)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetDriverControlStringQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetDriverControlStringQCOM))orig_func)
           (driverControl, bufSize, length, driverControlString);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetDriverControlStringQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->driverControl = driverControl;
   thread_data->bufSize = bufSize;
   thread_data->length = length;
   thread_data->driverControlString = driverControlString;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetDriverControlStringQCOM),
                              thread_mode);
}

/*
 * void
 * glEnableDriverControlQCOM(GLuint driverControl);
 */

typedef void(*GL_TH_FNTYPE(glEnableDriverControlQCOM))(GLuint driverControl);

typedef struct
{
   GL_TH_FNTYPE(glEnableDriverControlQCOM) orig_func;
   GLuint driverControl;

} GL_TH_ST(glEnableDriverControlQCOM);

static void
GL_TH_CB(glEnableDriverControlQCOM)(void *data)
{
   GL_TH_ST(glEnableDriverControlQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glEnableDriverControlQCOM))thread_data->orig_func)
      (thread_data->driverControl);

}

void
GL_TH_FN(glEnableDriverControlQCOM)(GL_TH_DP, GLuint driverControl)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glEnableDriverControlQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glEnableDriverControlQCOM))orig_func)
           (driverControl);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glEnableDriverControlQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->driverControl = driverControl;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glEnableDriverControlQCOM),
                              thread_mode);
}

/*
 * void
 * glDisableDriverControlQCOM(GLuint driverControl);
 */

typedef void(*GL_TH_FNTYPE(glDisableDriverControlQCOM))(GLuint driverControl);

typedef struct
{
   GL_TH_FNTYPE(glDisableDriverControlQCOM) orig_func;
   GLuint driverControl;

} GL_TH_ST(glDisableDriverControlQCOM);

static void
GL_TH_CB(glDisableDriverControlQCOM)(void *data)
{
   GL_TH_ST(glDisableDriverControlQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDisableDriverControlQCOM))thread_data->orig_func)
      (thread_data->driverControl);

}

void
GL_TH_FN(glDisableDriverControlQCOM)(GL_TH_DP, GLuint driverControl)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDisableDriverControlQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDisableDriverControlQCOM))orig_func)
           (driverControl);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDisableDriverControlQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->driverControl = driverControl;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDisableDriverControlQCOM),
                              thread_mode);
}

/*
 * void
 * glExtGetTexturesQCOM(GLuint* textures, GLint maxTextures, GLint* numTextures);
 */

typedef void(*GL_TH_FNTYPE(glExtGetTexturesQCOM))(GLuint* textures, GLint maxTextures, GLint* numTextures);

typedef struct
{
   GL_TH_FNTYPE(glExtGetTexturesQCOM) orig_func;
   GLuint* textures;
   GLint maxTextures;
   GLint* numTextures;

} GL_TH_ST(glExtGetTexturesQCOM);

static void
GL_TH_CB(glExtGetTexturesQCOM)(void *data)
{
   GL_TH_ST(glExtGetTexturesQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glExtGetTexturesQCOM))thread_data->orig_func)
      (thread_data->textures,
       thread_data->maxTextures,
       thread_data->numTextures);

}

void
GL_TH_FN(glExtGetTexturesQCOM)(GL_TH_DP, GLuint* textures, GLint maxTextures, GLint* numTextures)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glExtGetTexturesQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glExtGetTexturesQCOM))orig_func)
           (textures, maxTextures, numTextures);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glExtGetTexturesQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->textures = textures;
   thread_data->maxTextures = maxTextures;
   thread_data->numTextures = numTextures;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glExtGetTexturesQCOM),
                              thread_mode);
}

/*
 * void
 * glExtGetBuffersQCOM(GLuint* buffers, GLint maxBuffers, GLint* numBuffers);
 */

typedef void(*GL_TH_FNTYPE(glExtGetBuffersQCOM))(GLuint* buffers, GLint maxBuffers, GLint* numBuffers);

typedef struct
{
   GL_TH_FNTYPE(glExtGetBuffersQCOM) orig_func;
   GLuint* buffers;
   GLint maxBuffers;
   GLint* numBuffers;

} GL_TH_ST(glExtGetBuffersQCOM);

static void
GL_TH_CB(glExtGetBuffersQCOM)(void *data)
{
   GL_TH_ST(glExtGetBuffersQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glExtGetBuffersQCOM))thread_data->orig_func)
      (thread_data->buffers,
       thread_data->maxBuffers,
       thread_data->numBuffers);

}

void
GL_TH_FN(glExtGetBuffersQCOM)(GL_TH_DP, GLuint* buffers, GLint maxBuffers, GLint* numBuffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glExtGetBuffersQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glExtGetBuffersQCOM))orig_func)
           (buffers, maxBuffers, numBuffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glExtGetBuffersQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->buffers = buffers;
   thread_data->maxBuffers = maxBuffers;
   thread_data->numBuffers = numBuffers;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glExtGetBuffersQCOM),
                              thread_mode);
}

/*
 * void
 * glExtGetRenderbuffersQCOM(GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers);
 */

typedef void(*GL_TH_FNTYPE(glExtGetRenderbuffersQCOM))(GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers);

typedef struct
{
   GL_TH_FNTYPE(glExtGetRenderbuffersQCOM) orig_func;
   GLuint* renderbuffers;
   GLint maxRenderbuffers;
   GLint* numRenderbuffers;

} GL_TH_ST(glExtGetRenderbuffersQCOM);

static void
GL_TH_CB(glExtGetRenderbuffersQCOM)(void *data)
{
   GL_TH_ST(glExtGetRenderbuffersQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glExtGetRenderbuffersQCOM))thread_data->orig_func)
      (thread_data->renderbuffers,
       thread_data->maxRenderbuffers,
       thread_data->numRenderbuffers);

}

void
GL_TH_FN(glExtGetRenderbuffersQCOM)(GL_TH_DP, GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glExtGetRenderbuffersQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glExtGetRenderbuffersQCOM))orig_func)
           (renderbuffers, maxRenderbuffers, numRenderbuffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glExtGetRenderbuffersQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->renderbuffers = renderbuffers;
   thread_data->maxRenderbuffers = maxRenderbuffers;
   thread_data->numRenderbuffers = numRenderbuffers;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glExtGetRenderbuffersQCOM),
                              thread_mode);
}

/*
 * void
 * glExtGetFramebuffersQCOM(GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers);
 */

typedef void(*GL_TH_FNTYPE(glExtGetFramebuffersQCOM))(GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers);

typedef struct
{
   GL_TH_FNTYPE(glExtGetFramebuffersQCOM) orig_func;
   GLuint* framebuffers;
   GLint maxFramebuffers;
   GLint* numFramebuffers;

} GL_TH_ST(glExtGetFramebuffersQCOM);

static void
GL_TH_CB(glExtGetFramebuffersQCOM)(void *data)
{
   GL_TH_ST(glExtGetFramebuffersQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glExtGetFramebuffersQCOM))thread_data->orig_func)
      (thread_data->framebuffers,
       thread_data->maxFramebuffers,
       thread_data->numFramebuffers);

}

void
GL_TH_FN(glExtGetFramebuffersQCOM)(GL_TH_DP, GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glExtGetFramebuffersQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glExtGetFramebuffersQCOM))orig_func)
           (framebuffers, maxFramebuffers, numFramebuffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glExtGetFramebuffersQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->framebuffers = framebuffers;
   thread_data->maxFramebuffers = maxFramebuffers;
   thread_data->numFramebuffers = numFramebuffers;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glExtGetFramebuffersQCOM),
                              thread_mode);
}

/*
 * void
 * glExtGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glExtGetTexLevelParameterivQCOM))(GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glExtGetTexLevelParameterivQCOM) orig_func;
   GLuint texture;
   GLenum face;
   GLint level;
   GLenum pname;
   GLint* params;

} GL_TH_ST(glExtGetTexLevelParameterivQCOM);

static void
GL_TH_CB(glExtGetTexLevelParameterivQCOM)(void *data)
{
   GL_TH_ST(glExtGetTexLevelParameterivQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glExtGetTexLevelParameterivQCOM))thread_data->orig_func)
      (thread_data->texture,
       thread_data->face,
       thread_data->level,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glExtGetTexLevelParameterivQCOM)(GL_TH_DP, GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glExtGetTexLevelParameterivQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glExtGetTexLevelParameterivQCOM))orig_func)
           (texture, face, level, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glExtGetTexLevelParameterivQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->texture = texture;
   thread_data->face = face;
   thread_data->level = level;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glExtGetTexLevelParameterivQCOM),
                              thread_mode);
}

/*
 * void
 * glExtTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param);
 */

typedef void(*GL_TH_FNTYPE(glExtTexObjectStateOverrideiQCOM))(GLenum target, GLenum pname, GLint param);

typedef struct
{
   GL_TH_FNTYPE(glExtTexObjectStateOverrideiQCOM) orig_func;
   GLenum target;
   GLenum pname;
   GLint param;

} GL_TH_ST(glExtTexObjectStateOverrideiQCOM);

static void
GL_TH_CB(glExtTexObjectStateOverrideiQCOM)(void *data)
{
   GL_TH_ST(glExtTexObjectStateOverrideiQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glExtTexObjectStateOverrideiQCOM))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glExtTexObjectStateOverrideiQCOM)(GL_TH_DP, GLenum target, GLenum pname, GLint param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glExtTexObjectStateOverrideiQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glExtTexObjectStateOverrideiQCOM))orig_func)
           (target, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glExtTexObjectStateOverrideiQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glExtTexObjectStateOverrideiQCOM),
                              thread_mode);
}

/*
 * void
 * glExtGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void* texels);
 */

typedef void(*GL_TH_FNTYPE(glExtGetTexSubImageQCOM))(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void* texels);

typedef struct
{
   GL_TH_FNTYPE(glExtGetTexSubImageQCOM) orig_func;
   GLenum target;
   GLint level;
   GLint xoffset;
   GLint yoffset;
   GLint zoffset;
   GLsizei width;
   GLsizei height;
   GLsizei depth;
   GLenum format;
   GLenum type;
   void* texels;

} GL_TH_ST(glExtGetTexSubImageQCOM);

static void
GL_TH_CB(glExtGetTexSubImageQCOM)(void *data)
{
   GL_TH_ST(glExtGetTexSubImageQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glExtGetTexSubImageQCOM))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->xoffset,
       thread_data->yoffset,
       thread_data->zoffset,
       thread_data->width,
       thread_data->height,
       thread_data->depth,
       thread_data->format,
       thread_data->type,
       thread_data->texels);

}

void
GL_TH_FN(glExtGetTexSubImageQCOM)(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void* texels)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glExtGetTexSubImageQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glExtGetTexSubImageQCOM))orig_func)
           (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glExtGetTexSubImageQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->xoffset = xoffset;
   thread_data->yoffset = yoffset;
   thread_data->zoffset = zoffset;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->depth = depth;
   thread_data->format = format;
   thread_data->type = type;
   thread_data->texels = texels;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glExtGetTexSubImageQCOM),
                              thread_mode);
}

/*
 * void
 * glExtGetBufferPointervQCOM(GLenum target, void** params);
 */

typedef void(*GL_TH_FNTYPE(glExtGetBufferPointervQCOM))(GLenum target, void** params);

typedef struct
{
   GL_TH_FNTYPE(glExtGetBufferPointervQCOM) orig_func;
   GLenum target;
   void** params;

} GL_TH_ST(glExtGetBufferPointervQCOM);

static void
GL_TH_CB(glExtGetBufferPointervQCOM)(void *data)
{
   GL_TH_ST(glExtGetBufferPointervQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glExtGetBufferPointervQCOM))thread_data->orig_func)
      (thread_data->target,
       thread_data->params);

}

void
GL_TH_FN(glExtGetBufferPointervQCOM)(GL_TH_DP, GLenum target, void** params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glExtGetBufferPointervQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glExtGetBufferPointervQCOM))orig_func)
           (target, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glExtGetBufferPointervQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glExtGetBufferPointervQCOM),
                              thread_mode);
}

/*
 * void
 * glExtGetShadersQCOM(GLuint* shaders, GLint maxShaders, GLint* numShaders);
 */

typedef void(*GL_TH_FNTYPE(glExtGetShadersQCOM))(GLuint* shaders, GLint maxShaders, GLint* numShaders);

typedef struct
{
   GL_TH_FNTYPE(glExtGetShadersQCOM) orig_func;
   GLuint* shaders;
   GLint maxShaders;
   GLint* numShaders;

} GL_TH_ST(glExtGetShadersQCOM);

static void
GL_TH_CB(glExtGetShadersQCOM)(void *data)
{
   GL_TH_ST(glExtGetShadersQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glExtGetShadersQCOM))thread_data->orig_func)
      (thread_data->shaders,
       thread_data->maxShaders,
       thread_data->numShaders);

}

void
GL_TH_FN(glExtGetShadersQCOM)(GL_TH_DP, GLuint* shaders, GLint maxShaders, GLint* numShaders)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glExtGetShadersQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glExtGetShadersQCOM))orig_func)
           (shaders, maxShaders, numShaders);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glExtGetShadersQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->shaders = shaders;
   thread_data->maxShaders = maxShaders;
   thread_data->numShaders = numShaders;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glExtGetShadersQCOM),
                              thread_mode);
}

/*
 * void
 * glExtGetProgramsQCOM(GLuint* programs, GLint maxPrograms, GLint* numPrograms);
 */

typedef void(*GL_TH_FNTYPE(glExtGetProgramsQCOM))(GLuint* programs, GLint maxPrograms, GLint* numPrograms);

typedef struct
{
   GL_TH_FNTYPE(glExtGetProgramsQCOM) orig_func;
   GLuint* programs;
   GLint maxPrograms;
   GLint* numPrograms;

} GL_TH_ST(glExtGetProgramsQCOM);

static void
GL_TH_CB(glExtGetProgramsQCOM)(void *data)
{
   GL_TH_ST(glExtGetProgramsQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glExtGetProgramsQCOM))thread_data->orig_func)
      (thread_data->programs,
       thread_data->maxPrograms,
       thread_data->numPrograms);

}

void
GL_TH_FN(glExtGetProgramsQCOM)(GL_TH_DP, GLuint* programs, GLint maxPrograms, GLint* numPrograms)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glExtGetProgramsQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glExtGetProgramsQCOM))orig_func)
           (programs, maxPrograms, numPrograms);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glExtGetProgramsQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->programs = programs;
   thread_data->maxPrograms = maxPrograms;
   thread_data->numPrograms = numPrograms;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glExtGetProgramsQCOM),
                              thread_mode);
}

/*
 * GLboolean
 * glExtIsProgramBinaryQCOM(GLuint program);
 */

typedef GLboolean(*GL_TH_FNTYPE(glExtIsProgramBinaryQCOM))(GLuint program);

typedef struct
{
   GL_TH_FNTYPE(glExtIsProgramBinaryQCOM) orig_func;
   GLboolean return_value;
   GLuint program;

} GL_TH_ST(glExtIsProgramBinaryQCOM);

static void
GL_TH_CB(glExtIsProgramBinaryQCOM)(void *data)
{
   GL_TH_ST(glExtIsProgramBinaryQCOM) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glExtIsProgramBinaryQCOM))thread_data->orig_func)
      (thread_data->program);

}

GLboolean
GL_TH_FN(glExtIsProgramBinaryQCOM)(GL_TH_DP, GLuint program)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glExtIsProgramBinaryQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glExtIsProgramBinaryQCOM))orig_func)
           (program);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glExtIsProgramBinaryQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glExtIsProgramBinaryQCOM),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glExtGetProgramBinarySourceQCOM(GLuint program, GLenum shadertype, char* source, GLint* length);
 */

typedef void(*GL_TH_FNTYPE(glExtGetProgramBinarySourceQCOM))(GLuint program, GLenum shadertype, char* source, GLint* length);

typedef struct
{
   GL_TH_FNTYPE(glExtGetProgramBinarySourceQCOM) orig_func;
   GLuint program;
   GLenum shadertype;
   char* source;
   GLint* length;

} GL_TH_ST(glExtGetProgramBinarySourceQCOM);

static void
GL_TH_CB(glExtGetProgramBinarySourceQCOM)(void *data)
{
   GL_TH_ST(glExtGetProgramBinarySourceQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glExtGetProgramBinarySourceQCOM))thread_data->orig_func)
      (thread_data->program,
       thread_data->shadertype,
       thread_data->source,
       thread_data->length);

}

void
GL_TH_FN(glExtGetProgramBinarySourceQCOM)(GL_TH_DP, GLuint program, GLenum shadertype, char* source, GLint* length)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glExtGetProgramBinarySourceQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glExtGetProgramBinarySourceQCOM))orig_func)
           (program, shadertype, source, length);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glExtGetProgramBinarySourceQCOM) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->shadertype = shadertype;
   thread_data->source = source;
   thread_data->length = length;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glExtGetProgramBinarySourceQCOM),
                              thread_mode);
}

#ifndef GL_GLES
/*
 * void
 * glAlphaFunc(GLenum func, GLclampf ref);
 */

typedef void(*GL_TH_FNTYPE(glAlphaFunc))(GLenum func, GLclampf ref);

typedef struct
{
   GL_TH_FNTYPE(glAlphaFunc) orig_func;
   GLenum func;
   GLclampf ref;

} GL_TH_ST(glAlphaFunc);

static void
GL_TH_CB(glAlphaFunc)(void *data)
{
   GL_TH_ST(glAlphaFunc) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glAlphaFunc))thread_data->orig_func)
      (thread_data->func,
       thread_data->ref);

}

void
GL_TH_FN(glAlphaFunc)(GL_TH_DP, GLenum func, GLclampf ref)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glAlphaFunc) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glAlphaFunc))orig_func)
           (func, ref);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glAlphaFunc) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->func = func;
   thread_data->ref = ref;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glAlphaFunc),
                              thread_mode);
}

#endif
/*
 * void
 * glClipPlanef(GLenum plane, const GLfloat *equation);
 */

typedef void(*GL_TH_FNTYPE(glClipPlanef))(GLenum plane, const GLfloat *equation);

typedef struct
{
   GL_TH_FNTYPE(glClipPlanef) orig_func;
   GLenum plane;
   const GLfloat *equation;

} GL_TH_ST(glClipPlanef);

static void
GL_TH_CB(glClipPlanef)(void *data)
{
   GL_TH_ST(glClipPlanef) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClipPlanef))thread_data->orig_func)
      (thread_data->plane,
       thread_data->equation);

}

void
GL_TH_FN(glClipPlanef)(GL_TH_DP, GLenum plane, const GLfloat *equation)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClipPlanef) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClipPlanef))orig_func)
           (plane, equation);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClipPlanef) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->plane = plane;
   thread_data->equation = equation;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClipPlanef),
                              thread_mode);
}

/*
 * void
 * glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
 */

typedef void(*GL_TH_FNTYPE(glColor4f))(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);

typedef struct
{
   GL_TH_FNTYPE(glColor4f) orig_func;
   GLfloat red;
   GLfloat green;
   GLfloat blue;
   GLfloat alpha;

} GL_TH_ST(glColor4f);

static void
GL_TH_CB(glColor4f)(void *data)
{
   GL_TH_ST(glColor4f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glColor4f))thread_data->orig_func)
      (thread_data->red,
       thread_data->green,
       thread_data->blue,
       thread_data->alpha);

}

void
GL_TH_FN(glColor4f)(GL_TH_DP, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glColor4f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glColor4f))orig_func)
           (red, green, blue, alpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glColor4f) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->red = red;
   thread_data->green = green;
   thread_data->blue = blue;
   thread_data->alpha = alpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glColor4f),
                              thread_mode);
}

/*
 * void
 * glFogf(GLenum pname, GLfloat param);
 */

typedef void(*GL_TH_FNTYPE(glFogf))(GLenum pname, GLfloat param);

typedef struct
{
   GL_TH_FNTYPE(glFogf) orig_func;
   GLenum pname;
   GLfloat param;

} GL_TH_ST(glFogf);

static void
GL_TH_CB(glFogf)(void *data)
{
   GL_TH_ST(glFogf) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFogf))thread_data->orig_func)
      (thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glFogf)(GL_TH_DP, GLenum pname, GLfloat param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFogf) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFogf))orig_func)
           (pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFogf) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFogf),
                              thread_mode);
}

/*
 * void
 * glFogfv(GLenum pname, const GLfloat *params);
 */

typedef void(*GL_TH_FNTYPE(glFogfv))(GLenum pname, const GLfloat *params);

typedef struct
{
   GL_TH_FNTYPE(glFogfv) orig_func;
   GLenum pname;
   const GLfloat *params;

} GL_TH_ST(glFogfv);

static void
GL_TH_CB(glFogfv)(void *data)
{
   GL_TH_ST(glFogfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFogfv))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glFogfv)(GL_TH_DP, GLenum pname, const GLfloat *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFogfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFogfv))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFogfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFogfv),
                              thread_mode);
}

/*
 * void
 * glFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
 */

typedef void(*GL_TH_FNTYPE(glFrustumf))(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);

typedef struct
{
   GL_TH_FNTYPE(glFrustumf) orig_func;
   GLfloat left;
   GLfloat right;
   GLfloat bottom;
   GLfloat top;
   GLfloat zNear;
   GLfloat zFar;

} GL_TH_ST(glFrustumf);

static void
GL_TH_CB(glFrustumf)(void *data)
{
   GL_TH_ST(glFrustumf) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFrustumf))thread_data->orig_func)
      (thread_data->left,
       thread_data->right,
       thread_data->bottom,
       thread_data->top,
       thread_data->zNear,
       thread_data->zFar);

}

void
GL_TH_FN(glFrustumf)(GL_TH_DP, GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFrustumf) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFrustumf))orig_func)
           (left, right, bottom, top, zNear, zFar);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFrustumf) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->left = left;
   thread_data->right = right;
   thread_data->bottom = bottom;
   thread_data->top = top;
   thread_data->zNear = zNear;
   thread_data->zFar = zFar;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFrustumf),
                              thread_mode);
}

/*
 * void
 * glGetClipPlanef(GLenum pname, GLfloat eqn[4]);
 */

typedef void(*GL_TH_FNTYPE(glGetClipPlanef))(GLenum pname, GLfloat eqn[4]);

typedef struct
{
   GL_TH_FNTYPE(glGetClipPlanef) orig_func;
   GLenum pname;
   GLfloat eqn[4];

} GL_TH_ST(glGetClipPlanef);

static void
GL_TH_CB(glGetClipPlanef)(void *data)
{
   GL_TH_ST(glGetClipPlanef) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetClipPlanef))thread_data->orig_func)
      (thread_data->pname,
       thread_data->eqn);

}

void
GL_TH_FN(glGetClipPlanef)(GL_TH_DP, GLenum pname, GLfloat eqn[4])
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetClipPlanef) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetClipPlanef))orig_func)
           (pname, eqn);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetClipPlanef) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   memcpy(thread_data->eqn, &eqn, sizeof(GLfloat) * 4);
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetClipPlanef),
                              thread_mode);
}

/*
 * void
 * glGetLightfv(GLenum light, GLenum pname, GLfloat *params);
 */

typedef void(*GL_TH_FNTYPE(glGetLightfv))(GLenum light, GLenum pname, GLfloat *params);

typedef struct
{
   GL_TH_FNTYPE(glGetLightfv) orig_func;
   GLenum light;
   GLenum pname;
   GLfloat *params;

} GL_TH_ST(glGetLightfv);

static void
GL_TH_CB(glGetLightfv)(void *data)
{
   GL_TH_ST(glGetLightfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetLightfv))thread_data->orig_func)
      (thread_data->light,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetLightfv)(GL_TH_DP, GLenum light, GLenum pname, GLfloat *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetLightfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetLightfv))orig_func)
           (light, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetLightfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->light = light;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetLightfv),
                              thread_mode);
}

/*
 * void
 * glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params);
 */

typedef void(*GL_TH_FNTYPE(glGetMaterialfv))(GLenum face, GLenum pname, GLfloat *params);

typedef struct
{
   GL_TH_FNTYPE(glGetMaterialfv) orig_func;
   GLenum face;
   GLenum pname;
   GLfloat *params;

} GL_TH_ST(glGetMaterialfv);

static void
GL_TH_CB(glGetMaterialfv)(void *data)
{
   GL_TH_ST(glGetMaterialfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetMaterialfv))thread_data->orig_func)
      (thread_data->face,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetMaterialfv)(GL_TH_DP, GLenum face, GLenum pname, GLfloat *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetMaterialfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetMaterialfv))orig_func)
           (face, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetMaterialfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->face = face;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetMaterialfv),
                              thread_mode);
}

/*
 * void
 * glGetTexEnvfv(GLenum env, GLenum pname, GLfloat *params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexEnvfv))(GLenum env, GLenum pname, GLfloat *params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexEnvfv) orig_func;
   GLenum env;
   GLenum pname;
   GLfloat *params;

} GL_TH_ST(glGetTexEnvfv);

static void
GL_TH_CB(glGetTexEnvfv)(void *data)
{
   GL_TH_ST(glGetTexEnvfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexEnvfv))thread_data->orig_func)
      (thread_data->env,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexEnvfv)(GL_TH_DP, GLenum env, GLenum pname, GLfloat *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexEnvfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexEnvfv))orig_func)
           (env, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexEnvfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->env = env;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexEnvfv),
                              thread_mode);
}

/*
 * void
 * glLightModelf(GLenum pname, GLfloat param);
 */

typedef void(*GL_TH_FNTYPE(glLightModelf))(GLenum pname, GLfloat param);

typedef struct
{
   GL_TH_FNTYPE(glLightModelf) orig_func;
   GLenum pname;
   GLfloat param;

} GL_TH_ST(glLightModelf);

static void
GL_TH_CB(glLightModelf)(void *data)
{
   GL_TH_ST(glLightModelf) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLightModelf))thread_data->orig_func)
      (thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glLightModelf)(GL_TH_DP, GLenum pname, GLfloat param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLightModelf) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLightModelf))orig_func)
           (pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLightModelf) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLightModelf),
                              thread_mode);
}

/*
 * void
 * glLightModelfv(GLenum pname, const GLfloat *params);
 */

typedef void(*GL_TH_FNTYPE(glLightModelfv))(GLenum pname, const GLfloat *params);

typedef struct
{
   GL_TH_FNTYPE(glLightModelfv) orig_func;
   GLenum pname;
   const GLfloat *params;

} GL_TH_ST(glLightModelfv);

static void
GL_TH_CB(glLightModelfv)(void *data)
{
   GL_TH_ST(glLightModelfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLightModelfv))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glLightModelfv)(GL_TH_DP, GLenum pname, const GLfloat *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLightModelfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLightModelfv))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLightModelfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLightModelfv),
                              thread_mode);
}

/*
 * void
 * glLightf(GLenum light, GLenum pname, GLfloat param);
 */

typedef void(*GL_TH_FNTYPE(glLightf))(GLenum light, GLenum pname, GLfloat param);

typedef struct
{
   GL_TH_FNTYPE(glLightf) orig_func;
   GLenum light;
   GLenum pname;
   GLfloat param;

} GL_TH_ST(glLightf);

static void
GL_TH_CB(glLightf)(void *data)
{
   GL_TH_ST(glLightf) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLightf))thread_data->orig_func)
      (thread_data->light,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glLightf)(GL_TH_DP, GLenum light, GLenum pname, GLfloat param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLightf) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLightf))orig_func)
           (light, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLightf) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->light = light;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLightf),
                              thread_mode);
}

/*
 * void
 * glLightfv(GLenum light, GLenum pname, const GLfloat *params);
 */

typedef void(*GL_TH_FNTYPE(glLightfv))(GLenum light, GLenum pname, const GLfloat *params);

typedef struct
{
   GL_TH_FNTYPE(glLightfv) orig_func;
   GLenum light;
   GLenum pname;
   const GLfloat *params;

} GL_TH_ST(glLightfv);

static void
GL_TH_CB(glLightfv)(void *data)
{
   GL_TH_ST(glLightfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLightfv))thread_data->orig_func)
      (thread_data->light,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glLightfv)(GL_TH_DP, GLenum light, GLenum pname, const GLfloat *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLightfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLightfv))orig_func)
           (light, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLightfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->light = light;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLightfv),
                              thread_mode);
}

/*
 * void
 * glLoadMatrixf(const GLfloat *m);
 */

typedef void(*GL_TH_FNTYPE(glLoadMatrixf))(const GLfloat *m);

typedef struct
{
   GL_TH_FNTYPE(glLoadMatrixf) orig_func;
   const GLfloat *m;

} GL_TH_ST(glLoadMatrixf);

static void
GL_TH_CB(glLoadMatrixf)(void *data)
{
   GL_TH_ST(glLoadMatrixf) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLoadMatrixf))thread_data->orig_func)
      (thread_data->m);

}

void
GL_TH_FN(glLoadMatrixf)(GL_TH_DP, const GLfloat *m)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLoadMatrixf) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLoadMatrixf))orig_func)
           (m);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLoadMatrixf) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->m = m;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLoadMatrixf),
                              thread_mode);
}

/*
 * void
 * glMaterialf(GLenum face, GLenum pname, GLfloat param);
 */

typedef void(*GL_TH_FNTYPE(glMaterialf))(GLenum face, GLenum pname, GLfloat param);

typedef struct
{
   GL_TH_FNTYPE(glMaterialf) orig_func;
   GLenum face;
   GLenum pname;
   GLfloat param;

} GL_TH_ST(glMaterialf);

static void
GL_TH_CB(glMaterialf)(void *data)
{
   GL_TH_ST(glMaterialf) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMaterialf))thread_data->orig_func)
      (thread_data->face,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glMaterialf)(GL_TH_DP, GLenum face, GLenum pname, GLfloat param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMaterialf) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMaterialf))orig_func)
           (face, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMaterialf) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->face = face;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMaterialf),
                              thread_mode);
}

/*
 * void
 * glMaterialfv(GLenum face, GLenum pname, const GLfloat *params);
 */

typedef void(*GL_TH_FNTYPE(glMaterialfv))(GLenum face, GLenum pname, const GLfloat *params);

typedef struct
{
   GL_TH_FNTYPE(glMaterialfv) orig_func;
   GLenum face;
   GLenum pname;
   const GLfloat *params;

} GL_TH_ST(glMaterialfv);

static void
GL_TH_CB(glMaterialfv)(void *data)
{
   GL_TH_ST(glMaterialfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMaterialfv))thread_data->orig_func)
      (thread_data->face,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glMaterialfv)(GL_TH_DP, GLenum face, GLenum pname, const GLfloat *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMaterialfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMaterialfv))orig_func)
           (face, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMaterialfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->face = face;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMaterialfv),
                              thread_mode);
}

/*
 * void
 * glMultMatrixf(const GLfloat *m);
 */

typedef void(*GL_TH_FNTYPE(glMultMatrixf))(const GLfloat *m);

typedef struct
{
   GL_TH_FNTYPE(glMultMatrixf) orig_func;
   const GLfloat *m;

} GL_TH_ST(glMultMatrixf);

static void
GL_TH_CB(glMultMatrixf)(void *data)
{
   GL_TH_ST(glMultMatrixf) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMultMatrixf))thread_data->orig_func)
      (thread_data->m);

}

void
GL_TH_FN(glMultMatrixf)(GL_TH_DP, const GLfloat *m)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMultMatrixf) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMultMatrixf))orig_func)
           (m);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMultMatrixf) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->m = m;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMultMatrixf),
                              thread_mode);
}

/*
 * void
 * glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
 */

typedef void(*GL_TH_FNTYPE(glMultiTexCoord4f))(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);

typedef struct
{
   GL_TH_FNTYPE(glMultiTexCoord4f) orig_func;
   GLenum target;
   GLfloat s;
   GLfloat t;
   GLfloat r;
   GLfloat q;

} GL_TH_ST(glMultiTexCoord4f);

static void
GL_TH_CB(glMultiTexCoord4f)(void *data)
{
   GL_TH_ST(glMultiTexCoord4f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMultiTexCoord4f))thread_data->orig_func)
      (thread_data->target,
       thread_data->s,
       thread_data->t,
       thread_data->r,
       thread_data->q);

}

void
GL_TH_FN(glMultiTexCoord4f)(GL_TH_DP, GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMultiTexCoord4f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMultiTexCoord4f))orig_func)
           (target, s, t, r, q);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMultiTexCoord4f) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->s = s;
   thread_data->t = t;
   thread_data->r = r;
   thread_data->q = q;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMultiTexCoord4f),
                              thread_mode);
}

/*
 * void
 * glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);
 */

typedef void(*GL_TH_FNTYPE(glNormal3f))(GLfloat nx, GLfloat ny, GLfloat nz);

typedef struct
{
   GL_TH_FNTYPE(glNormal3f) orig_func;
   GLfloat nx;
   GLfloat ny;
   GLfloat nz;

} GL_TH_ST(glNormal3f);

static void
GL_TH_CB(glNormal3f)(void *data)
{
   GL_TH_ST(glNormal3f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glNormal3f))thread_data->orig_func)
      (thread_data->nx,
       thread_data->ny,
       thread_data->nz);

}

void
GL_TH_FN(glNormal3f)(GL_TH_DP, GLfloat nx, GLfloat ny, GLfloat nz)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glNormal3f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glNormal3f))orig_func)
           (nx, ny, nz);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glNormal3f) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->nx = nx;
   thread_data->ny = ny;
   thread_data->nz = nz;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glNormal3f),
                              thread_mode);
}

/*
 * void
 * glOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
 */

typedef void(*GL_TH_FNTYPE(glOrthof))(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);

typedef struct
{
   GL_TH_FNTYPE(glOrthof) orig_func;
   GLfloat left;
   GLfloat right;
   GLfloat bottom;
   GLfloat top;
   GLfloat zNear;
   GLfloat zFar;

} GL_TH_ST(glOrthof);

static void
GL_TH_CB(glOrthof)(void *data)
{
   GL_TH_ST(glOrthof) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glOrthof))thread_data->orig_func)
      (thread_data->left,
       thread_data->right,
       thread_data->bottom,
       thread_data->top,
       thread_data->zNear,
       thread_data->zFar);

}

void
GL_TH_FN(glOrthof)(GL_TH_DP, GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glOrthof) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glOrthof))orig_func)
           (left, right, bottom, top, zNear, zFar);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glOrthof) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->left = left;
   thread_data->right = right;
   thread_data->bottom = bottom;
   thread_data->top = top;
   thread_data->zNear = zNear;
   thread_data->zFar = zFar;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glOrthof),
                              thread_mode);
}

/*
 * void
 * glPointParameterf(GLenum pname, GLfloat param);
 */

typedef void(*GL_TH_FNTYPE(glPointParameterf))(GLenum pname, GLfloat param);

typedef struct
{
   GL_TH_FNTYPE(glPointParameterf) orig_func;
   GLenum pname;
   GLfloat param;

} GL_TH_ST(glPointParameterf);

static void
GL_TH_CB(glPointParameterf)(void *data)
{
   GL_TH_ST(glPointParameterf) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPointParameterf))thread_data->orig_func)
      (thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glPointParameterf)(GL_TH_DP, GLenum pname, GLfloat param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPointParameterf) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPointParameterf))orig_func)
           (pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPointParameterf) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPointParameterf),
                              thread_mode);
}

/*
 * void
 * glPointParameterfv(GLenum pname, const GLfloat *params);
 */

typedef void(*GL_TH_FNTYPE(glPointParameterfv))(GLenum pname, const GLfloat *params);

typedef struct
{
   GL_TH_FNTYPE(glPointParameterfv) orig_func;
   GLenum pname;
   const GLfloat *params;

} GL_TH_ST(glPointParameterfv);

static void
GL_TH_CB(glPointParameterfv)(void *data)
{
   GL_TH_ST(glPointParameterfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPointParameterfv))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glPointParameterfv)(GL_TH_DP, GLenum pname, const GLfloat *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPointParameterfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPointParameterfv))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPointParameterfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPointParameterfv),
                              thread_mode);
}

/*
 * void
 * glPointSize(GLfloat size);
 */

typedef void(*GL_TH_FNTYPE(glPointSize))(GLfloat size);

typedef struct
{
   GL_TH_FNTYPE(glPointSize) orig_func;
   GLfloat size;

} GL_TH_ST(glPointSize);

static void
GL_TH_CB(glPointSize)(void *data)
{
   GL_TH_ST(glPointSize) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPointSize))thread_data->orig_func)
      (thread_data->size);

}

void
GL_TH_FN(glPointSize)(GL_TH_DP, GLfloat size)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPointSize) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPointSize))orig_func)
           (size);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPointSize) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->size = size;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPointSize),
                              thread_mode);
}

/*
 * void
 * glPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid * pointer);
 */

typedef void(*GL_TH_FNTYPE(glPointSizePointerOES))(GLenum type, GLsizei stride, const GLvoid * pointer);

typedef struct
{
   GL_TH_FNTYPE(glPointSizePointerOES) orig_func;
   GLenum type;
   GLsizei stride;
   const GLvoid * pointer;

} GL_TH_ST(glPointSizePointerOES);

static void
GL_TH_CB(glPointSizePointerOES)(void *data)
{
   GL_TH_ST(glPointSizePointerOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPointSizePointerOES))thread_data->orig_func)
      (thread_data->type,
       thread_data->stride,
       thread_data->pointer);

}

void
GL_TH_FN(glPointSizePointerOES)(GL_TH_DP, GLenum type, GLsizei stride, const GLvoid * pointer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPointSizePointerOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPointSizePointerOES))orig_func)
           (type, stride, pointer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPointSizePointerOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->type = type;
   thread_data->stride = stride;
   thread_data->pointer = pointer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPointSizePointerOES),
                              thread_mode);
}

/*
 * void
 * glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
 */

typedef void(*GL_TH_FNTYPE(glRotatef))(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);

typedef struct
{
   GL_TH_FNTYPE(glRotatef) orig_func;
   GLfloat angle;
   GLfloat x;
   GLfloat y;
   GLfloat z;

} GL_TH_ST(glRotatef);

static void
GL_TH_CB(glRotatef)(void *data)
{
   GL_TH_ST(glRotatef) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glRotatef))thread_data->orig_func)
      (thread_data->angle,
       thread_data->x,
       thread_data->y,
       thread_data->z);

}

void
GL_TH_FN(glRotatef)(GL_TH_DP, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glRotatef) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glRotatef))orig_func)
           (angle, x, y, z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glRotatef) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->angle = angle;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glRotatef),
                              thread_mode);
}

/*
 * void
 * glScalef(GLfloat x, GLfloat y, GLfloat z);
 */

typedef void(*GL_TH_FNTYPE(glScalef))(GLfloat x, GLfloat y, GLfloat z);

typedef struct
{
   GL_TH_FNTYPE(glScalef) orig_func;
   GLfloat x;
   GLfloat y;
   GLfloat z;

} GL_TH_ST(glScalef);

static void
GL_TH_CB(glScalef)(void *data)
{
   GL_TH_ST(glScalef) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glScalef))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->z);

}

void
GL_TH_FN(glScalef)(GL_TH_DP, GLfloat x, GLfloat y, GLfloat z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glScalef) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glScalef))orig_func)
           (x, y, z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glScalef) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glScalef),
                              thread_mode);
}

/*
 * void
 * glTexEnvf(GLenum target, GLenum pname, GLfloat param);
 */

typedef void(*GL_TH_FNTYPE(glTexEnvf))(GLenum target, GLenum pname, GLfloat param);

typedef struct
{
   GL_TH_FNTYPE(glTexEnvf) orig_func;
   GLenum target;
   GLenum pname;
   GLfloat param;

} GL_TH_ST(glTexEnvf);

static void
GL_TH_CB(glTexEnvf)(void *data)
{
   GL_TH_ST(glTexEnvf) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexEnvf))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glTexEnvf)(GL_TH_DP, GLenum target, GLenum pname, GLfloat param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexEnvf) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexEnvf))orig_func)
           (target, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexEnvf) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexEnvf),
                              thread_mode);
}

/*
 * void
 * glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params);
 */

typedef void(*GL_TH_FNTYPE(glTexEnvfv))(GLenum target, GLenum pname, const GLfloat *params);

typedef struct
{
   GL_TH_FNTYPE(glTexEnvfv) orig_func;
   GLenum target;
   GLenum pname;
   const GLfloat *params;

} GL_TH_ST(glTexEnvfv);

static void
GL_TH_CB(glTexEnvfv)(void *data)
{
   GL_TH_ST(glTexEnvfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexEnvfv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glTexEnvfv)(GL_TH_DP, GLenum target, GLenum pname, const GLfloat *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexEnvfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexEnvfv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexEnvfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexEnvfv),
                              thread_mode);
}

/*
 * void
 * glTranslatef(GLfloat x, GLfloat y, GLfloat z);
 */

typedef void(*GL_TH_FNTYPE(glTranslatef))(GLfloat x, GLfloat y, GLfloat z);

typedef struct
{
   GL_TH_FNTYPE(glTranslatef) orig_func;
   GLfloat x;
   GLfloat y;
   GLfloat z;

} GL_TH_ST(glTranslatef);

static void
GL_TH_CB(glTranslatef)(void *data)
{
   GL_TH_ST(glTranslatef) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTranslatef))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->z);

}

void
GL_TH_FN(glTranslatef)(GL_TH_DP, GLfloat x, GLfloat y, GLfloat z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTranslatef) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTranslatef))orig_func)
           (x, y, z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTranslatef) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTranslatef),
                              thread_mode);
}

/*
 * void
 * glAlphaFuncx(GLenum func, GLclampx ref);
 */

typedef void(*GL_TH_FNTYPE(glAlphaFuncx))(GLenum func, GLclampx ref);

typedef struct
{
   GL_TH_FNTYPE(glAlphaFuncx) orig_func;
   GLenum func;
   GLclampx ref;

} GL_TH_ST(glAlphaFuncx);

static void
GL_TH_CB(glAlphaFuncx)(void *data)
{
   GL_TH_ST(glAlphaFuncx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glAlphaFuncx))thread_data->orig_func)
      (thread_data->func,
       thread_data->ref);

}

void
GL_TH_FN(glAlphaFuncx)(GL_TH_DP, GLenum func, GLclampx ref)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glAlphaFuncx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glAlphaFuncx))orig_func)
           (func, ref);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glAlphaFuncx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->func = func;
   thread_data->ref = ref;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glAlphaFuncx),
                              thread_mode);
}

/*
 * void
 * glClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
 */

typedef void(*GL_TH_FNTYPE(glClearColorx))(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);

typedef struct
{
   GL_TH_FNTYPE(glClearColorx) orig_func;
   GLclampx red;
   GLclampx green;
   GLclampx blue;
   GLclampx alpha;

} GL_TH_ST(glClearColorx);

static void
GL_TH_CB(glClearColorx)(void *data)
{
   GL_TH_ST(glClearColorx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClearColorx))thread_data->orig_func)
      (thread_data->red,
       thread_data->green,
       thread_data->blue,
       thread_data->alpha);

}

void
GL_TH_FN(glClearColorx)(GL_TH_DP, GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClearColorx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClearColorx))orig_func)
           (red, green, blue, alpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClearColorx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->red = red;
   thread_data->green = green;
   thread_data->blue = blue;
   thread_data->alpha = alpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClearColorx),
                              thread_mode);
}

/*
 * void
 * glClearDepthx(GLclampx depth);
 */

typedef void(*GL_TH_FNTYPE(glClearDepthx))(GLclampx depth);

typedef struct
{
   GL_TH_FNTYPE(glClearDepthx) orig_func;
   GLclampx depth;

} GL_TH_ST(glClearDepthx);

static void
GL_TH_CB(glClearDepthx)(void *data)
{
   GL_TH_ST(glClearDepthx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClearDepthx))thread_data->orig_func)
      (thread_data->depth);

}

void
GL_TH_FN(glClearDepthx)(GL_TH_DP, GLclampx depth)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClearDepthx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClearDepthx))orig_func)
           (depth);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClearDepthx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->depth = depth;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClearDepthx),
                              thread_mode);
}

/*
 * void
 * glClientActiveTexture(GLenum texture);
 */

typedef void(*GL_TH_FNTYPE(glClientActiveTexture))(GLenum texture);

typedef struct
{
   GL_TH_FNTYPE(glClientActiveTexture) orig_func;
   GLenum texture;

} GL_TH_ST(glClientActiveTexture);

static void
GL_TH_CB(glClientActiveTexture)(void *data)
{
   GL_TH_ST(glClientActiveTexture) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClientActiveTexture))thread_data->orig_func)
      (thread_data->texture);

}

void
GL_TH_FN(glClientActiveTexture)(GL_TH_DP, GLenum texture)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClientActiveTexture) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClientActiveTexture))orig_func)
           (texture);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClientActiveTexture) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->texture = texture;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClientActiveTexture),
                              thread_mode);
}

/*
 * void
 * glClipPlanex(GLenum plane, const GLfixed *equation);
 */

typedef void(*GL_TH_FNTYPE(glClipPlanex))(GLenum plane, const GLfixed *equation);

typedef struct
{
   GL_TH_FNTYPE(glClipPlanex) orig_func;
   GLenum plane;
   const GLfixed *equation;

} GL_TH_ST(glClipPlanex);

static void
GL_TH_CB(glClipPlanex)(void *data)
{
   GL_TH_ST(glClipPlanex) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClipPlanex))thread_data->orig_func)
      (thread_data->plane,
       thread_data->equation);

}

void
GL_TH_FN(glClipPlanex)(GL_TH_DP, GLenum plane, const GLfixed *equation)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClipPlanex) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClipPlanex))orig_func)
           (plane, equation);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClipPlanex) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->plane = plane;
   thread_data->equation = equation;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClipPlanex),
                              thread_mode);
}

/*
 * void
 * glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
 */

typedef void(*GL_TH_FNTYPE(glColor4ub))(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);

typedef struct
{
   GL_TH_FNTYPE(glColor4ub) orig_func;
   GLubyte red;
   GLubyte green;
   GLubyte blue;
   GLubyte alpha;

} GL_TH_ST(glColor4ub);

static void
GL_TH_CB(glColor4ub)(void *data)
{
   GL_TH_ST(glColor4ub) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glColor4ub))thread_data->orig_func)
      (thread_data->red,
       thread_data->green,
       thread_data->blue,
       thread_data->alpha);

}

void
GL_TH_FN(glColor4ub)(GL_TH_DP, GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glColor4ub) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glColor4ub))orig_func)
           (red, green, blue, alpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glColor4ub) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->red = red;
   thread_data->green = green;
   thread_data->blue = blue;
   thread_data->alpha = alpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glColor4ub),
                              thread_mode);
}

/*
 * void
 * glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
 */

typedef void(*GL_TH_FNTYPE(glColor4x))(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);

typedef struct
{
   GL_TH_FNTYPE(glColor4x) orig_func;
   GLfixed red;
   GLfixed green;
   GLfixed blue;
   GLfixed alpha;

} GL_TH_ST(glColor4x);

static void
GL_TH_CB(glColor4x)(void *data)
{
   GL_TH_ST(glColor4x) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glColor4x))thread_data->orig_func)
      (thread_data->red,
       thread_data->green,
       thread_data->blue,
       thread_data->alpha);

}

void
GL_TH_FN(glColor4x)(GL_TH_DP, GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glColor4x) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glColor4x))orig_func)
           (red, green, blue, alpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glColor4x) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->red = red;
   thread_data->green = green;
   thread_data->blue = blue;
   thread_data->alpha = alpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glColor4x),
                              thread_mode);
}

/*
 * void
 * glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
 */

typedef void(*GL_TH_FNTYPE(glColorPointer))(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

typedef struct
{
   GL_TH_FNTYPE(glColorPointer) orig_func;
   GLint size;
   GLenum type;
   GLsizei stride;
   const GLvoid *pointer;

} GL_TH_ST(glColorPointer);

static void
GL_TH_CB(glColorPointer)(void *data)
{
   GL_TH_ST(glColorPointer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glColorPointer))thread_data->orig_func)
      (thread_data->size,
       thread_data->type,
       thread_data->stride,
       thread_data->pointer);

}

void
GL_TH_FN(glColorPointer)(GL_TH_DP, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glColorPointer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glColorPointer))orig_func)
           (size, type, stride, pointer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glColorPointer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->size = size;
   thread_data->type = type;
   thread_data->stride = stride;
   thread_data->pointer = pointer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glColorPointer),
                              thread_mode);
}

/*
 * void
 * glDepthRangex(GLclampx zNear, GLclampx zFar);
 */

typedef void(*GL_TH_FNTYPE(glDepthRangex))(GLclampx zNear, GLclampx zFar);

typedef struct
{
   GL_TH_FNTYPE(glDepthRangex) orig_func;
   GLclampx zNear;
   GLclampx zFar;

} GL_TH_ST(glDepthRangex);

static void
GL_TH_CB(glDepthRangex)(void *data)
{
   GL_TH_ST(glDepthRangex) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDepthRangex))thread_data->orig_func)
      (thread_data->zNear,
       thread_data->zFar);

}

void
GL_TH_FN(glDepthRangex)(GL_TH_DP, GLclampx zNear, GLclampx zFar)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDepthRangex) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDepthRangex))orig_func)
           (zNear, zFar);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDepthRangex) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->zNear = zNear;
   thread_data->zFar = zFar;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDepthRangex),
                              thread_mode);
}

/*
 * void
 * glDisableClientState(GLenum array);
 */

typedef void(*GL_TH_FNTYPE(glDisableClientState))(GLenum array);

typedef struct
{
   GL_TH_FNTYPE(glDisableClientState) orig_func;
   GLenum array;

} GL_TH_ST(glDisableClientState);

static void
GL_TH_CB(glDisableClientState)(void *data)
{
   GL_TH_ST(glDisableClientState) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDisableClientState))thread_data->orig_func)
      (thread_data->array);

}

void
GL_TH_FN(glDisableClientState)(GL_TH_DP, GLenum array)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDisableClientState) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDisableClientState))orig_func)
           (array);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDisableClientState) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->array = array;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDisableClientState),
                              thread_mode);
}

/*
 * void
 * glEnableClientState(GLenum array);
 */

typedef void(*GL_TH_FNTYPE(glEnableClientState))(GLenum array);

typedef struct
{
   GL_TH_FNTYPE(glEnableClientState) orig_func;
   GLenum array;

} GL_TH_ST(glEnableClientState);

static void
GL_TH_CB(glEnableClientState)(void *data)
{
   GL_TH_ST(glEnableClientState) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glEnableClientState))thread_data->orig_func)
      (thread_data->array);

}

void
GL_TH_FN(glEnableClientState)(GL_TH_DP, GLenum array)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glEnableClientState) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glEnableClientState))orig_func)
           (array);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glEnableClientState) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->array = array;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glEnableClientState),
                              thread_mode);
}

/*
 * void
 * glFogx(GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glFogx))(GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glFogx) orig_func;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glFogx);

static void
GL_TH_CB(glFogx)(void *data)
{
   GL_TH_ST(glFogx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFogx))thread_data->orig_func)
      (thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glFogx)(GL_TH_DP, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFogx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFogx))orig_func)
           (pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFogx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFogx),
                              thread_mode);
}

/*
 * void
 * glFogxv(GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glFogxv))(GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glFogxv) orig_func;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glFogxv);

static void
GL_TH_CB(glFogxv)(void *data)
{
   GL_TH_ST(glFogxv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFogxv))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glFogxv)(GL_TH_DP, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFogxv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFogxv))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFogxv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFogxv),
                              thread_mode);
}

/*
 * void
 * glFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
 */

typedef void(*GL_TH_FNTYPE(glFrustumx))(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);

typedef struct
{
   GL_TH_FNTYPE(glFrustumx) orig_func;
   GLfixed left;
   GLfixed right;
   GLfixed bottom;
   GLfixed top;
   GLfixed zNear;
   GLfixed zFar;

} GL_TH_ST(glFrustumx);

static void
GL_TH_CB(glFrustumx)(void *data)
{
   GL_TH_ST(glFrustumx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFrustumx))thread_data->orig_func)
      (thread_data->left,
       thread_data->right,
       thread_data->bottom,
       thread_data->top,
       thread_data->zNear,
       thread_data->zFar);

}

void
GL_TH_FN(glFrustumx)(GL_TH_DP, GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFrustumx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFrustumx))orig_func)
           (left, right, bottom, top, zNear, zFar);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFrustumx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->left = left;
   thread_data->right = right;
   thread_data->bottom = bottom;
   thread_data->top = top;
   thread_data->zNear = zNear;
   thread_data->zFar = zFar;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFrustumx),
                              thread_mode);
}

/*
 * void
 * glGetClipPlanex(GLenum pname, GLfixed eqn[4]);
 */

typedef void(*GL_TH_FNTYPE(glGetClipPlanex))(GLenum pname, GLfixed eqn[4]);

typedef struct
{
   GL_TH_FNTYPE(glGetClipPlanex) orig_func;
   GLenum pname;
   GLfixed eqn[4];

} GL_TH_ST(glGetClipPlanex);

static void
GL_TH_CB(glGetClipPlanex)(void *data)
{
   GL_TH_ST(glGetClipPlanex) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetClipPlanex))thread_data->orig_func)
      (thread_data->pname,
       thread_data->eqn);

}

void
GL_TH_FN(glGetClipPlanex)(GL_TH_DP, GLenum pname, GLfixed eqn[4])
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetClipPlanex) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetClipPlanex))orig_func)
           (pname, eqn);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetClipPlanex) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   memcpy(thread_data->eqn, &eqn, sizeof(GLfixed) * 4);
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetClipPlanex),
                              thread_mode);
}

/*
 * void
 * glGetFixedv(GLenum pname, GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glGetFixedv))(GLenum pname, GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glGetFixedv) orig_func;
   GLenum pname;
   GLfixed *params;

} GL_TH_ST(glGetFixedv);

static void
GL_TH_CB(glGetFixedv)(void *data)
{
   GL_TH_ST(glGetFixedv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetFixedv))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetFixedv)(GL_TH_DP, GLenum pname, GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetFixedv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetFixedv))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetFixedv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetFixedv),
                              thread_mode);
}

/*
 * void
 * glGetLightxv(GLenum light, GLenum pname, GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glGetLightxv))(GLenum light, GLenum pname, GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glGetLightxv) orig_func;
   GLenum light;
   GLenum pname;
   GLfixed *params;

} GL_TH_ST(glGetLightxv);

static void
GL_TH_CB(glGetLightxv)(void *data)
{
   GL_TH_ST(glGetLightxv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetLightxv))thread_data->orig_func)
      (thread_data->light,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetLightxv)(GL_TH_DP, GLenum light, GLenum pname, GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetLightxv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetLightxv))orig_func)
           (light, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetLightxv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->light = light;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetLightxv),
                              thread_mode);
}

/*
 * void
 * glGetMaterialxv(GLenum face, GLenum pname, GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glGetMaterialxv))(GLenum face, GLenum pname, GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glGetMaterialxv) orig_func;
   GLenum face;
   GLenum pname;
   GLfixed *params;

} GL_TH_ST(glGetMaterialxv);

static void
GL_TH_CB(glGetMaterialxv)(void *data)
{
   GL_TH_ST(glGetMaterialxv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetMaterialxv))thread_data->orig_func)
      (thread_data->face,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetMaterialxv)(GL_TH_DP, GLenum face, GLenum pname, GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetMaterialxv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetMaterialxv))orig_func)
           (face, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetMaterialxv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->face = face;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetMaterialxv),
                              thread_mode);
}

/*
 * void
 * glGetPointerv(GLenum pname, GLvoid **params);
 */

typedef void(*GL_TH_FNTYPE(glGetPointerv))(GLenum pname, GLvoid **params);

typedef struct
{
   GL_TH_FNTYPE(glGetPointerv) orig_func;
   GLenum pname;
   GLvoid **params;

} GL_TH_ST(glGetPointerv);

static void
GL_TH_CB(glGetPointerv)(void *data)
{
   GL_TH_ST(glGetPointerv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetPointerv))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetPointerv)(GL_TH_DP, GLenum pname, GLvoid **params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetPointerv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetPointerv))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetPointerv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetPointerv),
                              thread_mode);
}

/*
 * void
 * glGetTexEnviv(GLenum env, GLenum pname, GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexEnviv))(GLenum env, GLenum pname, GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexEnviv) orig_func;
   GLenum env;
   GLenum pname;
   GLint *params;

} GL_TH_ST(glGetTexEnviv);

static void
GL_TH_CB(glGetTexEnviv)(void *data)
{
   GL_TH_ST(glGetTexEnviv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexEnviv))thread_data->orig_func)
      (thread_data->env,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexEnviv)(GL_TH_DP, GLenum env, GLenum pname, GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexEnviv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexEnviv))orig_func)
           (env, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexEnviv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->env = env;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexEnviv),
                              thread_mode);
}

/*
 * void
 * glGetTexEnvxv(GLenum env, GLenum pname, GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexEnvxv))(GLenum env, GLenum pname, GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexEnvxv) orig_func;
   GLenum env;
   GLenum pname;
   GLfixed *params;

} GL_TH_ST(glGetTexEnvxv);

static void
GL_TH_CB(glGetTexEnvxv)(void *data)
{
   GL_TH_ST(glGetTexEnvxv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexEnvxv))thread_data->orig_func)
      (thread_data->env,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexEnvxv)(GL_TH_DP, GLenum env, GLenum pname, GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexEnvxv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexEnvxv))orig_func)
           (env, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexEnvxv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->env = env;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexEnvxv),
                              thread_mode);
}

/*
 * void
 * glGetTexParameterxv(GLenum target, GLenum pname, GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexParameterxv))(GLenum target, GLenum pname, GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexParameterxv) orig_func;
   GLenum target;
   GLenum pname;
   GLfixed *params;

} GL_TH_ST(glGetTexParameterxv);

static void
GL_TH_CB(glGetTexParameterxv)(void *data)
{
   GL_TH_ST(glGetTexParameterxv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexParameterxv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexParameterxv)(GL_TH_DP, GLenum target, GLenum pname, GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexParameterxv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexParameterxv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexParameterxv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexParameterxv),
                              thread_mode);
}

/*
 * void
 * glLightModelx(GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glLightModelx))(GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glLightModelx) orig_func;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glLightModelx);

static void
GL_TH_CB(glLightModelx)(void *data)
{
   GL_TH_ST(glLightModelx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLightModelx))thread_data->orig_func)
      (thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glLightModelx)(GL_TH_DP, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLightModelx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLightModelx))orig_func)
           (pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLightModelx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLightModelx),
                              thread_mode);
}

/*
 * void
 * glLightModelxv(GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glLightModelxv))(GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glLightModelxv) orig_func;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glLightModelxv);

static void
GL_TH_CB(glLightModelxv)(void *data)
{
   GL_TH_ST(glLightModelxv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLightModelxv))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glLightModelxv)(GL_TH_DP, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLightModelxv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLightModelxv))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLightModelxv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLightModelxv),
                              thread_mode);
}

/*
 * void
 * glLightx(GLenum light, GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glLightx))(GLenum light, GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glLightx) orig_func;
   GLenum light;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glLightx);

static void
GL_TH_CB(glLightx)(void *data)
{
   GL_TH_ST(glLightx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLightx))thread_data->orig_func)
      (thread_data->light,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glLightx)(GL_TH_DP, GLenum light, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLightx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLightx))orig_func)
           (light, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLightx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->light = light;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLightx),
                              thread_mode);
}

/*
 * void
 * glLightxv(GLenum light, GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glLightxv))(GLenum light, GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glLightxv) orig_func;
   GLenum light;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glLightxv);

static void
GL_TH_CB(glLightxv)(void *data)
{
   GL_TH_ST(glLightxv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLightxv))thread_data->orig_func)
      (thread_data->light,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glLightxv)(GL_TH_DP, GLenum light, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLightxv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLightxv))orig_func)
           (light, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLightxv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->light = light;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLightxv),
                              thread_mode);
}

/*
 * void
 * glLineWidthx(GLfixed width);
 */

typedef void(*GL_TH_FNTYPE(glLineWidthx))(GLfixed width);

typedef struct
{
   GL_TH_FNTYPE(glLineWidthx) orig_func;
   GLfixed width;

} GL_TH_ST(glLineWidthx);

static void
GL_TH_CB(glLineWidthx)(void *data)
{
   GL_TH_ST(glLineWidthx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLineWidthx))thread_data->orig_func)
      (thread_data->width);

}

void
GL_TH_FN(glLineWidthx)(GL_TH_DP, GLfixed width)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLineWidthx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLineWidthx))orig_func)
           (width);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLineWidthx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->width = width;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLineWidthx),
                              thread_mode);
}

/*
 * void
 * glLoadIdentity(void);
 */

typedef void(*GL_TH_FNTYPE(glLoadIdentity))(void);

typedef struct
{
   GL_TH_FNTYPE(glLoadIdentity) orig_func;

} GL_TH_ST(glLoadIdentity);

static void
GL_TH_CB(glLoadIdentity)(void *data)
{
   GL_TH_ST(glLoadIdentity) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLoadIdentity))thread_data->orig_func)
      ();

}

void
GL_TH_FN(glLoadIdentity)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLoadIdentity) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLoadIdentity))orig_func)
           ();
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLoadIdentity) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLoadIdentity),
                              thread_mode);
}

/*
 * void
 * glLoadMatrixx(const GLfixed *m);
 */

typedef void(*GL_TH_FNTYPE(glLoadMatrixx))(const GLfixed *m);

typedef struct
{
   GL_TH_FNTYPE(glLoadMatrixx) orig_func;
   const GLfixed *m;

} GL_TH_ST(glLoadMatrixx);

static void
GL_TH_CB(glLoadMatrixx)(void *data)
{
   GL_TH_ST(glLoadMatrixx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLoadMatrixx))thread_data->orig_func)
      (thread_data->m);

}

void
GL_TH_FN(glLoadMatrixx)(GL_TH_DP, const GLfixed *m)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLoadMatrixx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLoadMatrixx))orig_func)
           (m);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLoadMatrixx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->m = m;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLoadMatrixx),
                              thread_mode);
}

/*
 * void
 * glLogicOp(GLenum opcode);
 */

typedef void(*GL_TH_FNTYPE(glLogicOp))(GLenum opcode);

typedef struct
{
   GL_TH_FNTYPE(glLogicOp) orig_func;
   GLenum opcode;

} GL_TH_ST(glLogicOp);

static void
GL_TH_CB(glLogicOp)(void *data)
{
   GL_TH_ST(glLogicOp) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLogicOp))thread_data->orig_func)
      (thread_data->opcode);

}

void
GL_TH_FN(glLogicOp)(GL_TH_DP, GLenum opcode)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLogicOp) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLogicOp))orig_func)
           (opcode);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLogicOp) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->opcode = opcode;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLogicOp),
                              thread_mode);
}

/*
 * void
 * glMaterialx(GLenum face, GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glMaterialx))(GLenum face, GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glMaterialx) orig_func;
   GLenum face;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glMaterialx);

static void
GL_TH_CB(glMaterialx)(void *data)
{
   GL_TH_ST(glMaterialx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMaterialx))thread_data->orig_func)
      (thread_data->face,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glMaterialx)(GL_TH_DP, GLenum face, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMaterialx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMaterialx))orig_func)
           (face, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMaterialx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->face = face;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMaterialx),
                              thread_mode);
}

/*
 * void
 * glMaterialxv(GLenum face, GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glMaterialxv))(GLenum face, GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glMaterialxv) orig_func;
   GLenum face;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glMaterialxv);

static void
GL_TH_CB(glMaterialxv)(void *data)
{
   GL_TH_ST(glMaterialxv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMaterialxv))thread_data->orig_func)
      (thread_data->face,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glMaterialxv)(GL_TH_DP, GLenum face, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMaterialxv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMaterialxv))orig_func)
           (face, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMaterialxv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->face = face;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMaterialxv),
                              thread_mode);
}

/*
 * void
 * glMatrixMode(GLenum mode);
 */

typedef void(*GL_TH_FNTYPE(glMatrixMode))(GLenum mode);

typedef struct
{
   GL_TH_FNTYPE(glMatrixMode) orig_func;
   GLenum mode;

} GL_TH_ST(glMatrixMode);

static void
GL_TH_CB(glMatrixMode)(void *data)
{
   GL_TH_ST(glMatrixMode) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMatrixMode))thread_data->orig_func)
      (thread_data->mode);

}

void
GL_TH_FN(glMatrixMode)(GL_TH_DP, GLenum mode)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMatrixMode) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMatrixMode))orig_func)
           (mode);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMatrixMode) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMatrixMode),
                              thread_mode);
}

/*
 * void
 * glMultMatrixx(const GLfixed *m);
 */

typedef void(*GL_TH_FNTYPE(glMultMatrixx))(const GLfixed *m);

typedef struct
{
   GL_TH_FNTYPE(glMultMatrixx) orig_func;
   const GLfixed *m;

} GL_TH_ST(glMultMatrixx);

static void
GL_TH_CB(glMultMatrixx)(void *data)
{
   GL_TH_ST(glMultMatrixx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMultMatrixx))thread_data->orig_func)
      (thread_data->m);

}

void
GL_TH_FN(glMultMatrixx)(GL_TH_DP, const GLfixed *m)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMultMatrixx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMultMatrixx))orig_func)
           (m);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMultMatrixx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->m = m;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMultMatrixx),
                              thread_mode);
}

/*
 * void
 * glMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
 */

typedef void(*GL_TH_FNTYPE(glMultiTexCoord4x))(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);

typedef struct
{
   GL_TH_FNTYPE(glMultiTexCoord4x) orig_func;
   GLenum target;
   GLfixed s;
   GLfixed t;
   GLfixed r;
   GLfixed q;

} GL_TH_ST(glMultiTexCoord4x);

static void
GL_TH_CB(glMultiTexCoord4x)(void *data)
{
   GL_TH_ST(glMultiTexCoord4x) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMultiTexCoord4x))thread_data->orig_func)
      (thread_data->target,
       thread_data->s,
       thread_data->t,
       thread_data->r,
       thread_data->q);

}

void
GL_TH_FN(glMultiTexCoord4x)(GL_TH_DP, GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMultiTexCoord4x) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMultiTexCoord4x))orig_func)
           (target, s, t, r, q);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMultiTexCoord4x) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->s = s;
   thread_data->t = t;
   thread_data->r = r;
   thread_data->q = q;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMultiTexCoord4x),
                              thread_mode);
}

/*
 * void
 * glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz);
 */

typedef void(*GL_TH_FNTYPE(glNormal3x))(GLfixed nx, GLfixed ny, GLfixed nz);

typedef struct
{
   GL_TH_FNTYPE(glNormal3x) orig_func;
   GLfixed nx;
   GLfixed ny;
   GLfixed nz;

} GL_TH_ST(glNormal3x);

static void
GL_TH_CB(glNormal3x)(void *data)
{
   GL_TH_ST(glNormal3x) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glNormal3x))thread_data->orig_func)
      (thread_data->nx,
       thread_data->ny,
       thread_data->nz);

}

void
GL_TH_FN(glNormal3x)(GL_TH_DP, GLfixed nx, GLfixed ny, GLfixed nz)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glNormal3x) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glNormal3x))orig_func)
           (nx, ny, nz);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glNormal3x) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->nx = nx;
   thread_data->ny = ny;
   thread_data->nz = nz;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glNormal3x),
                              thread_mode);
}

/*
 * void
 * glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer);
 */

typedef void(*GL_TH_FNTYPE(glNormalPointer))(GLenum type, GLsizei stride, const GLvoid *pointer);

typedef struct
{
   GL_TH_FNTYPE(glNormalPointer) orig_func;
   GLenum type;
   GLsizei stride;
   const GLvoid *pointer;

} GL_TH_ST(glNormalPointer);

static void
GL_TH_CB(glNormalPointer)(void *data)
{
   GL_TH_ST(glNormalPointer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glNormalPointer))thread_data->orig_func)
      (thread_data->type,
       thread_data->stride,
       thread_data->pointer);

}

void
GL_TH_FN(glNormalPointer)(GL_TH_DP, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glNormalPointer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glNormalPointer))orig_func)
           (type, stride, pointer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glNormalPointer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->type = type;
   thread_data->stride = stride;
   thread_data->pointer = pointer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glNormalPointer),
                              thread_mode);
}

/*
 * void
 * glOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
 */

typedef void(*GL_TH_FNTYPE(glOrthox))(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);

typedef struct
{
   GL_TH_FNTYPE(glOrthox) orig_func;
   GLfixed left;
   GLfixed right;
   GLfixed bottom;
   GLfixed top;
   GLfixed zNear;
   GLfixed zFar;

} GL_TH_ST(glOrthox);

static void
GL_TH_CB(glOrthox)(void *data)
{
   GL_TH_ST(glOrthox) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glOrthox))thread_data->orig_func)
      (thread_data->left,
       thread_data->right,
       thread_data->bottom,
       thread_data->top,
       thread_data->zNear,
       thread_data->zFar);

}

void
GL_TH_FN(glOrthox)(GL_TH_DP, GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glOrthox) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glOrthox))orig_func)
           (left, right, bottom, top, zNear, zFar);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glOrthox) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->left = left;
   thread_data->right = right;
   thread_data->bottom = bottom;
   thread_data->top = top;
   thread_data->zNear = zNear;
   thread_data->zFar = zFar;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glOrthox),
                              thread_mode);
}

/*
 * void
 * glPointParameterx(GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glPointParameterx))(GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glPointParameterx) orig_func;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glPointParameterx);

static void
GL_TH_CB(glPointParameterx)(void *data)
{
   GL_TH_ST(glPointParameterx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPointParameterx))thread_data->orig_func)
      (thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glPointParameterx)(GL_TH_DP, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPointParameterx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPointParameterx))orig_func)
           (pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPointParameterx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPointParameterx),
                              thread_mode);
}

/*
 * void
 * glPointParameterxv(GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glPointParameterxv))(GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glPointParameterxv) orig_func;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glPointParameterxv);

static void
GL_TH_CB(glPointParameterxv)(void *data)
{
   GL_TH_ST(glPointParameterxv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPointParameterxv))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glPointParameterxv)(GL_TH_DP, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPointParameterxv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPointParameterxv))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPointParameterxv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPointParameterxv),
                              thread_mode);
}

/*
 * void
 * glPointSizex(GLfixed size);
 */

typedef void(*GL_TH_FNTYPE(glPointSizex))(GLfixed size);

typedef struct
{
   GL_TH_FNTYPE(glPointSizex) orig_func;
   GLfixed size;

} GL_TH_ST(glPointSizex);

static void
GL_TH_CB(glPointSizex)(void *data)
{
   GL_TH_ST(glPointSizex) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPointSizex))thread_data->orig_func)
      (thread_data->size);

}

void
GL_TH_FN(glPointSizex)(GL_TH_DP, GLfixed size)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPointSizex) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPointSizex))orig_func)
           (size);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPointSizex) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->size = size;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPointSizex),
                              thread_mode);
}

/*
 * void
 * glPolygonOffsetx(GLfixed factor, GLfixed units);
 */

typedef void(*GL_TH_FNTYPE(glPolygonOffsetx))(GLfixed factor, GLfixed units);

typedef struct
{
   GL_TH_FNTYPE(glPolygonOffsetx) orig_func;
   GLfixed factor;
   GLfixed units;

} GL_TH_ST(glPolygonOffsetx);

static void
GL_TH_CB(glPolygonOffsetx)(void *data)
{
   GL_TH_ST(glPolygonOffsetx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPolygonOffsetx))thread_data->orig_func)
      (thread_data->factor,
       thread_data->units);

}

void
GL_TH_FN(glPolygonOffsetx)(GL_TH_DP, GLfixed factor, GLfixed units)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPolygonOffsetx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPolygonOffsetx))orig_func)
           (factor, units);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPolygonOffsetx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->factor = factor;
   thread_data->units = units;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPolygonOffsetx),
                              thread_mode);
}

/*
 * void
 * glPopMatrix(void);
 */

typedef void(*GL_TH_FNTYPE(glPopMatrix))(void);

typedef struct
{
   GL_TH_FNTYPE(glPopMatrix) orig_func;

} GL_TH_ST(glPopMatrix);

static void
GL_TH_CB(glPopMatrix)(void *data)
{
   GL_TH_ST(glPopMatrix) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPopMatrix))thread_data->orig_func)
      ();

}

void
GL_TH_FN(glPopMatrix)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPopMatrix) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPopMatrix))orig_func)
           ();
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPopMatrix) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPopMatrix),
                              thread_mode);
}

/*
 * void
 * glPushMatrix(void);
 */

typedef void(*GL_TH_FNTYPE(glPushMatrix))(void);

typedef struct
{
   GL_TH_FNTYPE(glPushMatrix) orig_func;

} GL_TH_ST(glPushMatrix);

static void
GL_TH_CB(glPushMatrix)(void *data)
{
   GL_TH_ST(glPushMatrix) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPushMatrix))thread_data->orig_func)
      ();

}

void
GL_TH_FN(glPushMatrix)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPushMatrix) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPushMatrix))orig_func)
           ();
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPushMatrix) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPushMatrix),
                              thread_mode);
}

/*
 * void
 * glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
 */

typedef void(*GL_TH_FNTYPE(glRotatex))(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);

typedef struct
{
   GL_TH_FNTYPE(glRotatex) orig_func;
   GLfixed angle;
   GLfixed x;
   GLfixed y;
   GLfixed z;

} GL_TH_ST(glRotatex);

static void
GL_TH_CB(glRotatex)(void *data)
{
   GL_TH_ST(glRotatex) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glRotatex))thread_data->orig_func)
      (thread_data->angle,
       thread_data->x,
       thread_data->y,
       thread_data->z);

}

void
GL_TH_FN(glRotatex)(GL_TH_DP, GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glRotatex) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glRotatex))orig_func)
           (angle, x, y, z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glRotatex) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->angle = angle;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glRotatex),
                              thread_mode);
}

/*
 * void
 * glSampleCoveragex(GLclampx value, GLboolean invert);
 */

typedef void(*GL_TH_FNTYPE(glSampleCoveragex))(GLclampx value, GLboolean invert);

typedef struct
{
   GL_TH_FNTYPE(glSampleCoveragex) orig_func;
   GLclampx value;
   GLboolean invert;

} GL_TH_ST(glSampleCoveragex);

static void
GL_TH_CB(glSampleCoveragex)(void *data)
{
   GL_TH_ST(glSampleCoveragex) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glSampleCoveragex))thread_data->orig_func)
      (thread_data->value,
       thread_data->invert);

}

void
GL_TH_FN(glSampleCoveragex)(GL_TH_DP, GLclampx value, GLboolean invert)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glSampleCoveragex) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glSampleCoveragex))orig_func)
           (value, invert);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glSampleCoveragex) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->value = value;
   thread_data->invert = invert;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glSampleCoveragex),
                              thread_mode);
}

/*
 * void
 * glScalex(GLfixed x, GLfixed y, GLfixed z);
 */

typedef void(*GL_TH_FNTYPE(glScalex))(GLfixed x, GLfixed y, GLfixed z);

typedef struct
{
   GL_TH_FNTYPE(glScalex) orig_func;
   GLfixed x;
   GLfixed y;
   GLfixed z;

} GL_TH_ST(glScalex);

static void
GL_TH_CB(glScalex)(void *data)
{
   GL_TH_ST(glScalex) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glScalex))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->z);

}

void
GL_TH_FN(glScalex)(GL_TH_DP, GLfixed x, GLfixed y, GLfixed z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glScalex) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glScalex))orig_func)
           (x, y, z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glScalex) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glScalex),
                              thread_mode);
}

/*
 * void
 * glShadeModel(GLenum mode);
 */

typedef void(*GL_TH_FNTYPE(glShadeModel))(GLenum mode);

typedef struct
{
   GL_TH_FNTYPE(glShadeModel) orig_func;
   GLenum mode;

} GL_TH_ST(glShadeModel);

static void
GL_TH_CB(glShadeModel)(void *data)
{
   GL_TH_ST(glShadeModel) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glShadeModel))thread_data->orig_func)
      (thread_data->mode);

}

void
GL_TH_FN(glShadeModel)(GL_TH_DP, GLenum mode)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glShadeModel) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glShadeModel))orig_func)
           (mode);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glShadeModel) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glShadeModel),
                              thread_mode);
}

/*
 * void
 * glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
 */

typedef void(*GL_TH_FNTYPE(glTexCoordPointer))(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

typedef struct
{
   GL_TH_FNTYPE(glTexCoordPointer) orig_func;
   GLint size;
   GLenum type;
   GLsizei stride;
   const GLvoid *pointer;

} GL_TH_ST(glTexCoordPointer);

static void
GL_TH_CB(glTexCoordPointer)(void *data)
{
   GL_TH_ST(glTexCoordPointer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexCoordPointer))thread_data->orig_func)
      (thread_data->size,
       thread_data->type,
       thread_data->stride,
       thread_data->pointer);

}

void
GL_TH_FN(glTexCoordPointer)(GL_TH_DP, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexCoordPointer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexCoordPointer))orig_func)
           (size, type, stride, pointer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexCoordPointer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->size = size;
   thread_data->type = type;
   thread_data->stride = stride;
   thread_data->pointer = pointer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexCoordPointer),
                              thread_mode);
}

/*
 * void
 * glTexEnvi(GLenum target, GLenum pname, GLint param);
 */

typedef void(*GL_TH_FNTYPE(glTexEnvi))(GLenum target, GLenum pname, GLint param);

typedef struct
{
   GL_TH_FNTYPE(glTexEnvi) orig_func;
   GLenum target;
   GLenum pname;
   GLint param;

} GL_TH_ST(glTexEnvi);

static void
GL_TH_CB(glTexEnvi)(void *data)
{
   GL_TH_ST(glTexEnvi) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexEnvi))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glTexEnvi)(GL_TH_DP, GLenum target, GLenum pname, GLint param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexEnvi) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexEnvi))orig_func)
           (target, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexEnvi) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexEnvi),
                              thread_mode);
}

/*
 * void
 * glTexEnvx(GLenum target, GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glTexEnvx))(GLenum target, GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glTexEnvx) orig_func;
   GLenum target;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glTexEnvx);

static void
GL_TH_CB(glTexEnvx)(void *data)
{
   GL_TH_ST(glTexEnvx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexEnvx))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glTexEnvx)(GL_TH_DP, GLenum target, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexEnvx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexEnvx))orig_func)
           (target, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexEnvx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexEnvx),
                              thread_mode);
}

/*
 * void
 * glTexEnviv(GLenum target, GLenum pname, const GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glTexEnviv))(GLenum target, GLenum pname, const GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glTexEnviv) orig_func;
   GLenum target;
   GLenum pname;
   const GLint *params;

} GL_TH_ST(glTexEnviv);

static void
GL_TH_CB(glTexEnviv)(void *data)
{
   GL_TH_ST(glTexEnviv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexEnviv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glTexEnviv)(GL_TH_DP, GLenum target, GLenum pname, const GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexEnviv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexEnviv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexEnviv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexEnviv),
                              thread_mode);
}

/*
 * void
 * glTexEnvxv(GLenum target, GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glTexEnvxv))(GLenum target, GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glTexEnvxv) orig_func;
   GLenum target;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glTexEnvxv);

static void
GL_TH_CB(glTexEnvxv)(void *data)
{
   GL_TH_ST(glTexEnvxv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexEnvxv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glTexEnvxv)(GL_TH_DP, GLenum target, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexEnvxv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexEnvxv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexEnvxv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexEnvxv),
                              thread_mode);
}

/*
 * void
 * glTexParameterx(GLenum target, GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glTexParameterx))(GLenum target, GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glTexParameterx) orig_func;
   GLenum target;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glTexParameterx);

static void
GL_TH_CB(glTexParameterx)(void *data)
{
   GL_TH_ST(glTexParameterx) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexParameterx))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glTexParameterx)(GL_TH_DP, GLenum target, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexParameterx) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexParameterx))orig_func)
           (target, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexParameterx) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexParameterx),
                              thread_mode);
}

/*
 * void
 * glTexParameterxv(GLenum target, GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glTexParameterxv))(GLenum target, GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glTexParameterxv) orig_func;
   GLenum target;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glTexParameterxv);

static void
GL_TH_CB(glTexParameterxv)(void *data)
{
   GL_TH_ST(glTexParameterxv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexParameterxv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glTexParameterxv)(GL_TH_DP, GLenum target, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexParameterxv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexParameterxv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexParameterxv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexParameterxv),
                              thread_mode);
}

/*
 * void
 * glTranslatex(GLfixed x, GLfixed y, GLfixed z);
 */

typedef void(*GL_TH_FNTYPE(glTranslatex))(GLfixed x, GLfixed y, GLfixed z);

typedef struct
{
   GL_TH_FNTYPE(glTranslatex) orig_func;
   GLfixed x;
   GLfixed y;
   GLfixed z;

} GL_TH_ST(glTranslatex);

static void
GL_TH_CB(glTranslatex)(void *data)
{
   GL_TH_ST(glTranslatex) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTranslatex))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->z);

}

void
GL_TH_FN(glTranslatex)(GL_TH_DP, GLfixed x, GLfixed y, GLfixed z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTranslatex) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTranslatex))orig_func)
           (x, y, z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTranslatex) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTranslatex),
                              thread_mode);
}

/*
 * void
 * glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
 */

typedef void(*GL_TH_FNTYPE(glVertexPointer))(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

typedef struct
{
   GL_TH_FNTYPE(glVertexPointer) orig_func;
   GLint size;
   GLenum type;
   GLsizei stride;
   const GLvoid *pointer;

} GL_TH_ST(glVertexPointer);

static void
GL_TH_CB(glVertexPointer)(void *data)
{
   GL_TH_ST(glVertexPointer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexPointer))thread_data->orig_func)
      (thread_data->size,
       thread_data->type,
       thread_data->stride,
       thread_data->pointer);

}

void
GL_TH_FN(glVertexPointer)(GL_TH_DP, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexPointer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexPointer))orig_func)
           (size, type, stride, pointer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexPointer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->size = size;
   thread_data->type = type;
   thread_data->stride = stride;
   thread_data->pointer = pointer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexPointer),
                              thread_mode);
}

/*
 * void
 * glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha);
 */

typedef void(*GL_TH_FNTYPE(glBlendEquationSeparateOES))(GLenum modeRGB, GLenum modeAlpha);

typedef struct
{
   GL_TH_FNTYPE(glBlendEquationSeparateOES) orig_func;
   GLenum modeRGB;
   GLenum modeAlpha;

} GL_TH_ST(glBlendEquationSeparateOES);

static void
GL_TH_CB(glBlendEquationSeparateOES)(void *data)
{
   GL_TH_ST(glBlendEquationSeparateOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBlendEquationSeparateOES))thread_data->orig_func)
      (thread_data->modeRGB,
       thread_data->modeAlpha);

}

void
GL_TH_FN(glBlendEquationSeparateOES)(GL_TH_DP, GLenum modeRGB, GLenum modeAlpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBlendEquationSeparateOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBlendEquationSeparateOES))orig_func)
           (modeRGB, modeAlpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBlendEquationSeparateOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->modeRGB = modeRGB;
   thread_data->modeAlpha = modeAlpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBlendEquationSeparateOES),
                              thread_mode);
}

/*
 * void
 * glBlendFuncSeparateOES(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
 */

typedef void(*GL_TH_FNTYPE(glBlendFuncSeparateOES))(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);

typedef struct
{
   GL_TH_FNTYPE(glBlendFuncSeparateOES) orig_func;
   GLenum srcRGB;
   GLenum dstRGB;
   GLenum srcAlpha;
   GLenum dstAlpha;

} GL_TH_ST(glBlendFuncSeparateOES);

static void
GL_TH_CB(glBlendFuncSeparateOES)(void *data)
{
   GL_TH_ST(glBlendFuncSeparateOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBlendFuncSeparateOES))thread_data->orig_func)
      (thread_data->srcRGB,
       thread_data->dstRGB,
       thread_data->srcAlpha,
       thread_data->dstAlpha);

}

void
GL_TH_FN(glBlendFuncSeparateOES)(GL_TH_DP, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBlendFuncSeparateOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBlendFuncSeparateOES))orig_func)
           (srcRGB, dstRGB, srcAlpha, dstAlpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBlendFuncSeparateOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->srcRGB = srcRGB;
   thread_data->dstRGB = dstRGB;
   thread_data->srcAlpha = srcAlpha;
   thread_data->dstAlpha = dstAlpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBlendFuncSeparateOES),
                              thread_mode);
}

/*
 * void
 * glBlendEquationOES(GLenum mode);
 */

typedef void(*GL_TH_FNTYPE(glBlendEquationOES))(GLenum mode);

typedef struct
{
   GL_TH_FNTYPE(glBlendEquationOES) orig_func;
   GLenum mode;

} GL_TH_ST(glBlendEquationOES);

static void
GL_TH_CB(glBlendEquationOES)(void *data)
{
   GL_TH_ST(glBlendEquationOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBlendEquationOES))thread_data->orig_func)
      (thread_data->mode);

}

void
GL_TH_FN(glBlendEquationOES)(GL_TH_DP, GLenum mode)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBlendEquationOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBlendEquationOES))orig_func)
           (mode);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBlendEquationOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBlendEquationOES),
                              thread_mode);
}

/*
 * void
 * glDrawTexsOES(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height);
 */

typedef void(*GL_TH_FNTYPE(glDrawTexsOES))(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height);

typedef struct
{
   GL_TH_FNTYPE(glDrawTexsOES) orig_func;
   GLshort x;
   GLshort y;
   GLshort z;
   GLshort width;
   GLshort height;

} GL_TH_ST(glDrawTexsOES);

static void
GL_TH_CB(glDrawTexsOES)(void *data)
{
   GL_TH_ST(glDrawTexsOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawTexsOES))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->z,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glDrawTexsOES)(GL_TH_DP, GLshort x, GLshort y, GLshort z, GLshort width, GLshort height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawTexsOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawTexsOES))orig_func)
           (x, y, z, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawTexsOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawTexsOES),
                              thread_mode);
}

/*
 * void
 * glDrawTexiOES(GLint x, GLint y, GLint z, GLint width, GLint height);
 */

typedef void(*GL_TH_FNTYPE(glDrawTexiOES))(GLint x, GLint y, GLint z, GLint width, GLint height);

typedef struct
{
   GL_TH_FNTYPE(glDrawTexiOES) orig_func;
   GLint x;
   GLint y;
   GLint z;
   GLint width;
   GLint height;

} GL_TH_ST(glDrawTexiOES);

static void
GL_TH_CB(glDrawTexiOES)(void *data)
{
   GL_TH_ST(glDrawTexiOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawTexiOES))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->z,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glDrawTexiOES)(GL_TH_DP, GLint x, GLint y, GLint z, GLint width, GLint height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawTexiOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawTexiOES))orig_func)
           (x, y, z, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawTexiOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawTexiOES),
                              thread_mode);
}

/*
 * void
 * glDrawTexxOES(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height);
 */

typedef void(*GL_TH_FNTYPE(glDrawTexxOES))(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height);

typedef struct
{
   GL_TH_FNTYPE(glDrawTexxOES) orig_func;
   GLfixed x;
   GLfixed y;
   GLfixed z;
   GLfixed width;
   GLfixed height;

} GL_TH_ST(glDrawTexxOES);

static void
GL_TH_CB(glDrawTexxOES)(void *data)
{
   GL_TH_ST(glDrawTexxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawTexxOES))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->z,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glDrawTexxOES)(GL_TH_DP, GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawTexxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawTexxOES))orig_func)
           (x, y, z, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawTexxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawTexxOES),
                              thread_mode);
}

/*
 * void
 * glDrawTexsvOES(const GLshort *coords);
 */

typedef void(*GL_TH_FNTYPE(glDrawTexsvOES))(const GLshort *coords);

typedef struct
{
   GL_TH_FNTYPE(glDrawTexsvOES) orig_func;
   const GLshort *coords;

} GL_TH_ST(glDrawTexsvOES);

static void
GL_TH_CB(glDrawTexsvOES)(void *data)
{
   GL_TH_ST(glDrawTexsvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawTexsvOES))thread_data->orig_func)
      (thread_data->coords);

}

void
GL_TH_FN(glDrawTexsvOES)(GL_TH_DP, const GLshort *coords)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawTexsvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawTexsvOES))orig_func)
           (coords);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawTexsvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coords = coords;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawTexsvOES),
                              thread_mode);
}

/*
 * void
 * glDrawTexivOES(const GLint *coords);
 */

typedef void(*GL_TH_FNTYPE(glDrawTexivOES))(const GLint *coords);

typedef struct
{
   GL_TH_FNTYPE(glDrawTexivOES) orig_func;
   const GLint *coords;

} GL_TH_ST(glDrawTexivOES);

static void
GL_TH_CB(glDrawTexivOES)(void *data)
{
   GL_TH_ST(glDrawTexivOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawTexivOES))thread_data->orig_func)
      (thread_data->coords);

}

void
GL_TH_FN(glDrawTexivOES)(GL_TH_DP, const GLint *coords)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawTexivOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawTexivOES))orig_func)
           (coords);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawTexivOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coords = coords;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawTexivOES),
                              thread_mode);
}

/*
 * void
 * glDrawTexxvOES(const GLfixed *coords);
 */

typedef void(*GL_TH_FNTYPE(glDrawTexxvOES))(const GLfixed *coords);

typedef struct
{
   GL_TH_FNTYPE(glDrawTexxvOES) orig_func;
   const GLfixed *coords;

} GL_TH_ST(glDrawTexxvOES);

static void
GL_TH_CB(glDrawTexxvOES)(void *data)
{
   GL_TH_ST(glDrawTexxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawTexxvOES))thread_data->orig_func)
      (thread_data->coords);

}

void
GL_TH_FN(glDrawTexxvOES)(GL_TH_DP, const GLfixed *coords)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawTexxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawTexxvOES))orig_func)
           (coords);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawTexxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coords = coords;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawTexxvOES),
                              thread_mode);
}

/*
 * void
 * glDrawTexfOES(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height);
 */

typedef void(*GL_TH_FNTYPE(glDrawTexfOES))(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height);

typedef struct
{
   GL_TH_FNTYPE(glDrawTexfOES) orig_func;
   GLfloat x;
   GLfloat y;
   GLfloat z;
   GLfloat width;
   GLfloat height;

} GL_TH_ST(glDrawTexfOES);

static void
GL_TH_CB(glDrawTexfOES)(void *data)
{
   GL_TH_ST(glDrawTexfOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawTexfOES))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->z,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glDrawTexfOES)(GL_TH_DP, GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawTexfOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawTexfOES))orig_func)
           (x, y, z, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawTexfOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawTexfOES),
                              thread_mode);
}

/*
 * void
 * glDrawTexfvOES(const GLfloat *coords);
 */

typedef void(*GL_TH_FNTYPE(glDrawTexfvOES))(const GLfloat *coords);

typedef struct
{
   GL_TH_FNTYPE(glDrawTexfvOES) orig_func;
   const GLfloat *coords;

} GL_TH_ST(glDrawTexfvOES);

static void
GL_TH_CB(glDrawTexfvOES)(void *data)
{
   GL_TH_ST(glDrawTexfvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawTexfvOES))thread_data->orig_func)
      (thread_data->coords);

}

void
GL_TH_FN(glDrawTexfvOES)(GL_TH_DP, const GLfloat *coords)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawTexfvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawTexfvOES))orig_func)
           (coords);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawTexfvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coords = coords;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawTexfvOES),
                              thread_mode);
}

/*
 * void
 * glAlphaFuncxOES(GLenum func, GLclampx ref);
 */

typedef void(*GL_TH_FNTYPE(glAlphaFuncxOES))(GLenum func, GLclampx ref);

typedef struct
{
   GL_TH_FNTYPE(glAlphaFuncxOES) orig_func;
   GLenum func;
   GLclampx ref;

} GL_TH_ST(glAlphaFuncxOES);

static void
GL_TH_CB(glAlphaFuncxOES)(void *data)
{
   GL_TH_ST(glAlphaFuncxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glAlphaFuncxOES))thread_data->orig_func)
      (thread_data->func,
       thread_data->ref);

}

void
GL_TH_FN(glAlphaFuncxOES)(GL_TH_DP, GLenum func, GLclampx ref)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glAlphaFuncxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glAlphaFuncxOES))orig_func)
           (func, ref);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glAlphaFuncxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->func = func;
   thread_data->ref = ref;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glAlphaFuncxOES),
                              thread_mode);
}

/*
 * void
 * glClearColorxOES(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
 */

typedef void(*GL_TH_FNTYPE(glClearColorxOES))(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);

typedef struct
{
   GL_TH_FNTYPE(glClearColorxOES) orig_func;
   GLclampx red;
   GLclampx green;
   GLclampx blue;
   GLclampx alpha;

} GL_TH_ST(glClearColorxOES);

static void
GL_TH_CB(glClearColorxOES)(void *data)
{
   GL_TH_ST(glClearColorxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClearColorxOES))thread_data->orig_func)
      (thread_data->red,
       thread_data->green,
       thread_data->blue,
       thread_data->alpha);

}

void
GL_TH_FN(glClearColorxOES)(GL_TH_DP, GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClearColorxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClearColorxOES))orig_func)
           (red, green, blue, alpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClearColorxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->red = red;
   thread_data->green = green;
   thread_data->blue = blue;
   thread_data->alpha = alpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClearColorxOES),
                              thread_mode);
}

/*
 * void
 * glClearDepthxOES(GLclampx depth);
 */

typedef void(*GL_TH_FNTYPE(glClearDepthxOES))(GLclampx depth);

typedef struct
{
   GL_TH_FNTYPE(glClearDepthxOES) orig_func;
   GLclampx depth;

} GL_TH_ST(glClearDepthxOES);

static void
GL_TH_CB(glClearDepthxOES)(void *data)
{
   GL_TH_ST(glClearDepthxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClearDepthxOES))thread_data->orig_func)
      (thread_data->depth);

}

void
GL_TH_FN(glClearDepthxOES)(GL_TH_DP, GLclampx depth)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClearDepthxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClearDepthxOES))orig_func)
           (depth);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClearDepthxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->depth = depth;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClearDepthxOES),
                              thread_mode);
}

/*
 * void
 * glClipPlanexOES(GLenum plane, const GLfixed *equation);
 */

typedef void(*GL_TH_FNTYPE(glClipPlanexOES))(GLenum plane, const GLfixed *equation);

typedef struct
{
   GL_TH_FNTYPE(glClipPlanexOES) orig_func;
   GLenum plane;
   const GLfixed *equation;

} GL_TH_ST(glClipPlanexOES);

static void
GL_TH_CB(glClipPlanexOES)(void *data)
{
   GL_TH_ST(glClipPlanexOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClipPlanexOES))thread_data->orig_func)
      (thread_data->plane,
       thread_data->equation);

}

void
GL_TH_FN(glClipPlanexOES)(GL_TH_DP, GLenum plane, const GLfixed *equation)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClipPlanexOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClipPlanexOES))orig_func)
           (plane, equation);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClipPlanexOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->plane = plane;
   thread_data->equation = equation;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClipPlanexOES),
                              thread_mode);
}

/*
 * void
 * glColor4xOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
 */

typedef void(*GL_TH_FNTYPE(glColor4xOES))(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);

typedef struct
{
   GL_TH_FNTYPE(glColor4xOES) orig_func;
   GLfixed red;
   GLfixed green;
   GLfixed blue;
   GLfixed alpha;

} GL_TH_ST(glColor4xOES);

static void
GL_TH_CB(glColor4xOES)(void *data)
{
   GL_TH_ST(glColor4xOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glColor4xOES))thread_data->orig_func)
      (thread_data->red,
       thread_data->green,
       thread_data->blue,
       thread_data->alpha);

}

void
GL_TH_FN(glColor4xOES)(GL_TH_DP, GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glColor4xOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glColor4xOES))orig_func)
           (red, green, blue, alpha);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glColor4xOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->red = red;
   thread_data->green = green;
   thread_data->blue = blue;
   thread_data->alpha = alpha;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glColor4xOES),
                              thread_mode);
}

/*
 * void
 * glDepthRangexOES(GLclampx zNear, GLclampx zFar);
 */

typedef void(*GL_TH_FNTYPE(glDepthRangexOES))(GLclampx zNear, GLclampx zFar);

typedef struct
{
   GL_TH_FNTYPE(glDepthRangexOES) orig_func;
   GLclampx zNear;
   GLclampx zFar;

} GL_TH_ST(glDepthRangexOES);

static void
GL_TH_CB(glDepthRangexOES)(void *data)
{
   GL_TH_ST(glDepthRangexOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDepthRangexOES))thread_data->orig_func)
      (thread_data->zNear,
       thread_data->zFar);

}

void
GL_TH_FN(glDepthRangexOES)(GL_TH_DP, GLclampx zNear, GLclampx zFar)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDepthRangexOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDepthRangexOES))orig_func)
           (zNear, zFar);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDepthRangexOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->zNear = zNear;
   thread_data->zFar = zFar;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDepthRangexOES),
                              thread_mode);
}

/*
 * void
 * glFogxOES(GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glFogxOES))(GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glFogxOES) orig_func;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glFogxOES);

static void
GL_TH_CB(glFogxOES)(void *data)
{
   GL_TH_ST(glFogxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFogxOES))thread_data->orig_func)
      (thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glFogxOES)(GL_TH_DP, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFogxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFogxOES))orig_func)
           (pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFogxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFogxOES),
                              thread_mode);
}

/*
 * void
 * glFogxvOES(GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glFogxvOES))(GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glFogxvOES) orig_func;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glFogxvOES);

static void
GL_TH_CB(glFogxvOES)(void *data)
{
   GL_TH_ST(glFogxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFogxvOES))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glFogxvOES)(GL_TH_DP, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFogxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFogxvOES))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFogxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFogxvOES),
                              thread_mode);
}

/*
 * void
 * glFrustumxOES(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
 */

typedef void(*GL_TH_FNTYPE(glFrustumxOES))(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);

typedef struct
{
   GL_TH_FNTYPE(glFrustumxOES) orig_func;
   GLfixed left;
   GLfixed right;
   GLfixed bottom;
   GLfixed top;
   GLfixed zNear;
   GLfixed zFar;

} GL_TH_ST(glFrustumxOES);

static void
GL_TH_CB(glFrustumxOES)(void *data)
{
   GL_TH_ST(glFrustumxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFrustumxOES))thread_data->orig_func)
      (thread_data->left,
       thread_data->right,
       thread_data->bottom,
       thread_data->top,
       thread_data->zNear,
       thread_data->zFar);

}

void
GL_TH_FN(glFrustumxOES)(GL_TH_DP, GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFrustumxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFrustumxOES))orig_func)
           (left, right, bottom, top, zNear, zFar);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFrustumxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->left = left;
   thread_data->right = right;
   thread_data->bottom = bottom;
   thread_data->top = top;
   thread_data->zNear = zNear;
   thread_data->zFar = zFar;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFrustumxOES),
                              thread_mode);
}

/*
 * void
 * glGetClipPlanexOES(GLenum pname, GLfixed eqn[4]);
 */

typedef void(*GL_TH_FNTYPE(glGetClipPlanexOES))(GLenum pname, GLfixed eqn[4]);

typedef struct
{
   GL_TH_FNTYPE(glGetClipPlanexOES) orig_func;
   GLenum pname;
   GLfixed eqn[4];

} GL_TH_ST(glGetClipPlanexOES);

static void
GL_TH_CB(glGetClipPlanexOES)(void *data)
{
   GL_TH_ST(glGetClipPlanexOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetClipPlanexOES))thread_data->orig_func)
      (thread_data->pname,
       thread_data->eqn);

}

void
GL_TH_FN(glGetClipPlanexOES)(GL_TH_DP, GLenum pname, GLfixed eqn[4])
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetClipPlanexOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetClipPlanexOES))orig_func)
           (pname, eqn);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetClipPlanexOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   memcpy(thread_data->eqn, &eqn, sizeof(GLfixed) * 4);
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetClipPlanexOES),
                              thread_mode);
}

/*
 * void
 * glGetFixedvOES(GLenum pname, GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glGetFixedvOES))(GLenum pname, GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glGetFixedvOES) orig_func;
   GLenum pname;
   GLfixed *params;

} GL_TH_ST(glGetFixedvOES);

static void
GL_TH_CB(glGetFixedvOES)(void *data)
{
   GL_TH_ST(glGetFixedvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetFixedvOES))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetFixedvOES)(GL_TH_DP, GLenum pname, GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetFixedvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetFixedvOES))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetFixedvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetFixedvOES),
                              thread_mode);
}

/*
 * void
 * glGetLightxvOES(GLenum light, GLenum pname, GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glGetLightxvOES))(GLenum light, GLenum pname, GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glGetLightxvOES) orig_func;
   GLenum light;
   GLenum pname;
   GLfixed *params;

} GL_TH_ST(glGetLightxvOES);

static void
GL_TH_CB(glGetLightxvOES)(void *data)
{
   GL_TH_ST(glGetLightxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetLightxvOES))thread_data->orig_func)
      (thread_data->light,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetLightxvOES)(GL_TH_DP, GLenum light, GLenum pname, GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetLightxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetLightxvOES))orig_func)
           (light, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetLightxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->light = light;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetLightxvOES),
                              thread_mode);
}

/*
 * void
 * glGetMaterialxvOES(GLenum face, GLenum pname, GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glGetMaterialxvOES))(GLenum face, GLenum pname, GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glGetMaterialxvOES) orig_func;
   GLenum face;
   GLenum pname;
   GLfixed *params;

} GL_TH_ST(glGetMaterialxvOES);

static void
GL_TH_CB(glGetMaterialxvOES)(void *data)
{
   GL_TH_ST(glGetMaterialxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetMaterialxvOES))thread_data->orig_func)
      (thread_data->face,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetMaterialxvOES)(GL_TH_DP, GLenum face, GLenum pname, GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetMaterialxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetMaterialxvOES))orig_func)
           (face, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetMaterialxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->face = face;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetMaterialxvOES),
                              thread_mode);
}

/*
 * void
 * glGetTexEnvxvOES(GLenum env, GLenum pname, GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexEnvxvOES))(GLenum env, GLenum pname, GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexEnvxvOES) orig_func;
   GLenum env;
   GLenum pname;
   GLfixed *params;

} GL_TH_ST(glGetTexEnvxvOES);

static void
GL_TH_CB(glGetTexEnvxvOES)(void *data)
{
   GL_TH_ST(glGetTexEnvxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexEnvxvOES))thread_data->orig_func)
      (thread_data->env,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexEnvxvOES)(GL_TH_DP, GLenum env, GLenum pname, GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexEnvxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexEnvxvOES))orig_func)
           (env, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexEnvxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->env = env;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexEnvxvOES),
                              thread_mode);
}

/*
 * void
 * glGetTexParameterxvOES(GLenum target, GLenum pname, GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexParameterxvOES))(GLenum target, GLenum pname, GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexParameterxvOES) orig_func;
   GLenum target;
   GLenum pname;
   GLfixed *params;

} GL_TH_ST(glGetTexParameterxvOES);

static void
GL_TH_CB(glGetTexParameterxvOES)(void *data)
{
   GL_TH_ST(glGetTexParameterxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexParameterxvOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexParameterxvOES)(GL_TH_DP, GLenum target, GLenum pname, GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexParameterxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexParameterxvOES))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexParameterxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexParameterxvOES),
                              thread_mode);
}

/*
 * void
 * glLightModelxOES(GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glLightModelxOES))(GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glLightModelxOES) orig_func;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glLightModelxOES);

static void
GL_TH_CB(glLightModelxOES)(void *data)
{
   GL_TH_ST(glLightModelxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLightModelxOES))thread_data->orig_func)
      (thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glLightModelxOES)(GL_TH_DP, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLightModelxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLightModelxOES))orig_func)
           (pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLightModelxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLightModelxOES),
                              thread_mode);
}

/*
 * void
 * glLightModelxvOES(GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glLightModelxvOES))(GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glLightModelxvOES) orig_func;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glLightModelxvOES);

static void
GL_TH_CB(glLightModelxvOES)(void *data)
{
   GL_TH_ST(glLightModelxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLightModelxvOES))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glLightModelxvOES)(GL_TH_DP, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLightModelxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLightModelxvOES))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLightModelxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLightModelxvOES),
                              thread_mode);
}

/*
 * void
 * glLightxOES(GLenum light, GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glLightxOES))(GLenum light, GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glLightxOES) orig_func;
   GLenum light;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glLightxOES);

static void
GL_TH_CB(glLightxOES)(void *data)
{
   GL_TH_ST(glLightxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLightxOES))thread_data->orig_func)
      (thread_data->light,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glLightxOES)(GL_TH_DP, GLenum light, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLightxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLightxOES))orig_func)
           (light, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLightxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->light = light;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLightxOES),
                              thread_mode);
}

/*
 * void
 * glLightxvOES(GLenum light, GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glLightxvOES))(GLenum light, GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glLightxvOES) orig_func;
   GLenum light;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glLightxvOES);

static void
GL_TH_CB(glLightxvOES)(void *data)
{
   GL_TH_ST(glLightxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLightxvOES))thread_data->orig_func)
      (thread_data->light,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glLightxvOES)(GL_TH_DP, GLenum light, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLightxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLightxvOES))orig_func)
           (light, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLightxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->light = light;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLightxvOES),
                              thread_mode);
}

/*
 * void
 * glLineWidthxOES(GLfixed width);
 */

typedef void(*GL_TH_FNTYPE(glLineWidthxOES))(GLfixed width);

typedef struct
{
   GL_TH_FNTYPE(glLineWidthxOES) orig_func;
   GLfixed width;

} GL_TH_ST(glLineWidthxOES);

static void
GL_TH_CB(glLineWidthxOES)(void *data)
{
   GL_TH_ST(glLineWidthxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLineWidthxOES))thread_data->orig_func)
      (thread_data->width);

}

void
GL_TH_FN(glLineWidthxOES)(GL_TH_DP, GLfixed width)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLineWidthxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLineWidthxOES))orig_func)
           (width);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLineWidthxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->width = width;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLineWidthxOES),
                              thread_mode);
}

/*
 * void
 * glLoadMatrixxOES(const GLfixed *m);
 */

typedef void(*GL_TH_FNTYPE(glLoadMatrixxOES))(const GLfixed *m);

typedef struct
{
   GL_TH_FNTYPE(glLoadMatrixxOES) orig_func;
   const GLfixed *m;

} GL_TH_ST(glLoadMatrixxOES);

static void
GL_TH_CB(glLoadMatrixxOES)(void *data)
{
   GL_TH_ST(glLoadMatrixxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLoadMatrixxOES))thread_data->orig_func)
      (thread_data->m);

}

void
GL_TH_FN(glLoadMatrixxOES)(GL_TH_DP, const GLfixed *m)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLoadMatrixxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLoadMatrixxOES))orig_func)
           (m);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLoadMatrixxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->m = m;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLoadMatrixxOES),
                              thread_mode);
}

/*
 * void
 * glMaterialxOES(GLenum face, GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glMaterialxOES))(GLenum face, GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glMaterialxOES) orig_func;
   GLenum face;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glMaterialxOES);

static void
GL_TH_CB(glMaterialxOES)(void *data)
{
   GL_TH_ST(glMaterialxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMaterialxOES))thread_data->orig_func)
      (thread_data->face,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glMaterialxOES)(GL_TH_DP, GLenum face, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMaterialxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMaterialxOES))orig_func)
           (face, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMaterialxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->face = face;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMaterialxOES),
                              thread_mode);
}

/*
 * void
 * glMaterialxvOES(GLenum face, GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glMaterialxvOES))(GLenum face, GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glMaterialxvOES) orig_func;
   GLenum face;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glMaterialxvOES);

static void
GL_TH_CB(glMaterialxvOES)(void *data)
{
   GL_TH_ST(glMaterialxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMaterialxvOES))thread_data->orig_func)
      (thread_data->face,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glMaterialxvOES)(GL_TH_DP, GLenum face, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMaterialxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMaterialxvOES))orig_func)
           (face, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMaterialxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->face = face;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMaterialxvOES),
                              thread_mode);
}

/*
 * void
 * glMultMatrixxOES(const GLfixed *m);
 */

typedef void(*GL_TH_FNTYPE(glMultMatrixxOES))(const GLfixed *m);

typedef struct
{
   GL_TH_FNTYPE(glMultMatrixxOES) orig_func;
   const GLfixed *m;

} GL_TH_ST(glMultMatrixxOES);

static void
GL_TH_CB(glMultMatrixxOES)(void *data)
{
   GL_TH_ST(glMultMatrixxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMultMatrixxOES))thread_data->orig_func)
      (thread_data->m);

}

void
GL_TH_FN(glMultMatrixxOES)(GL_TH_DP, const GLfixed *m)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMultMatrixxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMultMatrixxOES))orig_func)
           (m);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMultMatrixxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->m = m;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMultMatrixxOES),
                              thread_mode);
}

/*
 * void
 * glMultiTexCoord4xOES(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
 */

typedef void(*GL_TH_FNTYPE(glMultiTexCoord4xOES))(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);

typedef struct
{
   GL_TH_FNTYPE(glMultiTexCoord4xOES) orig_func;
   GLenum target;
   GLfixed s;
   GLfixed t;
   GLfixed r;
   GLfixed q;

} GL_TH_ST(glMultiTexCoord4xOES);

static void
GL_TH_CB(glMultiTexCoord4xOES)(void *data)
{
   GL_TH_ST(glMultiTexCoord4xOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMultiTexCoord4xOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->s,
       thread_data->t,
       thread_data->r,
       thread_data->q);

}

void
GL_TH_FN(glMultiTexCoord4xOES)(GL_TH_DP, GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMultiTexCoord4xOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMultiTexCoord4xOES))orig_func)
           (target, s, t, r, q);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMultiTexCoord4xOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->s = s;
   thread_data->t = t;
   thread_data->r = r;
   thread_data->q = q;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMultiTexCoord4xOES),
                              thread_mode);
}

/*
 * void
 * glNormal3xOES(GLfixed nx, GLfixed ny, GLfixed nz);
 */

typedef void(*GL_TH_FNTYPE(glNormal3xOES))(GLfixed nx, GLfixed ny, GLfixed nz);

typedef struct
{
   GL_TH_FNTYPE(glNormal3xOES) orig_func;
   GLfixed nx;
   GLfixed ny;
   GLfixed nz;

} GL_TH_ST(glNormal3xOES);

static void
GL_TH_CB(glNormal3xOES)(void *data)
{
   GL_TH_ST(glNormal3xOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glNormal3xOES))thread_data->orig_func)
      (thread_data->nx,
       thread_data->ny,
       thread_data->nz);

}

void
GL_TH_FN(glNormal3xOES)(GL_TH_DP, GLfixed nx, GLfixed ny, GLfixed nz)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glNormal3xOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glNormal3xOES))orig_func)
           (nx, ny, nz);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glNormal3xOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->nx = nx;
   thread_data->ny = ny;
   thread_data->nz = nz;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glNormal3xOES),
                              thread_mode);
}

/*
 * void
 * glOrthoxOES(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
 */

typedef void(*GL_TH_FNTYPE(glOrthoxOES))(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);

typedef struct
{
   GL_TH_FNTYPE(glOrthoxOES) orig_func;
   GLfixed left;
   GLfixed right;
   GLfixed bottom;
   GLfixed top;
   GLfixed zNear;
   GLfixed zFar;

} GL_TH_ST(glOrthoxOES);

static void
GL_TH_CB(glOrthoxOES)(void *data)
{
   GL_TH_ST(glOrthoxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glOrthoxOES))thread_data->orig_func)
      (thread_data->left,
       thread_data->right,
       thread_data->bottom,
       thread_data->top,
       thread_data->zNear,
       thread_data->zFar);

}

void
GL_TH_FN(glOrthoxOES)(GL_TH_DP, GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glOrthoxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glOrthoxOES))orig_func)
           (left, right, bottom, top, zNear, zFar);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glOrthoxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->left = left;
   thread_data->right = right;
   thread_data->bottom = bottom;
   thread_data->top = top;
   thread_data->zNear = zNear;
   thread_data->zFar = zFar;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glOrthoxOES),
                              thread_mode);
}

/*
 * void
 * glPointParameterxOES(GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glPointParameterxOES))(GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glPointParameterxOES) orig_func;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glPointParameterxOES);

static void
GL_TH_CB(glPointParameterxOES)(void *data)
{
   GL_TH_ST(glPointParameterxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPointParameterxOES))thread_data->orig_func)
      (thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glPointParameterxOES)(GL_TH_DP, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPointParameterxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPointParameterxOES))orig_func)
           (pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPointParameterxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPointParameterxOES),
                              thread_mode);
}

/*
 * void
 * glPointParameterxvOES(GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glPointParameterxvOES))(GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glPointParameterxvOES) orig_func;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glPointParameterxvOES);

static void
GL_TH_CB(glPointParameterxvOES)(void *data)
{
   GL_TH_ST(glPointParameterxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPointParameterxvOES))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glPointParameterxvOES)(GL_TH_DP, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPointParameterxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPointParameterxvOES))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPointParameterxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPointParameterxvOES),
                              thread_mode);
}

/*
 * void
 * glPointSizexOES(GLfixed size);
 */

typedef void(*GL_TH_FNTYPE(glPointSizexOES))(GLfixed size);

typedef struct
{
   GL_TH_FNTYPE(glPointSizexOES) orig_func;
   GLfixed size;

} GL_TH_ST(glPointSizexOES);

static void
GL_TH_CB(glPointSizexOES)(void *data)
{
   GL_TH_ST(glPointSizexOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPointSizexOES))thread_data->orig_func)
      (thread_data->size);

}

void
GL_TH_FN(glPointSizexOES)(GL_TH_DP, GLfixed size)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPointSizexOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPointSizexOES))orig_func)
           (size);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPointSizexOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->size = size;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPointSizexOES),
                              thread_mode);
}

/*
 * void
 * glPolygonOffsetxOES(GLfixed factor, GLfixed units);
 */

typedef void(*GL_TH_FNTYPE(glPolygonOffsetxOES))(GLfixed factor, GLfixed units);

typedef struct
{
   GL_TH_FNTYPE(glPolygonOffsetxOES) orig_func;
   GLfixed factor;
   GLfixed units;

} GL_TH_ST(glPolygonOffsetxOES);

static void
GL_TH_CB(glPolygonOffsetxOES)(void *data)
{
   GL_TH_ST(glPolygonOffsetxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPolygonOffsetxOES))thread_data->orig_func)
      (thread_data->factor,
       thread_data->units);

}

void
GL_TH_FN(glPolygonOffsetxOES)(GL_TH_DP, GLfixed factor, GLfixed units)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPolygonOffsetxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPolygonOffsetxOES))orig_func)
           (factor, units);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPolygonOffsetxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->factor = factor;
   thread_data->units = units;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPolygonOffsetxOES),
                              thread_mode);
}

/*
 * void
 * glRotatexOES(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
 */

typedef void(*GL_TH_FNTYPE(glRotatexOES))(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);

typedef struct
{
   GL_TH_FNTYPE(glRotatexOES) orig_func;
   GLfixed angle;
   GLfixed x;
   GLfixed y;
   GLfixed z;

} GL_TH_ST(glRotatexOES);

static void
GL_TH_CB(glRotatexOES)(void *data)
{
   GL_TH_ST(glRotatexOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glRotatexOES))thread_data->orig_func)
      (thread_data->angle,
       thread_data->x,
       thread_data->y,
       thread_data->z);

}

void
GL_TH_FN(glRotatexOES)(GL_TH_DP, GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glRotatexOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glRotatexOES))orig_func)
           (angle, x, y, z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glRotatexOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->angle = angle;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glRotatexOES),
                              thread_mode);
}

/*
 * void
 * glSampleCoveragexOES(GLclampx value, GLboolean invert);
 */

typedef void(*GL_TH_FNTYPE(glSampleCoveragexOES))(GLclampx value, GLboolean invert);

typedef struct
{
   GL_TH_FNTYPE(glSampleCoveragexOES) orig_func;
   GLclampx value;
   GLboolean invert;

} GL_TH_ST(glSampleCoveragexOES);

static void
GL_TH_CB(glSampleCoveragexOES)(void *data)
{
   GL_TH_ST(glSampleCoveragexOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glSampleCoveragexOES))thread_data->orig_func)
      (thread_data->value,
       thread_data->invert);

}

void
GL_TH_FN(glSampleCoveragexOES)(GL_TH_DP, GLclampx value, GLboolean invert)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glSampleCoveragexOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glSampleCoveragexOES))orig_func)
           (value, invert);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glSampleCoveragexOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->value = value;
   thread_data->invert = invert;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glSampleCoveragexOES),
                              thread_mode);
}

/*
 * void
 * glScalexOES(GLfixed x, GLfixed y, GLfixed z);
 */

typedef void(*GL_TH_FNTYPE(glScalexOES))(GLfixed x, GLfixed y, GLfixed z);

typedef struct
{
   GL_TH_FNTYPE(glScalexOES) orig_func;
   GLfixed x;
   GLfixed y;
   GLfixed z;

} GL_TH_ST(glScalexOES);

static void
GL_TH_CB(glScalexOES)(void *data)
{
   GL_TH_ST(glScalexOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glScalexOES))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->z);

}

void
GL_TH_FN(glScalexOES)(GL_TH_DP, GLfixed x, GLfixed y, GLfixed z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glScalexOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glScalexOES))orig_func)
           (x, y, z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glScalexOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glScalexOES),
                              thread_mode);
}

/*
 * void
 * glTexEnvxOES(GLenum target, GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glTexEnvxOES))(GLenum target, GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glTexEnvxOES) orig_func;
   GLenum target;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glTexEnvxOES);

static void
GL_TH_CB(glTexEnvxOES)(void *data)
{
   GL_TH_ST(glTexEnvxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexEnvxOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glTexEnvxOES)(GL_TH_DP, GLenum target, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexEnvxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexEnvxOES))orig_func)
           (target, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexEnvxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexEnvxOES),
                              thread_mode);
}

/*
 * void
 * glTexEnvxvOES(GLenum target, GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glTexEnvxvOES))(GLenum target, GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glTexEnvxvOES) orig_func;
   GLenum target;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glTexEnvxvOES);

static void
GL_TH_CB(glTexEnvxvOES)(void *data)
{
   GL_TH_ST(glTexEnvxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexEnvxvOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glTexEnvxvOES)(GL_TH_DP, GLenum target, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexEnvxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexEnvxvOES))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexEnvxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexEnvxvOES),
                              thread_mode);
}

/*
 * void
 * glTexParameterxOES(GLenum target, GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glTexParameterxOES))(GLenum target, GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glTexParameterxOES) orig_func;
   GLenum target;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glTexParameterxOES);

static void
GL_TH_CB(glTexParameterxOES)(void *data)
{
   GL_TH_ST(glTexParameterxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexParameterxOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glTexParameterxOES)(GL_TH_DP, GLenum target, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexParameterxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexParameterxOES))orig_func)
           (target, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexParameterxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexParameterxOES),
                              thread_mode);
}

/*
 * void
 * glTexParameterxvOES(GLenum target, GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glTexParameterxvOES))(GLenum target, GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glTexParameterxvOES) orig_func;
   GLenum target;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glTexParameterxvOES);

static void
GL_TH_CB(glTexParameterxvOES)(void *data)
{
   GL_TH_ST(glTexParameterxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexParameterxvOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glTexParameterxvOES)(GL_TH_DP, GLenum target, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexParameterxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexParameterxvOES))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexParameterxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexParameterxvOES),
                              thread_mode);
}

/*
 * void
 * glTranslatexOES(GLfixed x, GLfixed y, GLfixed z);
 */

typedef void(*GL_TH_FNTYPE(glTranslatexOES))(GLfixed x, GLfixed y, GLfixed z);

typedef struct
{
   GL_TH_FNTYPE(glTranslatexOES) orig_func;
   GLfixed x;
   GLfixed y;
   GLfixed z;

} GL_TH_ST(glTranslatexOES);

static void
GL_TH_CB(glTranslatexOES)(void *data)
{
   GL_TH_ST(glTranslatexOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTranslatexOES))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->z);

}

void
GL_TH_FN(glTranslatexOES)(GL_TH_DP, GLfixed x, GLfixed y, GLfixed z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTranslatexOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTranslatexOES))orig_func)
           (x, y, z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTranslatexOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->z = z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTranslatexOES),
                              thread_mode);
}

/*
 * GLboolean
 * glIsRenderbufferOES(GLuint renderbuffer);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsRenderbufferOES))(GLuint renderbuffer);

typedef struct
{
   GL_TH_FNTYPE(glIsRenderbufferOES) orig_func;
   GLboolean return_value;
   GLuint renderbuffer;

} GL_TH_ST(glIsRenderbufferOES);

static void
GL_TH_CB(glIsRenderbufferOES)(void *data)
{
   GL_TH_ST(glIsRenderbufferOES) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsRenderbufferOES))thread_data->orig_func)
      (thread_data->renderbuffer);

}

GLboolean
GL_TH_FN(glIsRenderbufferOES)(GL_TH_DP, GLuint renderbuffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsRenderbufferOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsRenderbufferOES))orig_func)
           (renderbuffer);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsRenderbufferOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->renderbuffer = renderbuffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsRenderbufferOES),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glBindRenderbufferOES(GLenum target, GLuint renderbuffer);
 */

typedef void(*GL_TH_FNTYPE(glBindRenderbufferOES))(GLenum target, GLuint renderbuffer);

typedef struct
{
   GL_TH_FNTYPE(glBindRenderbufferOES) orig_func;
   GLenum target;
   GLuint renderbuffer;

} GL_TH_ST(glBindRenderbufferOES);

static void
GL_TH_CB(glBindRenderbufferOES)(void *data)
{
   GL_TH_ST(glBindRenderbufferOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindRenderbufferOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->renderbuffer);

}

void
GL_TH_FN(glBindRenderbufferOES)(GL_TH_DP, GLenum target, GLuint renderbuffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindRenderbufferOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindRenderbufferOES))orig_func)
           (target, renderbuffer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindRenderbufferOES) *) + sizeof(GL_TH_ST(glBindRenderbufferOES)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glBindRenderbufferOES) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->renderbuffer = renderbuffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindRenderbufferOES),
                              thread_mode);
}

/*
 * void
 * glDeleteRenderbuffersOES(GLsizei n, const GLuint* renderbuffers);
 */

typedef void(*GL_TH_FNTYPE(glDeleteRenderbuffersOES))(GLsizei n, const GLuint* renderbuffers);

typedef struct
{
   GL_TH_FNTYPE(glDeleteRenderbuffersOES) orig_func;
   GLsizei n;
   const GLuint* renderbuffers;
   void *renderbuffers_copied; /* COPIED */

} GL_TH_ST(glDeleteRenderbuffersOES);

static void
GL_TH_CB(glDeleteRenderbuffersOES)(void *data)
{
   GL_TH_ST(glDeleteRenderbuffersOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteRenderbuffersOES))thread_data->orig_func)
      (thread_data->n,
       thread_data->renderbuffers);


   if (thread_data->renderbuffers_copied)
     eina_mempool_free(_mp_delete_object, thread_data->renderbuffers_copied);

}

void
GL_TH_FN(glDeleteRenderbuffersOES)(GL_TH_DP, GLsizei n, const GLuint* renderbuffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteRenderbuffersOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteRenderbuffersOES))orig_func)
           (n, renderbuffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteRenderbuffersOES) *) + sizeof(GL_TH_ST(glDeleteRenderbuffersOES)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glDeleteRenderbuffersOES) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->n = n;
   thread_data->renderbuffers = renderbuffers;
   thread_data->orig_func = orig_func;

   thread_data->renderbuffers_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (renderbuffers)
     {
        /* 1. check memory size */
        unsigned int copy_size = n * sizeof(GLuint);
        if (copy_size > _mp_delete_object_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->renderbuffers_copied = eina_mempool_malloc(_mp_delete_object, copy_size);
        if (thread_data->renderbuffers_copied)
          {
             memcpy(thread_data->renderbuffers_copied, renderbuffers, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->renderbuffers = (const GLuint *)thread_data->renderbuffers_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteRenderbuffersOES),
                              thread_mode);
}

/*
 * void
 * glGenRenderbuffersOES(GLsizei n, GLuint* renderbuffers);
 */

typedef void(*GL_TH_FNTYPE(glGenRenderbuffersOES))(GLsizei n, GLuint* renderbuffers);

typedef struct
{
   GL_TH_FNTYPE(glGenRenderbuffersOES) orig_func;
   GLsizei n;
   GLuint* renderbuffers;

} GL_TH_ST(glGenRenderbuffersOES);

static void
GL_TH_CB(glGenRenderbuffersOES)(void *data)
{
   GL_TH_ST(glGenRenderbuffersOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenRenderbuffersOES))thread_data->orig_func)
      (thread_data->n,
       thread_data->renderbuffers);

}

void
GL_TH_FN(glGenRenderbuffersOES)(GL_TH_DP, GLsizei n, GLuint* renderbuffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenRenderbuffersOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenRenderbuffersOES))orig_func)
           (n, renderbuffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenRenderbuffersOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->renderbuffers = renderbuffers;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenRenderbuffersOES),
                              thread_mode);
}

/*
 * void
 * glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
 */

typedef void(*GL_TH_FNTYPE(glRenderbufferStorageOES))(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);

typedef struct
{
   GL_TH_FNTYPE(glRenderbufferStorageOES) orig_func;
   GLenum target;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;

} GL_TH_ST(glRenderbufferStorageOES);

static void
GL_TH_CB(glRenderbufferStorageOES)(void *data)
{
   GL_TH_ST(glRenderbufferStorageOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glRenderbufferStorageOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glRenderbufferStorageOES)(GL_TH_DP, GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glRenderbufferStorageOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glRenderbufferStorageOES))orig_func)
           (target, internalformat, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glRenderbufferStorageOES) *) + sizeof(GL_TH_ST(glRenderbufferStorageOES)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glRenderbufferStorageOES) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glRenderbufferStorageOES),
                              thread_mode);
}

/*
 * void
 * glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetRenderbufferParameterivOES))(GLenum target, GLenum pname, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetRenderbufferParameterivOES) orig_func;
   GLenum target;
   GLenum pname;
   GLint* params;

} GL_TH_ST(glGetRenderbufferParameterivOES);

static void
GL_TH_CB(glGetRenderbufferParameterivOES)(void *data)
{
   GL_TH_ST(glGetRenderbufferParameterivOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetRenderbufferParameterivOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetRenderbufferParameterivOES)(GL_TH_DP, GLenum target, GLenum pname, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetRenderbufferParameterivOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetRenderbufferParameterivOES))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetRenderbufferParameterivOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetRenderbufferParameterivOES),
                              thread_mode);
}

/*
 * GLboolean
 * glIsFramebufferOES(GLuint framebuffer);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsFramebufferOES))(GLuint framebuffer);

typedef struct
{
   GL_TH_FNTYPE(glIsFramebufferOES) orig_func;
   GLboolean return_value;
   GLuint framebuffer;

} GL_TH_ST(glIsFramebufferOES);

static void
GL_TH_CB(glIsFramebufferOES)(void *data)
{
   GL_TH_ST(glIsFramebufferOES) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsFramebufferOES))thread_data->orig_func)
      (thread_data->framebuffer);

}

GLboolean
GL_TH_FN(glIsFramebufferOES)(GL_TH_DP, GLuint framebuffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsFramebufferOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsFramebufferOES))orig_func)
           (framebuffer);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsFramebufferOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->framebuffer = framebuffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsFramebufferOES),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glBindFramebufferOES(GLenum target, GLuint framebuffer);
 */

typedef void(*GL_TH_FNTYPE(glBindFramebufferOES))(GLenum target, GLuint framebuffer);

typedef struct
{
   GL_TH_FNTYPE(glBindFramebufferOES) orig_func;
   GLenum target;
   GLuint framebuffer;

} GL_TH_ST(glBindFramebufferOES);

static void
GL_TH_CB(glBindFramebufferOES)(void *data)
{
   GL_TH_ST(glBindFramebufferOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindFramebufferOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->framebuffer);

}

void
GL_TH_FN(glBindFramebufferOES)(GL_TH_DP, GLenum target, GLuint framebuffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindFramebufferOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindFramebufferOES))orig_func)
           (target, framebuffer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindFramebufferOES) *) + sizeof(GL_TH_ST(glBindFramebufferOES)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glBindFramebufferOES) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->framebuffer = framebuffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindFramebufferOES),
                              thread_mode);
}

/*
 * void
 * glDeleteFramebuffersOES(GLsizei n, const GLuint* framebuffers);
 */

typedef void(*GL_TH_FNTYPE(glDeleteFramebuffersOES))(GLsizei n, const GLuint* framebuffers);

typedef struct
{
   GL_TH_FNTYPE(glDeleteFramebuffersOES) orig_func;
   GLsizei n;
   const GLuint* framebuffers;
   void *framebuffers_copied; /* COPIED */

} GL_TH_ST(glDeleteFramebuffersOES);

static void
GL_TH_CB(glDeleteFramebuffersOES)(void *data)
{
   GL_TH_ST(glDeleteFramebuffersOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteFramebuffersOES))thread_data->orig_func)
      (thread_data->n,
       thread_data->framebuffers);


   if (thread_data->framebuffers_copied)
     eina_mempool_free(_mp_delete_object, thread_data->framebuffers_copied);

}

void
GL_TH_FN(glDeleteFramebuffersOES)(GL_TH_DP, GLsizei n, const GLuint* framebuffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteFramebuffersOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteFramebuffersOES))orig_func)
           (n, framebuffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteFramebuffersOES) *) + sizeof(GL_TH_ST(glDeleteFramebuffersOES)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glDeleteFramebuffersOES) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->n = n;
   thread_data->framebuffers = framebuffers;
   thread_data->orig_func = orig_func;

   thread_data->framebuffers_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (framebuffers)
     {
        /* 1. check memory size */
        unsigned int copy_size = n * sizeof(GLuint);
        if (copy_size > _mp_delete_object_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->framebuffers_copied = eina_mempool_malloc(_mp_delete_object, copy_size);
        if (thread_data->framebuffers_copied)
          {
             memcpy(thread_data->framebuffers_copied, framebuffers, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->framebuffers = (const GLuint *)thread_data->framebuffers_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteFramebuffersOES),
                              thread_mode);
}

/*
 * void
 * glGenFramebuffersOES(GLsizei n, GLuint* framebuffers);
 */

typedef void(*GL_TH_FNTYPE(glGenFramebuffersOES))(GLsizei n, GLuint* framebuffers);

typedef struct
{
   GL_TH_FNTYPE(glGenFramebuffersOES) orig_func;
   GLsizei n;
   GLuint* framebuffers;

} GL_TH_ST(glGenFramebuffersOES);

static void
GL_TH_CB(glGenFramebuffersOES)(void *data)
{
   GL_TH_ST(glGenFramebuffersOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenFramebuffersOES))thread_data->orig_func)
      (thread_data->n,
       thread_data->framebuffers);

}

void
GL_TH_FN(glGenFramebuffersOES)(GL_TH_DP, GLsizei n, GLuint* framebuffers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenFramebuffersOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenFramebuffersOES))orig_func)
           (n, framebuffers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenFramebuffersOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->framebuffers = framebuffers;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenFramebuffersOES),
                              thread_mode);
}

/*
 * GLenum
 * glCheckFramebufferStatusOES(GLenum target);
 */

typedef GLenum(*GL_TH_FNTYPE(glCheckFramebufferStatusOES))(GLenum target);

typedef struct
{
   GL_TH_FNTYPE(glCheckFramebufferStatusOES) orig_func;
   GLenum return_value;
   GLenum target;

} GL_TH_ST(glCheckFramebufferStatusOES);

static void
GL_TH_CB(glCheckFramebufferStatusOES)(void *data)
{
   GL_TH_ST(glCheckFramebufferStatusOES) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glCheckFramebufferStatusOES))thread_data->orig_func)
      (thread_data->target);

}

GLenum
GL_TH_FN(glCheckFramebufferStatusOES)(GL_TH_DP, GLenum target)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCheckFramebufferStatusOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glCheckFramebufferStatusOES))orig_func)
           (target);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCheckFramebufferStatusOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCheckFramebufferStatusOES),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
 */

typedef void(*GL_TH_FNTYPE(glFramebufferRenderbufferOES))(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);

typedef struct
{
   GL_TH_FNTYPE(glFramebufferRenderbufferOES) orig_func;
   GLenum target;
   GLenum attachment;
   GLenum renderbuffertarget;
   GLuint renderbuffer;

} GL_TH_ST(glFramebufferRenderbufferOES);

static void
GL_TH_CB(glFramebufferRenderbufferOES)(void *data)
{
   GL_TH_ST(glFramebufferRenderbufferOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFramebufferRenderbufferOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->attachment,
       thread_data->renderbuffertarget,
       thread_data->renderbuffer);

}

void
GL_TH_FN(glFramebufferRenderbufferOES)(GL_TH_DP, GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFramebufferRenderbufferOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFramebufferRenderbufferOES))orig_func)
           (target, attachment, renderbuffertarget, renderbuffer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFramebufferRenderbufferOES) *) + sizeof(GL_TH_ST(glFramebufferRenderbufferOES)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glFramebufferRenderbufferOES) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->attachment = attachment;
   thread_data->renderbuffertarget = renderbuffertarget;
   thread_data->renderbuffer = renderbuffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFramebufferRenderbufferOES),
                              thread_mode);
}

/*
 * void
 * glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
 */

typedef void(*GL_TH_FNTYPE(glFramebufferTexture2DOES))(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);

typedef struct
{
   GL_TH_FNTYPE(glFramebufferTexture2DOES) orig_func;
   GLenum target;
   GLenum attachment;
   GLenum textarget;
   GLuint texture;
   GLint level;

} GL_TH_ST(glFramebufferTexture2DOES);

static void
GL_TH_CB(glFramebufferTexture2DOES)(void *data)
{
   GL_TH_ST(glFramebufferTexture2DOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFramebufferTexture2DOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->attachment,
       thread_data->textarget,
       thread_data->texture,
       thread_data->level);

}

void
GL_TH_FN(glFramebufferTexture2DOES)(GL_TH_DP, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFramebufferTexture2DOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFramebufferTexture2DOES))orig_func)
           (target, attachment, textarget, texture, level);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFramebufferTexture2DOES) *) + sizeof(GL_TH_ST(glFramebufferTexture2DOES)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glFramebufferTexture2DOES) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->attachment = attachment;
   thread_data->textarget = textarget;
   thread_data->texture = texture;
   thread_data->level = level;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFramebufferTexture2DOES),
                              thread_mode);
}

/*
 * void
 * glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetFramebufferAttachmentParameterivOES))(GLenum target, GLenum attachment, GLenum pname, GLint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetFramebufferAttachmentParameterivOES) orig_func;
   GLenum target;
   GLenum attachment;
   GLenum pname;
   GLint* params;

} GL_TH_ST(glGetFramebufferAttachmentParameterivOES);

static void
GL_TH_CB(glGetFramebufferAttachmentParameterivOES)(void *data)
{
   GL_TH_ST(glGetFramebufferAttachmentParameterivOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetFramebufferAttachmentParameterivOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->attachment,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetFramebufferAttachmentParameterivOES)(GL_TH_DP, GLenum target, GLenum attachment, GLenum pname, GLint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetFramebufferAttachmentParameterivOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetFramebufferAttachmentParameterivOES))orig_func)
           (target, attachment, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetFramebufferAttachmentParameterivOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->attachment = attachment;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetFramebufferAttachmentParameterivOES),
                              thread_mode);
}

/*
 * void
 * glGenerateMipmapOES(GLenum target);
 */

typedef void(*GL_TH_FNTYPE(glGenerateMipmapOES))(GLenum target);

typedef struct
{
   GL_TH_FNTYPE(glGenerateMipmapOES) orig_func;
   GLenum target;

} GL_TH_ST(glGenerateMipmapOES);

static void
GL_TH_CB(glGenerateMipmapOES)(void *data)
{
   GL_TH_ST(glGenerateMipmapOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenerateMipmapOES))thread_data->orig_func)
      (thread_data->target);

}

void
GL_TH_FN(glGenerateMipmapOES)(GL_TH_DP, GLenum target)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenerateMipmapOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenerateMipmapOES))orig_func)
           (target);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenerateMipmapOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenerateMipmapOES),
                              thread_mode);
}

/*
 * void
 * glCurrentPaletteMatrixOES(GLuint matrixpaletteindex);
 */

typedef void(*GL_TH_FNTYPE(glCurrentPaletteMatrixOES))(GLuint matrixpaletteindex);

typedef struct
{
   GL_TH_FNTYPE(glCurrentPaletteMatrixOES) orig_func;
   GLuint matrixpaletteindex;

} GL_TH_ST(glCurrentPaletteMatrixOES);

static void
GL_TH_CB(glCurrentPaletteMatrixOES)(void *data)
{
   GL_TH_ST(glCurrentPaletteMatrixOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCurrentPaletteMatrixOES))thread_data->orig_func)
      (thread_data->matrixpaletteindex);

}

void
GL_TH_FN(glCurrentPaletteMatrixOES)(GL_TH_DP, GLuint matrixpaletteindex)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCurrentPaletteMatrixOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCurrentPaletteMatrixOES))orig_func)
           (matrixpaletteindex);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCurrentPaletteMatrixOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->matrixpaletteindex = matrixpaletteindex;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCurrentPaletteMatrixOES),
                              thread_mode);
}

/*
 * void
 * glLoadPaletteFromModelViewMatrixOES(void);
 */

typedef void(*GL_TH_FNTYPE(glLoadPaletteFromModelViewMatrixOES))(void);

typedef struct
{
   GL_TH_FNTYPE(glLoadPaletteFromModelViewMatrixOES) orig_func;

} GL_TH_ST(glLoadPaletteFromModelViewMatrixOES);

static void
GL_TH_CB(glLoadPaletteFromModelViewMatrixOES)(void *data)
{
   GL_TH_ST(glLoadPaletteFromModelViewMatrixOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glLoadPaletteFromModelViewMatrixOES))thread_data->orig_func)
      ();

}

void
GL_TH_FN(glLoadPaletteFromModelViewMatrixOES)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glLoadPaletteFromModelViewMatrixOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glLoadPaletteFromModelViewMatrixOES))orig_func)
           ();
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glLoadPaletteFromModelViewMatrixOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glLoadPaletteFromModelViewMatrixOES),
                              thread_mode);
}

/*
 * void
 * glMatrixIndexPointerOES(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
 */

typedef void(*GL_TH_FNTYPE(glMatrixIndexPointerOES))(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

typedef struct
{
   GL_TH_FNTYPE(glMatrixIndexPointerOES) orig_func;
   GLint size;
   GLenum type;
   GLsizei stride;
   const GLvoid *pointer;

} GL_TH_ST(glMatrixIndexPointerOES);

static void
GL_TH_CB(glMatrixIndexPointerOES)(void *data)
{
   GL_TH_ST(glMatrixIndexPointerOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMatrixIndexPointerOES))thread_data->orig_func)
      (thread_data->size,
       thread_data->type,
       thread_data->stride,
       thread_data->pointer);

}

void
GL_TH_FN(glMatrixIndexPointerOES)(GL_TH_DP, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMatrixIndexPointerOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMatrixIndexPointerOES))orig_func)
           (size, type, stride, pointer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMatrixIndexPointerOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->size = size;
   thread_data->type = type;
   thread_data->stride = stride;
   thread_data->pointer = pointer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMatrixIndexPointerOES),
                              thread_mode);
}

/*
 * void
 * glWeightPointerOES(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
 */

typedef void(*GL_TH_FNTYPE(glWeightPointerOES))(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

typedef struct
{
   GL_TH_FNTYPE(glWeightPointerOES) orig_func;
   GLint size;
   GLenum type;
   GLsizei stride;
   const GLvoid *pointer;

} GL_TH_ST(glWeightPointerOES);

static void
GL_TH_CB(glWeightPointerOES)(void *data)
{
   GL_TH_ST(glWeightPointerOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glWeightPointerOES))thread_data->orig_func)
      (thread_data->size,
       thread_data->type,
       thread_data->stride,
       thread_data->pointer);

}

void
GL_TH_FN(glWeightPointerOES)(GL_TH_DP, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glWeightPointerOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glWeightPointerOES))orig_func)
           (size, type, stride, pointer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glWeightPointerOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->size = size;
   thread_data->type = type;
   thread_data->stride = stride;
   thread_data->pointer = pointer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glWeightPointerOES),
                              thread_mode);
}

/*
 * GLbitfield
 * glQueryMatrixxOES(GLfixed mantissa[16], GLint exponent[16]);
 */

typedef GLbitfield(*GL_TH_FNTYPE(glQueryMatrixxOES))(GLfixed mantissa[16], GLint exponent[16]);

typedef struct
{
   GL_TH_FNTYPE(glQueryMatrixxOES) orig_func;
   GLbitfield return_value;
   GLfixed mantissa[16];
   GLint exponent[16];

} GL_TH_ST(glQueryMatrixxOES);

static void
GL_TH_CB(glQueryMatrixxOES)(void *data)
{
   GL_TH_ST(glQueryMatrixxOES) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glQueryMatrixxOES))thread_data->orig_func)
      (thread_data->mantissa,
       thread_data->exponent);

}

GLbitfield
GL_TH_FN(glQueryMatrixxOES)(GL_TH_DP, GLfixed mantissa[16], GLint exponent[16])
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glQueryMatrixxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glQueryMatrixxOES))orig_func)
           (mantissa, exponent);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glQueryMatrixxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   memcpy(thread_data->mantissa, &mantissa, sizeof(GLfixed) * 16);
   memcpy(thread_data->exponent, &exponent, sizeof(GLint) * 16);
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glQueryMatrixxOES),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glDepthRangefOES(GLclampf zNear, GLclampf zFar);
 */

typedef void(*GL_TH_FNTYPE(glDepthRangefOES))(GLclampf zNear, GLclampf zFar);

typedef struct
{
   GL_TH_FNTYPE(glDepthRangefOES) orig_func;
   GLclampf zNear;
   GLclampf zFar;

} GL_TH_ST(glDepthRangefOES);

static void
GL_TH_CB(glDepthRangefOES)(void *data)
{
   GL_TH_ST(glDepthRangefOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDepthRangefOES))thread_data->orig_func)
      (thread_data->zNear,
       thread_data->zFar);

}

void
GL_TH_FN(glDepthRangefOES)(GL_TH_DP, GLclampf zNear, GLclampf zFar)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDepthRangefOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDepthRangefOES))orig_func)
           (zNear, zFar);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDepthRangefOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->zNear = zNear;
   thread_data->zFar = zFar;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDepthRangefOES),
                              thread_mode);
}

/*
 * void
 * glFrustumfOES(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
 */

typedef void(*GL_TH_FNTYPE(glFrustumfOES))(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);

typedef struct
{
   GL_TH_FNTYPE(glFrustumfOES) orig_func;
   GLfloat left;
   GLfloat right;
   GLfloat bottom;
   GLfloat top;
   GLfloat zNear;
   GLfloat zFar;

} GL_TH_ST(glFrustumfOES);

static void
GL_TH_CB(glFrustumfOES)(void *data)
{
   GL_TH_ST(glFrustumfOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFrustumfOES))thread_data->orig_func)
      (thread_data->left,
       thread_data->right,
       thread_data->bottom,
       thread_data->top,
       thread_data->zNear,
       thread_data->zFar);

}

void
GL_TH_FN(glFrustumfOES)(GL_TH_DP, GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFrustumfOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFrustumfOES))orig_func)
           (left, right, bottom, top, zNear, zFar);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFrustumfOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->left = left;
   thread_data->right = right;
   thread_data->bottom = bottom;
   thread_data->top = top;
   thread_data->zNear = zNear;
   thread_data->zFar = zFar;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFrustumfOES),
                              thread_mode);
}

/*
 * void
 * glOrthofOES(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
 */

typedef void(*GL_TH_FNTYPE(glOrthofOES))(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);

typedef struct
{
   GL_TH_FNTYPE(glOrthofOES) orig_func;
   GLfloat left;
   GLfloat right;
   GLfloat bottom;
   GLfloat top;
   GLfloat zNear;
   GLfloat zFar;

} GL_TH_ST(glOrthofOES);

static void
GL_TH_CB(glOrthofOES)(void *data)
{
   GL_TH_ST(glOrthofOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glOrthofOES))thread_data->orig_func)
      (thread_data->left,
       thread_data->right,
       thread_data->bottom,
       thread_data->top,
       thread_data->zNear,
       thread_data->zFar);

}

void
GL_TH_FN(glOrthofOES)(GL_TH_DP, GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glOrthofOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glOrthofOES))orig_func)
           (left, right, bottom, top, zNear, zFar);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glOrthofOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->left = left;
   thread_data->right = right;
   thread_data->bottom = bottom;
   thread_data->top = top;
   thread_data->zNear = zNear;
   thread_data->zFar = zFar;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glOrthofOES),
                              thread_mode);
}

/*
 * void
 * glClipPlanefOES(GLenum plane, const GLfloat *equation);
 */

typedef void(*GL_TH_FNTYPE(glClipPlanefOES))(GLenum plane, const GLfloat *equation);

typedef struct
{
   GL_TH_FNTYPE(glClipPlanefOES) orig_func;
   GLenum plane;
   const GLfloat *equation;

} GL_TH_ST(glClipPlanefOES);

static void
GL_TH_CB(glClipPlanefOES)(void *data)
{
   GL_TH_ST(glClipPlanefOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClipPlanefOES))thread_data->orig_func)
      (thread_data->plane,
       thread_data->equation);

}

void
GL_TH_FN(glClipPlanefOES)(GL_TH_DP, GLenum plane, const GLfloat *equation)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClipPlanefOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClipPlanefOES))orig_func)
           (plane, equation);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClipPlanefOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->plane = plane;
   thread_data->equation = equation;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClipPlanefOES),
                              thread_mode);
}

/*
 * void
 * glGetClipPlanefOES(GLenum pname, GLfloat eqn[4]);
 */

typedef void(*GL_TH_FNTYPE(glGetClipPlanefOES))(GLenum pname, GLfloat eqn[4]);

typedef struct
{
   GL_TH_FNTYPE(glGetClipPlanefOES) orig_func;
   GLenum pname;
   GLfloat eqn[4];

} GL_TH_ST(glGetClipPlanefOES);

static void
GL_TH_CB(glGetClipPlanefOES)(void *data)
{
   GL_TH_ST(glGetClipPlanefOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetClipPlanefOES))thread_data->orig_func)
      (thread_data->pname,
       thread_data->eqn);

}

void
GL_TH_FN(glGetClipPlanefOES)(GL_TH_DP, GLenum pname, GLfloat eqn[4])
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetClipPlanefOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetClipPlanefOES))orig_func)
           (pname, eqn);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetClipPlanefOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   memcpy(thread_data->eqn, &eqn, sizeof(GLfloat) * 4);
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetClipPlanefOES),
                              thread_mode);
}

/*
 * void
 * glClearDepthfOES(GLclampf depth);
 */

typedef void(*GL_TH_FNTYPE(glClearDepthfOES))(GLclampf depth);

typedef struct
{
   GL_TH_FNTYPE(glClearDepthfOES) orig_func;
   GLclampf depth;

} GL_TH_ST(glClearDepthfOES);

static void
GL_TH_CB(glClearDepthfOES)(void *data)
{
   GL_TH_ST(glClearDepthfOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClearDepthfOES))thread_data->orig_func)
      (thread_data->depth);

}

void
GL_TH_FN(glClearDepthfOES)(GL_TH_DP, GLclampf depth)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClearDepthfOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClearDepthfOES))orig_func)
           (depth);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClearDepthfOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->depth = depth;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClearDepthfOES),
                              thread_mode);
}

/*
 * void
 * glTexGenfOES(GLenum coord, GLenum pname, GLfloat param);
 */

typedef void(*GL_TH_FNTYPE(glTexGenfOES))(GLenum coord, GLenum pname, GLfloat param);

typedef struct
{
   GL_TH_FNTYPE(glTexGenfOES) orig_func;
   GLenum coord;
   GLenum pname;
   GLfloat param;

} GL_TH_ST(glTexGenfOES);

static void
GL_TH_CB(glTexGenfOES)(void *data)
{
   GL_TH_ST(glTexGenfOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexGenfOES))thread_data->orig_func)
      (thread_data->coord,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glTexGenfOES)(GL_TH_DP, GLenum coord, GLenum pname, GLfloat param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexGenfOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexGenfOES))orig_func)
           (coord, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexGenfOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coord = coord;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexGenfOES),
                              thread_mode);
}

/*
 * void
 * glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat *params);
 */

typedef void(*GL_TH_FNTYPE(glTexGenfvOES))(GLenum coord, GLenum pname, const GLfloat *params);

typedef struct
{
   GL_TH_FNTYPE(glTexGenfvOES) orig_func;
   GLenum coord;
   GLenum pname;
   const GLfloat *params;

} GL_TH_ST(glTexGenfvOES);

static void
GL_TH_CB(glTexGenfvOES)(void *data)
{
   GL_TH_ST(glTexGenfvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexGenfvOES))thread_data->orig_func)
      (thread_data->coord,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glTexGenfvOES)(GL_TH_DP, GLenum coord, GLenum pname, const GLfloat *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexGenfvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexGenfvOES))orig_func)
           (coord, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexGenfvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coord = coord;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexGenfvOES),
                              thread_mode);
}

/*
 * void
 * glTexGeniOES(GLenum coord, GLenum pname, GLint param);
 */

typedef void(*GL_TH_FNTYPE(glTexGeniOES))(GLenum coord, GLenum pname, GLint param);

typedef struct
{
   GL_TH_FNTYPE(glTexGeniOES) orig_func;
   GLenum coord;
   GLenum pname;
   GLint param;

} GL_TH_ST(glTexGeniOES);

static void
GL_TH_CB(glTexGeniOES)(void *data)
{
   GL_TH_ST(glTexGeniOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexGeniOES))thread_data->orig_func)
      (thread_data->coord,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glTexGeniOES)(GL_TH_DP, GLenum coord, GLenum pname, GLint param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexGeniOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexGeniOES))orig_func)
           (coord, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexGeniOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coord = coord;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexGeniOES),
                              thread_mode);
}

/*
 * void
 * glTexGenivOES(GLenum coord, GLenum pname, const GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glTexGenivOES))(GLenum coord, GLenum pname, const GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glTexGenivOES) orig_func;
   GLenum coord;
   GLenum pname;
   const GLint *params;

} GL_TH_ST(glTexGenivOES);

static void
GL_TH_CB(glTexGenivOES)(void *data)
{
   GL_TH_ST(glTexGenivOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexGenivOES))thread_data->orig_func)
      (thread_data->coord,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glTexGenivOES)(GL_TH_DP, GLenum coord, GLenum pname, const GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexGenivOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexGenivOES))orig_func)
           (coord, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexGenivOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coord = coord;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexGenivOES),
                              thread_mode);
}

/*
 * void
 * glTexGenxOES(GLenum coord, GLenum pname, GLfixed param);
 */

typedef void(*GL_TH_FNTYPE(glTexGenxOES))(GLenum coord, GLenum pname, GLfixed param);

typedef struct
{
   GL_TH_FNTYPE(glTexGenxOES) orig_func;
   GLenum coord;
   GLenum pname;
   GLfixed param;

} GL_TH_ST(glTexGenxOES);

static void
GL_TH_CB(glTexGenxOES)(void *data)
{
   GL_TH_ST(glTexGenxOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexGenxOES))thread_data->orig_func)
      (thread_data->coord,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glTexGenxOES)(GL_TH_DP, GLenum coord, GLenum pname, GLfixed param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexGenxOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexGenxOES))orig_func)
           (coord, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexGenxOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coord = coord;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexGenxOES),
                              thread_mode);
}

/*
 * void
 * glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glTexGenxvOES))(GLenum coord, GLenum pname, const GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glTexGenxvOES) orig_func;
   GLenum coord;
   GLenum pname;
   const GLfixed *params;

} GL_TH_ST(glTexGenxvOES);

static void
GL_TH_CB(glTexGenxvOES)(void *data)
{
   GL_TH_ST(glTexGenxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexGenxvOES))thread_data->orig_func)
      (thread_data->coord,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glTexGenxvOES)(GL_TH_DP, GLenum coord, GLenum pname, const GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexGenxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexGenxvOES))orig_func)
           (coord, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexGenxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coord = coord;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexGenxvOES),
                              thread_mode);
}

/*
 * void
 * glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat *params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexGenfvOES))(GLenum coord, GLenum pname, GLfloat *params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexGenfvOES) orig_func;
   GLenum coord;
   GLenum pname;
   GLfloat *params;

} GL_TH_ST(glGetTexGenfvOES);

static void
GL_TH_CB(glGetTexGenfvOES)(void *data)
{
   GL_TH_ST(glGetTexGenfvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexGenfvOES))thread_data->orig_func)
      (thread_data->coord,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexGenfvOES)(GL_TH_DP, GLenum coord, GLenum pname, GLfloat *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexGenfvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexGenfvOES))orig_func)
           (coord, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexGenfvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coord = coord;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexGenfvOES),
                              thread_mode);
}

/*
 * void
 * glGetTexGenivOES(GLenum coord, GLenum pname, GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexGenivOES))(GLenum coord, GLenum pname, GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexGenivOES) orig_func;
   GLenum coord;
   GLenum pname;
   GLint *params;

} GL_TH_ST(glGetTexGenivOES);

static void
GL_TH_CB(glGetTexGenivOES)(void *data)
{
   GL_TH_ST(glGetTexGenivOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexGenivOES))thread_data->orig_func)
      (thread_data->coord,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexGenivOES)(GL_TH_DP, GLenum coord, GLenum pname, GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexGenivOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexGenivOES))orig_func)
           (coord, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexGenivOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coord = coord;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexGenivOES),
                              thread_mode);
}

/*
 * void
 * glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed *params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexGenxvOES))(GLenum coord, GLenum pname, GLfixed *params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexGenxvOES) orig_func;
   GLenum coord;
   GLenum pname;
   GLfixed *params;

} GL_TH_ST(glGetTexGenxvOES);

static void
GL_TH_CB(glGetTexGenxvOES)(void *data)
{
   GL_TH_ST(glGetTexGenxvOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexGenxvOES))thread_data->orig_func)
      (thread_data->coord,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexGenxvOES)(GL_TH_DP, GLenum coord, GLenum pname, GLfixed *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexGenxvOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexGenxvOES))orig_func)
           (coord, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexGenxvOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->coord = coord;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexGenxvOES),
                              thread_mode);
}

/*
 * void
 * glBindVertexArrayOES(GLuint array);
 */

typedef void(*GL_TH_FNTYPE(glBindVertexArrayOES))(GLuint array);

typedef struct
{
   GL_TH_FNTYPE(glBindVertexArrayOES) orig_func;
   GLuint array;

} GL_TH_ST(glBindVertexArrayOES);

static void
GL_TH_CB(glBindVertexArrayOES)(void *data)
{
   GL_TH_ST(glBindVertexArrayOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindVertexArrayOES))thread_data->orig_func)
      (thread_data->array);

}

void
GL_TH_FN(glBindVertexArrayOES)(GL_TH_DP, GLuint array)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindVertexArrayOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindVertexArrayOES))orig_func)
           (array);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindVertexArrayOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->array = array;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindVertexArrayOES),
                              thread_mode);
}

/*
 * void
 * glDeleteVertexArraysOES(GLsizei n, const GLuint *arrays);
 */

typedef void(*GL_TH_FNTYPE(glDeleteVertexArraysOES))(GLsizei n, const GLuint *arrays);

typedef struct
{
   GL_TH_FNTYPE(glDeleteVertexArraysOES) orig_func;
   GLsizei n;
   const GLuint *arrays;

} GL_TH_ST(glDeleteVertexArraysOES);

static void
GL_TH_CB(glDeleteVertexArraysOES)(void *data)
{
   GL_TH_ST(glDeleteVertexArraysOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteVertexArraysOES))thread_data->orig_func)
      (thread_data->n,
       thread_data->arrays);

}

void
GL_TH_FN(glDeleteVertexArraysOES)(GL_TH_DP, GLsizei n, const GLuint *arrays)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteVertexArraysOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteVertexArraysOES))orig_func)
           (n, arrays);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteVertexArraysOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->arrays = arrays;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteVertexArraysOES),
                              thread_mode);
}

/*
 * void
 * glGenVertexArraysOES(GLsizei n, GLuint *arrays);
 */

typedef void(*GL_TH_FNTYPE(glGenVertexArraysOES))(GLsizei n, GLuint *arrays);

typedef struct
{
   GL_TH_FNTYPE(glGenVertexArraysOES) orig_func;
   GLsizei n;
   GLuint *arrays;

} GL_TH_ST(glGenVertexArraysOES);

static void
GL_TH_CB(glGenVertexArraysOES)(void *data)
{
   GL_TH_ST(glGenVertexArraysOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenVertexArraysOES))thread_data->orig_func)
      (thread_data->n,
       thread_data->arrays);

}

void
GL_TH_FN(glGenVertexArraysOES)(GL_TH_DP, GLsizei n, GLuint *arrays)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenVertexArraysOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenVertexArraysOES))orig_func)
           (n, arrays);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenVertexArraysOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->arrays = arrays;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenVertexArraysOES),
                              thread_mode);
}

/*
 * GLboolean
 * glIsVertexArrayOES(GLuint array);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsVertexArrayOES))(GLuint array);

typedef struct
{
   GL_TH_FNTYPE(glIsVertexArrayOES) orig_func;
   GLboolean return_value;
   GLuint array;

} GL_TH_ST(glIsVertexArrayOES);

static void
GL_TH_CB(glIsVertexArrayOES)(void *data)
{
   GL_TH_ST(glIsVertexArrayOES) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsVertexArrayOES))thread_data->orig_func)
      (thread_data->array);

}

GLboolean
GL_TH_FN(glIsVertexArrayOES)(GL_TH_DP, GLuint array)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsVertexArrayOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsVertexArrayOES))orig_func)
           (array);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsVertexArrayOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->array = array;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsVertexArrayOES),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glCopyTextureLevelsAPPLE(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount);
 */

typedef void(*GL_TH_FNTYPE(glCopyTextureLevelsAPPLE))(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount);

typedef struct
{
   GL_TH_FNTYPE(glCopyTextureLevelsAPPLE) orig_func;
   GLuint destinationTexture;
   GLuint sourceTexture;
   GLint sourceBaseLevel;
   GLsizei sourceLevelCount;

} GL_TH_ST(glCopyTextureLevelsAPPLE);

static void
GL_TH_CB(glCopyTextureLevelsAPPLE)(void *data)
{
   GL_TH_ST(glCopyTextureLevelsAPPLE) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCopyTextureLevelsAPPLE))thread_data->orig_func)
      (thread_data->destinationTexture,
       thread_data->sourceTexture,
       thread_data->sourceBaseLevel,
       thread_data->sourceLevelCount);

}

void
GL_TH_FN(glCopyTextureLevelsAPPLE)(GL_TH_DP, GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCopyTextureLevelsAPPLE) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCopyTextureLevelsAPPLE))orig_func)
           (destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCopyTextureLevelsAPPLE) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->destinationTexture = destinationTexture;
   thread_data->sourceTexture = sourceTexture;
   thread_data->sourceBaseLevel = sourceBaseLevel;
   thread_data->sourceLevelCount = sourceLevelCount;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCopyTextureLevelsAPPLE),
                              thread_mode);
}

/*
 * void
 * glRenderbufferStorageMultisampleAPPLE(GLenum a, GLsizei b, GLenum c, GLsizei d, GLsizei e);
 */

typedef void(*GL_TH_FNTYPE(glRenderbufferStorageMultisampleAPPLE))(GLenum a, GLsizei b, GLenum c, GLsizei d, GLsizei e);

typedef struct
{
   GL_TH_FNTYPE(glRenderbufferStorageMultisampleAPPLE) orig_func;
   GLenum a;
   GLsizei b;
   GLenum c;
   GLsizei d;
   GLsizei e;

} GL_TH_ST(glRenderbufferStorageMultisampleAPPLE);

static void
GL_TH_CB(glRenderbufferStorageMultisampleAPPLE)(void *data)
{
   GL_TH_ST(glRenderbufferStorageMultisampleAPPLE) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glRenderbufferStorageMultisampleAPPLE))thread_data->orig_func)
      (thread_data->a,
       thread_data->b,
       thread_data->c,
       thread_data->d,
       thread_data->e);

}

void
GL_TH_FN(glRenderbufferStorageMultisampleAPPLE)(GL_TH_DP, GLenum a, GLsizei b, GLenum c, GLsizei d, GLsizei e)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glRenderbufferStorageMultisampleAPPLE) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glRenderbufferStorageMultisampleAPPLE))orig_func)
           (a, b, c, d, e);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glRenderbufferStorageMultisampleAPPLE) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->a = a;
   thread_data->b = b;
   thread_data->c = c;
   thread_data->d = d;
   thread_data->e = e;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glRenderbufferStorageMultisampleAPPLE),
                              thread_mode);
}

/*
 * void
 * glResolveMultisampleFramebufferAPPLE(void);
 */

typedef void(*GL_TH_FNTYPE(glResolveMultisampleFramebufferAPPLE))(void);

typedef struct
{
   GL_TH_FNTYPE(glResolveMultisampleFramebufferAPPLE) orig_func;

} GL_TH_ST(glResolveMultisampleFramebufferAPPLE);

static void
GL_TH_CB(glResolveMultisampleFramebufferAPPLE)(void *data)
{
   GL_TH_ST(glResolveMultisampleFramebufferAPPLE) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glResolveMultisampleFramebufferAPPLE))thread_data->orig_func)
      ();

}

void
GL_TH_FN(glResolveMultisampleFramebufferAPPLE)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glResolveMultisampleFramebufferAPPLE) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glResolveMultisampleFramebufferAPPLE))orig_func)
           ();
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glResolveMultisampleFramebufferAPPLE) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glResolveMultisampleFramebufferAPPLE),
                              thread_mode);
}

/*
 * GLsync
 * glFenceSyncAPPLE(GLenum condition, GLbitfield flags);
 */

typedef GLsync(*GL_TH_FNTYPE(glFenceSyncAPPLE))(GLenum condition, GLbitfield flags);

typedef struct
{
   GL_TH_FNTYPE(glFenceSyncAPPLE) orig_func;
   GLsync return_value;
   GLenum condition;
   GLbitfield flags;

} GL_TH_ST(glFenceSyncAPPLE);

static void
GL_TH_CB(glFenceSyncAPPLE)(void *data)
{
   GL_TH_ST(glFenceSyncAPPLE) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glFenceSyncAPPLE))thread_data->orig_func)
      (thread_data->condition,
       thread_data->flags);

}

GLsync
GL_TH_FN(glFenceSyncAPPLE)(GL_TH_DP, GLenum condition, GLbitfield flags)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFenceSyncAPPLE) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glFenceSyncAPPLE))orig_func)
           (condition, flags);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFenceSyncAPPLE) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->condition = condition;
   thread_data->flags = flags;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFenceSyncAPPLE),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glIsSyncAPPLE(GLsync sync);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsSyncAPPLE))(GLsync sync);

typedef struct
{
   GL_TH_FNTYPE(glIsSyncAPPLE) orig_func;
   GLboolean return_value;
   GLsync sync;

} GL_TH_ST(glIsSyncAPPLE);

static void
GL_TH_CB(glIsSyncAPPLE)(void *data)
{
   GL_TH_ST(glIsSyncAPPLE) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsSyncAPPLE))thread_data->orig_func)
      (thread_data->sync);

}

GLboolean
GL_TH_FN(glIsSyncAPPLE)(GL_TH_DP, GLsync sync)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsSyncAPPLE) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsSyncAPPLE))orig_func)
           (sync);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsSyncAPPLE) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sync = sync;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsSyncAPPLE),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glDeleteSyncAPPLE(GLsync sync);
 */

typedef void(*GL_TH_FNTYPE(glDeleteSyncAPPLE))(GLsync sync);

typedef struct
{
   GL_TH_FNTYPE(glDeleteSyncAPPLE) orig_func;
   GLsync sync;

} GL_TH_ST(glDeleteSyncAPPLE);

static void
GL_TH_CB(glDeleteSyncAPPLE)(void *data)
{
   GL_TH_ST(glDeleteSyncAPPLE) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteSyncAPPLE))thread_data->orig_func)
      (thread_data->sync);

}

void
GL_TH_FN(glDeleteSyncAPPLE)(GL_TH_DP, GLsync sync)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteSyncAPPLE) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteSyncAPPLE))orig_func)
           (sync);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteSyncAPPLE) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sync = sync;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteSyncAPPLE),
                              thread_mode);
}

/*
 * GLenum
 * glClientWaitSyncAPPLE(GLsync sync, GLbitfield flags, EvasGLuint64 timeout);
 */

typedef GLenum(*GL_TH_FNTYPE(glClientWaitSyncAPPLE))(GLsync sync, GLbitfield flags, EvasGLuint64 timeout);

typedef struct
{
   GL_TH_FNTYPE(glClientWaitSyncAPPLE) orig_func;
   GLenum return_value;
   GLsync sync;
   GLbitfield flags;
   EvasGLuint64 timeout;

} GL_TH_ST(glClientWaitSyncAPPLE);

static void
GL_TH_CB(glClientWaitSyncAPPLE)(void *data)
{
   GL_TH_ST(glClientWaitSyncAPPLE) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glClientWaitSyncAPPLE))thread_data->orig_func)
      (thread_data->sync,
       thread_data->flags,
       thread_data->timeout);

}

GLenum
GL_TH_FN(glClientWaitSyncAPPLE)(GL_TH_DP, GLsync sync, GLbitfield flags, EvasGLuint64 timeout)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClientWaitSyncAPPLE) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glClientWaitSyncAPPLE))orig_func)
           (sync, flags, timeout);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClientWaitSyncAPPLE) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sync = sync;
   thread_data->flags = flags;
   thread_data->timeout = timeout;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClientWaitSyncAPPLE),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glWaitSyncAPPLE(GLsync sync, GLbitfield flags, EvasGLuint64 timeout);
 */

typedef void(*GL_TH_FNTYPE(glWaitSyncAPPLE))(GLsync sync, GLbitfield flags, EvasGLuint64 timeout);

typedef struct
{
   GL_TH_FNTYPE(glWaitSyncAPPLE) orig_func;
   GLsync sync;
   GLbitfield flags;
   EvasGLuint64 timeout;

} GL_TH_ST(glWaitSyncAPPLE);

static void
GL_TH_CB(glWaitSyncAPPLE)(void *data)
{
   GL_TH_ST(glWaitSyncAPPLE) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glWaitSyncAPPLE))thread_data->orig_func)
      (thread_data->sync,
       thread_data->flags,
       thread_data->timeout);

}

void
GL_TH_FN(glWaitSyncAPPLE)(GL_TH_DP, GLsync sync, GLbitfield flags, EvasGLuint64 timeout)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glWaitSyncAPPLE) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glWaitSyncAPPLE))orig_func)
           (sync, flags, timeout);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glWaitSyncAPPLE) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sync = sync;
   thread_data->flags = flags;
   thread_data->timeout = timeout;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glWaitSyncAPPLE),
                              thread_mode);
}

/*
 * void
 * glGetInteger64vAPPLE(GLenum pname, EvasGLint64 *params);
 */

typedef void(*GL_TH_FNTYPE(glGetInteger64vAPPLE))(GLenum pname, EvasGLint64 *params);

typedef struct
{
   GL_TH_FNTYPE(glGetInteger64vAPPLE) orig_func;
   GLenum pname;
   EvasGLint64 *params;

} GL_TH_ST(glGetInteger64vAPPLE);

static void
GL_TH_CB(glGetInteger64vAPPLE)(void *data)
{
   GL_TH_ST(glGetInteger64vAPPLE) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetInteger64vAPPLE))thread_data->orig_func)
      (thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetInteger64vAPPLE)(GL_TH_DP, GLenum pname, EvasGLint64 *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetInteger64vAPPLE) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetInteger64vAPPLE))orig_func)
           (pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetInteger64vAPPLE) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetInteger64vAPPLE),
                              thread_mode);
}

/*
 * void
 * glGetSyncivAPPLE(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
 */

typedef void(*GL_TH_FNTYPE(glGetSyncivAPPLE))(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);

typedef struct
{
   GL_TH_FNTYPE(glGetSyncivAPPLE) orig_func;
   GLsync sync;
   GLenum pname;
   GLsizei bufSize;
   GLsizei *length;
   GLint *values;

} GL_TH_ST(glGetSyncivAPPLE);

static void
GL_TH_CB(glGetSyncivAPPLE)(void *data)
{
   GL_TH_ST(glGetSyncivAPPLE) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetSyncivAPPLE))thread_data->orig_func)
      (thread_data->sync,
       thread_data->pname,
       thread_data->bufSize,
       thread_data->length,
       thread_data->values);

}

void
GL_TH_FN(glGetSyncivAPPLE)(GL_TH_DP, GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetSyncivAPPLE) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetSyncivAPPLE))orig_func)
           (sync, pname, bufSize, length, values);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetSyncivAPPLE) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sync = sync;
   thread_data->pname = pname;
   thread_data->bufSize = bufSize;
   thread_data->length = length;
   thread_data->values = values;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetSyncivAPPLE),
                              thread_mode);
}

/*
 * void *
 * glMapBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
 */

typedef void *(*GL_TH_FNTYPE(glMapBufferRangeEXT))(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);

typedef struct
{
   GL_TH_FNTYPE(glMapBufferRangeEXT) orig_func;
   void * return_value;
   GLenum target;
   GLintptr offset;
   GLsizeiptr length;
   GLbitfield access;

} GL_TH_ST(glMapBufferRangeEXT);

static void
GL_TH_CB(glMapBufferRangeEXT)(void *data)
{
   GL_TH_ST(glMapBufferRangeEXT) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glMapBufferRangeEXT))thread_data->orig_func)
      (thread_data->target,
       thread_data->offset,
       thread_data->length,
       thread_data->access);

}

void *
GL_TH_FN(glMapBufferRangeEXT)(GL_TH_DP, GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMapBufferRangeEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glMapBufferRangeEXT))orig_func)
           (target, offset, length, access);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMapBufferRangeEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->offset = offset;
   thread_data->length = length;
   thread_data->access = access;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMapBufferRangeEXT),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glFlushMappedBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length);
 */

typedef void(*GL_TH_FNTYPE(glFlushMappedBufferRangeEXT))(GLenum target, GLintptr offset, GLsizeiptr length);

typedef struct
{
   GL_TH_FNTYPE(glFlushMappedBufferRangeEXT) orig_func;
   GLenum target;
   GLintptr offset;
   GLsizeiptr length;

} GL_TH_ST(glFlushMappedBufferRangeEXT);

static void
GL_TH_CB(glFlushMappedBufferRangeEXT)(void *data)
{
   GL_TH_ST(glFlushMappedBufferRangeEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFlushMappedBufferRangeEXT))thread_data->orig_func)
      (thread_data->target,
       thread_data->offset,
       thread_data->length);

}

void
GL_TH_FN(glFlushMappedBufferRangeEXT)(GL_TH_DP, GLenum target, GLintptr offset, GLsizeiptr length)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFlushMappedBufferRangeEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFlushMappedBufferRangeEXT))orig_func)
           (target, offset, length);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFlushMappedBufferRangeEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->offset = offset;
   thread_data->length = length;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFlushMappedBufferRangeEXT),
                              thread_mode);
}

/*
 * void
 * glRenderbufferStorageMultisampleEXT(GLenum a, GLsizei b, GLenum c, GLsizei d, GLsizei e);
 */

typedef void(*GL_TH_FNTYPE(glRenderbufferStorageMultisampleEXT))(GLenum a, GLsizei b, GLenum c, GLsizei d, GLsizei e);

typedef struct
{
   GL_TH_FNTYPE(glRenderbufferStorageMultisampleEXT) orig_func;
   GLenum a;
   GLsizei b;
   GLenum c;
   GLsizei d;
   GLsizei e;

} GL_TH_ST(glRenderbufferStorageMultisampleEXT);

static void
GL_TH_CB(glRenderbufferStorageMultisampleEXT)(void *data)
{
   GL_TH_ST(glRenderbufferStorageMultisampleEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glRenderbufferStorageMultisampleEXT))thread_data->orig_func)
      (thread_data->a,
       thread_data->b,
       thread_data->c,
       thread_data->d,
       thread_data->e);

}

void
GL_TH_FN(glRenderbufferStorageMultisampleEXT)(GL_TH_DP, GLenum a, GLsizei b, GLenum c, GLsizei d, GLsizei e)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glRenderbufferStorageMultisampleEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glRenderbufferStorageMultisampleEXT))orig_func)
           (a, b, c, d, e);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glRenderbufferStorageMultisampleEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->a = a;
   thread_data->b = b;
   thread_data->c = c;
   thread_data->d = d;
   thread_data->e = e;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glRenderbufferStorageMultisampleEXT),
                              thread_mode);
}

/*
 * void
 * glFramebufferTexture2DMultisampleEXT(GLenum a, GLenum b, GLenum c, GLuint d, GLint e, GLsizei f);
 */

typedef void(*GL_TH_FNTYPE(glFramebufferTexture2DMultisampleEXT))(GLenum a, GLenum b, GLenum c, GLuint d, GLint e, GLsizei f);

typedef struct
{
   GL_TH_FNTYPE(glFramebufferTexture2DMultisampleEXT) orig_func;
   GLenum a;
   GLenum b;
   GLenum c;
   GLuint d;
   GLint e;
   GLsizei f;

} GL_TH_ST(glFramebufferTexture2DMultisampleEXT);

static void
GL_TH_CB(glFramebufferTexture2DMultisampleEXT)(void *data)
{
   GL_TH_ST(glFramebufferTexture2DMultisampleEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFramebufferTexture2DMultisampleEXT))thread_data->orig_func)
      (thread_data->a,
       thread_data->b,
       thread_data->c,
       thread_data->d,
       thread_data->e,
       thread_data->f);

}

void
GL_TH_FN(glFramebufferTexture2DMultisampleEXT)(GL_TH_DP, GLenum a, GLenum b, GLenum c, GLuint d, GLint e, GLsizei f)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFramebufferTexture2DMultisampleEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFramebufferTexture2DMultisampleEXT))orig_func)
           (a, b, c, d, e, f);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFramebufferTexture2DMultisampleEXT) *) + sizeof(GL_TH_ST(glFramebufferTexture2DMultisampleEXT)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glFramebufferTexture2DMultisampleEXT) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->a = a;
   thread_data->b = b;
   thread_data->c = c;
   thread_data->d = d;
   thread_data->e = e;
   thread_data->f = f;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFramebufferTexture2DMultisampleEXT),
                              thread_mode);
}

/*
 * GLenum
 * glGetGraphicsResetStatusEXT(void);
 */

typedef GLenum(*GL_TH_FNTYPE(glGetGraphicsResetStatusEXT))(void);

typedef struct
{
   GL_TH_FNTYPE(glGetGraphicsResetStatusEXT) orig_func;
   GLenum return_value;

} GL_TH_ST(glGetGraphicsResetStatusEXT);

static void
GL_TH_CB(glGetGraphicsResetStatusEXT)(void *data)
{
   GL_TH_ST(glGetGraphicsResetStatusEXT) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glGetGraphicsResetStatusEXT))thread_data->orig_func)
      ();

}

GLenum
GL_TH_FN(glGetGraphicsResetStatusEXT)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetGraphicsResetStatusEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glGetGraphicsResetStatusEXT))orig_func)
           ();
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetGraphicsResetStatusEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetGraphicsResetStatusEXT),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glReadnPixelsEXT(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
 */

typedef void(*GL_TH_FNTYPE(glReadnPixelsEXT))(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);

typedef struct
{
   GL_TH_FNTYPE(glReadnPixelsEXT) orig_func;
   GLint x;
   GLint y;
   GLsizei width;
   GLsizei height;
   GLenum format;
   GLenum type;
   GLsizei bufSize;
   void *data;

} GL_TH_ST(glReadnPixelsEXT);

static void
GL_TH_CB(glReadnPixelsEXT)(void *data)
{
   GL_TH_ST(glReadnPixelsEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glReadnPixelsEXT))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->width,
       thread_data->height,
       thread_data->format,
       thread_data->type,
       thread_data->bufSize,
       thread_data->data);

}

void
GL_TH_FN(glReadnPixelsEXT)(GL_TH_DP, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glReadnPixelsEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glReadnPixelsEXT))orig_func)
           (x, y, width, height, format, type, bufSize, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glReadnPixelsEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->format = format;
   thread_data->type = type;
   thread_data->bufSize = bufSize;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glReadnPixelsEXT),
                              thread_mode);
}

/*
 * void
 * glGetnUniformfvEXT(GLuint program, GLint location, GLsizei bufSize, float *params);
 */

typedef void(*GL_TH_FNTYPE(glGetnUniformfvEXT))(GLuint program, GLint location, GLsizei bufSize, float *params);

typedef struct
{
   GL_TH_FNTYPE(glGetnUniformfvEXT) orig_func;
   GLuint program;
   GLint location;
   GLsizei bufSize;
   float *params;

} GL_TH_ST(glGetnUniformfvEXT);

static void
GL_TH_CB(glGetnUniformfvEXT)(void *data)
{
   GL_TH_ST(glGetnUniformfvEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetnUniformfvEXT))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->bufSize,
       thread_data->params);

}

void
GL_TH_FN(glGetnUniformfvEXT)(GL_TH_DP, GLuint program, GLint location, GLsizei bufSize, float *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetnUniformfvEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetnUniformfvEXT))orig_func)
           (program, location, bufSize, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetnUniformfvEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->bufSize = bufSize;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetnUniformfvEXT),
                              thread_mode);
}

/*
 * void
 * glGetnUniformivEXT(GLuint program, GLint location, GLsizei bufSize, GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetnUniformivEXT))(GLuint program, GLint location, GLsizei bufSize, GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetnUniformivEXT) orig_func;
   GLuint program;
   GLint location;
   GLsizei bufSize;
   GLint *params;

} GL_TH_ST(glGetnUniformivEXT);

static void
GL_TH_CB(glGetnUniformivEXT)(void *data)
{
   GL_TH_ST(glGetnUniformivEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetnUniformivEXT))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->bufSize,
       thread_data->params);

}

void
GL_TH_FN(glGetnUniformivEXT)(GL_TH_DP, GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetnUniformivEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetnUniformivEXT))orig_func)
           (program, location, bufSize, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetnUniformivEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->bufSize = bufSize;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetnUniformivEXT),
                              thread_mode);
}

/*
 * void
 * glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
 */

typedef void(*GL_TH_FNTYPE(glTexStorage1DEXT))(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);

typedef struct
{
   GL_TH_FNTYPE(glTexStorage1DEXT) orig_func;
   GLenum target;
   GLsizei levels;
   GLenum internalformat;
   GLsizei width;

} GL_TH_ST(glTexStorage1DEXT);

static void
GL_TH_CB(glTexStorage1DEXT)(void *data)
{
   GL_TH_ST(glTexStorage1DEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexStorage1DEXT))thread_data->orig_func)
      (thread_data->target,
       thread_data->levels,
       thread_data->internalformat,
       thread_data->width);

}

void
GL_TH_FN(glTexStorage1DEXT)(GL_TH_DP, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexStorage1DEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexStorage1DEXT))orig_func)
           (target, levels, internalformat, width);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexStorage1DEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->levels = levels;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexStorage1DEXT),
                              thread_mode);
}

/*
 * void
 * glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
 */

typedef void(*GL_TH_FNTYPE(glTexStorage2DEXT))(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);

typedef struct
{
   GL_TH_FNTYPE(glTexStorage2DEXT) orig_func;
   GLenum target;
   GLsizei levels;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;

} GL_TH_ST(glTexStorage2DEXT);

static void
GL_TH_CB(glTexStorage2DEXT)(void *data)
{
   GL_TH_ST(glTexStorage2DEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexStorage2DEXT))thread_data->orig_func)
      (thread_data->target,
       thread_data->levels,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glTexStorage2DEXT)(GL_TH_DP, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexStorage2DEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexStorage2DEXT))orig_func)
           (target, levels, internalformat, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexStorage2DEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->levels = levels;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexStorage2DEXT),
                              thread_mode);
}

/*
 * void
 * glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
 */

typedef void(*GL_TH_FNTYPE(glTexStorage3DEXT))(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);

typedef struct
{
   GL_TH_FNTYPE(glTexStorage3DEXT) orig_func;
   GLenum target;
   GLsizei levels;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;
   GLsizei depth;

} GL_TH_ST(glTexStorage3DEXT);

static void
GL_TH_CB(glTexStorage3DEXT)(void *data)
{
   GL_TH_ST(glTexStorage3DEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexStorage3DEXT))thread_data->orig_func)
      (thread_data->target,
       thread_data->levels,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height,
       thread_data->depth);

}

void
GL_TH_FN(glTexStorage3DEXT)(GL_TH_DP, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexStorage3DEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexStorage3DEXT))orig_func)
           (target, levels, internalformat, width, height, depth);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexStorage3DEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->levels = levels;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->depth = depth;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexStorage3DEXT),
                              thread_mode);
}

/*
 * void
 * glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
 */

typedef void(*GL_TH_FNTYPE(glTextureStorage1DEXT))(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);

typedef struct
{
   GL_TH_FNTYPE(glTextureStorage1DEXT) orig_func;
   GLuint texture;
   GLenum target;
   GLsizei levels;
   GLenum internalformat;
   GLsizei width;

} GL_TH_ST(glTextureStorage1DEXT);

static void
GL_TH_CB(glTextureStorage1DEXT)(void *data)
{
   GL_TH_ST(glTextureStorage1DEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTextureStorage1DEXT))thread_data->orig_func)
      (thread_data->texture,
       thread_data->target,
       thread_data->levels,
       thread_data->internalformat,
       thread_data->width);

}

void
GL_TH_FN(glTextureStorage1DEXT)(GL_TH_DP, GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTextureStorage1DEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTextureStorage1DEXT))orig_func)
           (texture, target, levels, internalformat, width);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTextureStorage1DEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->texture = texture;
   thread_data->target = target;
   thread_data->levels = levels;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTextureStorage1DEXT),
                              thread_mode);
}

/*
 * void
 * glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
 */

typedef void(*GL_TH_FNTYPE(glTextureStorage2DEXT))(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);

typedef struct
{
   GL_TH_FNTYPE(glTextureStorage2DEXT) orig_func;
   GLuint texture;
   GLenum target;
   GLsizei levels;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;

} GL_TH_ST(glTextureStorage2DEXT);

static void
GL_TH_CB(glTextureStorage2DEXT)(void *data)
{
   GL_TH_ST(glTextureStorage2DEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTextureStorage2DEXT))thread_data->orig_func)
      (thread_data->texture,
       thread_data->target,
       thread_data->levels,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glTextureStorage2DEXT)(GL_TH_DP, GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTextureStorage2DEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTextureStorage2DEXT))orig_func)
           (texture, target, levels, internalformat, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTextureStorage2DEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->texture = texture;
   thread_data->target = target;
   thread_data->levels = levels;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTextureStorage2DEXT),
                              thread_mode);
}

/*
 * void
 * glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
 */

typedef void(*GL_TH_FNTYPE(glTextureStorage3DEXT))(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);

typedef struct
{
   GL_TH_FNTYPE(glTextureStorage3DEXT) orig_func;
   GLuint texture;
   GLenum target;
   GLsizei levels;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;
   GLsizei depth;

} GL_TH_ST(glTextureStorage3DEXT);

static void
GL_TH_CB(glTextureStorage3DEXT)(void *data)
{
   GL_TH_ST(glTextureStorage3DEXT) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTextureStorage3DEXT))thread_data->orig_func)
      (thread_data->texture,
       thread_data->target,
       thread_data->levels,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height,
       thread_data->depth);

}

void
GL_TH_FN(glTextureStorage3DEXT)(GL_TH_DP, GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTextureStorage3DEXT) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTextureStorage3DEXT))orig_func)
           (texture, target, levels, internalformat, width, height, depth);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTextureStorage3DEXT) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->texture = texture;
   thread_data->target = target;
   thread_data->levels = levels;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->depth = depth;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTextureStorage3DEXT),
                              thread_mode);
}

/*
 * void
 * glClipPlanefIMG(GLenum a, const GLfloat * b);
 */

typedef void(*GL_TH_FNTYPE(glClipPlanefIMG))(GLenum a, const GLfloat * b);

typedef struct
{
   GL_TH_FNTYPE(glClipPlanefIMG) orig_func;
   GLenum a;
   const GLfloat * b;

} GL_TH_ST(glClipPlanefIMG);

static void
GL_TH_CB(glClipPlanefIMG)(void *data)
{
   GL_TH_ST(glClipPlanefIMG) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClipPlanefIMG))thread_data->orig_func)
      (thread_data->a,
       thread_data->b);

}

void
GL_TH_FN(glClipPlanefIMG)(GL_TH_DP, GLenum a, const GLfloat * b)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClipPlanefIMG) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClipPlanefIMG))orig_func)
           (a, b);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClipPlanefIMG) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->a = a;
   thread_data->b = b;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClipPlanefIMG),
                              thread_mode);
}

/*
 * void
 * glClipPlanexIMG(GLenum a, const GLfixed * b);
 */

typedef void(*GL_TH_FNTYPE(glClipPlanexIMG))(GLenum a, const GLfixed * b);

typedef struct
{
   GL_TH_FNTYPE(glClipPlanexIMG) orig_func;
   GLenum a;
   const GLfixed * b;

} GL_TH_ST(glClipPlanexIMG);

static void
GL_TH_CB(glClipPlanexIMG)(void *data)
{
   GL_TH_ST(glClipPlanexIMG) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClipPlanexIMG))thread_data->orig_func)
      (thread_data->a,
       thread_data->b);

}

void
GL_TH_FN(glClipPlanexIMG)(GL_TH_DP, GLenum a, const GLfixed * b)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClipPlanexIMG) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClipPlanexIMG))orig_func)
           (a, b);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClipPlanexIMG) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->a = a;
   thread_data->b = b;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClipPlanexIMG),
                              thread_mode);
}

/*
 * void
 * glRenderbufferStorageMultisampleIMG(GLenum a, GLsizei b, GLenum c, GLsizei d, GLsizei e);
 */

typedef void(*GL_TH_FNTYPE(glRenderbufferStorageMultisampleIMG))(GLenum a, GLsizei b, GLenum c, GLsizei d, GLsizei e);

typedef struct
{
   GL_TH_FNTYPE(glRenderbufferStorageMultisampleIMG) orig_func;
   GLenum a;
   GLsizei b;
   GLenum c;
   GLsizei d;
   GLsizei e;

} GL_TH_ST(glRenderbufferStorageMultisampleIMG);

static void
GL_TH_CB(glRenderbufferStorageMultisampleIMG)(void *data)
{
   GL_TH_ST(glRenderbufferStorageMultisampleIMG) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glRenderbufferStorageMultisampleIMG))thread_data->orig_func)
      (thread_data->a,
       thread_data->b,
       thread_data->c,
       thread_data->d,
       thread_data->e);

}

void
GL_TH_FN(glRenderbufferStorageMultisampleIMG)(GL_TH_DP, GLenum a, GLsizei b, GLenum c, GLsizei d, GLsizei e)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glRenderbufferStorageMultisampleIMG) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glRenderbufferStorageMultisampleIMG))orig_func)
           (a, b, c, d, e);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glRenderbufferStorageMultisampleIMG) *) + sizeof(GL_TH_ST(glRenderbufferStorageMultisampleIMG)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glRenderbufferStorageMultisampleIMG) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->a = a;
   thread_data->b = b;
   thread_data->c = c;
   thread_data->d = d;
   thread_data->e = e;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glRenderbufferStorageMultisampleIMG),
                              thread_mode);
}

/*
 * void
 * glFramebufferTexture2DMultisampleIMG(GLenum a, GLenum b, GLenum c, GLuint d, GLint e, GLsizei f);
 */

typedef void(*GL_TH_FNTYPE(glFramebufferTexture2DMultisampleIMG))(GLenum a, GLenum b, GLenum c, GLuint d, GLint e, GLsizei f);

typedef struct
{
   GL_TH_FNTYPE(glFramebufferTexture2DMultisampleIMG) orig_func;
   GLenum a;
   GLenum b;
   GLenum c;
   GLuint d;
   GLint e;
   GLsizei f;

} GL_TH_ST(glFramebufferTexture2DMultisampleIMG);

static void
GL_TH_CB(glFramebufferTexture2DMultisampleIMG)(void *data)
{
   GL_TH_ST(glFramebufferTexture2DMultisampleIMG) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFramebufferTexture2DMultisampleIMG))thread_data->orig_func)
      (thread_data->a,
       thread_data->b,
       thread_data->c,
       thread_data->d,
       thread_data->e,
       thread_data->f);

}

void
GL_TH_FN(glFramebufferTexture2DMultisampleIMG)(GL_TH_DP, GLenum a, GLenum b, GLenum c, GLuint d, GLint e, GLsizei f)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFramebufferTexture2DMultisampleIMG) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFramebufferTexture2DMultisampleIMG))orig_func)
           (a, b, c, d, e, f);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFramebufferTexture2DMultisampleIMG) *) + sizeof(GL_TH_ST(glFramebufferTexture2DMultisampleIMG)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glFramebufferTexture2DMultisampleIMG) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->a = a;
   thread_data->b = b;
   thread_data->c = c;
   thread_data->d = d;
   thread_data->e = e;
   thread_data->f = f;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFramebufferTexture2DMultisampleIMG),
                              thread_mode);
}

/*
 * void
 * glActivateTile(GLuint a, GLuint b, GLuint c, GLuint d, GLuint e);
 */

typedef void(*GL_TH_FNTYPE(glActivateTile))(GLuint a, GLuint b, GLuint c, GLuint d, GLuint e);

typedef struct
{
   GL_TH_FNTYPE(glActivateTile) orig_func;
   GLuint a;
   GLuint b;
   GLuint c;
   GLuint d;
   GLuint e;

} GL_TH_ST(glActivateTile);

static void
GL_TH_CB(glActivateTile)(void *data)
{
   GL_TH_ST(glActivateTile) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glActivateTile))thread_data->orig_func)
      (thread_data->a,
       thread_data->b,
       thread_data->c,
       thread_data->d,
       thread_data->e);

}

void
GL_TH_FN(glActivateTile)(GL_TH_DP, GLuint a, GLuint b, GLuint c, GLuint d, GLuint e)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glActivateTile) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glActivateTile))orig_func)
           (a, b, c, d, e);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glActivateTile) *) + sizeof(GL_TH_ST(glActivateTile)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glActivateTile) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->a = a;
   thread_data->b = b;
   thread_data->c = c;
   thread_data->d = d;
   thread_data->e = e;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glActivateTile),
                              thread_mode);
}

/*
 * void
 * glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);
 */

typedef void(*GL_TH_FNTYPE(glStartTilingQCOM))(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);

typedef struct
{
   GL_TH_FNTYPE(glStartTilingQCOM) orig_func;
   GLuint x;
   GLuint y;
   GLuint width;
   GLuint height;
   GLbitfield preserveMask;

} GL_TH_ST(glStartTilingQCOM);

static void
GL_TH_CB(glStartTilingQCOM)(void *data)
{
   GL_TH_ST(glStartTilingQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glStartTilingQCOM))thread_data->orig_func)
      (thread_data->x,
       thread_data->y,
       thread_data->width,
       thread_data->height,
       thread_data->preserveMask);

}

void
GL_TH_FN(glStartTilingQCOM)(GL_TH_DP, GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glStartTilingQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glStartTilingQCOM))orig_func)
           (x, y, width, height, preserveMask);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glStartTilingQCOM) *) + sizeof(GL_TH_ST(glStartTilingQCOM)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glStartTilingQCOM) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->x = x;
   thread_data->y = y;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->preserveMask = preserveMask;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glStartTilingQCOM),
                              thread_mode);
}

/*
 * void
 * glEndTilingQCOM(GLbitfield preserveMask);
 */

typedef void(*GL_TH_FNTYPE(glEndTilingQCOM))(GLbitfield preserveMask);

typedef struct
{
   GL_TH_FNTYPE(glEndTilingQCOM) orig_func;
   GLbitfield preserveMask;

} GL_TH_ST(glEndTilingQCOM);

static void
GL_TH_CB(glEndTilingQCOM)(void *data)
{
   GL_TH_ST(glEndTilingQCOM) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glEndTilingQCOM))thread_data->orig_func)
      (thread_data->preserveMask);

}

void
GL_TH_FN(glEndTilingQCOM)(GL_TH_DP, GLbitfield preserveMask)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glEndTilingQCOM) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glEndTilingQCOM))orig_func)
           (preserveMask);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glEndTilingQCOM) *) + sizeof(GL_TH_ST(glEndTilingQCOM)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glEndTilingQCOM) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->preserveMask = preserveMask;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glEndTilingQCOM),
                              thread_mode);
}

/*
 * void
 * glBeginQuery(GLenum target, GLuint id);
 */

typedef void(*GL_TH_FNTYPE(glBeginQuery))(GLenum target, GLuint id);

typedef struct
{
   GL_TH_FNTYPE(glBeginQuery) orig_func;
   GLenum target;
   GLuint id;

} GL_TH_ST(glBeginQuery);

static void
GL_TH_CB(glBeginQuery)(void *data)
{
   GL_TH_ST(glBeginQuery) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBeginQuery))thread_data->orig_func)
      (thread_data->target,
       thread_data->id);

}

void
GL_TH_FN(glBeginQuery)(GL_TH_DP, GLenum target, GLuint id)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBeginQuery) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBeginQuery))orig_func)
           (target, id);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBeginQuery) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->id = id;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBeginQuery),
                              thread_mode);
}

/*
 * void
 * glBeginTransformFeedback(GLenum primitiveMode);
 */

typedef void(*GL_TH_FNTYPE(glBeginTransformFeedback))(GLenum primitiveMode);

typedef struct
{
   GL_TH_FNTYPE(glBeginTransformFeedback) orig_func;
   GLenum primitiveMode;

} GL_TH_ST(glBeginTransformFeedback);

static void
GL_TH_CB(glBeginTransformFeedback)(void *data)
{
   GL_TH_ST(glBeginTransformFeedback) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBeginTransformFeedback))thread_data->orig_func)
      (thread_data->primitiveMode);

}

void
GL_TH_FN(glBeginTransformFeedback)(GL_TH_DP, GLenum primitiveMode)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBeginTransformFeedback) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBeginTransformFeedback))orig_func)
           (primitiveMode);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBeginTransformFeedback) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->primitiveMode = primitiveMode;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBeginTransformFeedback),
                              thread_mode);
}

/*
 * void
 * glBindBufferBase(GLenum target, GLuint index, GLuint buffer);
 */

typedef void(*GL_TH_FNTYPE(glBindBufferBase))(GLenum target, GLuint index, GLuint buffer);

typedef struct
{
   GL_TH_FNTYPE(glBindBufferBase) orig_func;
   GLenum target;
   GLuint index;
   GLuint buffer;

} GL_TH_ST(glBindBufferBase);

static void
GL_TH_CB(glBindBufferBase)(void *data)
{
   GL_TH_ST(glBindBufferBase) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindBufferBase))thread_data->orig_func)
      (thread_data->target,
       thread_data->index,
       thread_data->buffer);

}

void
GL_TH_FN(glBindBufferBase)(GL_TH_DP, GLenum target, GLuint index, GLuint buffer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindBufferBase) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindBufferBase))orig_func)
           (target, index, buffer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindBufferBase) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->index = index;
   thread_data->buffer = buffer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindBufferBase),
                              thread_mode);
}

/*
 * void
 * glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
 */

typedef void(*GL_TH_FNTYPE(glBindBufferRange))(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);

typedef struct
{
   GL_TH_FNTYPE(glBindBufferRange) orig_func;
   GLenum target;
   GLuint index;
   GLuint buffer;
   GLintptr offset;
   GLsizeiptr size;

} GL_TH_ST(glBindBufferRange);

static void
GL_TH_CB(glBindBufferRange)(void *data)
{
   GL_TH_ST(glBindBufferRange) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindBufferRange))thread_data->orig_func)
      (thread_data->target,
       thread_data->index,
       thread_data->buffer,
       thread_data->offset,
       thread_data->size);

}

void
GL_TH_FN(glBindBufferRange)(GL_TH_DP, GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindBufferRange) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindBufferRange))orig_func)
           (target, index, buffer, offset, size);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindBufferRange) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->index = index;
   thread_data->buffer = buffer;
   thread_data->offset = offset;
   thread_data->size = size;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindBufferRange),
                              thread_mode);
}

/*
 * void
 * glBindSampler(GLuint unit, GLuint sampler);
 */

typedef void(*GL_TH_FNTYPE(glBindSampler))(GLuint unit, GLuint sampler);

typedef struct
{
   GL_TH_FNTYPE(glBindSampler) orig_func;
   GLuint unit;
   GLuint sampler;

} GL_TH_ST(glBindSampler);

static void
GL_TH_CB(glBindSampler)(void *data)
{
   GL_TH_ST(glBindSampler) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindSampler))thread_data->orig_func)
      (thread_data->unit,
       thread_data->sampler);

}

void
GL_TH_FN(glBindSampler)(GL_TH_DP, GLuint unit, GLuint sampler)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindSampler) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindSampler))orig_func)
           (unit, sampler);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindSampler) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->unit = unit;
   thread_data->sampler = sampler;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindSampler),
                              thread_mode);
}

/*
 * void
 * glBindTransformFeedback(GLenum target, GLuint id);
 */

typedef void(*GL_TH_FNTYPE(glBindTransformFeedback))(GLenum target, GLuint id);

typedef struct
{
   GL_TH_FNTYPE(glBindTransformFeedback) orig_func;
   GLenum target;
   GLuint id;

} GL_TH_ST(glBindTransformFeedback);

static void
GL_TH_CB(glBindTransformFeedback)(void *data)
{
   GL_TH_ST(glBindTransformFeedback) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindTransformFeedback))thread_data->orig_func)
      (thread_data->target,
       thread_data->id);

}

void
GL_TH_FN(glBindTransformFeedback)(GL_TH_DP, GLenum target, GLuint id)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindTransformFeedback) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindTransformFeedback))orig_func)
           (target, id);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindTransformFeedback) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->id = id;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindTransformFeedback),
                              thread_mode);
}

/*
 * void
 * glBindVertexArray(GLuint array);
 */

typedef void(*GL_TH_FNTYPE(glBindVertexArray))(GLuint array);

typedef struct
{
   GL_TH_FNTYPE(glBindVertexArray) orig_func;
   GLuint array;

} GL_TH_ST(glBindVertexArray);

static void
GL_TH_CB(glBindVertexArray)(void *data)
{
   GL_TH_ST(glBindVertexArray) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindVertexArray))thread_data->orig_func)
      (thread_data->array);

}

void
GL_TH_FN(glBindVertexArray)(GL_TH_DP, GLuint array)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindVertexArray) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindVertexArray))orig_func)
           (array);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindVertexArray) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->array = array;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindVertexArray),
                              thread_mode);
}

/*
 * void
 * glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
 */

typedef void(*GL_TH_FNTYPE(glBlitFramebuffer))(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);

typedef struct
{
   GL_TH_FNTYPE(glBlitFramebuffer) orig_func;
   GLint srcX0;
   GLint srcY0;
   GLint srcX1;
   GLint srcY1;
   GLint dstX0;
   GLint dstY0;
   GLint dstX1;
   GLint dstY1;
   GLbitfield mask;
   GLenum filter;

} GL_TH_ST(glBlitFramebuffer);

static void
GL_TH_CB(glBlitFramebuffer)(void *data)
{
   GL_TH_ST(glBlitFramebuffer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBlitFramebuffer))thread_data->orig_func)
      (thread_data->srcX0,
       thread_data->srcY0,
       thread_data->srcX1,
       thread_data->srcY1,
       thread_data->dstX0,
       thread_data->dstY0,
       thread_data->dstX1,
       thread_data->dstY1,
       thread_data->mask,
       thread_data->filter);

}

void
GL_TH_FN(glBlitFramebuffer)(GL_TH_DP, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBlitFramebuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBlitFramebuffer))orig_func)
           (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBlitFramebuffer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->srcX0 = srcX0;
   thread_data->srcY0 = srcY0;
   thread_data->srcX1 = srcX1;
   thread_data->srcY1 = srcY1;
   thread_data->dstX0 = dstX0;
   thread_data->dstY0 = dstY0;
   thread_data->dstX1 = dstX1;
   thread_data->dstY1 = dstY1;
   thread_data->mask = mask;
   thread_data->filter = filter;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBlitFramebuffer),
                              thread_mode);
}

/*
 * void
 * glClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);
 */

typedef void(*GL_TH_FNTYPE(glClearBufferfi))(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);

typedef struct
{
   GL_TH_FNTYPE(glClearBufferfi) orig_func;
   GLenum buffer;
   GLint drawBuffer;
   GLfloat depth;
   GLint stencil;

} GL_TH_ST(glClearBufferfi);

static void
GL_TH_CB(glClearBufferfi)(void *data)
{
   GL_TH_ST(glClearBufferfi) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClearBufferfi))thread_data->orig_func)
      (thread_data->buffer,
       thread_data->drawBuffer,
       thread_data->depth,
       thread_data->stencil);

}

void
GL_TH_FN(glClearBufferfi)(GL_TH_DP, GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClearBufferfi) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClearBufferfi))orig_func)
           (buffer, drawBuffer, depth, stencil);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClearBufferfi) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->buffer = buffer;
   thread_data->drawBuffer = drawBuffer;
   thread_data->depth = depth;
   thread_data->stencil = stencil;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClearBufferfi),
                              thread_mode);
}

/*
 * void
 * glClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat * value);
 */

typedef void(*GL_TH_FNTYPE(glClearBufferfv))(GLenum buffer, GLint drawBuffer, const GLfloat * value);

typedef struct
{
   GL_TH_FNTYPE(glClearBufferfv) orig_func;
   GLenum buffer;
   GLint drawBuffer;
   const GLfloat * value;

} GL_TH_ST(glClearBufferfv);

static void
GL_TH_CB(glClearBufferfv)(void *data)
{
   GL_TH_ST(glClearBufferfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClearBufferfv))thread_data->orig_func)
      (thread_data->buffer,
       thread_data->drawBuffer,
       thread_data->value);

}

void
GL_TH_FN(glClearBufferfv)(GL_TH_DP, GLenum buffer, GLint drawBuffer, const GLfloat * value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClearBufferfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClearBufferfv))orig_func)
           (buffer, drawBuffer, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClearBufferfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->buffer = buffer;
   thread_data->drawBuffer = drawBuffer;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClearBufferfv),
                              thread_mode);
}

/*
 * void
 * glClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint * value);
 */

typedef void(*GL_TH_FNTYPE(glClearBufferiv))(GLenum buffer, GLint drawBuffer, const GLint * value);

typedef struct
{
   GL_TH_FNTYPE(glClearBufferiv) orig_func;
   GLenum buffer;
   GLint drawBuffer;
   const GLint * value;

} GL_TH_ST(glClearBufferiv);

static void
GL_TH_CB(glClearBufferiv)(void *data)
{
   GL_TH_ST(glClearBufferiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClearBufferiv))thread_data->orig_func)
      (thread_data->buffer,
       thread_data->drawBuffer,
       thread_data->value);

}

void
GL_TH_FN(glClearBufferiv)(GL_TH_DP, GLenum buffer, GLint drawBuffer, const GLint * value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClearBufferiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClearBufferiv))orig_func)
           (buffer, drawBuffer, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClearBufferiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->buffer = buffer;
   thread_data->drawBuffer = drawBuffer;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClearBufferiv),
                              thread_mode);
}

/*
 * void
 * glClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint * value);
 */

typedef void(*GL_TH_FNTYPE(glClearBufferuiv))(GLenum buffer, GLint drawBuffer, const GLuint * value);

typedef struct
{
   GL_TH_FNTYPE(glClearBufferuiv) orig_func;
   GLenum buffer;
   GLint drawBuffer;
   const GLuint * value;

} GL_TH_ST(glClearBufferuiv);

static void
GL_TH_CB(glClearBufferuiv)(void *data)
{
   GL_TH_ST(glClearBufferuiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glClearBufferuiv))thread_data->orig_func)
      (thread_data->buffer,
       thread_data->drawBuffer,
       thread_data->value);

}

void
GL_TH_FN(glClearBufferuiv)(GL_TH_DP, GLenum buffer, GLint drawBuffer, const GLuint * value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClearBufferuiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glClearBufferuiv))orig_func)
           (buffer, drawBuffer, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClearBufferuiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->buffer = buffer;
   thread_data->drawBuffer = drawBuffer;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClearBufferuiv),
                              thread_mode);
}

/*
 * GLenum
 * glClientWaitSync(GLsync sync, GLbitfield flags, EvasGLuint64 timeout);
 */

typedef GLenum(*GL_TH_FNTYPE(glClientWaitSync))(GLsync sync, GLbitfield flags, EvasGLuint64 timeout);

typedef struct
{
   GL_TH_FNTYPE(glClientWaitSync) orig_func;
   GLenum return_value;
   GLsync sync;
   GLbitfield flags;
   EvasGLuint64 timeout;

} GL_TH_ST(glClientWaitSync);

static void
GL_TH_CB(glClientWaitSync)(void *data)
{
   GL_TH_ST(glClientWaitSync) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glClientWaitSync))thread_data->orig_func)
      (thread_data->sync,
       thread_data->flags,
       thread_data->timeout);

}

GLenum
GL_TH_FN(glClientWaitSync)(GL_TH_DP, GLsync sync, GLbitfield flags, EvasGLuint64 timeout)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glClientWaitSync) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glClientWaitSync))orig_func)
           (sync, flags, timeout);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glClientWaitSync) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sync = sync;
   thread_data->flags = flags;
   thread_data->timeout = timeout;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glClientWaitSync),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data);
 */

typedef void(*GL_TH_FNTYPE(glCompressedTexImage3D))(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data);

typedef struct
{
   GL_TH_FNTYPE(glCompressedTexImage3D) orig_func;
   GLenum target;
   GLint level;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;
   GLsizei depth;
   GLint border;
   GLsizei imageSize;
   const GLvoid * data;

} GL_TH_ST(glCompressedTexImage3D);

static void
GL_TH_CB(glCompressedTexImage3D)(void *data)
{
   GL_TH_ST(glCompressedTexImage3D) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCompressedTexImage3D))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height,
       thread_data->depth,
       thread_data->border,
       thread_data->imageSize,
       thread_data->data);

}

void
GL_TH_FN(glCompressedTexImage3D)(GL_TH_DP, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCompressedTexImage3D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCompressedTexImage3D))orig_func)
           (target, level, internalformat, width, height, depth, border, imageSize, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCompressedTexImage3D) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->depth = depth;
   thread_data->border = border;
   thread_data->imageSize = imageSize;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCompressedTexImage3D),
                              thread_mode);
}

/*
 * void
 * glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data);
 */

typedef void(*GL_TH_FNTYPE(glCompressedTexSubImage3D))(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data);

typedef struct
{
   GL_TH_FNTYPE(glCompressedTexSubImage3D) orig_func;
   GLenum target;
   GLint level;
   GLint xoffset;
   GLint yoffset;
   GLint zoffset;
   GLsizei width;
   GLsizei height;
   GLsizei depth;
   GLenum format;
   GLsizei imageSize;
   const GLvoid * data;

} GL_TH_ST(glCompressedTexSubImage3D);

static void
GL_TH_CB(glCompressedTexSubImage3D)(void *data)
{
   GL_TH_ST(glCompressedTexSubImage3D) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCompressedTexSubImage3D))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->xoffset,
       thread_data->yoffset,
       thread_data->zoffset,
       thread_data->width,
       thread_data->height,
       thread_data->depth,
       thread_data->format,
       thread_data->imageSize,
       thread_data->data);

}

void
GL_TH_FN(glCompressedTexSubImage3D)(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCompressedTexSubImage3D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCompressedTexSubImage3D))orig_func)
           (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCompressedTexSubImage3D) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->xoffset = xoffset;
   thread_data->yoffset = yoffset;
   thread_data->zoffset = zoffset;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->depth = depth;
   thread_data->format = format;
   thread_data->imageSize = imageSize;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCompressedTexSubImage3D),
                              thread_mode);
}

/*
 * void
 * glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
 */

typedef void(*GL_TH_FNTYPE(glCopyBufferSubData))(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);

typedef struct
{
   GL_TH_FNTYPE(glCopyBufferSubData) orig_func;
   GLenum readtarget;
   GLenum writetarget;
   GLintptr readoffset;
   GLintptr writeoffset;
   GLsizeiptr size;

} GL_TH_ST(glCopyBufferSubData);

static void
GL_TH_CB(glCopyBufferSubData)(void *data)
{
   GL_TH_ST(glCopyBufferSubData) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCopyBufferSubData))thread_data->orig_func)
      (thread_data->readtarget,
       thread_data->writetarget,
       thread_data->readoffset,
       thread_data->writeoffset,
       thread_data->size);

}

void
GL_TH_FN(glCopyBufferSubData)(GL_TH_DP, GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCopyBufferSubData) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCopyBufferSubData))orig_func)
           (readtarget, writetarget, readoffset, writeoffset, size);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCopyBufferSubData) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->readtarget = readtarget;
   thread_data->writetarget = writetarget;
   thread_data->readoffset = readoffset;
   thread_data->writeoffset = writeoffset;
   thread_data->size = size;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCopyBufferSubData),
                              thread_mode);
}

/*
 * void
 * glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
 */

typedef void(*GL_TH_FNTYPE(glCopyTexSubImage3D))(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);

typedef struct
{
   GL_TH_FNTYPE(glCopyTexSubImage3D) orig_func;
   GLenum target;
   GLint level;
   GLint xoffset;
   GLint yoffset;
   GLint zoffset;
   GLint x;
   GLint y;
   GLsizei width;
   GLsizei height;

} GL_TH_ST(glCopyTexSubImage3D);

static void
GL_TH_CB(glCopyTexSubImage3D)(void *data)
{
   GL_TH_ST(glCopyTexSubImage3D) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glCopyTexSubImage3D))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->xoffset,
       thread_data->yoffset,
       thread_data->zoffset,
       thread_data->x,
       thread_data->y,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glCopyTexSubImage3D)(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCopyTexSubImage3D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glCopyTexSubImage3D))orig_func)
           (target, level, xoffset, yoffset, zoffset, x, y, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCopyTexSubImage3D) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->xoffset = xoffset;
   thread_data->yoffset = yoffset;
   thread_data->zoffset = zoffset;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCopyTexSubImage3D),
                              thread_mode);
}

/*
 * void
 * glDeleteQueries(GLsizei n, const GLuint * ids);
 */

typedef void(*GL_TH_FNTYPE(glDeleteQueries))(GLsizei n, const GLuint * ids);

typedef struct
{
   GL_TH_FNTYPE(glDeleteQueries) orig_func;
   GLsizei n;
   const GLuint * ids;

} GL_TH_ST(glDeleteQueries);

static void
GL_TH_CB(glDeleteQueries)(void *data)
{
   GL_TH_ST(glDeleteQueries) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteQueries))thread_data->orig_func)
      (thread_data->n,
       thread_data->ids);

}

void
GL_TH_FN(glDeleteQueries)(GL_TH_DP, GLsizei n, const GLuint * ids)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteQueries) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteQueries))orig_func)
           (n, ids);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteQueries) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->ids = ids;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteQueries),
                              thread_mode);
}

/*
 * void
 * glDeleteSamplers(GLsizei n, const GLuint * samplers);
 */

typedef void(*GL_TH_FNTYPE(glDeleteSamplers))(GLsizei n, const GLuint * samplers);

typedef struct
{
   GL_TH_FNTYPE(glDeleteSamplers) orig_func;
   GLsizei n;
   const GLuint * samplers;

} GL_TH_ST(glDeleteSamplers);

static void
GL_TH_CB(glDeleteSamplers)(void *data)
{
   GL_TH_ST(glDeleteSamplers) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteSamplers))thread_data->orig_func)
      (thread_data->n,
       thread_data->samplers);

}

void
GL_TH_FN(glDeleteSamplers)(GL_TH_DP, GLsizei n, const GLuint * samplers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteSamplers) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteSamplers))orig_func)
           (n, samplers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteSamplers) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->samplers = samplers;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteSamplers),
                              thread_mode);
}

/*
 * void
 * glDeleteSync(GLsync sync);
 */

typedef void(*GL_TH_FNTYPE(glDeleteSync))(GLsync sync);

typedef struct
{
   GL_TH_FNTYPE(glDeleteSync) orig_func;
   GLsync sync;

} GL_TH_ST(glDeleteSync);

static void
GL_TH_CB(glDeleteSync)(void *data)
{
   GL_TH_ST(glDeleteSync) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteSync))thread_data->orig_func)
      (thread_data->sync);

}

void
GL_TH_FN(glDeleteSync)(GL_TH_DP, GLsync sync)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteSync) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteSync))orig_func)
           (sync);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteSync) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sync = sync;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteSync),
                              thread_mode);
}

/*
 * void
 * glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids);
 */

typedef void(*GL_TH_FNTYPE(glDeleteTransformFeedbacks))(GLsizei n, const GLuint *ids);

typedef struct
{
   GL_TH_FNTYPE(glDeleteTransformFeedbacks) orig_func;
   GLsizei n;
   const GLuint *ids;

} GL_TH_ST(glDeleteTransformFeedbacks);

static void
GL_TH_CB(glDeleteTransformFeedbacks)(void *data)
{
   GL_TH_ST(glDeleteTransformFeedbacks) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteTransformFeedbacks))thread_data->orig_func)
      (thread_data->n,
       thread_data->ids);

}

void
GL_TH_FN(glDeleteTransformFeedbacks)(GL_TH_DP, GLsizei n, const GLuint *ids)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteTransformFeedbacks) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteTransformFeedbacks))orig_func)
           (n, ids);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteTransformFeedbacks) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->ids = ids;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteTransformFeedbacks),
                              thread_mode);
}

/*
 * void
 * glDeleteVertexArrays(GLsizei n, const GLuint *arrays);
 */

typedef void(*GL_TH_FNTYPE(glDeleteVertexArrays))(GLsizei n, const GLuint *arrays);

typedef struct
{
   GL_TH_FNTYPE(glDeleteVertexArrays) orig_func;
   GLsizei n;
   const GLuint *arrays;

} GL_TH_ST(glDeleteVertexArrays);

static void
GL_TH_CB(glDeleteVertexArrays)(void *data)
{
   GL_TH_ST(glDeleteVertexArrays) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteVertexArrays))thread_data->orig_func)
      (thread_data->n,
       thread_data->arrays);

}

void
GL_TH_FN(glDeleteVertexArrays)(GL_TH_DP, GLsizei n, const GLuint *arrays)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteVertexArrays) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteVertexArrays))orig_func)
           (n, arrays);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteVertexArrays) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->arrays = arrays;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteVertexArrays),
                              thread_mode);
}

/*
 * void
 * glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
 */

typedef void(*GL_TH_FNTYPE(glDrawArraysInstanced))(GLenum mode, GLint first, GLsizei count, GLsizei primcount);

typedef struct
{
   GL_TH_FNTYPE(glDrawArraysInstanced) orig_func;
   GLenum mode;
   GLint first;
   GLsizei count;
   GLsizei primcount;

} GL_TH_ST(glDrawArraysInstanced);

static void
GL_TH_CB(glDrawArraysInstanced)(void *data)
{
   GL_TH_ST(glDrawArraysInstanced) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawArraysInstanced))thread_data->orig_func)
      (thread_data->mode,
       thread_data->first,
       thread_data->count,
       thread_data->primcount);

}

void
GL_TH_FN(glDrawArraysInstanced)(GL_TH_DP, GLenum mode, GLint first, GLsizei count, GLsizei primcount)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawArraysInstanced) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawArraysInstanced))orig_func)
           (mode, first, count, primcount);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawArraysInstanced) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->first = first;
   thread_data->count = count;
   thread_data->primcount = primcount;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawArraysInstanced),
                              thread_mode);
}

/*
 * void
 * glDrawBuffers(GLsizei n, const GLenum *bufs);
 */

typedef void(*GL_TH_FNTYPE(glDrawBuffers))(GLsizei n, const GLenum *bufs);

typedef struct
{
   GL_TH_FNTYPE(glDrawBuffers) orig_func;
   GLsizei n;
   const GLenum *bufs;

} GL_TH_ST(glDrawBuffers);

static void
GL_TH_CB(glDrawBuffers)(void *data)
{
   GL_TH_ST(glDrawBuffers) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawBuffers))thread_data->orig_func)
      (thread_data->n,
       thread_data->bufs);

}

void
GL_TH_FN(glDrawBuffers)(GL_TH_DP, GLsizei n, const GLenum *bufs)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawBuffers) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawBuffers))orig_func)
           (n, bufs);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawBuffers) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->bufs = bufs;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawBuffers),
                              thread_mode);
}

/*
 * void
 * glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);
 */

typedef void(*GL_TH_FNTYPE(glDrawElementsInstanced))(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);

typedef struct
{
   GL_TH_FNTYPE(glDrawElementsInstanced) orig_func;
   GLenum mode;
   GLsizei count;
   GLenum type;
   const void * indices;
   GLsizei primcount;

} GL_TH_ST(glDrawElementsInstanced);

static void
GL_TH_CB(glDrawElementsInstanced)(void *data)
{
   GL_TH_ST(glDrawElementsInstanced) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawElementsInstanced))thread_data->orig_func)
      (thread_data->mode,
       thread_data->count,
       thread_data->type,
       thread_data->indices,
       thread_data->primcount);

}

void
GL_TH_FN(glDrawElementsInstanced)(GL_TH_DP, GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawElementsInstanced) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawElementsInstanced))orig_func)
           (mode, count, type, indices, primcount);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawElementsInstanced) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->count = count;
   thread_data->type = type;
   thread_data->indices = indices;
   thread_data->primcount = primcount;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawElementsInstanced),
                              thread_mode);
}

/*
 * void
 * glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices);
 */

typedef void(*GL_TH_FNTYPE(glDrawRangeElements))(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices);

typedef struct
{
   GL_TH_FNTYPE(glDrawRangeElements) orig_func;
   GLenum mode;
   GLuint start;
   GLuint end;
   GLsizei count;
   GLenum type;
   const GLvoid * indices;

} GL_TH_ST(glDrawRangeElements);

static void
GL_TH_CB(glDrawRangeElements)(void *data)
{
   GL_TH_ST(glDrawRangeElements) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawRangeElements))thread_data->orig_func)
      (thread_data->mode,
       thread_data->start,
       thread_data->end,
       thread_data->count,
       thread_data->type,
       thread_data->indices);

}

void
GL_TH_FN(glDrawRangeElements)(GL_TH_DP, GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawRangeElements) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawRangeElements))orig_func)
           (mode, start, end, count, type, indices);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawRangeElements) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->start = start;
   thread_data->end = end;
   thread_data->count = count;
   thread_data->type = type;
   thread_data->indices = indices;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawRangeElements),
                              thread_mode);
}

/*
 * void
 * glEndQuery(GLenum target);
 */

typedef void(*GL_TH_FNTYPE(glEndQuery))(GLenum target);

typedef struct
{
   GL_TH_FNTYPE(glEndQuery) orig_func;
   GLenum target;

} GL_TH_ST(glEndQuery);

static void
GL_TH_CB(glEndQuery)(void *data)
{
   GL_TH_ST(glEndQuery) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glEndQuery))thread_data->orig_func)
      (thread_data->target);

}

void
GL_TH_FN(glEndQuery)(GL_TH_DP, GLenum target)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glEndQuery) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glEndQuery))orig_func)
           (target);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glEndQuery) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glEndQuery),
                              thread_mode);
}

/*
 * void
 * glEndTransformFeedback(void);
 */

typedef void(*GL_TH_FNTYPE(glEndTransformFeedback))(void);

typedef struct
{
   GL_TH_FNTYPE(glEndTransformFeedback) orig_func;

} GL_TH_ST(glEndTransformFeedback);

static void
GL_TH_CB(glEndTransformFeedback)(void *data)
{
   GL_TH_ST(glEndTransformFeedback) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glEndTransformFeedback))thread_data->orig_func)
      ();

}

void
GL_TH_FN(glEndTransformFeedback)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glEndTransformFeedback) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glEndTransformFeedback))orig_func)
           ();
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glEndTransformFeedback) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glEndTransformFeedback),
                              thread_mode);
}

/*
 * GLsync
 * glFenceSync(GLenum condition, GLbitfield flags);
 */

typedef GLsync(*GL_TH_FNTYPE(glFenceSync))(GLenum condition, GLbitfield flags);

typedef struct
{
   GL_TH_FNTYPE(glFenceSync) orig_func;
   GLsync return_value;
   GLenum condition;
   GLbitfield flags;

} GL_TH_ST(glFenceSync);

static void
GL_TH_CB(glFenceSync)(void *data)
{
   GL_TH_ST(glFenceSync) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glFenceSync))thread_data->orig_func)
      (thread_data->condition,
       thread_data->flags);

}

GLsync
GL_TH_FN(glFenceSync)(GL_TH_DP, GLenum condition, GLbitfield flags)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFenceSync) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glFenceSync))orig_func)
           (condition, flags);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFenceSync) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->condition = condition;
   thread_data->flags = flags;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFenceSync),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLsync
 * glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);
 */

typedef GLsync(*GL_TH_FNTYPE(glFlushMappedBufferRange))(GLenum target, GLintptr offset, GLsizeiptr length);

typedef struct
{
   GL_TH_FNTYPE(glFlushMappedBufferRange) orig_func;
   GLsync return_value;
   GLenum target;
   GLintptr offset;
   GLsizeiptr length;

} GL_TH_ST(glFlushMappedBufferRange);

static void
GL_TH_CB(glFlushMappedBufferRange)(void *data)
{
   GL_TH_ST(glFlushMappedBufferRange) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glFlushMappedBufferRange))thread_data->orig_func)
      (thread_data->target,
       thread_data->offset,
       thread_data->length);

}

GLsync
GL_TH_FN(glFlushMappedBufferRange)(GL_TH_DP, GLenum target, GLintptr offset, GLsizeiptr length)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFlushMappedBufferRange) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glFlushMappedBufferRange))orig_func)
           (target, offset, length);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFlushMappedBufferRange) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->offset = offset;
   thread_data->length = length;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFlushMappedBufferRange),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
 */

typedef void(*GL_TH_FNTYPE(glFramebufferTextureLayer))(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);

typedef struct
{
   GL_TH_FNTYPE(glFramebufferTextureLayer) orig_func;
   GLenum target;
   GLenum attachment;
   GLuint texture;
   GLint level;
   GLint layer;

} GL_TH_ST(glFramebufferTextureLayer);

static void
GL_TH_CB(glFramebufferTextureLayer)(void *data)
{
   GL_TH_ST(glFramebufferTextureLayer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFramebufferTextureLayer))thread_data->orig_func)
      (thread_data->target,
       thread_data->attachment,
       thread_data->texture,
       thread_data->level,
       thread_data->layer);

}

void
GL_TH_FN(glFramebufferTextureLayer)(GL_TH_DP, GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFramebufferTextureLayer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFramebufferTextureLayer))orig_func)
           (target, attachment, texture, level, layer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFramebufferTextureLayer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->attachment = attachment;
   thread_data->texture = texture;
   thread_data->level = level;
   thread_data->layer = layer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFramebufferTextureLayer),
                              thread_mode);
}

/*
 * void
 * glGenQueries(GLsizei n, GLuint * ids);
 */

typedef void(*GL_TH_FNTYPE(glGenQueries))(GLsizei n, GLuint * ids);

typedef struct
{
   GL_TH_FNTYPE(glGenQueries) orig_func;
   GLsizei n;
   GLuint * ids;

} GL_TH_ST(glGenQueries);

static void
GL_TH_CB(glGenQueries)(void *data)
{
   GL_TH_ST(glGenQueries) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenQueries))thread_data->orig_func)
      (thread_data->n,
       thread_data->ids);

}

void
GL_TH_FN(glGenQueries)(GL_TH_DP, GLsizei n, GLuint * ids)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenQueries) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenQueries))orig_func)
           (n, ids);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenQueries) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->ids = ids;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenQueries),
                              thread_mode);
}

/*
 * void
 * glGenSamplers(GLsizei n, GLuint *samplers);
 */

typedef void(*GL_TH_FNTYPE(glGenSamplers))(GLsizei n, GLuint *samplers);

typedef struct
{
   GL_TH_FNTYPE(glGenSamplers) orig_func;
   GLsizei n;
   GLuint *samplers;

} GL_TH_ST(glGenSamplers);

static void
GL_TH_CB(glGenSamplers)(void *data)
{
   GL_TH_ST(glGenSamplers) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenSamplers))thread_data->orig_func)
      (thread_data->n,
       thread_data->samplers);

}

void
GL_TH_FN(glGenSamplers)(GL_TH_DP, GLsizei n, GLuint *samplers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenSamplers) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenSamplers))orig_func)
           (n, samplers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenSamplers) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->samplers = samplers;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenSamplers),
                              thread_mode);
}

/*
 * void
 * glGenTransformFeedbacks(GLsizei n, GLuint *ids);
 */

typedef void(*GL_TH_FNTYPE(glGenTransformFeedbacks))(GLsizei n, GLuint *ids);

typedef struct
{
   GL_TH_FNTYPE(glGenTransformFeedbacks) orig_func;
   GLsizei n;
   GLuint *ids;

} GL_TH_ST(glGenTransformFeedbacks);

static void
GL_TH_CB(glGenTransformFeedbacks)(void *data)
{
   GL_TH_ST(glGenTransformFeedbacks) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenTransformFeedbacks))thread_data->orig_func)
      (thread_data->n,
       thread_data->ids);

}

void
GL_TH_FN(glGenTransformFeedbacks)(GL_TH_DP, GLsizei n, GLuint *ids)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenTransformFeedbacks) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenTransformFeedbacks))orig_func)
           (n, ids);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenTransformFeedbacks) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->ids = ids;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenTransformFeedbacks),
                              thread_mode);
}

/*
 * void
 * glGenVertexArrays(GLsizei n, GLuint *arrays);
 */

typedef void(*GL_TH_FNTYPE(glGenVertexArrays))(GLsizei n, GLuint *arrays);

typedef struct
{
   GL_TH_FNTYPE(glGenVertexArrays) orig_func;
   GLsizei n;
   GLuint *arrays;

} GL_TH_ST(glGenVertexArrays);

static void
GL_TH_CB(glGenVertexArrays)(void *data)
{
   GL_TH_ST(glGenVertexArrays) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenVertexArrays))thread_data->orig_func)
      (thread_data->n,
       thread_data->arrays);

}

void
GL_TH_FN(glGenVertexArrays)(GL_TH_DP, GLsizei n, GLuint *arrays)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenVertexArrays) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenVertexArrays))orig_func)
           (n, arrays);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenVertexArrays) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->arrays = arrays;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenVertexArrays),
                              thread_mode);
}

/*
 * void
 * glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetActiveUniformBlockiv))(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetActiveUniformBlockiv) orig_func;
   GLuint program;
   GLuint uniformBlockIndex;
   GLenum pname;
   GLint *params;

} GL_TH_ST(glGetActiveUniformBlockiv);

static void
GL_TH_CB(glGetActiveUniformBlockiv)(void *data)
{
   GL_TH_ST(glGetActiveUniformBlockiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetActiveUniformBlockiv))thread_data->orig_func)
      (thread_data->program,
       thread_data->uniformBlockIndex,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetActiveUniformBlockiv)(GL_TH_DP, GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetActiveUniformBlockiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetActiveUniformBlockiv))orig_func)
           (program, uniformBlockIndex, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetActiveUniformBlockiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->uniformBlockIndex = uniformBlockIndex;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetActiveUniformBlockiv),
                              thread_mode);
}

/*
 * void
 * glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
 */

typedef void(*GL_TH_FNTYPE(glGetActiveUniformBlockName))(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);

typedef struct
{
   GL_TH_FNTYPE(glGetActiveUniformBlockName) orig_func;
   GLuint program;
   GLuint uniformBlockIndex;
   GLsizei bufSize;
   GLsizei *length;
   GLchar *uniformBlockName;

} GL_TH_ST(glGetActiveUniformBlockName);

static void
GL_TH_CB(glGetActiveUniformBlockName)(void *data)
{
   GL_TH_ST(glGetActiveUniformBlockName) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetActiveUniformBlockName))thread_data->orig_func)
      (thread_data->program,
       thread_data->uniformBlockIndex,
       thread_data->bufSize,
       thread_data->length,
       thread_data->uniformBlockName);

}

void
GL_TH_FN(glGetActiveUniformBlockName)(GL_TH_DP, GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetActiveUniformBlockName) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetActiveUniformBlockName))orig_func)
           (program, uniformBlockIndex, bufSize, length, uniformBlockName);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetActiveUniformBlockName) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->uniformBlockIndex = uniformBlockIndex;
   thread_data->bufSize = bufSize;
   thread_data->length = length;
   thread_data->uniformBlockName = uniformBlockName;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetActiveUniformBlockName),
                              thread_mode);
}

/*
 * void
 * glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetActiveUniformsiv))(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetActiveUniformsiv) orig_func;
   GLuint program;
   GLsizei uniformCount;
   const GLuint *uniformIndices;
   GLenum pname;
   GLint *params;

} GL_TH_ST(glGetActiveUniformsiv);

static void
GL_TH_CB(glGetActiveUniformsiv)(void *data)
{
   GL_TH_ST(glGetActiveUniformsiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetActiveUniformsiv))thread_data->orig_func)
      (thread_data->program,
       thread_data->uniformCount,
       thread_data->uniformIndices,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetActiveUniformsiv)(GL_TH_DP, GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetActiveUniformsiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetActiveUniformsiv))orig_func)
           (program, uniformCount, uniformIndices, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetActiveUniformsiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->uniformCount = uniformCount;
   thread_data->uniformIndices = uniformIndices;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetActiveUniformsiv),
                              thread_mode);
}

/*
 * void
 * glGetBufferParameteri64v(GLenum target, GLenum value, EvasGLint64 * data);
 */

typedef void(*GL_TH_FNTYPE(glGetBufferParameteri64v))(GLenum target, GLenum value, EvasGLint64 * data);

typedef struct
{
   GL_TH_FNTYPE(glGetBufferParameteri64v) orig_func;
   GLenum target;
   GLenum value;
   EvasGLint64 * data;

} GL_TH_ST(glGetBufferParameteri64v);

static void
GL_TH_CB(glGetBufferParameteri64v)(void *data)
{
   GL_TH_ST(glGetBufferParameteri64v) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetBufferParameteri64v))thread_data->orig_func)
      (thread_data->target,
       thread_data->value,
       thread_data->data);

}

void
GL_TH_FN(glGetBufferParameteri64v)(GL_TH_DP, GLenum target, GLenum value, EvasGLint64 * data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetBufferParameteri64v) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetBufferParameteri64v))orig_func)
           (target, value, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetBufferParameteri64v) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->value = value;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetBufferParameteri64v),
                              thread_mode);
}

/*
 * void
 * glGetBufferPointerv(GLenum target, GLenum pname, GLvoid ** params);
 */

typedef void(*GL_TH_FNTYPE(glGetBufferPointerv))(GLenum target, GLenum pname, GLvoid ** params);

typedef struct
{
   GL_TH_FNTYPE(glGetBufferPointerv) orig_func;
   GLenum target;
   GLenum pname;
   GLvoid ** params;

} GL_TH_ST(glGetBufferPointerv);

static void
GL_TH_CB(glGetBufferPointerv)(void *data)
{
   GL_TH_ST(glGetBufferPointerv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetBufferPointerv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetBufferPointerv)(GL_TH_DP, GLenum target, GLenum pname, GLvoid ** params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetBufferPointerv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetBufferPointerv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetBufferPointerv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetBufferPointerv),
                              thread_mode);
}

/*
 * GLint
 * glGetFragDataLocation(GLuint program, const char * name);
 */

typedef GLint(*GL_TH_FNTYPE(glGetFragDataLocation))(GLuint program, const char * name);

typedef struct
{
   GL_TH_FNTYPE(glGetFragDataLocation) orig_func;
   GLint return_value;
   GLuint program;
   const char * name;

} GL_TH_ST(glGetFragDataLocation);

static void
GL_TH_CB(glGetFragDataLocation)(void *data)
{
   GL_TH_ST(glGetFragDataLocation) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glGetFragDataLocation))thread_data->orig_func)
      (thread_data->program,
       thread_data->name);

}

GLint
GL_TH_FN(glGetFragDataLocation)(GL_TH_DP, GLuint program, const char * name)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetFragDataLocation) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glGetFragDataLocation))orig_func)
           (program, name);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetFragDataLocation) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->name = name;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetFragDataLocation),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glGetInteger64i_v(GLenum target, GLuint index, EvasGLint64 * data);
 */

typedef void(*GL_TH_FNTYPE(glGetInteger64i_v))(GLenum target, GLuint index, EvasGLint64 * data);

typedef struct
{
   GL_TH_FNTYPE(glGetInteger64i_v) orig_func;
   GLenum target;
   GLuint index;
   EvasGLint64 * data;

} GL_TH_ST(glGetInteger64i_v);

static void
GL_TH_CB(glGetInteger64i_v)(void *data)
{
   GL_TH_ST(glGetInteger64i_v) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetInteger64i_v))thread_data->orig_func)
      (thread_data->target,
       thread_data->index,
       thread_data->data);

}

void
GL_TH_FN(glGetInteger64i_v)(GL_TH_DP, GLenum target, GLuint index, EvasGLint64 * data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetInteger64i_v) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetInteger64i_v))orig_func)
           (target, index, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetInteger64i_v) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->index = index;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetInteger64i_v),
                              thread_mode);
}

/*
 * void
 * glGetInteger64v(GLenum pname, EvasGLint64 * data);
 */

typedef void(*GL_TH_FNTYPE(glGetInteger64v))(GLenum pname, EvasGLint64 * data);

typedef struct
{
   GL_TH_FNTYPE(glGetInteger64v) orig_func;
   GLenum pname;
   EvasGLint64 * data;

} GL_TH_ST(glGetInteger64v);

static void
GL_TH_CB(glGetInteger64v)(void *data)
{
   GL_TH_ST(glGetInteger64v) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetInteger64v))thread_data->orig_func)
      (thread_data->pname,
       thread_data->data);

}

void
GL_TH_FN(glGetInteger64v)(GL_TH_DP, GLenum pname, EvasGLint64 * data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetInteger64v) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetInteger64v))orig_func)
           (pname, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetInteger64v) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetInteger64v),
                              thread_mode);
}

/*
 * void
 * glGetIntegeri_v(GLenum target, GLuint index, GLint * data);
 */

typedef void(*GL_TH_FNTYPE(glGetIntegeri_v))(GLenum target, GLuint index, GLint * data);

typedef struct
{
   GL_TH_FNTYPE(glGetIntegeri_v) orig_func;
   GLenum target;
   GLuint index;
   GLint * data;

} GL_TH_ST(glGetIntegeri_v);

static void
GL_TH_CB(glGetIntegeri_v)(void *data)
{
   GL_TH_ST(glGetIntegeri_v) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetIntegeri_v))thread_data->orig_func)
      (thread_data->target,
       thread_data->index,
       thread_data->data);

}

void
GL_TH_FN(glGetIntegeri_v)(GL_TH_DP, GLenum target, GLuint index, GLint * data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetIntegeri_v) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetIntegeri_v))orig_func)
           (target, index, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetIntegeri_v) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->index = index;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetIntegeri_v),
                              thread_mode);
}

/*
 * void
 * glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetInternalformativ))(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetInternalformativ) orig_func;
   GLenum target;
   GLenum internalformat;
   GLenum pname;
   GLsizei bufSize;
   GLint *params;

} GL_TH_ST(glGetInternalformativ);

static void
GL_TH_CB(glGetInternalformativ)(void *data)
{
   GL_TH_ST(glGetInternalformativ) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetInternalformativ))thread_data->orig_func)
      (thread_data->target,
       thread_data->internalformat,
       thread_data->pname,
       thread_data->bufSize,
       thread_data->params);

}

void
GL_TH_FN(glGetInternalformativ)(GL_TH_DP, GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetInternalformativ) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetInternalformativ))orig_func)
           (target, internalformat, pname, bufSize, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetInternalformativ) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->internalformat = internalformat;
   thread_data->pname = pname;
   thread_data->bufSize = bufSize;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetInternalformativ),
                              thread_mode);
}

/*
 * void
 * glGetProgramBinary(GLuint program, GLsizei bufsize, GLsizei *length, GLenum *binaryFormat, void *binary);
 */

typedef void(*GL_TH_FNTYPE(glGetProgramBinary))(GLuint program, GLsizei bufsize, GLsizei *length, GLenum *binaryFormat, void *binary);

typedef struct
{
   GL_TH_FNTYPE(glGetProgramBinary) orig_func;
   GLuint program;
   GLsizei bufsize;
   GLsizei *length;
   GLenum *binaryFormat;
   void *binary;

} GL_TH_ST(glGetProgramBinary);

static void
GL_TH_CB(glGetProgramBinary)(void *data)
{
   GL_TH_ST(glGetProgramBinary) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetProgramBinary))thread_data->orig_func)
      (thread_data->program,
       thread_data->bufsize,
       thread_data->length,
       thread_data->binaryFormat,
       thread_data->binary);

}

void
GL_TH_FN(glGetProgramBinary)(GL_TH_DP, GLuint program, GLsizei bufsize, GLsizei *length, GLenum *binaryFormat, void *binary)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetProgramBinary) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetProgramBinary))orig_func)
           (program, bufsize, length, binaryFormat, binary);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetProgramBinary) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->bufsize = bufsize;
   thread_data->length = length;
   thread_data->binaryFormat = binaryFormat;
   thread_data->binary = binary;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetProgramBinary),
                              thread_mode);
}

/*
 * void
 * glGetQueryiv(GLenum target, GLenum pname, GLint * params);
 */

typedef void(*GL_TH_FNTYPE(glGetQueryiv))(GLenum target, GLenum pname, GLint * params);

typedef struct
{
   GL_TH_FNTYPE(glGetQueryiv) orig_func;
   GLenum target;
   GLenum pname;
   GLint * params;

} GL_TH_ST(glGetQueryiv);

static void
GL_TH_CB(glGetQueryiv)(void *data)
{
   GL_TH_ST(glGetQueryiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetQueryiv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetQueryiv)(GL_TH_DP, GLenum target, GLenum pname, GLint * params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetQueryiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetQueryiv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetQueryiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetQueryiv),
                              thread_mode);
}

/*
 * void
 * glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params);
 */

typedef void(*GL_TH_FNTYPE(glGetQueryObjectuiv))(GLuint id, GLenum pname, GLuint * params);

typedef struct
{
   GL_TH_FNTYPE(glGetQueryObjectuiv) orig_func;
   GLuint id;
   GLenum pname;
   GLuint * params;

} GL_TH_ST(glGetQueryObjectuiv);

static void
GL_TH_CB(glGetQueryObjectuiv)(void *data)
{
   GL_TH_ST(glGetQueryObjectuiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetQueryObjectuiv))thread_data->orig_func)
      (thread_data->id,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetQueryObjectuiv)(GL_TH_DP, GLuint id, GLenum pname, GLuint * params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetQueryObjectuiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetQueryObjectuiv))orig_func)
           (id, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetQueryObjectuiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->id = id;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetQueryObjectuiv),
                              thread_mode);
}

/*
 * void
 * glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params);
 */

typedef void(*GL_TH_FNTYPE(glGetSamplerParameterfv))(GLuint sampler, GLenum pname, GLfloat * params);

typedef struct
{
   GL_TH_FNTYPE(glGetSamplerParameterfv) orig_func;
   GLuint sampler;
   GLenum pname;
   GLfloat * params;

} GL_TH_ST(glGetSamplerParameterfv);

static void
GL_TH_CB(glGetSamplerParameterfv)(void *data)
{
   GL_TH_ST(glGetSamplerParameterfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetSamplerParameterfv))thread_data->orig_func)
      (thread_data->sampler,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetSamplerParameterfv)(GL_TH_DP, GLuint sampler, GLenum pname, GLfloat * params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetSamplerParameterfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetSamplerParameterfv))orig_func)
           (sampler, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetSamplerParameterfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sampler = sampler;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetSamplerParameterfv),
                              thread_mode);
}

/*
 * void
 * glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params);
 */

typedef void(*GL_TH_FNTYPE(glGetSamplerParameteriv))(GLuint sampler, GLenum pname, GLint * params);

typedef struct
{
   GL_TH_FNTYPE(glGetSamplerParameteriv) orig_func;
   GLuint sampler;
   GLenum pname;
   GLint * params;

} GL_TH_ST(glGetSamplerParameteriv);

static void
GL_TH_CB(glGetSamplerParameteriv)(void *data)
{
   GL_TH_ST(glGetSamplerParameteriv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetSamplerParameteriv))thread_data->orig_func)
      (thread_data->sampler,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetSamplerParameteriv)(GL_TH_DP, GLuint sampler, GLenum pname, GLint * params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetSamplerParameteriv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetSamplerParameteriv))orig_func)
           (sampler, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetSamplerParameteriv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sampler = sampler;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetSamplerParameteriv),
                              thread_mode);
}

/*
 * const GLubyte *
 * glGetStringi(GLenum name, GLuint index);
 */

typedef const GLubyte *(*GL_TH_FNTYPE(glGetStringi))(GLenum name, GLuint index);

typedef struct
{
   GL_TH_FNTYPE(glGetStringi) orig_func;
   const GLubyte * return_value;
   GLenum name;
   GLuint index;

} GL_TH_ST(glGetStringi);

static void
GL_TH_CB(glGetStringi)(void *data)
{
   GL_TH_ST(glGetStringi) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glGetStringi))thread_data->orig_func)
      (thread_data->name,
       thread_data->index);

}

const GLubyte *
GL_TH_FN(glGetStringi)(GL_TH_DP, GLenum name, GLuint index)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetStringi) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glGetStringi))orig_func)
           (name, index);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetStringi) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->name = name;
   thread_data->index = index;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetStringi),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
 */

typedef void(*GL_TH_FNTYPE(glGetSynciv))(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);

typedef struct
{
   GL_TH_FNTYPE(glGetSynciv) orig_func;
   GLsync sync;
   GLenum pname;
   GLsizei bufSize;
   GLsizei *length;
   GLint *values;

} GL_TH_ST(glGetSynciv);

static void
GL_TH_CB(glGetSynciv)(void *data)
{
   GL_TH_ST(glGetSynciv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetSynciv))thread_data->orig_func)
      (thread_data->sync,
       thread_data->pname,
       thread_data->bufSize,
       thread_data->length,
       thread_data->values);

}

void
GL_TH_FN(glGetSynciv)(GL_TH_DP, GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetSynciv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetSynciv))orig_func)
           (sync, pname, bufSize, length, values);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetSynciv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sync = sync;
   thread_data->pname = pname;
   thread_data->bufSize = bufSize;
   thread_data->length = length;
   thread_data->values = values;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetSynciv),
                              thread_mode);
}

/*
 * void
 * glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, char * name);
 */

typedef void(*GL_TH_FNTYPE(glGetTransformFeedbackVarying))(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, char * name);

typedef struct
{
   GL_TH_FNTYPE(glGetTransformFeedbackVarying) orig_func;
   GLuint program;
   GLuint index;
   GLsizei bufSize;
   GLsizei * length;
   GLsizei * size;
   GLenum * type;
   char * name;

} GL_TH_ST(glGetTransformFeedbackVarying);

static void
GL_TH_CB(glGetTransformFeedbackVarying)(void *data)
{
   GL_TH_ST(glGetTransformFeedbackVarying) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTransformFeedbackVarying))thread_data->orig_func)
      (thread_data->program,
       thread_data->index,
       thread_data->bufSize,
       thread_data->length,
       thread_data->size,
       thread_data->type,
       thread_data->name);

}

void
GL_TH_FN(glGetTransformFeedbackVarying)(GL_TH_DP, GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, char * name)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTransformFeedbackVarying) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTransformFeedbackVarying))orig_func)
           (program, index, bufSize, length, size, type, name);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTransformFeedbackVarying) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->index = index;
   thread_data->bufSize = bufSize;
   thread_data->length = length;
   thread_data->size = size;
   thread_data->type = type;
   thread_data->name = name;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTransformFeedbackVarying),
                              thread_mode);
}

/*
 * GLuint
 * glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName);
 */

typedef GLuint(*GL_TH_FNTYPE(glGetUniformBlockIndex))(GLuint program, const GLchar *uniformBlockName);

typedef struct
{
   GL_TH_FNTYPE(glGetUniformBlockIndex) orig_func;
   GLuint return_value;
   GLuint program;
   const GLchar *uniformBlockName;

} GL_TH_ST(glGetUniformBlockIndex);

static void
GL_TH_CB(glGetUniformBlockIndex)(void *data)
{
   GL_TH_ST(glGetUniformBlockIndex) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glGetUniformBlockIndex))thread_data->orig_func)
      (thread_data->program,
       thread_data->uniformBlockName);

}

GLuint
GL_TH_FN(glGetUniformBlockIndex)(GL_TH_DP, GLuint program, const GLchar *uniformBlockName)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetUniformBlockIndex) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glGetUniformBlockIndex))orig_func)
           (program, uniformBlockName);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetUniformBlockIndex) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->uniformBlockName = uniformBlockName;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetUniformBlockIndex),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices);
 */

typedef void(*GL_TH_FNTYPE(glGetUniformIndices))(GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices);

typedef struct
{
   GL_TH_FNTYPE(glGetUniformIndices) orig_func;
   GLuint program;
   GLsizei uniformCount;
   const GLchar *const*uniformNames;
   GLuint *uniformIndices;

} GL_TH_ST(glGetUniformIndices);

static void
GL_TH_CB(glGetUniformIndices)(void *data)
{
   GL_TH_ST(glGetUniformIndices) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetUniformIndices))thread_data->orig_func)
      (thread_data->program,
       thread_data->uniformCount,
       thread_data->uniformNames,
       thread_data->uniformIndices);

}

void
GL_TH_FN(glGetUniformIndices)(GL_TH_DP, GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetUniformIndices) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetUniformIndices))orig_func)
           (program, uniformCount, uniformNames, uniformIndices);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetUniformIndices) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->uniformCount = uniformCount;
   thread_data->uniformNames = uniformNames;
   thread_data->uniformIndices = uniformIndices;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetUniformIndices),
                              thread_mode);
}

/*
 * void
 * glGetUniformuiv(GLuint program, GLint location, GLuint* params);
 */

typedef void(*GL_TH_FNTYPE(glGetUniformuiv))(GLuint program, GLint location, GLuint* params);

typedef struct
{
   GL_TH_FNTYPE(glGetUniformuiv) orig_func;
   GLuint program;
   GLint location;
   GLuint* params;

} GL_TH_ST(glGetUniformuiv);

static void
GL_TH_CB(glGetUniformuiv)(void *data)
{
   GL_TH_ST(glGetUniformuiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetUniformuiv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->params);

}

void
GL_TH_FN(glGetUniformuiv)(GL_TH_DP, GLuint program, GLint location, GLuint* params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetUniformuiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetUniformuiv))orig_func)
           (program, location, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetUniformuiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetUniformuiv),
                              thread_mode);
}

/*
 * void
 * glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetVertexAttribIiv))(GLuint index, GLenum pname, GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetVertexAttribIiv) orig_func;
   GLuint index;
   GLenum pname;
   GLint *params;

} GL_TH_ST(glGetVertexAttribIiv);

static void
GL_TH_CB(glGetVertexAttribIiv)(void *data)
{
   GL_TH_ST(glGetVertexAttribIiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetVertexAttribIiv))thread_data->orig_func)
      (thread_data->index,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetVertexAttribIiv)(GL_TH_DP, GLuint index, GLenum pname, GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetVertexAttribIiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetVertexAttribIiv))orig_func)
           (index, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetVertexAttribIiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->index = index;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetVertexAttribIiv),
                              thread_mode);
}

/*
 * void
 * glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetVertexAttribIuiv))(GLuint index, GLenum pname, GLuint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetVertexAttribIuiv) orig_func;
   GLuint index;
   GLenum pname;
   GLuint *params;

} GL_TH_ST(glGetVertexAttribIuiv);

static void
GL_TH_CB(glGetVertexAttribIuiv)(void *data)
{
   GL_TH_ST(glGetVertexAttribIuiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetVertexAttribIuiv))thread_data->orig_func)
      (thread_data->index,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetVertexAttribIuiv)(GL_TH_DP, GLuint index, GLenum pname, GLuint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetVertexAttribIuiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetVertexAttribIuiv))orig_func)
           (index, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetVertexAttribIuiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->index = index;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetVertexAttribIuiv),
                              thread_mode);
}

/*
 * void
 * glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments);
 */

typedef void(*GL_TH_FNTYPE(glInvalidateFramebuffer))(GLenum target, GLsizei numAttachments, const GLenum *attachments);

typedef struct
{
   GL_TH_FNTYPE(glInvalidateFramebuffer) orig_func;
   GLenum target;
   GLsizei numAttachments;
   const GLenum *attachments;

} GL_TH_ST(glInvalidateFramebuffer);

static void
GL_TH_CB(glInvalidateFramebuffer)(void *data)
{
   GL_TH_ST(glInvalidateFramebuffer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glInvalidateFramebuffer))thread_data->orig_func)
      (thread_data->target,
       thread_data->numAttachments,
       thread_data->attachments);

}

void
GL_TH_FN(glInvalidateFramebuffer)(GL_TH_DP, GLenum target, GLsizei numAttachments, const GLenum *attachments)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glInvalidateFramebuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glInvalidateFramebuffer))orig_func)
           (target, numAttachments, attachments);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glInvalidateFramebuffer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->numAttachments = numAttachments;
   thread_data->attachments = attachments;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glInvalidateFramebuffer),
                              thread_mode);
}

/*
 * void
 * glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
 */

typedef void(*GL_TH_FNTYPE(glInvalidateSubFramebuffer))(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);

typedef struct
{
   GL_TH_FNTYPE(glInvalidateSubFramebuffer) orig_func;
   GLenum target;
   GLsizei numAttachments;
   const GLenum *attachments;
   GLint x;
   GLint y;
   GLsizei width;
   GLsizei height;

} GL_TH_ST(glInvalidateSubFramebuffer);

static void
GL_TH_CB(glInvalidateSubFramebuffer)(void *data)
{
   GL_TH_ST(glInvalidateSubFramebuffer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glInvalidateSubFramebuffer))thread_data->orig_func)
      (thread_data->target,
       thread_data->numAttachments,
       thread_data->attachments,
       thread_data->x,
       thread_data->y,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glInvalidateSubFramebuffer)(GL_TH_DP, GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glInvalidateSubFramebuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glInvalidateSubFramebuffer))orig_func)
           (target, numAttachments, attachments, x, y, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glInvalidateSubFramebuffer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->numAttachments = numAttachments;
   thread_data->attachments = attachments;
   thread_data->x = x;
   thread_data->y = y;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glInvalidateSubFramebuffer),
                              thread_mode);
}

/*
 * GLboolean
 * glIsQuery(GLuint id);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsQuery))(GLuint id);

typedef struct
{
   GL_TH_FNTYPE(glIsQuery) orig_func;
   GLboolean return_value;
   GLuint id;

} GL_TH_ST(glIsQuery);

static void
GL_TH_CB(glIsQuery)(void *data)
{
   GL_TH_ST(glIsQuery) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsQuery))thread_data->orig_func)
      (thread_data->id);

}

GLboolean
GL_TH_FN(glIsQuery)(GL_TH_DP, GLuint id)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsQuery) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsQuery))orig_func)
           (id);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsQuery) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->id = id;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsQuery),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glIsSampler(GLuint id);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsSampler))(GLuint id);

typedef struct
{
   GL_TH_FNTYPE(glIsSampler) orig_func;
   GLboolean return_value;
   GLuint id;

} GL_TH_ST(glIsSampler);

static void
GL_TH_CB(glIsSampler)(void *data)
{
   GL_TH_ST(glIsSampler) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsSampler))thread_data->orig_func)
      (thread_data->id);

}

GLboolean
GL_TH_FN(glIsSampler)(GL_TH_DP, GLuint id)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsSampler) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsSampler))orig_func)
           (id);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsSampler) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->id = id;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsSampler),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glIsSync(GLsync sync);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsSync))(GLsync sync);

typedef struct
{
   GL_TH_FNTYPE(glIsSync) orig_func;
   GLboolean return_value;
   GLsync sync;

} GL_TH_ST(glIsSync);

static void
GL_TH_CB(glIsSync)(void *data)
{
   GL_TH_ST(glIsSync) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsSync))thread_data->orig_func)
      (thread_data->sync);

}

GLboolean
GL_TH_FN(glIsSync)(GL_TH_DP, GLsync sync)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsSync) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsSync))orig_func)
           (sync);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsSync) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sync = sync;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsSync),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glIsTransformFeedback(GLuint id);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsTransformFeedback))(GLuint id);

typedef struct
{
   GL_TH_FNTYPE(glIsTransformFeedback) orig_func;
   GLboolean return_value;
   GLuint id;

} GL_TH_ST(glIsTransformFeedback);

static void
GL_TH_CB(glIsTransformFeedback)(void *data)
{
   GL_TH_ST(glIsTransformFeedback) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsTransformFeedback))thread_data->orig_func)
      (thread_data->id);

}

GLboolean
GL_TH_FN(glIsTransformFeedback)(GL_TH_DP, GLuint id)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsTransformFeedback) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsTransformFeedback))orig_func)
           (id);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsTransformFeedback) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->id = id;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsTransformFeedback),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * GLboolean
 * glIsVertexArray(GLuint array);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsVertexArray))(GLuint array);

typedef struct
{
   GL_TH_FNTYPE(glIsVertexArray) orig_func;
   GLboolean return_value;
   GLuint array;

} GL_TH_ST(glIsVertexArray);

static void
GL_TH_CB(glIsVertexArray)(void *data)
{
   GL_TH_ST(glIsVertexArray) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsVertexArray))thread_data->orig_func)
      (thread_data->array);

}

GLboolean
GL_TH_FN(glIsVertexArray)(GL_TH_DP, GLuint array)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsVertexArray) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsVertexArray))orig_func)
           (array);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsVertexArray) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->array = array;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsVertexArray),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void *
 * glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
 */

typedef void *(*GL_TH_FNTYPE(glMapBufferRange))(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);

typedef struct
{
   GL_TH_FNTYPE(glMapBufferRange) orig_func;
   void * return_value;
   GLenum target;
   GLintptr offset;
   GLsizeiptr length;
   GLbitfield access;

} GL_TH_ST(glMapBufferRange);

static void
GL_TH_CB(glMapBufferRange)(void *data)
{
   GL_TH_ST(glMapBufferRange) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glMapBufferRange))thread_data->orig_func)
      (thread_data->target,
       thread_data->offset,
       thread_data->length,
       thread_data->access);

}

void *
GL_TH_FN(glMapBufferRange)(GL_TH_DP, GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMapBufferRange) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glMapBufferRange))orig_func)
           (target, offset, length, access);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMapBufferRange) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->offset = offset;
   thread_data->length = length;
   thread_data->access = access;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMapBufferRange),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glPauseTransformFeedback(void);
 */

typedef void(*GL_TH_FNTYPE(glPauseTransformFeedback))(void);

typedef struct
{
   GL_TH_FNTYPE(glPauseTransformFeedback) orig_func;

} GL_TH_ST(glPauseTransformFeedback);

static void
GL_TH_CB(glPauseTransformFeedback)(void *data)
{
   GL_TH_ST(glPauseTransformFeedback) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glPauseTransformFeedback))thread_data->orig_func)
      ();

}

void
GL_TH_FN(glPauseTransformFeedback)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glPauseTransformFeedback) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glPauseTransformFeedback))orig_func)
           ();
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glPauseTransformFeedback) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glPauseTransformFeedback),
                              thread_mode);
}

/*
 * void
 * glProgramBinary(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
 */

typedef void(*GL_TH_FNTYPE(glProgramBinary))(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);

typedef struct
{
   GL_TH_FNTYPE(glProgramBinary) orig_func;
   GLuint program;
   GLenum binaryFormat;
   const void *binary;
   GLsizei length;
   void *binary_copied; /* COPIED */

} GL_TH_ST(glProgramBinary);

static void
GL_TH_CB(glProgramBinary)(void *data)
{
   GL_TH_ST(glProgramBinary) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramBinary))thread_data->orig_func)
      (thread_data->program,
       thread_data->binaryFormat,
       thread_data->binary,
       thread_data->length);


   if (thread_data->binary_copied)
     eina_mempool_free(_mp_default, thread_data->binary_copied);

}

void
GL_TH_FN(glProgramBinary)(GL_TH_DP, GLuint program, GLenum binaryFormat, const void *binary, GLsizei length)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramBinary) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramBinary))orig_func)
           (program, binaryFormat, binary, length);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramBinary) *) + sizeof(GL_TH_ST(glProgramBinary)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glProgramBinary) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->program = program;
   thread_data->binaryFormat = binaryFormat;
   thread_data->binary = binary;
   thread_data->length = length;
   thread_data->orig_func = orig_func;

   thread_data->binary_copied = NULL;
   if (thread_mode == EVAS_GL_THREAD_MODE_FINISH)
     goto finish;

   /* copy variable */
   if (binary)
     {
        /* 1. check memory size */
        unsigned int copy_size = length;
        if (copy_size > _mp_default_memory_size)
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 2. malloc & copy */
        thread_data->binary_copied = eina_mempool_malloc(_mp_default, copy_size);
        if (thread_data->binary_copied)
          {
             memcpy(thread_data->binary_copied, binary, copy_size);
          }
        else
          {
             thread_mode = EVAS_GL_THREAD_MODE_FINISH;
             goto finish;
          }
        /* 3. replace */
        thread_data->binary = (const void  *)thread_data->binary_copied;
     }
   /* end of copy variable */

finish:
   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramBinary),
                              thread_mode);
}

/*
 * void
 * glProgramParameteri(GLuint program, GLenum pname, GLint value);
 */

typedef void(*GL_TH_FNTYPE(glProgramParameteri))(GLuint program, GLenum pname, GLint value);

typedef struct
{
   GL_TH_FNTYPE(glProgramParameteri) orig_func;
   GLuint program;
   GLenum pname;
   GLint value;

} GL_TH_ST(glProgramParameteri);

static void
GL_TH_CB(glProgramParameteri)(void *data)
{
   GL_TH_ST(glProgramParameteri) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramParameteri))thread_data->orig_func)
      (thread_data->program,
       thread_data->pname,
       thread_data->value);

}

void
GL_TH_FN(glProgramParameteri)(GL_TH_DP, GLuint program, GLenum pname, GLint value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramParameteri) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramParameteri))orig_func)
           (program, pname, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramParameteri) *) + sizeof(GL_TH_ST(glProgramParameteri)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glProgramParameteri) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->program = program;
   thread_data->pname = pname;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramParameteri),
                              thread_mode);
}

/*
 * void
 * glReadBuffer(GLenum src);
 */

typedef void(*GL_TH_FNTYPE(glReadBuffer))(GLenum src);

typedef struct
{
   GL_TH_FNTYPE(glReadBuffer) orig_func;
   GLenum src;

} GL_TH_ST(glReadBuffer);

static void
GL_TH_CB(glReadBuffer)(void *data)
{
   GL_TH_ST(glReadBuffer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glReadBuffer))thread_data->orig_func)
      (thread_data->src);

}

void
GL_TH_FN(glReadBuffer)(GL_TH_DP, GLenum src)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glReadBuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glReadBuffer))orig_func)
           (src);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glReadBuffer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->src = src;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glReadBuffer),
                              thread_mode);
}

#ifndef GL_GLES
/*
 * void
 * glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
 */

typedef void(*GL_TH_FNTYPE(glRenderbufferStorageMultisample))(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);

typedef struct
{
   GL_TH_FNTYPE(glRenderbufferStorageMultisample) orig_func;
   GLenum target;
   GLsizei samples;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;

} GL_TH_ST(glRenderbufferStorageMultisample);

static void
GL_TH_CB(glRenderbufferStorageMultisample)(void *data)
{
   GL_TH_ST(glRenderbufferStorageMultisample) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glRenderbufferStorageMultisample))thread_data->orig_func)
      (thread_data->target,
       thread_data->samples,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glRenderbufferStorageMultisample)(GL_TH_DP, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glRenderbufferStorageMultisample) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glRenderbufferStorageMultisample))orig_func)
           (target, samples, internalformat, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glRenderbufferStorageMultisample) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->samples = samples;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glRenderbufferStorageMultisample),
                              thread_mode);
}

#endif
/*
 * void
 * glResumeTransformFeedback(void);
 */

typedef void(*GL_TH_FNTYPE(glResumeTransformFeedback))(void);

typedef struct
{
   GL_TH_FNTYPE(glResumeTransformFeedback) orig_func;

} GL_TH_ST(glResumeTransformFeedback);

static void
GL_TH_CB(glResumeTransformFeedback)(void *data)
{
   GL_TH_ST(glResumeTransformFeedback) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glResumeTransformFeedback))thread_data->orig_func)
      ();

}

void
GL_TH_FN(glResumeTransformFeedback)(GL_TH_DP)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glResumeTransformFeedback) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glResumeTransformFeedback))orig_func)
           ();
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glResumeTransformFeedback) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glResumeTransformFeedback),
                              thread_mode);
}

/*
 * void
 * glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);
 */

typedef void(*GL_TH_FNTYPE(glSamplerParameterf))(GLuint sampler, GLenum pname, GLfloat param);

typedef struct
{
   GL_TH_FNTYPE(glSamplerParameterf) orig_func;
   GLuint sampler;
   GLenum pname;
   GLfloat param;

} GL_TH_ST(glSamplerParameterf);

static void
GL_TH_CB(glSamplerParameterf)(void *data)
{
   GL_TH_ST(glSamplerParameterf) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glSamplerParameterf))thread_data->orig_func)
      (thread_data->sampler,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glSamplerParameterf)(GL_TH_DP, GLuint sampler, GLenum pname, GLfloat param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glSamplerParameterf) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glSamplerParameterf))orig_func)
           (sampler, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glSamplerParameterf) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sampler = sampler;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glSamplerParameterf),
                              thread_mode);
}

/*
 * void
 * glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * params);
 */

typedef void(*GL_TH_FNTYPE(glSamplerParameterfv))(GLuint sampler, GLenum pname, const GLfloat * params);

typedef struct
{
   GL_TH_FNTYPE(glSamplerParameterfv) orig_func;
   GLuint sampler;
   GLenum pname;
   const GLfloat * params;

} GL_TH_ST(glSamplerParameterfv);

static void
GL_TH_CB(glSamplerParameterfv)(void *data)
{
   GL_TH_ST(glSamplerParameterfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glSamplerParameterfv))thread_data->orig_func)
      (thread_data->sampler,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glSamplerParameterfv)(GL_TH_DP, GLuint sampler, GLenum pname, const GLfloat * params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glSamplerParameterfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glSamplerParameterfv))orig_func)
           (sampler, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glSamplerParameterfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sampler = sampler;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glSamplerParameterfv),
                              thread_mode);
}

/*
 * void
 * glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);
 */

typedef void(*GL_TH_FNTYPE(glSamplerParameteri))(GLuint sampler, GLenum pname, GLint param);

typedef struct
{
   GL_TH_FNTYPE(glSamplerParameteri) orig_func;
   GLuint sampler;
   GLenum pname;
   GLint param;

} GL_TH_ST(glSamplerParameteri);

static void
GL_TH_CB(glSamplerParameteri)(void *data)
{
   GL_TH_ST(glSamplerParameteri) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glSamplerParameteri))thread_data->orig_func)
      (thread_data->sampler,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glSamplerParameteri)(GL_TH_DP, GLuint sampler, GLenum pname, GLint param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glSamplerParameteri) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glSamplerParameteri))orig_func)
           (sampler, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glSamplerParameteri) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sampler = sampler;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glSamplerParameteri),
                              thread_mode);
}

/*
 * void
 * glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * params);
 */

typedef void(*GL_TH_FNTYPE(glSamplerParameteriv))(GLuint sampler, GLenum pname, const GLint * params);

typedef struct
{
   GL_TH_FNTYPE(glSamplerParameteriv) orig_func;
   GLuint sampler;
   GLenum pname;
   const GLint * params;

} GL_TH_ST(glSamplerParameteriv);

static void
GL_TH_CB(glSamplerParameteriv)(void *data)
{
   GL_TH_ST(glSamplerParameteriv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glSamplerParameteriv))thread_data->orig_func)
      (thread_data->sampler,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glSamplerParameteriv)(GL_TH_DP, GLuint sampler, GLenum pname, const GLint * params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glSamplerParameteriv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glSamplerParameteriv))orig_func)
           (sampler, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glSamplerParameteriv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sampler = sampler;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glSamplerParameteriv),
                              thread_mode);
}

/*
 * void
 * glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * data);
 */

typedef void(*GL_TH_FNTYPE(glTexImage3D))(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * data);

typedef struct
{
   GL_TH_FNTYPE(glTexImage3D) orig_func;
   GLenum target;
   GLint level;
   GLint internalFormat;
   GLsizei width;
   GLsizei height;
   GLsizei depth;
   GLint border;
   GLenum format;
   GLenum type;
   const GLvoid * data;

} GL_TH_ST(glTexImage3D);

static void
GL_TH_CB(glTexImage3D)(void *data)
{
   GL_TH_ST(glTexImage3D) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexImage3D))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->internalFormat,
       thread_data->width,
       thread_data->height,
       thread_data->depth,
       thread_data->border,
       thread_data->format,
       thread_data->type,
       thread_data->data);

}

void
GL_TH_FN(glTexImage3D)(GL_TH_DP, GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexImage3D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexImage3D))orig_func)
           (target, level, internalFormat, width, height, depth, border, format, type, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexImage3D) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->internalFormat = internalFormat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->depth = depth;
   thread_data->border = border;
   thread_data->format = format;
   thread_data->type = type;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexImage3D),
                              thread_mode);
}

/*
 * void
 * glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
 */

typedef void(*GL_TH_FNTYPE(glTexStorage2D))(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);

typedef struct
{
   GL_TH_FNTYPE(glTexStorage2D) orig_func;
   GLenum target;
   GLsizei levels;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;

} GL_TH_ST(glTexStorage2D);

static void
GL_TH_CB(glTexStorage2D)(void *data)
{
   GL_TH_ST(glTexStorage2D) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexStorage2D))thread_data->orig_func)
      (thread_data->target,
       thread_data->levels,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height);

}

void
GL_TH_FN(glTexStorage2D)(GL_TH_DP, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexStorage2D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexStorage2D))orig_func)
           (target, levels, internalformat, width, height);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexStorage2D) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->levels = levels;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexStorage2D),
                              thread_mode);
}

/*
 * void
 * glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
 */

typedef void(*GL_TH_FNTYPE(glTexStorage3D))(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);

typedef struct
{
   GL_TH_FNTYPE(glTexStorage3D) orig_func;
   GLenum target;
   GLsizei levels;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;
   GLsizei depth;

} GL_TH_ST(glTexStorage3D);

static void
GL_TH_CB(glTexStorage3D)(void *data)
{
   GL_TH_ST(glTexStorage3D) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexStorage3D))thread_data->orig_func)
      (thread_data->target,
       thread_data->levels,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height,
       thread_data->depth);

}

void
GL_TH_FN(glTexStorage3D)(GL_TH_DP, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexStorage3D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexStorage3D))orig_func)
           (target, levels, internalformat, width, height, depth);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexStorage3D) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->levels = levels;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->depth = depth;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexStorage3D),
                              thread_mode);
}

/*
 * void
 * glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * data);
 */

typedef void(*GL_TH_FNTYPE(glTexSubImage3D))(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * data);

typedef struct
{
   GL_TH_FNTYPE(glTexSubImage3D) orig_func;
   GLenum target;
   GLint level;
   GLint xoffset;
   GLint yoffset;
   GLint zoffset;
   GLsizei width;
   GLsizei height;
   GLsizei depth;
   GLenum format;
   GLenum type;
   const GLvoid * data;

} GL_TH_ST(glTexSubImage3D);

static void
GL_TH_CB(glTexSubImage3D)(void *data)
{
   GL_TH_ST(glTexSubImage3D) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexSubImage3D))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->xoffset,
       thread_data->yoffset,
       thread_data->zoffset,
       thread_data->width,
       thread_data->height,
       thread_data->depth,
       thread_data->format,
       thread_data->type,
       thread_data->data);

}

void
GL_TH_FN(glTexSubImage3D)(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexSubImage3D) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexSubImage3D))orig_func)
           (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexSubImage3D) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->xoffset = xoffset;
   thread_data->yoffset = yoffset;
   thread_data->zoffset = zoffset;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->depth = depth;
   thread_data->format = format;
   thread_data->type = type;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexSubImage3D),
                              thread_mode);
}

/*
 * void
 * glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
 */

typedef void(*GL_TH_FNTYPE(glTransformFeedbackVaryings))(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);

typedef struct
{
   GL_TH_FNTYPE(glTransformFeedbackVaryings) orig_func;
   GLuint program;
   GLsizei count;
   const GLchar *const* varyings;
   GLenum bufferMode;

} GL_TH_ST(glTransformFeedbackVaryings);

static void
GL_TH_CB(glTransformFeedbackVaryings)(void *data)
{
   GL_TH_ST(glTransformFeedbackVaryings) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTransformFeedbackVaryings))thread_data->orig_func)
      (thread_data->program,
       thread_data->count,
       thread_data->varyings,
       thread_data->bufferMode);

}

void
GL_TH_FN(glTransformFeedbackVaryings)(GL_TH_DP, GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTransformFeedbackVaryings) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTransformFeedbackVaryings))orig_func)
           (program, count, varyings, bufferMode);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTransformFeedbackVaryings) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->count = count;
   thread_data->varyings = varyings;
   thread_data->bufferMode = bufferMode;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTransformFeedbackVaryings),
                              thread_mode);
}

/*
 * void
 * glUniform1ui(GLint location, GLuint v0);
 */

typedef void(*GL_TH_FNTYPE(glUniform1ui))(GLint location, GLuint v0);

typedef struct
{
   GL_TH_FNTYPE(glUniform1ui) orig_func;
   GLint location;
   GLuint v0;

} GL_TH_ST(glUniform1ui);

static void
GL_TH_CB(glUniform1ui)(void *data)
{
   GL_TH_ST(glUniform1ui) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform1ui))thread_data->orig_func)
      (thread_data->location,
       thread_data->v0);

}

void
GL_TH_FN(glUniform1ui)(GL_TH_DP, GLint location, GLuint v0)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform1ui) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform1ui))orig_func)
           (location, v0);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform1ui) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform1ui),
                              thread_mode);
}

/*
 * void
 * glUniform1uiv(GLint location, GLsizei count, const GLuint *value);
 */

typedef void(*GL_TH_FNTYPE(glUniform1uiv))(GLint location, GLsizei count, const GLuint *value);

typedef struct
{
   GL_TH_FNTYPE(glUniform1uiv) orig_func;
   GLint location;
   GLsizei count;
   const GLuint *value;

} GL_TH_ST(glUniform1uiv);

static void
GL_TH_CB(glUniform1uiv)(void *data)
{
   GL_TH_ST(glUniform1uiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform1uiv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glUniform1uiv)(GL_TH_DP, GLint location, GLsizei count, const GLuint *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform1uiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform1uiv))orig_func)
           (location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform1uiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform1uiv),
                              thread_mode);
}

/*
 * void
 * glUniform2ui(GLint location, GLuint v0, GLuint v1);
 */

typedef void(*GL_TH_FNTYPE(glUniform2ui))(GLint location, GLuint v0, GLuint v1);

typedef struct
{
   GL_TH_FNTYPE(glUniform2ui) orig_func;
   GLint location;
   GLuint v0;
   GLuint v1;

} GL_TH_ST(glUniform2ui);

static void
GL_TH_CB(glUniform2ui)(void *data)
{
   GL_TH_ST(glUniform2ui) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform2ui))thread_data->orig_func)
      (thread_data->location,
       thread_data->v0,
       thread_data->v1);

}

void
GL_TH_FN(glUniform2ui)(GL_TH_DP, GLint location, GLuint v0, GLuint v1)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform2ui) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform2ui))orig_func)
           (location, v0, v1);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform2ui) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform2ui),
                              thread_mode);
}

/*
 * void
 * glUniform2uiv(GLint location, GLsizei count, const GLuint *value);
 */

typedef void(*GL_TH_FNTYPE(glUniform2uiv))(GLint location, GLsizei count, const GLuint *value);

typedef struct
{
   GL_TH_FNTYPE(glUniform2uiv) orig_func;
   GLint location;
   GLsizei count;
   const GLuint *value;

} GL_TH_ST(glUniform2uiv);

static void
GL_TH_CB(glUniform2uiv)(void *data)
{
   GL_TH_ST(glUniform2uiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform2uiv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glUniform2uiv)(GL_TH_DP, GLint location, GLsizei count, const GLuint *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform2uiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform2uiv))orig_func)
           (location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform2uiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform2uiv),
                              thread_mode);
}

/*
 * void
 * glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2);
 */

typedef void(*GL_TH_FNTYPE(glUniform3ui))(GLint location, GLuint v0, GLuint v1, GLuint v2);

typedef struct
{
   GL_TH_FNTYPE(glUniform3ui) orig_func;
   GLint location;
   GLuint v0;
   GLuint v1;
   GLuint v2;

} GL_TH_ST(glUniform3ui);

static void
GL_TH_CB(glUniform3ui)(void *data)
{
   GL_TH_ST(glUniform3ui) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform3ui))thread_data->orig_func)
      (thread_data->location,
       thread_data->v0,
       thread_data->v1,
       thread_data->v2);

}

void
GL_TH_FN(glUniform3ui)(GL_TH_DP, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform3ui) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform3ui))orig_func)
           (location, v0, v1, v2);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform3ui) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->v2 = v2;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform3ui),
                              thread_mode);
}

/*
 * void
 * glUniform3uiv(GLint location, GLsizei count, const GLuint *value);
 */

typedef void(*GL_TH_FNTYPE(glUniform3uiv))(GLint location, GLsizei count, const GLuint *value);

typedef struct
{
   GL_TH_FNTYPE(glUniform3uiv) orig_func;
   GLint location;
   GLsizei count;
   const GLuint *value;

} GL_TH_ST(glUniform3uiv);

static void
GL_TH_CB(glUniform3uiv)(void *data)
{
   GL_TH_ST(glUniform3uiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform3uiv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glUniform3uiv)(GL_TH_DP, GLint location, GLsizei count, const GLuint *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform3uiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform3uiv))orig_func)
           (location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform3uiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform3uiv),
                              thread_mode);
}

/*
 * void
 * glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
 */

typedef void(*GL_TH_FNTYPE(glUniform4ui))(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);

typedef struct
{
   GL_TH_FNTYPE(glUniform4ui) orig_func;
   GLint location;
   GLuint v0;
   GLuint v1;
   GLuint v2;
   GLuint v3;

} GL_TH_ST(glUniform4ui);

static void
GL_TH_CB(glUniform4ui)(void *data)
{
   GL_TH_ST(glUniform4ui) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform4ui))thread_data->orig_func)
      (thread_data->location,
       thread_data->v0,
       thread_data->v1,
       thread_data->v2,
       thread_data->v3);

}

void
GL_TH_FN(glUniform4ui)(GL_TH_DP, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform4ui) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform4ui))orig_func)
           (location, v0, v1, v2, v3);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform4ui) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->v2 = v2;
   thread_data->v3 = v3;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform4ui),
                              thread_mode);
}

/*
 * void
 * glUniform4uiv(GLint location, GLsizei count, const GLuint *value);
 */

typedef void(*GL_TH_FNTYPE(glUniform4uiv))(GLint location, GLsizei count, const GLuint *value);

typedef struct
{
   GL_TH_FNTYPE(glUniform4uiv) orig_func;
   GLint location;
   GLsizei count;
   const GLuint *value;

} GL_TH_ST(glUniform4uiv);

static void
GL_TH_CB(glUniform4uiv)(void *data)
{
   GL_TH_ST(glUniform4uiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniform4uiv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glUniform4uiv)(GL_TH_DP, GLint location, GLsizei count, const GLuint *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniform4uiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniform4uiv))orig_func)
           (location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniform4uiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniform4uiv),
                              thread_mode);
}

/*
 * void
 * glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
 */

typedef void(*GL_TH_FNTYPE(glUniformBlockBinding))(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);

typedef struct
{
   GL_TH_FNTYPE(glUniformBlockBinding) orig_func;
   GLuint program;
   GLuint uniformBlockIndex;
   GLuint uniformBlockBinding;

} GL_TH_ST(glUniformBlockBinding);

static void
GL_TH_CB(glUniformBlockBinding)(void *data)
{
   GL_TH_ST(glUniformBlockBinding) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniformBlockBinding))thread_data->orig_func)
      (thread_data->program,
       thread_data->uniformBlockIndex,
       thread_data->uniformBlockBinding);

}

void
GL_TH_FN(glUniformBlockBinding)(GL_TH_DP, GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniformBlockBinding) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniformBlockBinding))orig_func)
           (program, uniformBlockIndex, uniformBlockBinding);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniformBlockBinding) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->uniformBlockIndex = uniformBlockIndex;
   thread_data->uniformBlockBinding = uniformBlockBinding;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniformBlockBinding),
                              thread_mode);
}

/*
 * void
 * glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glUniformMatrix2x3fv))(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glUniformMatrix2x3fv) orig_func;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glUniformMatrix2x3fv);

static void
GL_TH_CB(glUniformMatrix2x3fv)(void *data)
{
   GL_TH_ST(glUniformMatrix2x3fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniformMatrix2x3fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glUniformMatrix2x3fv)(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniformMatrix2x3fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniformMatrix2x3fv))orig_func)
           (location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniformMatrix2x3fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniformMatrix2x3fv),
                              thread_mode);
}

/*
 * void
 * glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glUniformMatrix3x2fv))(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glUniformMatrix3x2fv) orig_func;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glUniformMatrix3x2fv);

static void
GL_TH_CB(glUniformMatrix3x2fv)(void *data)
{
   GL_TH_ST(glUniformMatrix3x2fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniformMatrix3x2fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glUniformMatrix3x2fv)(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniformMatrix3x2fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniformMatrix3x2fv))orig_func)
           (location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniformMatrix3x2fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniformMatrix3x2fv),
                              thread_mode);
}

/*
 * void
 * glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glUniformMatrix2x4fv))(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glUniformMatrix2x4fv) orig_func;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glUniformMatrix2x4fv);

static void
GL_TH_CB(glUniformMatrix2x4fv)(void *data)
{
   GL_TH_ST(glUniformMatrix2x4fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniformMatrix2x4fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glUniformMatrix2x4fv)(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniformMatrix2x4fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniformMatrix2x4fv))orig_func)
           (location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniformMatrix2x4fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniformMatrix2x4fv),
                              thread_mode);
}

/*
 * void
 * glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glUniformMatrix4x2fv))(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glUniformMatrix4x2fv) orig_func;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glUniformMatrix4x2fv);

static void
GL_TH_CB(glUniformMatrix4x2fv)(void *data)
{
   GL_TH_ST(glUniformMatrix4x2fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniformMatrix4x2fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glUniformMatrix4x2fv)(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniformMatrix4x2fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniformMatrix4x2fv))orig_func)
           (location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniformMatrix4x2fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniformMatrix4x2fv),
                              thread_mode);
}

/*
 * void
 * glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glUniformMatrix3x4fv))(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glUniformMatrix3x4fv) orig_func;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glUniformMatrix3x4fv);

static void
GL_TH_CB(glUniformMatrix3x4fv)(void *data)
{
   GL_TH_ST(glUniformMatrix3x4fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniformMatrix3x4fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glUniformMatrix3x4fv)(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniformMatrix3x4fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniformMatrix3x4fv))orig_func)
           (location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniformMatrix3x4fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniformMatrix3x4fv),
                              thread_mode);
}

/*
 * void
 * glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glUniformMatrix4x3fv))(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glUniformMatrix4x3fv) orig_func;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glUniformMatrix4x3fv);

static void
GL_TH_CB(glUniformMatrix4x3fv)(void *data)
{
   GL_TH_ST(glUniformMatrix4x3fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUniformMatrix4x3fv))thread_data->orig_func)
      (thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glUniformMatrix4x3fv)(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUniformMatrix4x3fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUniformMatrix4x3fv))orig_func)
           (location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUniformMatrix4x3fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUniformMatrix4x3fv),
                              thread_mode);
}

/*
 * GLboolean
 * glUnmapBuffer(GLenum target);
 */

typedef GLboolean(*GL_TH_FNTYPE(glUnmapBuffer))(GLenum target);

typedef struct
{
   GL_TH_FNTYPE(glUnmapBuffer) orig_func;
   GLboolean return_value;
   GLenum target;

} GL_TH_ST(glUnmapBuffer);

static void
GL_TH_CB(glUnmapBuffer)(void *data)
{
   GL_TH_ST(glUnmapBuffer) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glUnmapBuffer))thread_data->orig_func)
      (thread_data->target);

}

GLboolean
GL_TH_FN(glUnmapBuffer)(GL_TH_DP, GLenum target)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUnmapBuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glUnmapBuffer))orig_func)
           (target);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUnmapBuffer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUnmapBuffer),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glVertexAttribDivisor(GLuint index, GLuint divisor);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttribDivisor))(GLuint index, GLuint divisor);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttribDivisor) orig_func;
   GLuint index;
   GLuint divisor;

} GL_TH_ST(glVertexAttribDivisor);

static void
GL_TH_CB(glVertexAttribDivisor)(void *data)
{
   GL_TH_ST(glVertexAttribDivisor) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttribDivisor))thread_data->orig_func)
      (thread_data->index,
       thread_data->divisor);

}

void
GL_TH_FN(glVertexAttribDivisor)(GL_TH_DP, GLuint index, GLuint divisor)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttribDivisor) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttribDivisor))orig_func)
           (index, divisor);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttribDivisor) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->index = index;
   thread_data->divisor = divisor;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttribDivisor),
                              thread_mode);
}

/*
 * void
 * glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttribI4i))(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttribI4i) orig_func;
   GLuint index;
   GLint v0;
   GLint v1;
   GLint v2;
   GLint v3;

} GL_TH_ST(glVertexAttribI4i);

static void
GL_TH_CB(glVertexAttribI4i)(void *data)
{
   GL_TH_ST(glVertexAttribI4i) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttribI4i))thread_data->orig_func)
      (thread_data->index,
       thread_data->v0,
       thread_data->v1,
       thread_data->v2,
       thread_data->v3);

}

void
GL_TH_FN(glVertexAttribI4i)(GL_TH_DP, GLuint index, GLint v0, GLint v1, GLint v2, GLint v3)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttribI4i) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttribI4i))orig_func)
           (index, v0, v1, v2, v3);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttribI4i) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->index = index;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->v2 = v2;
   thread_data->v3 = v3;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttribI4i),
                              thread_mode);
}

/*
 * void
 * glVertexAttribI4iv(GLuint index, const GLint *v);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttribI4iv))(GLuint index, const GLint *v);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttribI4iv) orig_func;
   GLuint index;
   const GLint *v;

} GL_TH_ST(glVertexAttribI4iv);

static void
GL_TH_CB(glVertexAttribI4iv)(void *data)
{
   GL_TH_ST(glVertexAttribI4iv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttribI4iv))thread_data->orig_func)
      (thread_data->index,
       thread_data->v);

}

void
GL_TH_FN(glVertexAttribI4iv)(GL_TH_DP, GLuint index, const GLint *v)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttribI4iv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttribI4iv))orig_func)
           (index, v);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttribI4iv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->index = index;
   thread_data->v = v;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttribI4iv),
                              thread_mode);
}

/*
 * void
 * glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttribI4ui))(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttribI4ui) orig_func;
   GLuint index;
   GLuint v0;
   GLuint v1;
   GLuint v2;
   GLuint v3;

} GL_TH_ST(glVertexAttribI4ui);

static void
GL_TH_CB(glVertexAttribI4ui)(void *data)
{
   GL_TH_ST(glVertexAttribI4ui) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttribI4ui))thread_data->orig_func)
      (thread_data->index,
       thread_data->v0,
       thread_data->v1,
       thread_data->v2,
       thread_data->v3);

}

void
GL_TH_FN(glVertexAttribI4ui)(GL_TH_DP, GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttribI4ui) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttribI4ui))orig_func)
           (index, v0, v1, v2, v3);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttribI4ui) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->index = index;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->v2 = v2;
   thread_data->v3 = v3;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttribI4ui),
                              thread_mode);
}

/*
 * void
 * glVertexAttribI4uiv(GLuint index, const GLuint *v);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttribI4uiv))(GLuint index, const GLuint *v);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttribI4uiv) orig_func;
   GLuint index;
   const GLuint *v;

} GL_TH_ST(glVertexAttribI4uiv);

static void
GL_TH_CB(glVertexAttribI4uiv)(void *data)
{
   GL_TH_ST(glVertexAttribI4uiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttribI4uiv))thread_data->orig_func)
      (thread_data->index,
       thread_data->v);

}

void
GL_TH_FN(glVertexAttribI4uiv)(GL_TH_DP, GLuint index, const GLuint *v)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttribI4uiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttribI4uiv))orig_func)
           (index, v);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttribI4uiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->index = index;
   thread_data->v = v;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttribI4uiv),
                              thread_mode);
}

/*
 * void
 * glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttribIPointer))(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttribIPointer) orig_func;
   GLuint index;
   GLint size;
   GLenum type;
   GLsizei stride;
   const GLvoid *pointer;

} GL_TH_ST(glVertexAttribIPointer);

static void
GL_TH_CB(glVertexAttribIPointer)(void *data)
{
   GL_TH_ST(glVertexAttribIPointer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttribIPointer))thread_data->orig_func)
      (thread_data->index,
       thread_data->size,
       thread_data->type,
       thread_data->stride,
       thread_data->pointer);

}

void
GL_TH_FN(glVertexAttribIPointer)(GL_TH_DP, GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttribIPointer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttribIPointer))orig_func)
           (index, size, type, stride, pointer);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttribIPointer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->index = index;
   thread_data->size = size;
   thread_data->type = type;
   thread_data->stride = stride;
   thread_data->pointer = pointer;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttribIPointer),
                              thread_mode);
}

/*
 * void
 * glWaitSync(GLsync sync, GLbitfield flags, EvasGLuint64 timeout);
 */

typedef void(*GL_TH_FNTYPE(glWaitSync))(GLsync sync, GLbitfield flags, EvasGLuint64 timeout);

typedef struct
{
   GL_TH_FNTYPE(glWaitSync) orig_func;
   GLsync sync;
   GLbitfield flags;
   EvasGLuint64 timeout;

} GL_TH_ST(glWaitSync);

static void
GL_TH_CB(glWaitSync)(void *data)
{
   GL_TH_ST(glWaitSync) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glWaitSync))thread_data->orig_func)
      (thread_data->sync,
       thread_data->flags,
       thread_data->timeout);

}

void
GL_TH_FN(glWaitSync)(GL_TH_DP, GLsync sync, GLbitfield flags, EvasGLuint64 timeout)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glWaitSync) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glWaitSync))orig_func)
           (sync, flags, timeout);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glWaitSync) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->sync = sync;
   thread_data->flags = flags;
   thread_data->timeout = timeout;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glWaitSync),
                              thread_mode);
}

/*
 * void
 * glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
 */

typedef void(*GL_TH_FNTYPE(glDispatchCompute))(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);

typedef struct
{
   GL_TH_FNTYPE(glDispatchCompute) orig_func;
   GLuint num_groups_x;
   GLuint num_groups_y;
   GLuint num_groups_z;

} GL_TH_ST(glDispatchCompute);

static void
GL_TH_CB(glDispatchCompute)(void *data)
{
   GL_TH_ST(glDispatchCompute) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDispatchCompute))thread_data->orig_func)
      (thread_data->num_groups_x,
       thread_data->num_groups_y,
       thread_data->num_groups_z);

}

void
GL_TH_FN(glDispatchCompute)(GL_TH_DP, GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDispatchCompute) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDispatchCompute))orig_func)
           (num_groups_x, num_groups_y, num_groups_z);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDispatchCompute) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->num_groups_x = num_groups_x;
   thread_data->num_groups_y = num_groups_y;
   thread_data->num_groups_z = num_groups_z;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDispatchCompute),
                              thread_mode);
}

/*
 * void
 * glDispatchComputeIndirect(GLintptr indirect);
 */

typedef void(*GL_TH_FNTYPE(glDispatchComputeIndirect))(GLintptr indirect);

typedef struct
{
   GL_TH_FNTYPE(glDispatchComputeIndirect) orig_func;
   GLintptr indirect;

} GL_TH_ST(glDispatchComputeIndirect);

static void
GL_TH_CB(glDispatchComputeIndirect)(void *data)
{
   GL_TH_ST(glDispatchComputeIndirect) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDispatchComputeIndirect))thread_data->orig_func)
      (thread_data->indirect);

}

void
GL_TH_FN(glDispatchComputeIndirect)(GL_TH_DP, GLintptr indirect)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDispatchComputeIndirect) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDispatchComputeIndirect))orig_func)
           (indirect);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDispatchComputeIndirect) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->indirect = indirect;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDispatchComputeIndirect),
                              thread_mode);
}

/*
 * void
 * glDrawArraysIndirect(GLenum mode, const void *indirect);
 */

typedef void(*GL_TH_FNTYPE(glDrawArraysIndirect))(GLenum mode, const void *indirect);

typedef struct
{
   GL_TH_FNTYPE(glDrawArraysIndirect) orig_func;
   GLenum mode;
   const void *indirect;

} GL_TH_ST(glDrawArraysIndirect);

static void
GL_TH_CB(glDrawArraysIndirect)(void *data)
{
   GL_TH_ST(glDrawArraysIndirect) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawArraysIndirect))thread_data->orig_func)
      (thread_data->mode,
       thread_data->indirect);

}

void
GL_TH_FN(glDrawArraysIndirect)(GL_TH_DP, GLenum mode, const void *indirect)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawArraysIndirect) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawArraysIndirect))orig_func)
           (mode, indirect);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawArraysIndirect) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->indirect = indirect;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawArraysIndirect),
                              thread_mode);
}

/*
 * void
 * glDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect);
 */

typedef void(*GL_TH_FNTYPE(glDrawElementsIndirect))(GLenum mode, GLenum type, const void *indirect);

typedef struct
{
   GL_TH_FNTYPE(glDrawElementsIndirect) orig_func;
   GLenum mode;
   GLenum type;
   const void *indirect;

} GL_TH_ST(glDrawElementsIndirect);

static void
GL_TH_CB(glDrawElementsIndirect)(void *data)
{
   GL_TH_ST(glDrawElementsIndirect) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDrawElementsIndirect))thread_data->orig_func)
      (thread_data->mode,
       thread_data->type,
       thread_data->indirect);

}

void
GL_TH_FN(glDrawElementsIndirect)(GL_TH_DP, GLenum mode, GLenum type, const void *indirect)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDrawElementsIndirect) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDrawElementsIndirect))orig_func)
           (mode, type, indirect);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDrawElementsIndirect) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->mode = mode;
   thread_data->type = type;
   thread_data->indirect = indirect;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDrawElementsIndirect),
                              thread_mode);
}

/*
 * void
 * glFramebufferParameteri(GLenum target, GLenum pname, GLint param);
 */

typedef void(*GL_TH_FNTYPE(glFramebufferParameteri))(GLenum target, GLenum pname, GLint param);

typedef struct
{
   GL_TH_FNTYPE(glFramebufferParameteri) orig_func;
   GLenum target;
   GLenum pname;
   GLint param;

} GL_TH_ST(glFramebufferParameteri);

static void
GL_TH_CB(glFramebufferParameteri)(void *data)
{
   GL_TH_ST(glFramebufferParameteri) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glFramebufferParameteri))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->param);

}

void
GL_TH_FN(glFramebufferParameteri)(GL_TH_DP, GLenum target, GLenum pname, GLint param)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glFramebufferParameteri) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glFramebufferParameteri))orig_func)
           (target, pname, param);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glFramebufferParameteri) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->param = param;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glFramebufferParameteri),
                              thread_mode);
}

/*
 * void
 * glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetFramebufferParameteriv))(GLenum target, GLenum pname, GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetFramebufferParameteriv) orig_func;
   GLenum target;
   GLenum pname;
   GLint *params;

} GL_TH_ST(glGetFramebufferParameteriv);

static void
GL_TH_CB(glGetFramebufferParameteriv)(void *data)
{
   GL_TH_ST(glGetFramebufferParameteriv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetFramebufferParameteriv))thread_data->orig_func)
      (thread_data->target,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetFramebufferParameteriv)(GL_TH_DP, GLenum target, GLenum pname, GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetFramebufferParameteriv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetFramebufferParameteriv))orig_func)
           (target, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetFramebufferParameteriv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetFramebufferParameteriv),
                              thread_mode);
}

/*
 * void
 * glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetProgramInterfaceiv))(GLuint program, GLenum programInterface, GLenum pname, GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetProgramInterfaceiv) orig_func;
   GLuint program;
   GLenum programInterface;
   GLenum pname;
   GLint *params;

} GL_TH_ST(glGetProgramInterfaceiv);

static void
GL_TH_CB(glGetProgramInterfaceiv)(void *data)
{
   GL_TH_ST(glGetProgramInterfaceiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetProgramInterfaceiv))thread_data->orig_func)
      (thread_data->program,
       thread_data->programInterface,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetProgramInterfaceiv)(GL_TH_DP, GLuint program, GLenum programInterface, GLenum pname, GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetProgramInterfaceiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetProgramInterfaceiv))orig_func)
           (program, programInterface, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetProgramInterfaceiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->programInterface = programInterface;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetProgramInterfaceiv),
                              thread_mode);
}

/*
 * GLuint
 * glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar *name);
 */

typedef GLuint(*GL_TH_FNTYPE(glGetProgramResourceIndex))(GLuint program, GLenum programInterface, const GLchar *name);

typedef struct
{
   GL_TH_FNTYPE(glGetProgramResourceIndex) orig_func;
   GLuint return_value;
   GLuint program;
   GLenum programInterface;
   const GLchar *name;

} GL_TH_ST(glGetProgramResourceIndex);

static void
GL_TH_CB(glGetProgramResourceIndex)(void *data)
{
   GL_TH_ST(glGetProgramResourceIndex) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glGetProgramResourceIndex))thread_data->orig_func)
      (thread_data->program,
       thread_data->programInterface,
       thread_data->name);

}

GLuint
GL_TH_FN(glGetProgramResourceIndex)(GL_TH_DP, GLuint program, GLenum programInterface, const GLchar *name)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetProgramResourceIndex) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glGetProgramResourceIndex))orig_func)
           (program, programInterface, name);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetProgramResourceIndex) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->programInterface = programInterface;
   thread_data->name = name;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetProgramResourceIndex),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
 */

typedef void(*GL_TH_FNTYPE(glGetProgramResourceName))(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);

typedef struct
{
   GL_TH_FNTYPE(glGetProgramResourceName) orig_func;
   GLuint program;
   GLenum programInterface;
   GLuint index;
   GLsizei bufSize;
   GLsizei *length;
   GLchar *name;

} GL_TH_ST(glGetProgramResourceName);

static void
GL_TH_CB(glGetProgramResourceName)(void *data)
{
   GL_TH_ST(glGetProgramResourceName) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetProgramResourceName))thread_data->orig_func)
      (thread_data->program,
       thread_data->programInterface,
       thread_data->index,
       thread_data->bufSize,
       thread_data->length,
       thread_data->name);

}

void
GL_TH_FN(glGetProgramResourceName)(GL_TH_DP, GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetProgramResourceName) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetProgramResourceName))orig_func)
           (program, programInterface, index, bufSize, length, name);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetProgramResourceName) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->programInterface = programInterface;
   thread_data->index = index;
   thread_data->bufSize = bufSize;
   thread_data->length = length;
   thread_data->name = name;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetProgramResourceName),
                              thread_mode);
}

/*
 * void
 * glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetProgramResourceiv))(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetProgramResourceiv) orig_func;
   GLuint program;
   GLenum programInterface;
   GLuint index;
   GLsizei propCount;
   const GLenum *props;
   GLsizei bufSize;
   GLsizei *length;
   GLint *params;

} GL_TH_ST(glGetProgramResourceiv);

static void
GL_TH_CB(glGetProgramResourceiv)(void *data)
{
   GL_TH_ST(glGetProgramResourceiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetProgramResourceiv))thread_data->orig_func)
      (thread_data->program,
       thread_data->programInterface,
       thread_data->index,
       thread_data->propCount,
       thread_data->props,
       thread_data->bufSize,
       thread_data->length,
       thread_data->params);

}

void
GL_TH_FN(glGetProgramResourceiv)(GL_TH_DP, GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetProgramResourceiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetProgramResourceiv))orig_func)
           (program, programInterface, index, propCount, props, bufSize, length, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetProgramResourceiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->programInterface = programInterface;
   thread_data->index = index;
   thread_data->propCount = propCount;
   thread_data->props = props;
   thread_data->bufSize = bufSize;
   thread_data->length = length;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetProgramResourceiv),
                              thread_mode);
}

/*
 * GLint
 * glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar *name);
 */

typedef GLint(*GL_TH_FNTYPE(glGetProgramResourceLocation))(GLuint program, GLenum programInterface, const GLchar *name);

typedef struct
{
   GL_TH_FNTYPE(glGetProgramResourceLocation) orig_func;
   GLint return_value;
   GLuint program;
   GLenum programInterface;
   const GLchar *name;

} GL_TH_ST(glGetProgramResourceLocation);

static void
GL_TH_CB(glGetProgramResourceLocation)(void *data)
{
   GL_TH_ST(glGetProgramResourceLocation) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glGetProgramResourceLocation))thread_data->orig_func)
      (thread_data->program,
       thread_data->programInterface,
       thread_data->name);

}

GLint
GL_TH_FN(glGetProgramResourceLocation)(GL_TH_DP, GLuint program, GLenum programInterface, const GLchar *name)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetProgramResourceLocation) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glGetProgramResourceLocation))orig_func)
           (program, programInterface, name);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetProgramResourceLocation) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->programInterface = programInterface;
   thread_data->name = name;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetProgramResourceLocation),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program);
 */

typedef void(*GL_TH_FNTYPE(glUseProgramStages))(GLuint pipeline, GLbitfield stages, GLuint program);

typedef struct
{
   GL_TH_FNTYPE(glUseProgramStages) orig_func;
   GLuint pipeline;
   GLbitfield stages;
   GLuint program;

} GL_TH_ST(glUseProgramStages);

static void
GL_TH_CB(glUseProgramStages)(void *data)
{
   GL_TH_ST(glUseProgramStages) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glUseProgramStages))thread_data->orig_func)
      (thread_data->pipeline,
       thread_data->stages,
       thread_data->program);

}

void
GL_TH_FN(glUseProgramStages)(GL_TH_DP, GLuint pipeline, GLbitfield stages, GLuint program)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glUseProgramStages) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glUseProgramStages))orig_func)
           (pipeline, stages, program);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glUseProgramStages) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pipeline = pipeline;
   thread_data->stages = stages;
   thread_data->program = program;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glUseProgramStages),
                              thread_mode);
}

/*
 * void
 * glActiveShaderProgram(GLuint pipeline, GLuint program);
 */

typedef void(*GL_TH_FNTYPE(glActiveShaderProgram))(GLuint pipeline, GLuint program);

typedef struct
{
   GL_TH_FNTYPE(glActiveShaderProgram) orig_func;
   GLuint pipeline;
   GLuint program;

} GL_TH_ST(glActiveShaderProgram);

static void
GL_TH_CB(glActiveShaderProgram)(void *data)
{
   GL_TH_ST(glActiveShaderProgram) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glActiveShaderProgram))thread_data->orig_func)
      (thread_data->pipeline,
       thread_data->program);

}

void
GL_TH_FN(glActiveShaderProgram)(GL_TH_DP, GLuint pipeline, GLuint program)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glActiveShaderProgram) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glActiveShaderProgram))orig_func)
           (pipeline, program);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glActiveShaderProgram) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pipeline = pipeline;
   thread_data->program = program;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glActiveShaderProgram),
                              thread_mode);
}

/*
 * GLuint
 * glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar *const*strings);
 */

typedef GLuint(*GL_TH_FNTYPE(glCreateShaderProgramv))(GLenum type, GLsizei count, const GLchar *const*strings);

typedef struct
{
   GL_TH_FNTYPE(glCreateShaderProgramv) orig_func;
   GLuint return_value;
   GLenum type;
   GLsizei count;
   const GLchar *const*strings;

} GL_TH_ST(glCreateShaderProgramv);

static void
GL_TH_CB(glCreateShaderProgramv)(void *data)
{
   GL_TH_ST(glCreateShaderProgramv) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glCreateShaderProgramv))thread_data->orig_func)
      (thread_data->type,
       thread_data->count,
       thread_data->strings);

}

GLuint
GL_TH_FN(glCreateShaderProgramv)(GL_TH_DP, GLenum type, GLsizei count, const GLchar *const*strings)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glCreateShaderProgramv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glCreateShaderProgramv))orig_func)
           (type, count, strings);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glCreateShaderProgramv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->type = type;
   thread_data->count = count;
   thread_data->strings = strings;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glCreateShaderProgramv),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glBindProgramPipeline(GLuint pipeline);
 */

typedef void(*GL_TH_FNTYPE(glBindProgramPipeline))(GLuint pipeline);

typedef struct
{
   GL_TH_FNTYPE(glBindProgramPipeline) orig_func;
   GLuint pipeline;

} GL_TH_ST(glBindProgramPipeline);

static void
GL_TH_CB(glBindProgramPipeline)(void *data)
{
   GL_TH_ST(glBindProgramPipeline) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindProgramPipeline))thread_data->orig_func)
      (thread_data->pipeline);

}

void
GL_TH_FN(glBindProgramPipeline)(GL_TH_DP, GLuint pipeline)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindProgramPipeline) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindProgramPipeline))orig_func)
           (pipeline);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindProgramPipeline) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pipeline = pipeline;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindProgramPipeline),
                              thread_mode);
}

/*
 * void
 * glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines);
 */

typedef void(*GL_TH_FNTYPE(glDeleteProgramPipelines))(GLsizei n, const GLuint *pipelines);

typedef struct
{
   GL_TH_FNTYPE(glDeleteProgramPipelines) orig_func;
   GLsizei n;
   const GLuint *pipelines;

} GL_TH_ST(glDeleteProgramPipelines);

static void
GL_TH_CB(glDeleteProgramPipelines)(void *data)
{
   GL_TH_ST(glDeleteProgramPipelines) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glDeleteProgramPipelines))thread_data->orig_func)
      (thread_data->n,
       thread_data->pipelines);

}

void
GL_TH_FN(glDeleteProgramPipelines)(GL_TH_DP, GLsizei n, const GLuint *pipelines)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glDeleteProgramPipelines) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glDeleteProgramPipelines))orig_func)
           (n, pipelines);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glDeleteProgramPipelines) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->pipelines = pipelines;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glDeleteProgramPipelines),
                              thread_mode);
}

/*
 * void
 * glGenProgramPipelines(GLsizei n, GLuint *pipelines);
 */

typedef void(*GL_TH_FNTYPE(glGenProgramPipelines))(GLsizei n, GLuint *pipelines);

typedef struct
{
   GL_TH_FNTYPE(glGenProgramPipelines) orig_func;
   GLsizei n;
   GLuint *pipelines;

} GL_TH_ST(glGenProgramPipelines);

static void
GL_TH_CB(glGenProgramPipelines)(void *data)
{
   GL_TH_ST(glGenProgramPipelines) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGenProgramPipelines))thread_data->orig_func)
      (thread_data->n,
       thread_data->pipelines);

}

void
GL_TH_FN(glGenProgramPipelines)(GL_TH_DP, GLsizei n, GLuint *pipelines)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGenProgramPipelines) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGenProgramPipelines))orig_func)
           (n, pipelines);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGenProgramPipelines) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->n = n;
   thread_data->pipelines = pipelines;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGenProgramPipelines),
                              thread_mode);
}

/*
 * GLboolean
 * glIsProgramPipeline(GLuint pipeline);
 */

typedef GLboolean(*GL_TH_FNTYPE(glIsProgramPipeline))(GLuint pipeline);

typedef struct
{
   GL_TH_FNTYPE(glIsProgramPipeline) orig_func;
   GLboolean return_value;
   GLuint pipeline;

} GL_TH_ST(glIsProgramPipeline);

static void
GL_TH_CB(glIsProgramPipeline)(void *data)
{
   GL_TH_ST(glIsProgramPipeline) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(glIsProgramPipeline))thread_data->orig_func)
      (thread_data->pipeline);

}

GLboolean
GL_TH_FN(glIsProgramPipeline)(GL_TH_DP, GLuint pipeline)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glIsProgramPipeline) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(glIsProgramPipeline))orig_func)
           (pipeline);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glIsProgramPipeline) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pipeline = pipeline;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glIsProgramPipeline),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetProgramPipelineiv))(GLuint pipeline, GLenum pname, GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetProgramPipelineiv) orig_func;
   GLuint pipeline;
   GLenum pname;
   GLint *params;

} GL_TH_ST(glGetProgramPipelineiv);

static void
GL_TH_CB(glGetProgramPipelineiv)(void *data)
{
   GL_TH_ST(glGetProgramPipelineiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetProgramPipelineiv))thread_data->orig_func)
      (thread_data->pipeline,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetProgramPipelineiv)(GL_TH_DP, GLuint pipeline, GLenum pname, GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetProgramPipelineiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetProgramPipelineiv))orig_func)
           (pipeline, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetProgramPipelineiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pipeline = pipeline;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetProgramPipelineiv),
                              thread_mode);
}

/*
 * void
 * glProgramUniform1i(GLuint program, GLint location, GLint v0);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform1i))(GLuint program, GLint location, GLint v0);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform1i) orig_func;
   GLuint program;
   GLint location;
   GLint v0;

} GL_TH_ST(glProgramUniform1i);

static void
GL_TH_CB(glProgramUniform1i)(void *data)
{
   GL_TH_ST(glProgramUniform1i) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform1i))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->v0);

}

void
GL_TH_FN(glProgramUniform1i)(GL_TH_DP, GLuint program, GLint location, GLint v0)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform1i) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform1i))orig_func)
           (program, location, v0);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform1i) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform1i),
                              thread_mode);
}

/*
 * void
 * glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform2i))(GLuint program, GLint location, GLint v0, GLint v1);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform2i) orig_func;
   GLuint program;
   GLint location;
   GLint v0;
   GLint v1;

} GL_TH_ST(glProgramUniform2i);

static void
GL_TH_CB(glProgramUniform2i)(void *data)
{
   GL_TH_ST(glProgramUniform2i) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform2i))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->v0,
       thread_data->v1);

}

void
GL_TH_FN(glProgramUniform2i)(GL_TH_DP, GLuint program, GLint location, GLint v0, GLint v1)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform2i) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform2i))orig_func)
           (program, location, v0, v1);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform2i) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform2i),
                              thread_mode);
}

/*
 * void
 * glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform3i))(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform3i) orig_func;
   GLuint program;
   GLint location;
   GLint v0;
   GLint v1;
   GLint v2;

} GL_TH_ST(glProgramUniform3i);

static void
GL_TH_CB(glProgramUniform3i)(void *data)
{
   GL_TH_ST(glProgramUniform3i) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform3i))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->v0,
       thread_data->v1,
       thread_data->v2);

}

void
GL_TH_FN(glProgramUniform3i)(GL_TH_DP, GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform3i) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform3i))orig_func)
           (program, location, v0, v1, v2);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform3i) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->v2 = v2;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform3i),
                              thread_mode);
}

/*
 * void
 * glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform4i))(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform4i) orig_func;
   GLuint program;
   GLint location;
   GLint v0;
   GLint v1;
   GLint v2;
   GLint v3;

} GL_TH_ST(glProgramUniform4i);

static void
GL_TH_CB(glProgramUniform4i)(void *data)
{
   GL_TH_ST(glProgramUniform4i) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform4i))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->v0,
       thread_data->v1,
       thread_data->v2,
       thread_data->v3);

}

void
GL_TH_FN(glProgramUniform4i)(GL_TH_DP, GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform4i) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform4i))orig_func)
           (program, location, v0, v1, v2, v3);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform4i) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->v2 = v2;
   thread_data->v3 = v3;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform4i),
                              thread_mode);
}

/*
 * void
 * glProgramUniform1ui(GLuint program, GLint location, GLuint v0);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform1ui))(GLuint program, GLint location, GLuint v0);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform1ui) orig_func;
   GLuint program;
   GLint location;
   GLuint v0;

} GL_TH_ST(glProgramUniform1ui);

static void
GL_TH_CB(glProgramUniform1ui)(void *data)
{
   GL_TH_ST(glProgramUniform1ui) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform1ui))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->v0);

}

void
GL_TH_FN(glProgramUniform1ui)(GL_TH_DP, GLuint program, GLint location, GLuint v0)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform1ui) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform1ui))orig_func)
           (program, location, v0);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform1ui) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform1ui),
                              thread_mode);
}

/*
 * void
 * glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform2ui))(GLuint program, GLint location, GLuint v0, GLuint v1);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform2ui) orig_func;
   GLuint program;
   GLint location;
   GLuint v0;
   GLuint v1;

} GL_TH_ST(glProgramUniform2ui);

static void
GL_TH_CB(glProgramUniform2ui)(void *data)
{
   GL_TH_ST(glProgramUniform2ui) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform2ui))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->v0,
       thread_data->v1);

}

void
GL_TH_FN(glProgramUniform2ui)(GL_TH_DP, GLuint program, GLint location, GLuint v0, GLuint v1)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform2ui) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform2ui))orig_func)
           (program, location, v0, v1);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform2ui) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform2ui),
                              thread_mode);
}

/*
 * void
 * glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform3ui))(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform3ui) orig_func;
   GLuint program;
   GLint location;
   GLuint v0;
   GLuint v1;
   GLuint v2;

} GL_TH_ST(glProgramUniform3ui);

static void
GL_TH_CB(glProgramUniform3ui)(void *data)
{
   GL_TH_ST(glProgramUniform3ui) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform3ui))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->v0,
       thread_data->v1,
       thread_data->v2);

}

void
GL_TH_FN(glProgramUniform3ui)(GL_TH_DP, GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform3ui) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform3ui))orig_func)
           (program, location, v0, v1, v2);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform3ui) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->v2 = v2;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform3ui),
                              thread_mode);
}

/*
 * void
 * glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform4ui))(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform4ui) orig_func;
   GLuint program;
   GLint location;
   GLuint v0;
   GLuint v1;
   GLuint v2;
   GLuint v3;

} GL_TH_ST(glProgramUniform4ui);

static void
GL_TH_CB(glProgramUniform4ui)(void *data)
{
   GL_TH_ST(glProgramUniform4ui) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform4ui))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->v0,
       thread_data->v1,
       thread_data->v2,
       thread_data->v3);

}

void
GL_TH_FN(glProgramUniform4ui)(GL_TH_DP, GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform4ui) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform4ui))orig_func)
           (program, location, v0, v1, v2, v3);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform4ui) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->v2 = v2;
   thread_data->v3 = v3;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform4ui),
                              thread_mode);
}

/*
 * void
 * glProgramUniform1f(GLuint program, GLint location, GLfloat v0);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform1f))(GLuint program, GLint location, GLfloat v0);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform1f) orig_func;
   GLuint program;
   GLint location;
   GLfloat v0;

} GL_TH_ST(glProgramUniform1f);

static void
GL_TH_CB(glProgramUniform1f)(void *data)
{
   GL_TH_ST(glProgramUniform1f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform1f))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->v0);

}

void
GL_TH_FN(glProgramUniform1f)(GL_TH_DP, GLuint program, GLint location, GLfloat v0)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform1f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform1f))orig_func)
           (program, location, v0);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform1f) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform1f),
                              thread_mode);
}

/*
 * void
 * glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform2f))(GLuint program, GLint location, GLfloat v0, GLfloat v1);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform2f) orig_func;
   GLuint program;
   GLint location;
   GLfloat v0;
   GLfloat v1;

} GL_TH_ST(glProgramUniform2f);

static void
GL_TH_CB(glProgramUniform2f)(void *data)
{
   GL_TH_ST(glProgramUniform2f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform2f))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->v0,
       thread_data->v1);

}

void
GL_TH_FN(glProgramUniform2f)(GL_TH_DP, GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform2f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform2f))orig_func)
           (program, location, v0, v1);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform2f) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform2f),
                              thread_mode);
}

/*
 * void
 * glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform3f))(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform3f) orig_func;
   GLuint program;
   GLint location;
   GLfloat v0;
   GLfloat v1;
   GLfloat v2;

} GL_TH_ST(glProgramUniform3f);

static void
GL_TH_CB(glProgramUniform3f)(void *data)
{
   GL_TH_ST(glProgramUniform3f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform3f))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->v0,
       thread_data->v1,
       thread_data->v2);

}

void
GL_TH_FN(glProgramUniform3f)(GL_TH_DP, GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform3f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform3f))orig_func)
           (program, location, v0, v1, v2);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform3f) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->v2 = v2;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform3f),
                              thread_mode);
}

/*
 * void
 * glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform4f))(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform4f) orig_func;
   GLuint program;
   GLint location;
   GLfloat v0;
   GLfloat v1;
   GLfloat v2;
   GLfloat v3;

} GL_TH_ST(glProgramUniform4f);

static void
GL_TH_CB(glProgramUniform4f)(void *data)
{
   GL_TH_ST(glProgramUniform4f) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform4f))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->v0,
       thread_data->v1,
       thread_data->v2,
       thread_data->v3);

}

void
GL_TH_FN(glProgramUniform4f)(GL_TH_DP, GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform4f) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform4f))orig_func)
           (program, location, v0, v1, v2, v3);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform4f) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->v0 = v0;
   thread_data->v1 = v1;
   thread_data->v2 = v2;
   thread_data->v3 = v3;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform4f),
                              thread_mode);
}

/*
 * void
 * glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform1iv))(GLuint program, GLint location, GLsizei count, const GLint *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform1iv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   const GLint *value;

} GL_TH_ST(glProgramUniform1iv);

static void
GL_TH_CB(glProgramUniform1iv)(void *data)
{
   GL_TH_ST(glProgramUniform1iv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform1iv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniform1iv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLint *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform1iv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform1iv))orig_func)
           (program, location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform1iv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform1iv),
                              thread_mode);
}

/*
 * void
 * glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform2iv))(GLuint program, GLint location, GLsizei count, const GLint *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform2iv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   const GLint *value;

} GL_TH_ST(glProgramUniform2iv);

static void
GL_TH_CB(glProgramUniform2iv)(void *data)
{
   GL_TH_ST(glProgramUniform2iv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform2iv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniform2iv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLint *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform2iv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform2iv))orig_func)
           (program, location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform2iv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform2iv),
                              thread_mode);
}

/*
 * void
 * glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform3iv))(GLuint program, GLint location, GLsizei count, const GLint *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform3iv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   const GLint *value;

} GL_TH_ST(glProgramUniform3iv);

static void
GL_TH_CB(glProgramUniform3iv)(void *data)
{
   GL_TH_ST(glProgramUniform3iv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform3iv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniform3iv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLint *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform3iv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform3iv))orig_func)
           (program, location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform3iv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform3iv),
                              thread_mode);
}

/*
 * void
 * glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform4iv))(GLuint program, GLint location, GLsizei count, const GLint *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform4iv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   const GLint *value;

} GL_TH_ST(glProgramUniform4iv);

static void
GL_TH_CB(glProgramUniform4iv)(void *data)
{
   GL_TH_ST(glProgramUniform4iv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform4iv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniform4iv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLint *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform4iv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform4iv))orig_func)
           (program, location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform4iv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform4iv),
                              thread_mode);
}

/*
 * void
 * glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform1uiv))(GLuint program, GLint location, GLsizei count, const GLuint *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform1uiv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   const GLuint *value;

} GL_TH_ST(glProgramUniform1uiv);

static void
GL_TH_CB(glProgramUniform1uiv)(void *data)
{
   GL_TH_ST(glProgramUniform1uiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform1uiv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniform1uiv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform1uiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform1uiv))orig_func)
           (program, location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform1uiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform1uiv),
                              thread_mode);
}

/*
 * void
 * glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform2uiv))(GLuint program, GLint location, GLsizei count, const GLuint *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform2uiv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   const GLuint *value;

} GL_TH_ST(glProgramUniform2uiv);

static void
GL_TH_CB(glProgramUniform2uiv)(void *data)
{
   GL_TH_ST(glProgramUniform2uiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform2uiv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniform2uiv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform2uiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform2uiv))orig_func)
           (program, location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform2uiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform2uiv),
                              thread_mode);
}

/*
 * void
 * glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform3uiv))(GLuint program, GLint location, GLsizei count, const GLuint *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform3uiv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   const GLuint *value;

} GL_TH_ST(glProgramUniform3uiv);

static void
GL_TH_CB(glProgramUniform3uiv)(void *data)
{
   GL_TH_ST(glProgramUniform3uiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform3uiv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniform3uiv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform3uiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform3uiv))orig_func)
           (program, location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform3uiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform3uiv),
                              thread_mode);
}

/*
 * void
 * glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform4uiv))(GLuint program, GLint location, GLsizei count, const GLuint *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform4uiv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   const GLuint *value;

} GL_TH_ST(glProgramUniform4uiv);

static void
GL_TH_CB(glProgramUniform4uiv)(void *data)
{
   GL_TH_ST(glProgramUniform4uiv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform4uiv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniform4uiv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform4uiv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform4uiv))orig_func)
           (program, location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform4uiv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform4uiv),
                              thread_mode);
}

/*
 * void
 * glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform1fv))(GLuint program, GLint location, GLsizei count, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform1fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   const GLfloat *value;

} GL_TH_ST(glProgramUniform1fv);

static void
GL_TH_CB(glProgramUniform1fv)(void *data)
{
   GL_TH_ST(glProgramUniform1fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform1fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniform1fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform1fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform1fv))orig_func)
           (program, location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform1fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform1fv),
                              thread_mode);
}

/*
 * void
 * glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform2fv))(GLuint program, GLint location, GLsizei count, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform2fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   const GLfloat *value;

} GL_TH_ST(glProgramUniform2fv);

static void
GL_TH_CB(glProgramUniform2fv)(void *data)
{
   GL_TH_ST(glProgramUniform2fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform2fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniform2fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform2fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform2fv))orig_func)
           (program, location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform2fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform2fv),
                              thread_mode);
}

/*
 * void
 * glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform3fv))(GLuint program, GLint location, GLsizei count, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform3fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   const GLfloat *value;

} GL_TH_ST(glProgramUniform3fv);

static void
GL_TH_CB(glProgramUniform3fv)(void *data)
{
   GL_TH_ST(glProgramUniform3fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform3fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniform3fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform3fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform3fv))orig_func)
           (program, location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform3fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform3fv),
                              thread_mode);
}

/*
 * void
 * glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniform4fv))(GLuint program, GLint location, GLsizei count, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniform4fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   const GLfloat *value;

} GL_TH_ST(glProgramUniform4fv);

static void
GL_TH_CB(glProgramUniform4fv)(void *data)
{
   GL_TH_ST(glProgramUniform4fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniform4fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniform4fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniform4fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniform4fv))orig_func)
           (program, location, count, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniform4fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniform4fv),
                              thread_mode);
}

/*
 * void
 * glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniformMatrix2fv))(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniformMatrix2fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glProgramUniformMatrix2fv);

static void
GL_TH_CB(glProgramUniformMatrix2fv)(void *data)
{
   GL_TH_ST(glProgramUniformMatrix2fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniformMatrix2fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniformMatrix2fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniformMatrix2fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniformMatrix2fv))orig_func)
           (program, location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniformMatrix2fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniformMatrix2fv),
                              thread_mode);
}

/*
 * void
 * glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniformMatrix3fv))(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniformMatrix3fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glProgramUniformMatrix3fv);

static void
GL_TH_CB(glProgramUniformMatrix3fv)(void *data)
{
   GL_TH_ST(glProgramUniformMatrix3fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniformMatrix3fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniformMatrix3fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniformMatrix3fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniformMatrix3fv))orig_func)
           (program, location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniformMatrix3fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniformMatrix3fv),
                              thread_mode);
}

/*
 * void
 * glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniformMatrix4fv))(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniformMatrix4fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glProgramUniformMatrix4fv);

static void
GL_TH_CB(glProgramUniformMatrix4fv)(void *data)
{
   GL_TH_ST(glProgramUniformMatrix4fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniformMatrix4fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniformMatrix4fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniformMatrix4fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniformMatrix4fv))orig_func)
           (program, location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniformMatrix4fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniformMatrix4fv),
                              thread_mode);
}

/*
 * void
 * glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniformMatrix2x3fv))(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniformMatrix2x3fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glProgramUniformMatrix2x3fv);

static void
GL_TH_CB(glProgramUniformMatrix2x3fv)(void *data)
{
   GL_TH_ST(glProgramUniformMatrix2x3fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniformMatrix2x3fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniformMatrix2x3fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniformMatrix2x3fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniformMatrix2x3fv))orig_func)
           (program, location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniformMatrix2x3fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniformMatrix2x3fv),
                              thread_mode);
}

/*
 * void
 * glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniformMatrix3x2fv))(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniformMatrix3x2fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glProgramUniformMatrix3x2fv);

static void
GL_TH_CB(glProgramUniformMatrix3x2fv)(void *data)
{
   GL_TH_ST(glProgramUniformMatrix3x2fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniformMatrix3x2fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniformMatrix3x2fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniformMatrix3x2fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniformMatrix3x2fv))orig_func)
           (program, location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniformMatrix3x2fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniformMatrix3x2fv),
                              thread_mode);
}

/*
 * void
 * glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniformMatrix2x4fv))(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniformMatrix2x4fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glProgramUniformMatrix2x4fv);

static void
GL_TH_CB(glProgramUniformMatrix2x4fv)(void *data)
{
   GL_TH_ST(glProgramUniformMatrix2x4fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniformMatrix2x4fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniformMatrix2x4fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniformMatrix2x4fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniformMatrix2x4fv))orig_func)
           (program, location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniformMatrix2x4fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniformMatrix2x4fv),
                              thread_mode);
}

/*
 * void
 * glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniformMatrix4x2fv))(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniformMatrix4x2fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glProgramUniformMatrix4x2fv);

static void
GL_TH_CB(glProgramUniformMatrix4x2fv)(void *data)
{
   GL_TH_ST(glProgramUniformMatrix4x2fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniformMatrix4x2fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniformMatrix4x2fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniformMatrix4x2fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniformMatrix4x2fv))orig_func)
           (program, location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniformMatrix4x2fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniformMatrix4x2fv),
                              thread_mode);
}

/*
 * void
 * glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniformMatrix3x4fv))(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniformMatrix3x4fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glProgramUniformMatrix3x4fv);

static void
GL_TH_CB(glProgramUniformMatrix3x4fv)(void *data)
{
   GL_TH_ST(glProgramUniformMatrix3x4fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniformMatrix3x4fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniformMatrix3x4fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniformMatrix3x4fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniformMatrix3x4fv))orig_func)
           (program, location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniformMatrix3x4fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniformMatrix3x4fv),
                              thread_mode);
}

/*
 * void
 * glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
 */

typedef void(*GL_TH_FNTYPE(glProgramUniformMatrix4x3fv))(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

typedef struct
{
   GL_TH_FNTYPE(glProgramUniformMatrix4x3fv) orig_func;
   GLuint program;
   GLint location;
   GLsizei count;
   GLboolean transpose;
   const GLfloat *value;

} GL_TH_ST(glProgramUniformMatrix4x3fv);

static void
GL_TH_CB(glProgramUniformMatrix4x3fv)(void *data)
{
   GL_TH_ST(glProgramUniformMatrix4x3fv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glProgramUniformMatrix4x3fv))thread_data->orig_func)
      (thread_data->program,
       thread_data->location,
       thread_data->count,
       thread_data->transpose,
       thread_data->value);

}

void
GL_TH_FN(glProgramUniformMatrix4x3fv)(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glProgramUniformMatrix4x3fv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glProgramUniformMatrix4x3fv))orig_func)
           (program, location, count, transpose, value);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glProgramUniformMatrix4x3fv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->program = program;
   thread_data->location = location;
   thread_data->count = count;
   thread_data->transpose = transpose;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glProgramUniformMatrix4x3fv),
                              thread_mode);
}

/*
 * void
 * glValidateProgramPipeline(GLuint pipeline);
 */

typedef void(*GL_TH_FNTYPE(glValidateProgramPipeline))(GLuint pipeline);

typedef struct
{
   GL_TH_FNTYPE(glValidateProgramPipeline) orig_func;
   GLuint pipeline;

} GL_TH_ST(glValidateProgramPipeline);

static void
GL_TH_CB(glValidateProgramPipeline)(void *data)
{
   GL_TH_ST(glValidateProgramPipeline) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glValidateProgramPipeline))thread_data->orig_func)
      (thread_data->pipeline);

}

void
GL_TH_FN(glValidateProgramPipeline)(GL_TH_DP, GLuint pipeline)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glValidateProgramPipeline) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glValidateProgramPipeline))orig_func)
           (pipeline);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glValidateProgramPipeline) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pipeline = pipeline;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glValidateProgramPipeline),
                              thread_mode);
}

/*
 * void
 * glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
 */

typedef void(*GL_TH_FNTYPE(glGetProgramPipelineInfoLog))(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);

typedef struct
{
   GL_TH_FNTYPE(glGetProgramPipelineInfoLog) orig_func;
   GLuint pipeline;
   GLsizei bufSize;
   GLsizei *length;
   GLchar *infoLog;

} GL_TH_ST(glGetProgramPipelineInfoLog);

static void
GL_TH_CB(glGetProgramPipelineInfoLog)(void *data)
{
   GL_TH_ST(glGetProgramPipelineInfoLog) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetProgramPipelineInfoLog))thread_data->orig_func)
      (thread_data->pipeline,
       thread_data->bufSize,
       thread_data->length,
       thread_data->infoLog);

}

void
GL_TH_FN(glGetProgramPipelineInfoLog)(GL_TH_DP, GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetProgramPipelineInfoLog) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetProgramPipelineInfoLog))orig_func)
           (pipeline, bufSize, length, infoLog);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetProgramPipelineInfoLog) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pipeline = pipeline;
   thread_data->bufSize = bufSize;
   thread_data->length = length;
   thread_data->infoLog = infoLog;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetProgramPipelineInfoLog),
                              thread_mode);
}

/*
 * void
 * glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
 */

typedef void(*GL_TH_FNTYPE(glBindImageTexture))(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);

typedef struct
{
   GL_TH_FNTYPE(glBindImageTexture) orig_func;
   GLuint unit;
   GLuint texture;
   GLint level;
   GLboolean layered;
   GLint layer;
   GLenum access;
   GLenum format;

} GL_TH_ST(glBindImageTexture);

static void
GL_TH_CB(glBindImageTexture)(void *data)
{
   GL_TH_ST(glBindImageTexture) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindImageTexture))thread_data->orig_func)
      (thread_data->unit,
       thread_data->texture,
       thread_data->level,
       thread_data->layered,
       thread_data->layer,
       thread_data->access,
       thread_data->format);

}

void
GL_TH_FN(glBindImageTexture)(GL_TH_DP, GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindImageTexture) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindImageTexture))orig_func)
           (unit, texture, level, layered, layer, access, format);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindImageTexture) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->unit = unit;
   thread_data->texture = texture;
   thread_data->level = level;
   thread_data->layered = layered;
   thread_data->layer = layer;
   thread_data->access = access;
   thread_data->format = format;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindImageTexture),
                              thread_mode);
}

/*
 * void
 * glGetBooleani_v(GLenum target, GLuint index, GLboolean *data);
 */

typedef void(*GL_TH_FNTYPE(glGetBooleani_v))(GLenum target, GLuint index, GLboolean *data);

typedef struct
{
   GL_TH_FNTYPE(glGetBooleani_v) orig_func;
   GLenum target;
   GLuint index;
   GLboolean *data;

} GL_TH_ST(glGetBooleani_v);

static void
GL_TH_CB(glGetBooleani_v)(void *data)
{
   GL_TH_ST(glGetBooleani_v) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetBooleani_v))thread_data->orig_func)
      (thread_data->target,
       thread_data->index,
       thread_data->data);

}

void
GL_TH_FN(glGetBooleani_v)(GL_TH_DP, GLenum target, GLuint index, GLboolean *data)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetBooleani_v) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetBooleani_v))orig_func)
           (target, index, data);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetBooleani_v) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->index = index;
   thread_data->data = data;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetBooleani_v),
                              thread_mode);
}

/*
 * void
 * glMemoryBarrier(GLbitfield barriers);
 */

typedef void(*GL_TH_FNTYPE(glMemoryBarrier))(GLbitfield barriers);

typedef struct
{
   GL_TH_FNTYPE(glMemoryBarrier) orig_func;
   GLbitfield barriers;

} GL_TH_ST(glMemoryBarrier);

static void
GL_TH_CB(glMemoryBarrier)(void *data)
{
   GL_TH_ST(glMemoryBarrier) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMemoryBarrier))thread_data->orig_func)
      (thread_data->barriers);

}

void
GL_TH_FN(glMemoryBarrier)(GL_TH_DP, GLbitfield barriers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMemoryBarrier) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMemoryBarrier))orig_func)
           (barriers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMemoryBarrier) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->barriers = barriers;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMemoryBarrier),
                              thread_mode);
}

/*
 * void
 * glMemoryBarrierByRegion(GLbitfield barriers);
 */

typedef void(*GL_TH_FNTYPE(glMemoryBarrierByRegion))(GLbitfield barriers);

typedef struct
{
   GL_TH_FNTYPE(glMemoryBarrierByRegion) orig_func;
   GLbitfield barriers;

} GL_TH_ST(glMemoryBarrierByRegion);

static void
GL_TH_CB(glMemoryBarrierByRegion)(void *data)
{
   GL_TH_ST(glMemoryBarrierByRegion) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glMemoryBarrierByRegion))thread_data->orig_func)
      (thread_data->barriers);

}

void
GL_TH_FN(glMemoryBarrierByRegion)(GL_TH_DP, GLbitfield barriers)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glMemoryBarrierByRegion) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glMemoryBarrierByRegion))orig_func)
           (barriers);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glMemoryBarrierByRegion) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->barriers = barriers;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glMemoryBarrierByRegion),
                              thread_mode);
}

/*
 * void
 * glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
 */

typedef void(*GL_TH_FNTYPE(glTexStorage2DMultisample))(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);

typedef struct
{
   GL_TH_FNTYPE(glTexStorage2DMultisample) orig_func;
   GLenum target;
   GLsizei samples;
   GLenum internalformat;
   GLsizei width;
   GLsizei height;
   GLboolean fixedsamplelocations;

} GL_TH_ST(glTexStorage2DMultisample);

static void
GL_TH_CB(glTexStorage2DMultisample)(void *data)
{
   GL_TH_ST(glTexStorage2DMultisample) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glTexStorage2DMultisample))thread_data->orig_func)
      (thread_data->target,
       thread_data->samples,
       thread_data->internalformat,
       thread_data->width,
       thread_data->height,
       thread_data->fixedsamplelocations);

}

void
GL_TH_FN(glTexStorage2DMultisample)(GL_TH_DP, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glTexStorage2DMultisample) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glTexStorage2DMultisample))orig_func)
           (target, samples, internalformat, width, height, fixedsamplelocations);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glTexStorage2DMultisample) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->samples = samples;
   thread_data->internalformat = internalformat;
   thread_data->width = width;
   thread_data->height = height;
   thread_data->fixedsamplelocations = fixedsamplelocations;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glTexStorage2DMultisample),
                              thread_mode);
}

/*
 * void
 * glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val);
 */

typedef void(*GL_TH_FNTYPE(glGetMultisamplefv))(GLenum pname, GLuint index, GLfloat *val);

typedef struct
{
   GL_TH_FNTYPE(glGetMultisamplefv) orig_func;
   GLenum pname;
   GLuint index;
   GLfloat *val;

} GL_TH_ST(glGetMultisamplefv);

static void
GL_TH_CB(glGetMultisamplefv)(void *data)
{
   GL_TH_ST(glGetMultisamplefv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetMultisamplefv))thread_data->orig_func)
      (thread_data->pname,
       thread_data->index,
       thread_data->val);

}

void
GL_TH_FN(glGetMultisamplefv)(GL_TH_DP, GLenum pname, GLuint index, GLfloat *val)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetMultisamplefv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetMultisamplefv))orig_func)
           (pname, index, val);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetMultisamplefv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->pname = pname;
   thread_data->index = index;
   thread_data->val = val;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetMultisamplefv),
                              thread_mode);
}

/*
 * void
 * glSampleMaski(GLuint maskNumber, GLbitfield mask);
 */

typedef void(*GL_TH_FNTYPE(glSampleMaski))(GLuint maskNumber, GLbitfield mask);

typedef struct
{
   GL_TH_FNTYPE(glSampleMaski) orig_func;
   GLuint maskNumber;
   GLbitfield mask;

} GL_TH_ST(glSampleMaski);

static void
GL_TH_CB(glSampleMaski)(void *data)
{
   GL_TH_ST(glSampleMaski) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glSampleMaski))thread_data->orig_func)
      (thread_data->maskNumber,
       thread_data->mask);

}

void
GL_TH_FN(glSampleMaski)(GL_TH_DP, GLuint maskNumber, GLbitfield mask)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glSampleMaski) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glSampleMaski))orig_func)
           (maskNumber, mask);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glSampleMaski) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->maskNumber = maskNumber;
   thread_data->mask = mask;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glSampleMaski),
                              thread_mode);
}

#ifndef GL_GLES
/*
 * void
 * glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexLevelParameteriv))(GLenum target, GLint level, GLenum pname, GLint *params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexLevelParameteriv) orig_func;
   GLenum target;
   GLint level;
   GLenum pname;
   GLint *params;

} GL_TH_ST(glGetTexLevelParameteriv);

static void
GL_TH_CB(glGetTexLevelParameteriv)(void *data)
{
   GL_TH_ST(glGetTexLevelParameteriv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexLevelParameteriv))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexLevelParameteriv)(GL_TH_DP, GLenum target, GLint level, GLenum pname, GLint *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexLevelParameteriv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexLevelParameteriv))orig_func)
           (target, level, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexLevelParameteriv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexLevelParameteriv),
                              thread_mode);
}

#endif
/*
 * void
 * glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params);
 */

typedef void(*GL_TH_FNTYPE(glGetTexLevelParameterfv))(GLenum target, GLint level, GLenum pname, GLfloat *params);

typedef struct
{
   GL_TH_FNTYPE(glGetTexLevelParameterfv) orig_func;
   GLenum target;
   GLint level;
   GLenum pname;
   GLfloat *params;

} GL_TH_ST(glGetTexLevelParameterfv);

static void
GL_TH_CB(glGetTexLevelParameterfv)(void *data)
{
   GL_TH_ST(glGetTexLevelParameterfv) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glGetTexLevelParameterfv))thread_data->orig_func)
      (thread_data->target,
       thread_data->level,
       thread_data->pname,
       thread_data->params);

}

void
GL_TH_FN(glGetTexLevelParameterfv)(GL_TH_DP, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glGetTexLevelParameterfv) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glGetTexLevelParameterfv))orig_func)
           (target, level, pname, params);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glGetTexLevelParameterfv) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->level = level;
   thread_data->pname = pname;
   thread_data->params = params;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glGetTexLevelParameterfv),
                              thread_mode);
}

/*
 * void
 * glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
 */

typedef void(*GL_TH_FNTYPE(glBindVertexBuffer))(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);

typedef struct
{
   GL_TH_FNTYPE(glBindVertexBuffer) orig_func;
   GLuint bindingindex;
   GLuint buffer;
   GLintptr offset;
   GLsizei stride;

} GL_TH_ST(glBindVertexBuffer);

static void
GL_TH_CB(glBindVertexBuffer)(void *data)
{
   GL_TH_ST(glBindVertexBuffer) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glBindVertexBuffer))thread_data->orig_func)
      (thread_data->bindingindex,
       thread_data->buffer,
       thread_data->offset,
       thread_data->stride);

}

void
GL_TH_FN(glBindVertexBuffer)(GL_TH_DP, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glBindVertexBuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glBindVertexBuffer))orig_func)
           (bindingindex, buffer, offset, stride);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glBindVertexBuffer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->bindingindex = bindingindex;
   thread_data->buffer = buffer;
   thread_data->offset = offset;
   thread_data->stride = stride;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glBindVertexBuffer),
                              thread_mode);
}

/*
 * void
 * glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttribFormat))(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttribFormat) orig_func;
   GLuint attribindex;
   GLint size;
   GLenum type;
   GLboolean normalized;
   GLuint relativeoffset;

} GL_TH_ST(glVertexAttribFormat);

static void
GL_TH_CB(glVertexAttribFormat)(void *data)
{
   GL_TH_ST(glVertexAttribFormat) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttribFormat))thread_data->orig_func)
      (thread_data->attribindex,
       thread_data->size,
       thread_data->type,
       thread_data->normalized,
       thread_data->relativeoffset);

}

void
GL_TH_FN(glVertexAttribFormat)(GL_TH_DP, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttribFormat) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttribFormat))orig_func)
           (attribindex, size, type, normalized, relativeoffset);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttribFormat) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->attribindex = attribindex;
   thread_data->size = size;
   thread_data->type = type;
   thread_data->normalized = normalized;
   thread_data->relativeoffset = relativeoffset;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttribFormat),
                              thread_mode);
}

/*
 * void
 * glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttribIFormat))(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttribIFormat) orig_func;
   GLuint attribindex;
   GLint size;
   GLenum type;
   GLuint relativeoffset;

} GL_TH_ST(glVertexAttribIFormat);

static void
GL_TH_CB(glVertexAttribIFormat)(void *data)
{
   GL_TH_ST(glVertexAttribIFormat) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttribIFormat))thread_data->orig_func)
      (thread_data->attribindex,
       thread_data->size,
       thread_data->type,
       thread_data->relativeoffset);

}

void
GL_TH_FN(glVertexAttribIFormat)(GL_TH_DP, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttribIFormat) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttribIFormat))orig_func)
           (attribindex, size, type, relativeoffset);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttribIFormat) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->attribindex = attribindex;
   thread_data->size = size;
   thread_data->type = type;
   thread_data->relativeoffset = relativeoffset;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttribIFormat),
                              thread_mode);
}

/*
 * void
 * glVertexAttribBinding(GLuint attribindex, GLuint bindingindex);
 */

typedef void(*GL_TH_FNTYPE(glVertexAttribBinding))(GLuint attribindex, GLuint bindingindex);

typedef struct
{
   GL_TH_FNTYPE(glVertexAttribBinding) orig_func;
   GLuint attribindex;
   GLuint bindingindex;

} GL_TH_ST(glVertexAttribBinding);

static void
GL_TH_CB(glVertexAttribBinding)(void *data)
{
   GL_TH_ST(glVertexAttribBinding) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexAttribBinding))thread_data->orig_func)
      (thread_data->attribindex,
       thread_data->bindingindex);

}

void
GL_TH_FN(glVertexAttribBinding)(GL_TH_DP, GLuint attribindex, GLuint bindingindex)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexAttribBinding) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexAttribBinding))orig_func)
           (attribindex, bindingindex);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexAttribBinding) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->attribindex = attribindex;
   thread_data->bindingindex = bindingindex;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexAttribBinding),
                              thread_mode);
}

/*
 * void
 * glVertexBindingDivisor(GLuint bindingindex, GLuint divisor);
 */

typedef void(*GL_TH_FNTYPE(glVertexBindingDivisor))(GLuint bindingindex, GLuint divisor);

typedef struct
{
   GL_TH_FNTYPE(glVertexBindingDivisor) orig_func;
   GLuint bindingindex;
   GLuint divisor;

} GL_TH_ST(glVertexBindingDivisor);

static void
GL_TH_CB(glVertexBindingDivisor)(void *data)
{
   GL_TH_ST(glVertexBindingDivisor) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glVertexBindingDivisor))thread_data->orig_func)
      (thread_data->bindingindex,
       thread_data->divisor);

}

void
GL_TH_FN(glVertexBindingDivisor)(GL_TH_DP, GLuint bindingindex, GLuint divisor)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glVertexBindingDivisor) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glVertexBindingDivisor))orig_func)
           (bindingindex, divisor);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glVertexBindingDivisor) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->bindingindex = bindingindex;
   thread_data->divisor = divisor;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glVertexBindingDivisor),
                              thread_mode);
}

/*
 * void
 * glEGLImageTargetTexture2DOES(GLenum target, void *image);
 */

typedef void(*GL_TH_FNTYPE(glEGLImageTargetTexture2DOES))(GLenum target, void *image);

typedef struct
{
   GL_TH_FNTYPE(glEGLImageTargetTexture2DOES) orig_func;
   GLenum target;
   void *image;

} GL_TH_ST(glEGLImageTargetTexture2DOES);

static void
GL_TH_CB(glEGLImageTargetTexture2DOES)(void *data)
{
   GL_TH_ST(glEGLImageTargetTexture2DOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glEGLImageTargetTexture2DOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->image);

}

void
GL_TH_FN(glEGLImageTargetTexture2DOES)(GL_TH_DP, GLenum target, void *image)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glEGLImageTargetTexture2DOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glEGLImageTargetTexture2DOES))orig_func)
           (target, image);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glEGLImageTargetTexture2DOES) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->image = image;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glEGLImageTargetTexture2DOES),
                              thread_mode);
}

/*
 * void
 * glEGLImageTargetRenderbufferStorageOES(GLenum target, void *image);
 */

typedef void(*GL_TH_FNTYPE(glEGLImageTargetRenderbufferStorageOES))(GLenum target, void *image);

typedef struct
{
   GL_TH_FNTYPE(glEGLImageTargetRenderbufferStorageOES) orig_func;
   GLenum target;
   void *image;

} GL_TH_ST(glEGLImageTargetRenderbufferStorageOES);

static void
GL_TH_CB(glEGLImageTargetRenderbufferStorageOES)(void *data)
{
   GL_TH_ST(glEGLImageTargetRenderbufferStorageOES) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(glEGLImageTargetRenderbufferStorageOES))thread_data->orig_func)
      (thread_data->target,
       thread_data->image);

}

void
GL_TH_FN(glEGLImageTargetRenderbufferStorageOES)(GL_TH_DP, GLenum target, void *image)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(glEGLImageTargetRenderbufferStorageOES) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(glEGLImageTargetRenderbufferStorageOES))orig_func)
           (target, image);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(glEGLImageTargetRenderbufferStorageOES) *) + sizeof(GL_TH_ST(glEGLImageTargetRenderbufferStorageOES)), &thcmd_ref);
   *thread_data_ptr = (void *)((char *)thread_data_ptr + sizeof(GL_TH_ST(glEGLImageTargetRenderbufferStorageOES) *));
   thread_data = *thread_data_ptr;

   if (!evas_gl_thread_force_finish())
     thread_mode = EVAS_GL_THREAD_MODE_FLUSH;

   thread_data->target = target;
   thread_data->image = image;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(glEGLImageTargetRenderbufferStorageOES),
                              thread_mode);
}

/*
 * EvasGLImage
 * evasglCreateImage(int target, void* buffer, const int *attrib_list);
 */

typedef EvasGLImage(*GL_TH_FNTYPE(evasglCreateImage))(int target, void* buffer, const int *attrib_list);

typedef struct
{
   GL_TH_FNTYPE(evasglCreateImage) orig_func;
   EvasGLImage return_value;
   int target;
   void* buffer;
   const int *attrib_list;

} GL_TH_ST(evasglCreateImage);

static void
GL_TH_CB(evasglCreateImage)(void *data)
{
   GL_TH_ST(evasglCreateImage) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(evasglCreateImage))thread_data->orig_func)
      (thread_data->target,
       thread_data->buffer,
       thread_data->attrib_list);

}

EvasGLImage
GL_TH_FN(evasglCreateImage)(GL_TH_DP, int target, void* buffer, const int *attrib_list)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(evasglCreateImage) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(evasglCreateImage))orig_func)
           (target, buffer, attrib_list);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(evasglCreateImage) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->target = target;
   thread_data->buffer = buffer;
   thread_data->attrib_list = attrib_list;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(evasglCreateImage),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * void
 * evasglDestroyImage(EvasGLImage image);
 */

typedef void(*GL_TH_FNTYPE(evasglDestroyImage))(EvasGLImage image);

typedef struct
{
   GL_TH_FNTYPE(evasglDestroyImage) orig_func;
   EvasGLImage image;

} GL_TH_ST(evasglDestroyImage);

static void
GL_TH_CB(evasglDestroyImage)(void *data)
{
   GL_TH_ST(evasglDestroyImage) *thread_data =
      *(void **)data;


   ((GL_TH_FNTYPE(evasglDestroyImage))thread_data->orig_func)
      (thread_data->image);

}

void
GL_TH_FN(evasglDestroyImage)(GL_TH_DP, EvasGLImage image)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(evasglDestroyImage) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        ((GL_TH_FNTYPE(evasglDestroyImage))orig_func)
           (image);
        return;
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(evasglDestroyImage) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->image = image;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(evasglDestroyImage),
                              thread_mode);
}

/*
 * EvasGLImage
 * evasglCreateImageForContext(Evas_GL *evas_gl, Evas_GL_Context *ctx, int target, void* buffer, const int *attrib_list);
 */

typedef EvasGLImage(*GL_TH_FNTYPE(evasglCreateImageForContext))(Evas_GL *evas_gl, Evas_GL_Context *ctx, int target, void* buffer, const int *attrib_list);

typedef struct
{
   GL_TH_FNTYPE(evasglCreateImageForContext) orig_func;
   EvasGLImage return_value;
   Evas_GL *evas_gl;
   Evas_GL_Context *ctx;
   int target;
   void* buffer;
   const int *attrib_list;

} GL_TH_ST(evasglCreateImageForContext);

static void
GL_TH_CB(evasglCreateImageForContext)(void *data)
{
   GL_TH_ST(evasglCreateImageForContext) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(evasglCreateImageForContext))thread_data->orig_func)
      (thread_data->evas_gl,
       thread_data->ctx,
       thread_data->target,
       thread_data->buffer,
       thread_data->attrib_list);

}

EvasGLImage
GL_TH_FN(evasglCreateImageForContext)(GL_TH_DP, Evas_GL *evas_gl, Evas_GL_Context *ctx, int target, void* buffer, const int *attrib_list)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(evasglCreateImageForContext) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(evasglCreateImageForContext))orig_func)
           (evas_gl, ctx, target, buffer, attrib_list);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(evasglCreateImageForContext) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->evas_gl = evas_gl;
   thread_data->ctx = ctx;
   thread_data->target = target;
   thread_data->buffer = buffer;
   thread_data->attrib_list = attrib_list;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(evasglCreateImageForContext),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * EvasGLSync
 * evasglCreateSync(Evas_GL *evas_gl, unsigned int type, const int *attrib_list);
 */

typedef EvasGLSync(*GL_TH_FNTYPE(evasglCreateSync))(Evas_GL *evas_gl, unsigned int type, const int *attrib_list);

typedef struct
{
   GL_TH_FNTYPE(evasglCreateSync) orig_func;
   EvasGLSync return_value;
   Evas_GL *evas_gl;
   unsigned int type;
   const int *attrib_list;

} GL_TH_ST(evasglCreateSync);

static void
GL_TH_CB(evasglCreateSync)(void *data)
{
   GL_TH_ST(evasglCreateSync) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(evasglCreateSync))thread_data->orig_func)
      (thread_data->evas_gl,
       thread_data->type,
       thread_data->attrib_list);

}

EvasGLSync
GL_TH_FN(evasglCreateSync)(GL_TH_DP, Evas_GL *evas_gl, unsigned int type, const int *attrib_list)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(evasglCreateSync) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(evasglCreateSync))orig_func)
           (evas_gl, type, attrib_list);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(evasglCreateSync) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->evas_gl = evas_gl;
   thread_data->type = type;
   thread_data->attrib_list = attrib_list;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(evasglCreateSync),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * Eina_Bool
 * evasglDestroySync(Evas_GL *evas_gl, EvasGLSync sync);
 */

typedef Eina_Bool(*GL_TH_FNTYPE(evasglDestroySync))(Evas_GL *evas_gl, EvasGLSync sync);

typedef struct
{
   GL_TH_FNTYPE(evasglDestroySync) orig_func;
   Eina_Bool return_value;
   Evas_GL *evas_gl;
   EvasGLSync sync;

} GL_TH_ST(evasglDestroySync);

static void
GL_TH_CB(evasglDestroySync)(void *data)
{
   GL_TH_ST(evasglDestroySync) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(evasglDestroySync))thread_data->orig_func)
      (thread_data->evas_gl,
       thread_data->sync);

}

Eina_Bool
GL_TH_FN(evasglDestroySync)(GL_TH_DP, Evas_GL *evas_gl, EvasGLSync sync)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(evasglDestroySync) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(evasglDestroySync))orig_func)
           (evas_gl, sync);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(evasglDestroySync) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->evas_gl = evas_gl;
   thread_data->sync = sync;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(evasglDestroySync),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * int
 * evasglClientWaitSync(Evas_GL *evas_gl, EvasGLSync sync, int flags, EvasGLTime timeout);
 */

typedef int(*GL_TH_FNTYPE(evasglClientWaitSync))(Evas_GL *evas_gl, EvasGLSync sync, int flags, EvasGLTime timeout);

typedef struct
{
   GL_TH_FNTYPE(evasglClientWaitSync) orig_func;
   int return_value;
   Evas_GL *evas_gl;
   EvasGLSync sync;
   int flags;
   EvasGLTime timeout;

} GL_TH_ST(evasglClientWaitSync);

static void
GL_TH_CB(evasglClientWaitSync)(void *data)
{
   GL_TH_ST(evasglClientWaitSync) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(evasglClientWaitSync))thread_data->orig_func)
      (thread_data->evas_gl,
       thread_data->sync,
       thread_data->flags,
       thread_data->timeout);

}

int
GL_TH_FN(evasglClientWaitSync)(GL_TH_DP, Evas_GL *evas_gl, EvasGLSync sync, int flags, EvasGLTime timeout)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(evasglClientWaitSync) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(evasglClientWaitSync))orig_func)
           (evas_gl, sync, flags, timeout);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(evasglClientWaitSync) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->evas_gl = evas_gl;
   thread_data->sync = sync;
   thread_data->flags = flags;
   thread_data->timeout = timeout;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(evasglClientWaitSync),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * Eina_Bool
 * evasglGetSyncAttrib(Evas_GL *evas_gl, EvasGLSync sync, int attribute, int *value);
 */

typedef Eina_Bool(*GL_TH_FNTYPE(evasglGetSyncAttrib))(Evas_GL *evas_gl, EvasGLSync sync, int attribute, int *value);

typedef struct
{
   GL_TH_FNTYPE(evasglGetSyncAttrib) orig_func;
   Eina_Bool return_value;
   Evas_GL *evas_gl;
   EvasGLSync sync;
   int attribute;
   int *value;

} GL_TH_ST(evasglGetSyncAttrib);

static void
GL_TH_CB(evasglGetSyncAttrib)(void *data)
{
   GL_TH_ST(evasglGetSyncAttrib) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(evasglGetSyncAttrib))thread_data->orig_func)
      (thread_data->evas_gl,
       thread_data->sync,
       thread_data->attribute,
       thread_data->value);

}

Eina_Bool
GL_TH_FN(evasglGetSyncAttrib)(GL_TH_DP, Evas_GL *evas_gl, EvasGLSync sync, int attribute, int *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(evasglGetSyncAttrib) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(evasglGetSyncAttrib))orig_func)
           (evas_gl, sync, attribute, value);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(evasglGetSyncAttrib) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->evas_gl = evas_gl;
   thread_data->sync = sync;
   thread_data->attribute = attribute;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(evasglGetSyncAttrib),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * Eina_Bool
 * evasglSignalSync(Evas_GL *evas_gl, EvasGLSync sync, unsigned mode);
 */

typedef Eina_Bool(*GL_TH_FNTYPE(evasglSignalSync))(Evas_GL *evas_gl, EvasGLSync sync, unsigned mode);

typedef struct
{
   GL_TH_FNTYPE(evasglSignalSync) orig_func;
   Eina_Bool return_value;
   Evas_GL *evas_gl;
   EvasGLSync sync;
   unsigned mode;

} GL_TH_ST(evasglSignalSync);

static void
GL_TH_CB(evasglSignalSync)(void *data)
{
   GL_TH_ST(evasglSignalSync) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(evasglSignalSync))thread_data->orig_func)
      (thread_data->evas_gl,
       thread_data->sync,
       thread_data->mode);

}

Eina_Bool
GL_TH_FN(evasglSignalSync)(GL_TH_DP, Evas_GL *evas_gl, EvasGLSync sync, unsigned mode)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(evasglSignalSync) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(evasglSignalSync))orig_func)
           (evas_gl, sync, mode);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(evasglSignalSync) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->evas_gl = evas_gl;
   thread_data->sync = sync;
   thread_data->mode = mode;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(evasglSignalSync),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * int
 * evasglWaitSync(Evas_GL *evas_gl, EvasGLSync sync, int flags);
 */

typedef int(*GL_TH_FNTYPE(evasglWaitSync))(Evas_GL *evas_gl, EvasGLSync sync, int flags);

typedef struct
{
   GL_TH_FNTYPE(evasglWaitSync) orig_func;
   int return_value;
   Evas_GL *evas_gl;
   EvasGLSync sync;
   int flags;

} GL_TH_ST(evasglWaitSync);

static void
GL_TH_CB(evasglWaitSync)(void *data)
{
   GL_TH_ST(evasglWaitSync) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(evasglWaitSync))thread_data->orig_func)
      (thread_data->evas_gl,
       thread_data->sync,
       thread_data->flags);

}

int
GL_TH_FN(evasglWaitSync)(GL_TH_DP, Evas_GL *evas_gl, EvasGLSync sync, int flags)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(evasglWaitSync) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(evasglWaitSync))orig_func)
           (evas_gl, sync, flags);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(evasglWaitSync) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->evas_gl = evas_gl;
   thread_data->sync = sync;
   thread_data->flags = flags;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(evasglWaitSync),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * Eina_Bool
 * evasglBindWaylandDisplay(Evas_GL *evas_gl, void *wl_display);
 */

typedef Eina_Bool(*GL_TH_FNTYPE(evasglBindWaylandDisplay))(Evas_GL *evas_gl, void *wl_display);

typedef struct
{
   GL_TH_FNTYPE(evasglBindWaylandDisplay) orig_func;
   Eina_Bool return_value;
   Evas_GL *evas_gl;
   void *wl_display;

} GL_TH_ST(evasglBindWaylandDisplay);

static void
GL_TH_CB(evasglBindWaylandDisplay)(void *data)
{
   GL_TH_ST(evasglBindWaylandDisplay) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(evasglBindWaylandDisplay))thread_data->orig_func)
      (thread_data->evas_gl,
       thread_data->wl_display);

}

Eina_Bool
GL_TH_FN(evasglBindWaylandDisplay)(GL_TH_DP, Evas_GL *evas_gl, void *wl_display)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(evasglBindWaylandDisplay) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(evasglBindWaylandDisplay))orig_func)
           (evas_gl, wl_display);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(evasglBindWaylandDisplay) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->evas_gl = evas_gl;
   thread_data->wl_display = wl_display;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(evasglBindWaylandDisplay),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * Eina_Bool
 * evasglUnbindWaylandDisplay(Evas_GL *evas_gl, void *wl_display);
 */

typedef Eina_Bool(*GL_TH_FNTYPE(evasglUnbindWaylandDisplay))(Evas_GL *evas_gl, void *wl_display);

typedef struct
{
   GL_TH_FNTYPE(evasglUnbindWaylandDisplay) orig_func;
   Eina_Bool return_value;
   Evas_GL *evas_gl;
   void *wl_display;

} GL_TH_ST(evasglUnbindWaylandDisplay);

static void
GL_TH_CB(evasglUnbindWaylandDisplay)(void *data)
{
   GL_TH_ST(evasglUnbindWaylandDisplay) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(evasglUnbindWaylandDisplay))thread_data->orig_func)
      (thread_data->evas_gl,
       thread_data->wl_display);

}

Eina_Bool
GL_TH_FN(evasglUnbindWaylandDisplay)(GL_TH_DP, Evas_GL *evas_gl, void *wl_display)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(evasglUnbindWaylandDisplay) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(evasglUnbindWaylandDisplay))orig_func)
           (evas_gl, wl_display);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(evasglUnbindWaylandDisplay) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->evas_gl = evas_gl;
   thread_data->wl_display = wl_display;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(evasglUnbindWaylandDisplay),
                              thread_mode);

   return thread_data->return_value;
}

/*
 * Eina_Bool
 * evasglQueryWaylandBuffer(Evas_GL *evas_gl, void *buffer, int attribute, int *value);
 */

typedef Eina_Bool(*GL_TH_FNTYPE(evasglQueryWaylandBuffer))(Evas_GL *evas_gl, void *buffer, int attribute, int *value);

typedef struct
{
   GL_TH_FNTYPE(evasglQueryWaylandBuffer) orig_func;
   Eina_Bool return_value;
   Evas_GL *evas_gl;
   void *buffer;
   int attribute;
   int *value;

} GL_TH_ST(evasglQueryWaylandBuffer);

static void
GL_TH_CB(evasglQueryWaylandBuffer)(void *data)
{
   GL_TH_ST(evasglQueryWaylandBuffer) *thread_data =
      *(void **)data;


   thread_data->return_value = ((GL_TH_FNTYPE(evasglQueryWaylandBuffer))thread_data->orig_func)
      (thread_data->evas_gl,
       thread_data->buffer,
       thread_data->attribute,
       thread_data->value);

}

Eina_Bool
GL_TH_FN(evasglQueryWaylandBuffer)(GL_TH_DP, Evas_GL *evas_gl, void *buffer, int attribute, int *value)
{
   int thread_mode = EVAS_GL_THREAD_MODE_FINISH;

   GL_TH_ST(evasglQueryWaylandBuffer) thread_data_local, *thread_data = &thread_data_local, **thread_data_ptr;
   void *thcmd_ref;


   if (!evas_gl_thread_enabled(thread_type))
     {
        return ((GL_TH_FNTYPE(evasglQueryWaylandBuffer))orig_func)
           (evas_gl, buffer, attribute, value);
     }
   thread_data_ptr =
      evas_gl_thread_cmd_create(thread_type, sizeof(GL_TH_ST(evasglQueryWaylandBuffer) *), &thcmd_ref);
   *thread_data_ptr = thread_data;

   thread_data->evas_gl = evas_gl;
   thread_data->buffer = buffer;
   thread_data->attribute = attribute;
   thread_data->value = value;
   thread_data->orig_func = orig_func;

   evas_gl_thread_cmd_enqueue(thcmd_ref,
                              GL_TH_CB(evasglQueryWaylandBuffer),
                              thread_mode);

   return thread_data->return_value;
}


typedef struct
{
   void (*GL_TH_FN(glActiveTexture))(GL_TH_DP, GLenum texture);
   void (*GL_TH_FN(glAttachShader))(GL_TH_DP, GLuint program, GLuint shader);
   void (*GL_TH_FN(glBindAttribLocation))(GL_TH_DP, GLuint program, GLuint index, const char* name);
   void (*GL_TH_FN(glBindBuffer))(GL_TH_DP, GLenum target, GLuint buffer);
   void (*GL_TH_FN(glBindFramebuffer))(GL_TH_DP, GLenum target, GLuint framebuffer);
   void (*GL_TH_FN(glBindRenderbuffer))(GL_TH_DP, GLenum target, GLuint renderbuffer);
   void (*GL_TH_FN(glBindTexture))(GL_TH_DP, GLenum target, GLuint texture);
   void (*GL_TH_FN(glBlendColor))(GL_TH_DP, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
   void (*GL_TH_FN(glBlendEquation))(GL_TH_DP, GLenum mode);
   void (*GL_TH_FN(glBlendEquationSeparate))(GL_TH_DP, GLenum modeRGB, GLenum modeAlpha);
   void (*GL_TH_FN(glBlendFunc))(GL_TH_DP, GLenum sfactor, GLenum dfactor);
   void (*GL_TH_FN(glBlendFuncSeparate))(GL_TH_DP, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
   void (*GL_TH_FN(glBufferData))(GL_TH_DP, GLenum target, GLsizeiptr size, const void* data, GLenum usage);
   void (*GL_TH_FN(glBufferSubData))(GL_TH_DP, GLenum target, GLintptr offset, GLsizeiptr size, const void* data);
   GLenum (*GL_TH_FN(glCheckFramebufferStatus))(GL_TH_DP, GLenum target);
   void (*GL_TH_FN(glClear))(GL_TH_DP, GLbitfield mask);
   void (*GL_TH_FN(glClearColor))(GL_TH_DP, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
   void (*GL_TH_FN(glClearDepthf))(GL_TH_DP, GLclampf depth);
   void (*GL_TH_FN(glClearStencil))(GL_TH_DP, GLint s);
   void (*GL_TH_FN(glColorMask))(GL_TH_DP, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
   void (*GL_TH_FN(glCompileShader))(GL_TH_DP, GLuint shader);
   void (*GL_TH_FN(glCompressedTexImage2D))(GL_TH_DP, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data);
   void (*GL_TH_FN(glCompressedTexSubImage2D))(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);
   void (*GL_TH_FN(glCopyTexImage2D))(GL_TH_DP, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
   void (*GL_TH_FN(glCopyTexSubImage2D))(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
   GLuint (*GL_TH_FN(glCreateProgram))(GL_TH_DP);
   GLuint (*GL_TH_FN(glCreateShader))(GL_TH_DP, GLenum type);
   void (*GL_TH_FN(glCullFace))(GL_TH_DP, GLenum mode);
   void (*GL_TH_FN(glDeleteBuffers))(GL_TH_DP, GLsizei n, const GLuint* buffers);
   void (*GL_TH_FN(glDeleteFramebuffers))(GL_TH_DP, GLsizei n, const GLuint* framebuffers);
   void (*GL_TH_FN(glDeleteProgram))(GL_TH_DP, GLuint program);
   void (*GL_TH_FN(glDeleteRenderbuffers))(GL_TH_DP, GLsizei n, const GLuint* renderbuffers);
   void (*GL_TH_FN(glDeleteShader))(GL_TH_DP, GLuint shader);
   void (*GL_TH_FN(glDeleteTextures))(GL_TH_DP, GLsizei n, const GLuint* textures);
   void (*GL_TH_FN(glDepthFunc))(GL_TH_DP, GLenum func);
   void (*GL_TH_FN(glDepthMask))(GL_TH_DP, GLboolean flag);
   void (*GL_TH_FN(glDepthRangef))(GL_TH_DP, GLclampf zNear, GLclampf zFar);
   void (*GL_TH_FN(glDetachShader))(GL_TH_DP, GLuint program, GLuint shader);
   void (*GL_TH_FN(glDisable))(GL_TH_DP, GLenum cap);
   void (*GL_TH_FN(glDisableVertexAttribArray))(GL_TH_DP, GLuint index);
   void (*GL_TH_FN(glDrawArrays))(GL_TH_DP, GLenum mode, GLint first, GLsizei count);
   void (*GL_TH_FN(glDrawElements))(GL_TH_DP, GLenum mode, GLsizei count, GLenum type, const void* indices);
   void (*GL_TH_FN(glEnable))(GL_TH_DP, GLenum cap);
   void (*GL_TH_FN(glEnableVertexAttribArray))(GL_TH_DP, GLuint index);
   void (*GL_TH_FN(glFinish))(GL_TH_DP);
   void (*GL_TH_FN(glFlush))(GL_TH_DP);
   void (*GL_TH_FN(glFramebufferRenderbuffer))(GL_TH_DP, GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
   void (*GL_TH_FN(glFramebufferTexture2D))(GL_TH_DP, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
   void (*GL_TH_FN(glFrontFace))(GL_TH_DP, GLenum mode);
   void (*GL_TH_FN(glGenBuffers))(GL_TH_DP, GLsizei n, GLuint* buffers);
   void (*GL_TH_FN(glGenerateMipmap))(GL_TH_DP, GLenum target);
   void (*GL_TH_FN(glGenFramebuffers))(GL_TH_DP, GLsizei n, GLuint* framebuffers);
   void (*GL_TH_FN(glGenRenderbuffers))(GL_TH_DP, GLsizei n, GLuint* renderbuffers);
   void (*GL_TH_FN(glGenTextures))(GL_TH_DP, GLsizei n, GLuint* textures);
   void (*GL_TH_FN(glGetActiveAttrib))(GL_TH_DP, GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name);
   void (*GL_TH_FN(glGetActiveUniform))(GL_TH_DP, GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, char* name);
   void (*GL_TH_FN(glGetAttachedShaders))(GL_TH_DP, GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders);
   int (*GL_TH_FN(glGetAttribLocation))(GL_TH_DP, GLuint program, const char* name);
   void (*GL_TH_FN(glGetBooleanv))(GL_TH_DP, GLenum pname, GLboolean* params);
   void (*GL_TH_FN(glGetBufferParameteriv))(GL_TH_DP, GLenum target, GLenum pname, GLint* params);
   GLenum (*GL_TH_FN(glGetError))(GL_TH_DP);
   void (*GL_TH_FN(glGetFloatv))(GL_TH_DP, GLenum pname, GLfloat* params);
   void (*GL_TH_FN(glGetFramebufferAttachmentParameteriv))(GL_TH_DP, GLenum target, GLenum attachment, GLenum pname, GLint* params);
   void (*GL_TH_FN(glGetIntegerv))(GL_TH_DP, GLenum pname, GLint* params);
   void (*GL_TH_FN(glGetProgramiv))(GL_TH_DP, GLuint program, GLenum pname, GLint* params);
   void (*GL_TH_FN(glGetProgramInfoLog))(GL_TH_DP, GLuint program, GLsizei bufsize, GLsizei* length, char* infolog);
   void (*GL_TH_FN(glGetRenderbufferParameteriv))(GL_TH_DP, GLenum target, GLenum pname, GLint* params);
   void (*GL_TH_FN(glGetShaderiv))(GL_TH_DP, GLuint shader, GLenum pname, GLint* params);
   void (*GL_TH_FN(glGetShaderInfoLog))(GL_TH_DP, GLuint shader, GLsizei bufsize, GLsizei* length, char* infolog);
   void (*GL_TH_FN(glGetShaderPrecisionFormat))(GL_TH_DP, GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);
   void (*GL_TH_FN(glGetShaderSource))(GL_TH_DP, GLuint shader, GLsizei bufsize, GLsizei* length, char* source);
   const GLubyte* (*GL_TH_FN(glGetString))(GL_TH_DP, GLenum name);
   void (*GL_TH_FN(glGetTexParameterfv))(GL_TH_DP, GLenum target, GLenum pname, GLfloat* params);
   void (*GL_TH_FN(glGetTexParameteriv))(GL_TH_DP, GLenum target, GLenum pname, GLint* params);
   void (*GL_TH_FN(glGetUniformfv))(GL_TH_DP, GLuint program, GLint location, GLfloat* params);
   void (*GL_TH_FN(glGetUniformiv))(GL_TH_DP, GLuint program, GLint location, GLint* params);
   int (*GL_TH_FN(glGetUniformLocation))(GL_TH_DP, GLuint program, const char* name);
   void (*GL_TH_FN(glGetVertexAttribfv))(GL_TH_DP, GLuint index, GLenum pname, GLfloat* params);
   void (*GL_TH_FN(glGetVertexAttribiv))(GL_TH_DP, GLuint index, GLenum pname, GLint* params);
   void (*GL_TH_FN(glGetVertexAttribPointerv))(GL_TH_DP, GLuint index, GLenum pname, void** pointer);
   void (*GL_TH_FN(glHint))(GL_TH_DP, GLenum target, GLenum mode);
   GLboolean (*GL_TH_FN(glIsBuffer))(GL_TH_DP, GLuint buffer);
   GLboolean (*GL_TH_FN(glIsEnabled))(GL_TH_DP, GLenum cap);
   GLboolean (*GL_TH_FN(glIsFramebuffer))(GL_TH_DP, GLuint framebuffer);
   GLboolean (*GL_TH_FN(glIsProgram))(GL_TH_DP, GLuint program);
   GLboolean (*GL_TH_FN(glIsRenderbuffer))(GL_TH_DP, GLuint renderbuffer);
   GLboolean (*GL_TH_FN(glIsShader))(GL_TH_DP, GLuint shader);
   GLboolean (*GL_TH_FN(glIsTexture))(GL_TH_DP, GLuint texture);
   void (*GL_TH_FN(glLineWidth))(GL_TH_DP, GLfloat width);
   void (*GL_TH_FN(glLinkProgram))(GL_TH_DP, GLuint program);
   void (*GL_TH_FN(glPixelStorei))(GL_TH_DP, GLenum pname, GLint param);
   void (*GL_TH_FN(glPolygonOffset))(GL_TH_DP, GLfloat factor, GLfloat units);
   void (*GL_TH_FN(glReadPixels))(GL_TH_DP, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);
   void (*GL_TH_FN(glReleaseShaderCompiler))(GL_TH_DP);
   void (*GL_TH_FN(glRenderbufferStorage))(GL_TH_DP, GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
   void (*GL_TH_FN(glSampleCoverage))(GL_TH_DP, GLclampf value, GLboolean invert);
   void (*GL_TH_FN(glScissor))(GL_TH_DP, GLint x, GLint y, GLsizei width, GLsizei height);
   void (*GL_TH_FN(glShaderBinary))(GL_TH_DP, GLsizei n, const GLuint* shaders, GLenum binaryformat, const void* binary, GLsizei length);
   void (*GL_TH_FN(glShaderSource))(GL_TH_DP, GLuint shader, GLsizei count, const char* const * string, const GLint* length);
   void (*GL_TH_FN(glStencilFunc))(GL_TH_DP, GLenum func, GLint ref, GLuint mask);
   void (*GL_TH_FN(glStencilFuncSeparate))(GL_TH_DP, GLenum face, GLenum func, GLint ref, GLuint mask);
   void (*GL_TH_FN(glStencilMask))(GL_TH_DP, GLuint mask);
   void (*GL_TH_FN(glStencilMaskSeparate))(GL_TH_DP, GLenum face, GLuint mask);
   void (*GL_TH_FN(glStencilOp))(GL_TH_DP, GLenum fail, GLenum zfail, GLenum zpass);
   void (*GL_TH_FN(glStencilOpSeparate))(GL_TH_DP, GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
   void (*GL_TH_FN(glTexImage2D))(GL_TH_DP, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
   void (*GL_TH_FN(glTexParameterf))(GL_TH_DP, GLenum target, GLenum pname, GLfloat param);
   void (*GL_TH_FN(glTexParameterfv))(GL_TH_DP, GLenum target, GLenum pname, const GLfloat* params);
   void (*GL_TH_FN(glTexParameteri))(GL_TH_DP, GLenum target, GLenum pname, GLint param);
   void (*GL_TH_FN(glTexParameteriv))(GL_TH_DP, GLenum target, GLenum pname, const GLint* params);
   void (*GL_TH_FN(glTexSubImage2D))(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
   void (*GL_TH_FN(glUniform1f))(GL_TH_DP, GLint location, GLfloat x);
   void (*GL_TH_FN(glUniform1fv))(GL_TH_DP, GLint location, GLsizei count, const GLfloat* v);
   void (*GL_TH_FN(glUniform1i))(GL_TH_DP, GLint location, GLint x);
   void (*GL_TH_FN(glUniform1iv))(GL_TH_DP, GLint location, GLsizei count, const GLint* v);
   void (*GL_TH_FN(glUniform2f))(GL_TH_DP, GLint location, GLfloat x, GLfloat y);
   void (*GL_TH_FN(glUniform2fv))(GL_TH_DP, GLint location, GLsizei count, const GLfloat* v);
   void (*GL_TH_FN(glUniform2i))(GL_TH_DP, GLint location, GLint x, GLint y);
   void (*GL_TH_FN(glUniform2iv))(GL_TH_DP, GLint location, GLsizei count, const GLint* v);
   void (*GL_TH_FN(glUniform3f))(GL_TH_DP, GLint location, GLfloat x, GLfloat y, GLfloat z);
   void (*GL_TH_FN(glUniform3fv))(GL_TH_DP, GLint location, GLsizei count, const GLfloat* v);
   void (*GL_TH_FN(glUniform3i))(GL_TH_DP, GLint location, GLint x, GLint y, GLint z);
   void (*GL_TH_FN(glUniform3iv))(GL_TH_DP, GLint location, GLsizei count, const GLint* v);
   void (*GL_TH_FN(glUniform4f))(GL_TH_DP, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
   void (*GL_TH_FN(glUniform4fv))(GL_TH_DP, GLint location, GLsizei count, const GLfloat* v);
   void (*GL_TH_FN(glUniform4i))(GL_TH_DP, GLint location, GLint x, GLint y, GLint z, GLint w);
   void (*GL_TH_FN(glUniform4iv))(GL_TH_DP, GLint location, GLsizei count, const GLint* v);
   void (*GL_TH_FN(glUniformMatrix2fv))(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
   void (*GL_TH_FN(glUniformMatrix3fv))(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
   void (*GL_TH_FN(glUniformMatrix4fv))(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
   void (*GL_TH_FN(glUseProgram))(GL_TH_DP, GLuint program);
   void (*GL_TH_FN(glValidateProgram))(GL_TH_DP, GLuint program);
   void (*GL_TH_FN(glVertexAttrib1f))(GL_TH_DP, GLuint indx, GLfloat x);
   void (*GL_TH_FN(glVertexAttrib1fv))(GL_TH_DP, GLuint indx, const GLfloat* values);
   void (*GL_TH_FN(glVertexAttrib2f))(GL_TH_DP, GLuint indx, GLfloat x, GLfloat y);
   void (*GL_TH_FN(glVertexAttrib2fv))(GL_TH_DP, GLuint indx, const GLfloat* values);
   void (*GL_TH_FN(glVertexAttrib3f))(GL_TH_DP, GLuint indx, GLfloat x, GLfloat y, GLfloat z);
   void (*GL_TH_FN(glVertexAttrib3fv))(GL_TH_DP, GLuint indx, const GLfloat* values);
   void (*GL_TH_FN(glVertexAttrib4f))(GL_TH_DP, GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
   void (*GL_TH_FN(glVertexAttrib4fv))(GL_TH_DP, GLuint indx, const GLfloat* values);
   void (*GL_TH_FN(glVertexAttribPointer))(GL_TH_DP, GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* ptr);
   void (*GL_TH_FN(glViewport))(GL_TH_DP, GLint x, GLint y, GLsizei width, GLsizei height);
   void (*GL_TH_FN(glEvasGLImageTargetTexture2DOES))(GL_TH_DP, GLenum target, EvasGLImage image);
   void (*GL_TH_FN(glEvasGLImageTargetRenderbufferStorageOES))(GL_TH_DP, GLenum target, EvasGLImage image);
   void (*GL_TH_FN(glGetProgramBinaryOES))(GL_TH_DP, GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);
   void (*GL_TH_FN(glProgramBinaryOES))(GL_TH_DP, GLuint program, GLenum binaryFormat, const void *binary, GLint length);
   void * (*GL_TH_FN(glMapBufferOES))(GL_TH_DP, GLenum target, GLenum access);
   GLboolean (*GL_TH_FN(glUnmapBufferOES))(GL_TH_DP, GLenum target);
   void (*GL_TH_FN(glGetBufferPointervOES))(GL_TH_DP, GLenum target, GLenum pname, void** params);
   void (*GL_TH_FN(glTexImage3DOES))(GL_TH_DP, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
   void (*GL_TH_FN(glTexSubImage3DOES))(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
   void (*GL_TH_FN(glCopyTexSubImage3DOES))(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
   void (*GL_TH_FN(glCompressedTexImage3DOES))(GL_TH_DP, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data);
   void (*GL_TH_FN(glCompressedTexSubImage3DOES))(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
   void (*GL_TH_FN(glFramebufferTexture3DOES))(GL_TH_DP, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
   void (*GL_TH_FN(glGetPerfMonitorGroupsAMD))(GL_TH_DP, GLint* numGroups, GLsizei groupsSize, GLuint* groups);
   void (*GL_TH_FN(glGetPerfMonitorCountersAMD))(GL_TH_DP, GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters);
   void (*GL_TH_FN(glGetPerfMonitorGroupStringAMD))(GL_TH_DP, GLuint group, GLsizei bufSize, GLsizei* length, char* groupString);
   void (*GL_TH_FN(glGetPerfMonitorCounterStringAMD))(GL_TH_DP, GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, char* counterString);
   void (*GL_TH_FN(glGetPerfMonitorCounterInfoAMD))(GL_TH_DP, GLuint group, GLuint counter, GLenum pname, void* data);
   void (*GL_TH_FN(glGenPerfMonitorsAMD))(GL_TH_DP, GLsizei n, GLuint* monitors);
   void (*GL_TH_FN(glDeletePerfMonitorsAMD))(GL_TH_DP, GLsizei n, GLuint* monitors);
   void (*GL_TH_FN(glSelectPerfMonitorCountersAMD))(GL_TH_DP, GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* countersList);
   void (*GL_TH_FN(glBeginPerfMonitorAMD))(GL_TH_DP, GLuint monitor);
   void (*GL_TH_FN(glEndPerfMonitorAMD))(GL_TH_DP, GLuint monitor);
   void (*GL_TH_FN(glGetPerfMonitorCounterDataAMD))(GL_TH_DP, GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten);
   void (*GL_TH_FN(glDiscardFramebufferEXT))(GL_TH_DP, GLenum target, GLsizei numAttachments, const GLenum* attachments);
   void (*GL_TH_FN(glMultiDrawArraysEXT))(GL_TH_DP, GLenum mode, GLint* first, GLsizei* count, GLsizei primcount);
   void (*GL_TH_FN(glMultiDrawElementsEXT))(GL_TH_DP, GLenum mode, const GLsizei* count, GLenum type, const GLvoid** indices, GLsizei primcount);
   void (*GL_TH_FN(glDeleteFencesNV))(GL_TH_DP, GLsizei n, const GLuint* fences);
   void (*GL_TH_FN(glGenFencesNV))(GL_TH_DP, GLsizei n, GLuint* fences);
   GLboolean (*GL_TH_FN(glIsFenceNV))(GL_TH_DP, GLuint fence);
   GLboolean (*GL_TH_FN(glTestFenceNV))(GL_TH_DP, GLuint fence);
   void (*GL_TH_FN(glGetFenceivNV))(GL_TH_DP, GLuint fence, GLenum pname, GLint* params);
   void (*GL_TH_FN(glFinishFenceNV))(GL_TH_DP, GLuint fence);
   void (*GL_TH_FN(glSetFenceNV))(GL_TH_DP, GLuint a, GLenum b);
   void (*GL_TH_FN(glGetDriverControlsQCOM))(GL_TH_DP, GLint* num, GLsizei size, GLuint* driverControls);
   void (*GL_TH_FN(glGetDriverControlStringQCOM))(GL_TH_DP, GLuint driverControl, GLsizei bufSize, GLsizei* length, char* driverControlString);
   void (*GL_TH_FN(glEnableDriverControlQCOM))(GL_TH_DP, GLuint driverControl);
   void (*GL_TH_FN(glDisableDriverControlQCOM))(GL_TH_DP, GLuint driverControl);
   void (*GL_TH_FN(glExtGetTexturesQCOM))(GL_TH_DP, GLuint* textures, GLint maxTextures, GLint* numTextures);
   void (*GL_TH_FN(glExtGetBuffersQCOM))(GL_TH_DP, GLuint* buffers, GLint maxBuffers, GLint* numBuffers);
   void (*GL_TH_FN(glExtGetRenderbuffersQCOM))(GL_TH_DP, GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers);
   void (*GL_TH_FN(glExtGetFramebuffersQCOM))(GL_TH_DP, GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers);
   void (*GL_TH_FN(glExtGetTexLevelParameterivQCOM))(GL_TH_DP, GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params);
   void (*GL_TH_FN(glExtTexObjectStateOverrideiQCOM))(GL_TH_DP, GLenum target, GLenum pname, GLint param);
   void (*GL_TH_FN(glExtGetTexSubImageQCOM))(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void* texels);
   void (*GL_TH_FN(glExtGetBufferPointervQCOM))(GL_TH_DP, GLenum target, void** params);
   void (*GL_TH_FN(glExtGetShadersQCOM))(GL_TH_DP, GLuint* shaders, GLint maxShaders, GLint* numShaders);
   void (*GL_TH_FN(glExtGetProgramsQCOM))(GL_TH_DP, GLuint* programs, GLint maxPrograms, GLint* numPrograms);
   GLboolean (*GL_TH_FN(glExtIsProgramBinaryQCOM))(GL_TH_DP, GLuint program);
   void (*GL_TH_FN(glExtGetProgramBinarySourceQCOM))(GL_TH_DP, GLuint program, GLenum shadertype, char* source, GLint* length);
#ifndef GL_GLES
   void (*GL_TH_FN(glAlphaFunc))(GL_TH_DP, GLenum func, GLclampf ref);
#endif
   void (*GL_TH_FN(glClipPlanef))(GL_TH_DP, GLenum plane, const GLfloat *equation);
   void (*GL_TH_FN(glColor4f))(GL_TH_DP, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
   void (*GL_TH_FN(glFogf))(GL_TH_DP, GLenum pname, GLfloat param);
   void (*GL_TH_FN(glFogfv))(GL_TH_DP, GLenum pname, const GLfloat *params);
   void (*GL_TH_FN(glFrustumf))(GL_TH_DP, GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
   void (*GL_TH_FN(glGetClipPlanef))(GL_TH_DP, GLenum pname, GLfloat eqn[4]);
   void (*GL_TH_FN(glGetLightfv))(GL_TH_DP, GLenum light, GLenum pname, GLfloat *params);
   void (*GL_TH_FN(glGetMaterialfv))(GL_TH_DP, GLenum face, GLenum pname, GLfloat *params);
   void (*GL_TH_FN(glGetTexEnvfv))(GL_TH_DP, GLenum env, GLenum pname, GLfloat *params);
   void (*GL_TH_FN(glLightModelf))(GL_TH_DP, GLenum pname, GLfloat param);
   void (*GL_TH_FN(glLightModelfv))(GL_TH_DP, GLenum pname, const GLfloat *params);
   void (*GL_TH_FN(glLightf))(GL_TH_DP, GLenum light, GLenum pname, GLfloat param);
   void (*GL_TH_FN(glLightfv))(GL_TH_DP, GLenum light, GLenum pname, const GLfloat *params);
   void (*GL_TH_FN(glLoadMatrixf))(GL_TH_DP, const GLfloat *m);
   void (*GL_TH_FN(glMaterialf))(GL_TH_DP, GLenum face, GLenum pname, GLfloat param);
   void (*GL_TH_FN(glMaterialfv))(GL_TH_DP, GLenum face, GLenum pname, const GLfloat *params);
   void (*GL_TH_FN(glMultMatrixf))(GL_TH_DP, const GLfloat *m);
   void (*GL_TH_FN(glMultiTexCoord4f))(GL_TH_DP, GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
   void (*GL_TH_FN(glNormal3f))(GL_TH_DP, GLfloat nx, GLfloat ny, GLfloat nz);
   void (*GL_TH_FN(glOrthof))(GL_TH_DP, GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
   void (*GL_TH_FN(glPointParameterf))(GL_TH_DP, GLenum pname, GLfloat param);
   void (*GL_TH_FN(glPointParameterfv))(GL_TH_DP, GLenum pname, const GLfloat *params);
   void (*GL_TH_FN(glPointSize))(GL_TH_DP, GLfloat size);
   void (*GL_TH_FN(glPointSizePointerOES))(GL_TH_DP, GLenum type, GLsizei stride, const GLvoid * pointer);
   void (*GL_TH_FN(glRotatef))(GL_TH_DP, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
   void (*GL_TH_FN(glScalef))(GL_TH_DP, GLfloat x, GLfloat y, GLfloat z);
   void (*GL_TH_FN(glTexEnvf))(GL_TH_DP, GLenum target, GLenum pname, GLfloat param);
   void (*GL_TH_FN(glTexEnvfv))(GL_TH_DP, GLenum target, GLenum pname, const GLfloat *params);
   void (*GL_TH_FN(glTranslatef))(GL_TH_DP, GLfloat x, GLfloat y, GLfloat z);
   void (*GL_TH_FN(glAlphaFuncx))(GL_TH_DP, GLenum func, GLclampx ref);
   void (*GL_TH_FN(glClearColorx))(GL_TH_DP, GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
   void (*GL_TH_FN(glClearDepthx))(GL_TH_DP, GLclampx depth);
   void (*GL_TH_FN(glClientActiveTexture))(GL_TH_DP, GLenum texture);
   void (*GL_TH_FN(glClipPlanex))(GL_TH_DP, GLenum plane, const GLfixed *equation);
   void (*GL_TH_FN(glColor4ub))(GL_TH_DP, GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
   void (*GL_TH_FN(glColor4x))(GL_TH_DP, GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
   void (*GL_TH_FN(glColorPointer))(GL_TH_DP, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
   void (*GL_TH_FN(glDepthRangex))(GL_TH_DP, GLclampx zNear, GLclampx zFar);
   void (*GL_TH_FN(glDisableClientState))(GL_TH_DP, GLenum array);
   void (*GL_TH_FN(glEnableClientState))(GL_TH_DP, GLenum array);
   void (*GL_TH_FN(glFogx))(GL_TH_DP, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glFogxv))(GL_TH_DP, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glFrustumx))(GL_TH_DP, GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
   void (*GL_TH_FN(glGetClipPlanex))(GL_TH_DP, GLenum pname, GLfixed eqn[4]);
   void (*GL_TH_FN(glGetFixedv))(GL_TH_DP, GLenum pname, GLfixed *params);
   void (*GL_TH_FN(glGetLightxv))(GL_TH_DP, GLenum light, GLenum pname, GLfixed *params);
   void (*GL_TH_FN(glGetMaterialxv))(GL_TH_DP, GLenum face, GLenum pname, GLfixed *params);
   void (*GL_TH_FN(glGetPointerv))(GL_TH_DP, GLenum pname, GLvoid **params);
   void (*GL_TH_FN(glGetTexEnviv))(GL_TH_DP, GLenum env, GLenum pname, GLint *params);
   void (*GL_TH_FN(glGetTexEnvxv))(GL_TH_DP, GLenum env, GLenum pname, GLfixed *params);
   void (*GL_TH_FN(glGetTexParameterxv))(GL_TH_DP, GLenum target, GLenum pname, GLfixed *params);
   void (*GL_TH_FN(glLightModelx))(GL_TH_DP, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glLightModelxv))(GL_TH_DP, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glLightx))(GL_TH_DP, GLenum light, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glLightxv))(GL_TH_DP, GLenum light, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glLineWidthx))(GL_TH_DP, GLfixed width);
   void (*GL_TH_FN(glLoadIdentity))(GL_TH_DP);
   void (*GL_TH_FN(glLoadMatrixx))(GL_TH_DP, const GLfixed *m);
   void (*GL_TH_FN(glLogicOp))(GL_TH_DP, GLenum opcode);
   void (*GL_TH_FN(glMaterialx))(GL_TH_DP, GLenum face, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glMaterialxv))(GL_TH_DP, GLenum face, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glMatrixMode))(GL_TH_DP, GLenum mode);
   void (*GL_TH_FN(glMultMatrixx))(GL_TH_DP, const GLfixed *m);
   void (*GL_TH_FN(glMultiTexCoord4x))(GL_TH_DP, GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
   void (*GL_TH_FN(glNormal3x))(GL_TH_DP, GLfixed nx, GLfixed ny, GLfixed nz);
   void (*GL_TH_FN(glNormalPointer))(GL_TH_DP, GLenum type, GLsizei stride, const GLvoid *pointer);
   void (*GL_TH_FN(glOrthox))(GL_TH_DP, GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
   void (*GL_TH_FN(glPointParameterx))(GL_TH_DP, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glPointParameterxv))(GL_TH_DP, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glPointSizex))(GL_TH_DP, GLfixed size);
   void (*GL_TH_FN(glPolygonOffsetx))(GL_TH_DP, GLfixed factor, GLfixed units);
   void (*GL_TH_FN(glPopMatrix))(GL_TH_DP);
   void (*GL_TH_FN(glPushMatrix))(GL_TH_DP);
   void (*GL_TH_FN(glRotatex))(GL_TH_DP, GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
   void (*GL_TH_FN(glSampleCoveragex))(GL_TH_DP, GLclampx value, GLboolean invert);
   void (*GL_TH_FN(glScalex))(GL_TH_DP, GLfixed x, GLfixed y, GLfixed z);
   void (*GL_TH_FN(glShadeModel))(GL_TH_DP, GLenum mode);
   void (*GL_TH_FN(glTexCoordPointer))(GL_TH_DP, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
   void (*GL_TH_FN(glTexEnvi))(GL_TH_DP, GLenum target, GLenum pname, GLint param);
   void (*GL_TH_FN(glTexEnvx))(GL_TH_DP, GLenum target, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glTexEnviv))(GL_TH_DP, GLenum target, GLenum pname, const GLint *params);
   void (*GL_TH_FN(glTexEnvxv))(GL_TH_DP, GLenum target, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glTexParameterx))(GL_TH_DP, GLenum target, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glTexParameterxv))(GL_TH_DP, GLenum target, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glTranslatex))(GL_TH_DP, GLfixed x, GLfixed y, GLfixed z);
   void (*GL_TH_FN(glVertexPointer))(GL_TH_DP, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
   void (*GL_TH_FN(glBlendEquationSeparateOES))(GL_TH_DP, GLenum modeRGB, GLenum modeAlpha);
   void (*GL_TH_FN(glBlendFuncSeparateOES))(GL_TH_DP, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
   void (*GL_TH_FN(glBlendEquationOES))(GL_TH_DP, GLenum mode);
   void (*GL_TH_FN(glDrawTexsOES))(GL_TH_DP, GLshort x, GLshort y, GLshort z, GLshort width, GLshort height);
   void (*GL_TH_FN(glDrawTexiOES))(GL_TH_DP, GLint x, GLint y, GLint z, GLint width, GLint height);
   void (*GL_TH_FN(glDrawTexxOES))(GL_TH_DP, GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height);
   void (*GL_TH_FN(glDrawTexsvOES))(GL_TH_DP, const GLshort *coords);
   void (*GL_TH_FN(glDrawTexivOES))(GL_TH_DP, const GLint *coords);
   void (*GL_TH_FN(glDrawTexxvOES))(GL_TH_DP, const GLfixed *coords);
   void (*GL_TH_FN(glDrawTexfOES))(GL_TH_DP, GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height);
   void (*GL_TH_FN(glDrawTexfvOES))(GL_TH_DP, const GLfloat *coords);
   void (*GL_TH_FN(glAlphaFuncxOES))(GL_TH_DP, GLenum func, GLclampx ref);
   void (*GL_TH_FN(glClearColorxOES))(GL_TH_DP, GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
   void (*GL_TH_FN(glClearDepthxOES))(GL_TH_DP, GLclampx depth);
   void (*GL_TH_FN(glClipPlanexOES))(GL_TH_DP, GLenum plane, const GLfixed *equation);
   void (*GL_TH_FN(glColor4xOES))(GL_TH_DP, GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
   void (*GL_TH_FN(glDepthRangexOES))(GL_TH_DP, GLclampx zNear, GLclampx zFar);
   void (*GL_TH_FN(glFogxOES))(GL_TH_DP, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glFogxvOES))(GL_TH_DP, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glFrustumxOES))(GL_TH_DP, GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
   void (*GL_TH_FN(glGetClipPlanexOES))(GL_TH_DP, GLenum pname, GLfixed eqn[4]);
   void (*GL_TH_FN(glGetFixedvOES))(GL_TH_DP, GLenum pname, GLfixed *params);
   void (*GL_TH_FN(glGetLightxvOES))(GL_TH_DP, GLenum light, GLenum pname, GLfixed *params);
   void (*GL_TH_FN(glGetMaterialxvOES))(GL_TH_DP, GLenum face, GLenum pname, GLfixed *params);
   void (*GL_TH_FN(glGetTexEnvxvOES))(GL_TH_DP, GLenum env, GLenum pname, GLfixed *params);
   void (*GL_TH_FN(glGetTexParameterxvOES))(GL_TH_DP, GLenum target, GLenum pname, GLfixed *params);
   void (*GL_TH_FN(glLightModelxOES))(GL_TH_DP, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glLightModelxvOES))(GL_TH_DP, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glLightxOES))(GL_TH_DP, GLenum light, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glLightxvOES))(GL_TH_DP, GLenum light, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glLineWidthxOES))(GL_TH_DP, GLfixed width);
   void (*GL_TH_FN(glLoadMatrixxOES))(GL_TH_DP, const GLfixed *m);
   void (*GL_TH_FN(glMaterialxOES))(GL_TH_DP, GLenum face, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glMaterialxvOES))(GL_TH_DP, GLenum face, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glMultMatrixxOES))(GL_TH_DP, const GLfixed *m);
   void (*GL_TH_FN(glMultiTexCoord4xOES))(GL_TH_DP, GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
   void (*GL_TH_FN(glNormal3xOES))(GL_TH_DP, GLfixed nx, GLfixed ny, GLfixed nz);
   void (*GL_TH_FN(glOrthoxOES))(GL_TH_DP, GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
   void (*GL_TH_FN(glPointParameterxOES))(GL_TH_DP, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glPointParameterxvOES))(GL_TH_DP, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glPointSizexOES))(GL_TH_DP, GLfixed size);
   void (*GL_TH_FN(glPolygonOffsetxOES))(GL_TH_DP, GLfixed factor, GLfixed units);
   void (*GL_TH_FN(glRotatexOES))(GL_TH_DP, GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
   void (*GL_TH_FN(glSampleCoveragexOES))(GL_TH_DP, GLclampx value, GLboolean invert);
   void (*GL_TH_FN(glScalexOES))(GL_TH_DP, GLfixed x, GLfixed y, GLfixed z);
   void (*GL_TH_FN(glTexEnvxOES))(GL_TH_DP, GLenum target, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glTexEnvxvOES))(GL_TH_DP, GLenum target, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glTexParameterxOES))(GL_TH_DP, GLenum target, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glTexParameterxvOES))(GL_TH_DP, GLenum target, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glTranslatexOES))(GL_TH_DP, GLfixed x, GLfixed y, GLfixed z);
   GLboolean (*GL_TH_FN(glIsRenderbufferOES))(GL_TH_DP, GLuint renderbuffer);
   void (*GL_TH_FN(glBindRenderbufferOES))(GL_TH_DP, GLenum target, GLuint renderbuffer);
   void (*GL_TH_FN(glDeleteRenderbuffersOES))(GL_TH_DP, GLsizei n, const GLuint* renderbuffers);
   void (*GL_TH_FN(glGenRenderbuffersOES))(GL_TH_DP, GLsizei n, GLuint* renderbuffers);
   void (*GL_TH_FN(glRenderbufferStorageOES))(GL_TH_DP, GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
   void (*GL_TH_FN(glGetRenderbufferParameterivOES))(GL_TH_DP, GLenum target, GLenum pname, GLint* params);
   GLboolean (*GL_TH_FN(glIsFramebufferOES))(GL_TH_DP, GLuint framebuffer);
   void (*GL_TH_FN(glBindFramebufferOES))(GL_TH_DP, GLenum target, GLuint framebuffer);
   void (*GL_TH_FN(glDeleteFramebuffersOES))(GL_TH_DP, GLsizei n, const GLuint* framebuffers);
   void (*GL_TH_FN(glGenFramebuffersOES))(GL_TH_DP, GLsizei n, GLuint* framebuffers);
   GLenum (*GL_TH_FN(glCheckFramebufferStatusOES))(GL_TH_DP, GLenum target);
   void (*GL_TH_FN(glFramebufferRenderbufferOES))(GL_TH_DP, GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
   void (*GL_TH_FN(glFramebufferTexture2DOES))(GL_TH_DP, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
   void (*GL_TH_FN(glGetFramebufferAttachmentParameterivOES))(GL_TH_DP, GLenum target, GLenum attachment, GLenum pname, GLint* params);
   void (*GL_TH_FN(glGenerateMipmapOES))(GL_TH_DP, GLenum target);
   void (*GL_TH_FN(glCurrentPaletteMatrixOES))(GL_TH_DP, GLuint matrixpaletteindex);
   void (*GL_TH_FN(glLoadPaletteFromModelViewMatrixOES))(GL_TH_DP);
   void (*GL_TH_FN(glMatrixIndexPointerOES))(GL_TH_DP, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
   void (*GL_TH_FN(glWeightPointerOES))(GL_TH_DP, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
   GLbitfield (*GL_TH_FN(glQueryMatrixxOES))(GL_TH_DP, GLfixed mantissa[16], GLint exponent[16]);
   void (*GL_TH_FN(glDepthRangefOES))(GL_TH_DP, GLclampf zNear, GLclampf zFar);
   void (*GL_TH_FN(glFrustumfOES))(GL_TH_DP, GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
   void (*GL_TH_FN(glOrthofOES))(GL_TH_DP, GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
   void (*GL_TH_FN(glClipPlanefOES))(GL_TH_DP, GLenum plane, const GLfloat *equation);
   void (*GL_TH_FN(glGetClipPlanefOES))(GL_TH_DP, GLenum pname, GLfloat eqn[4]);
   void (*GL_TH_FN(glClearDepthfOES))(GL_TH_DP, GLclampf depth);
   void (*GL_TH_FN(glTexGenfOES))(GL_TH_DP, GLenum coord, GLenum pname, GLfloat param);
   void (*GL_TH_FN(glTexGenfvOES))(GL_TH_DP, GLenum coord, GLenum pname, const GLfloat *params);
   void (*GL_TH_FN(glTexGeniOES))(GL_TH_DP, GLenum coord, GLenum pname, GLint param);
   void (*GL_TH_FN(glTexGenivOES))(GL_TH_DP, GLenum coord, GLenum pname, const GLint *params);
   void (*GL_TH_FN(glTexGenxOES))(GL_TH_DP, GLenum coord, GLenum pname, GLfixed param);
   void (*GL_TH_FN(glTexGenxvOES))(GL_TH_DP, GLenum coord, GLenum pname, const GLfixed *params);
   void (*GL_TH_FN(glGetTexGenfvOES))(GL_TH_DP, GLenum coord, GLenum pname, GLfloat *params);
   void (*GL_TH_FN(glGetTexGenivOES))(GL_TH_DP, GLenum coord, GLenum pname, GLint *params);
   void (*GL_TH_FN(glGetTexGenxvOES))(GL_TH_DP, GLenum coord, GLenum pname, GLfixed *params);
   void (*GL_TH_FN(glBindVertexArrayOES))(GL_TH_DP, GLuint array);
   void (*GL_TH_FN(glDeleteVertexArraysOES))(GL_TH_DP, GLsizei n, const GLuint *arrays);
   void (*GL_TH_FN(glGenVertexArraysOES))(GL_TH_DP, GLsizei n, GLuint *arrays);
   GLboolean (*GL_TH_FN(glIsVertexArrayOES))(GL_TH_DP, GLuint array);
   void (*GL_TH_FN(glCopyTextureLevelsAPPLE))(GL_TH_DP, GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount);
   void (*GL_TH_FN(glRenderbufferStorageMultisampleAPPLE))(GL_TH_DP, GLenum a, GLsizei b, GLenum c, GLsizei d, GLsizei e);
   void (*GL_TH_FN(glResolveMultisampleFramebufferAPPLE))(GL_TH_DP);
   GLsync (*GL_TH_FN(glFenceSyncAPPLE))(GL_TH_DP, GLenum condition, GLbitfield flags);
   GLboolean (*GL_TH_FN(glIsSyncAPPLE))(GL_TH_DP, GLsync sync);
   void (*GL_TH_FN(glDeleteSyncAPPLE))(GL_TH_DP, GLsync sync);
   GLenum (*GL_TH_FN(glClientWaitSyncAPPLE))(GL_TH_DP, GLsync sync, GLbitfield flags, EvasGLuint64 timeout);
   void (*GL_TH_FN(glWaitSyncAPPLE))(GL_TH_DP, GLsync sync, GLbitfield flags, EvasGLuint64 timeout);
   void (*GL_TH_FN(glGetInteger64vAPPLE))(GL_TH_DP, GLenum pname, EvasGLint64 *params);
   void (*GL_TH_FN(glGetSyncivAPPLE))(GL_TH_DP, GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
   void * (*GL_TH_FN(glMapBufferRangeEXT))(GL_TH_DP, GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
   void (*GL_TH_FN(glFlushMappedBufferRangeEXT))(GL_TH_DP, GLenum target, GLintptr offset, GLsizeiptr length);
   void (*GL_TH_FN(glRenderbufferStorageMultisampleEXT))(GL_TH_DP, GLenum a, GLsizei b, GLenum c, GLsizei d, GLsizei e);
   void (*GL_TH_FN(glFramebufferTexture2DMultisampleEXT))(GL_TH_DP, GLenum a, GLenum b, GLenum c, GLuint d, GLint e, GLsizei f);
   GLenum (*GL_TH_FN(glGetGraphicsResetStatusEXT))(GL_TH_DP);
   void (*GL_TH_FN(glReadnPixelsEXT))(GL_TH_DP, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
   void (*GL_TH_FN(glGetnUniformfvEXT))(GL_TH_DP, GLuint program, GLint location, GLsizei bufSize, float *params);
   void (*GL_TH_FN(glGetnUniformivEXT))(GL_TH_DP, GLuint program, GLint location, GLsizei bufSize, GLint *params);
   void (*GL_TH_FN(glTexStorage1DEXT))(GL_TH_DP, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
   void (*GL_TH_FN(glTexStorage2DEXT))(GL_TH_DP, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
   void (*GL_TH_FN(glTexStorage3DEXT))(GL_TH_DP, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
   void (*GL_TH_FN(glTextureStorage1DEXT))(GL_TH_DP, GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
   void (*GL_TH_FN(glTextureStorage2DEXT))(GL_TH_DP, GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
   void (*GL_TH_FN(glTextureStorage3DEXT))(GL_TH_DP, GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
   void (*GL_TH_FN(glClipPlanefIMG))(GL_TH_DP, GLenum a, const GLfloat * b);
   void (*GL_TH_FN(glClipPlanexIMG))(GL_TH_DP, GLenum a, const GLfixed * b);
   void (*GL_TH_FN(glRenderbufferStorageMultisampleIMG))(GL_TH_DP, GLenum a, GLsizei b, GLenum c, GLsizei d, GLsizei e);
   void (*GL_TH_FN(glFramebufferTexture2DMultisampleIMG))(GL_TH_DP, GLenum a, GLenum b, GLenum c, GLuint d, GLint e, GLsizei f);
   void (*GL_TH_FN(glActivateTile))(GL_TH_DP, GLuint a, GLuint b, GLuint c, GLuint d, GLuint e);
   void (*GL_TH_FN(glStartTilingQCOM))(GL_TH_DP, GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);
   void (*GL_TH_FN(glEndTilingQCOM))(GL_TH_DP, GLbitfield preserveMask);
   void (*GL_TH_FN(glBeginQuery))(GL_TH_DP, GLenum target, GLuint id);
   void (*GL_TH_FN(glBeginTransformFeedback))(GL_TH_DP, GLenum primitiveMode);
   void (*GL_TH_FN(glBindBufferBase))(GL_TH_DP, GLenum target, GLuint index, GLuint buffer);
   void (*GL_TH_FN(glBindBufferRange))(GL_TH_DP, GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
   void (*GL_TH_FN(glBindSampler))(GL_TH_DP, GLuint unit, GLuint sampler);
   void (*GL_TH_FN(glBindTransformFeedback))(GL_TH_DP, GLenum target, GLuint id);
   void (*GL_TH_FN(glBindVertexArray))(GL_TH_DP, GLuint array);
   void (*GL_TH_FN(glBlitFramebuffer))(GL_TH_DP, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
   void (*GL_TH_FN(glClearBufferfi))(GL_TH_DP, GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);
   void (*GL_TH_FN(glClearBufferfv))(GL_TH_DP, GLenum buffer, GLint drawBuffer, const GLfloat * value);
   void (*GL_TH_FN(glClearBufferiv))(GL_TH_DP, GLenum buffer, GLint drawBuffer, const GLint * value);
   void (*GL_TH_FN(glClearBufferuiv))(GL_TH_DP, GLenum buffer, GLint drawBuffer, const GLuint * value);
   GLenum (*GL_TH_FN(glClientWaitSync))(GL_TH_DP, GLsync sync, GLbitfield flags, EvasGLuint64 timeout);
   void (*GL_TH_FN(glCompressedTexImage3D))(GL_TH_DP, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data);
   void (*GL_TH_FN(glCompressedTexSubImage3D))(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data);
   void (*GL_TH_FN(glCopyBufferSubData))(GL_TH_DP, GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
   void (*GL_TH_FN(glCopyTexSubImage3D))(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
   void (*GL_TH_FN(glDeleteQueries))(GL_TH_DP, GLsizei n, const GLuint * ids);
   void (*GL_TH_FN(glDeleteSamplers))(GL_TH_DP, GLsizei n, const GLuint * samplers);
   void (*GL_TH_FN(glDeleteSync))(GL_TH_DP, GLsync sync);
   void (*GL_TH_FN(glDeleteTransformFeedbacks))(GL_TH_DP, GLsizei n, const GLuint *ids);
   void (*GL_TH_FN(glDeleteVertexArrays))(GL_TH_DP, GLsizei n, const GLuint *arrays);
   void (*GL_TH_FN(glDrawArraysInstanced))(GL_TH_DP, GLenum mode, GLint first, GLsizei count, GLsizei primcount);
   void (*GL_TH_FN(glDrawBuffers))(GL_TH_DP, GLsizei n, const GLenum *bufs);
   void (*GL_TH_FN(glDrawElementsInstanced))(GL_TH_DP, GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);
   void (*GL_TH_FN(glDrawRangeElements))(GL_TH_DP, GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices);
   void (*GL_TH_FN(glEndQuery))(GL_TH_DP, GLenum target);
   void (*GL_TH_FN(glEndTransformFeedback))(GL_TH_DP);
   GLsync (*GL_TH_FN(glFenceSync))(GL_TH_DP, GLenum condition, GLbitfield flags);
   GLsync (*GL_TH_FN(glFlushMappedBufferRange))(GL_TH_DP, GLenum target, GLintptr offset, GLsizeiptr length);
   void (*GL_TH_FN(glFramebufferTextureLayer))(GL_TH_DP, GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
   void (*GL_TH_FN(glGenQueries))(GL_TH_DP, GLsizei n, GLuint * ids);
   void (*GL_TH_FN(glGenSamplers))(GL_TH_DP, GLsizei n, GLuint *samplers);
   void (*GL_TH_FN(glGenTransformFeedbacks))(GL_TH_DP, GLsizei n, GLuint *ids);
   void (*GL_TH_FN(glGenVertexArrays))(GL_TH_DP, GLsizei n, GLuint *arrays);
   void (*GL_TH_FN(glGetActiveUniformBlockiv))(GL_TH_DP, GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
   void (*GL_TH_FN(glGetActiveUniformBlockName))(GL_TH_DP, GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
   void (*GL_TH_FN(glGetActiveUniformsiv))(GL_TH_DP, GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
   void (*GL_TH_FN(glGetBufferParameteri64v))(GL_TH_DP, GLenum target, GLenum value, EvasGLint64 * data);
   void (*GL_TH_FN(glGetBufferPointerv))(GL_TH_DP, GLenum target, GLenum pname, GLvoid ** params);
   GLint (*GL_TH_FN(glGetFragDataLocation))(GL_TH_DP, GLuint program, const char * name);
   void (*GL_TH_FN(glGetInteger64i_v))(GL_TH_DP, GLenum target, GLuint index, EvasGLint64 * data);
   void (*GL_TH_FN(glGetInteger64v))(GL_TH_DP, GLenum pname, EvasGLint64 * data);
   void (*GL_TH_FN(glGetIntegeri_v))(GL_TH_DP, GLenum target, GLuint index, GLint * data);
   void (*GL_TH_FN(glGetInternalformativ))(GL_TH_DP, GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
   void (*GL_TH_FN(glGetProgramBinary))(GL_TH_DP, GLuint program, GLsizei bufsize, GLsizei *length, GLenum *binaryFormat, void *binary);
   void (*GL_TH_FN(glGetQueryiv))(GL_TH_DP, GLenum target, GLenum pname, GLint * params);
   void (*GL_TH_FN(glGetQueryObjectuiv))(GL_TH_DP, GLuint id, GLenum pname, GLuint * params);
   void (*GL_TH_FN(glGetSamplerParameterfv))(GL_TH_DP, GLuint sampler, GLenum pname, GLfloat * params);
   void (*GL_TH_FN(glGetSamplerParameteriv))(GL_TH_DP, GLuint sampler, GLenum pname, GLint * params);
   const GLubyte * (*GL_TH_FN(glGetStringi))(GL_TH_DP, GLenum name, GLuint index);
   void (*GL_TH_FN(glGetSynciv))(GL_TH_DP, GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
   void (*GL_TH_FN(glGetTransformFeedbackVarying))(GL_TH_DP, GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, char * name);
   GLuint (*GL_TH_FN(glGetUniformBlockIndex))(GL_TH_DP, GLuint program, const GLchar *uniformBlockName);
   void (*GL_TH_FN(glGetUniformIndices))(GL_TH_DP, GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices);
   void (*GL_TH_FN(glGetUniformuiv))(GL_TH_DP, GLuint program, GLint location, GLuint* params);
   void (*GL_TH_FN(glGetVertexAttribIiv))(GL_TH_DP, GLuint index, GLenum pname, GLint *params);
   void (*GL_TH_FN(glGetVertexAttribIuiv))(GL_TH_DP, GLuint index, GLenum pname, GLuint *params);
   void (*GL_TH_FN(glInvalidateFramebuffer))(GL_TH_DP, GLenum target, GLsizei numAttachments, const GLenum *attachments);
   void (*GL_TH_FN(glInvalidateSubFramebuffer))(GL_TH_DP, GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
   GLboolean (*GL_TH_FN(glIsQuery))(GL_TH_DP, GLuint id);
   GLboolean (*GL_TH_FN(glIsSampler))(GL_TH_DP, GLuint id);
   GLboolean (*GL_TH_FN(glIsSync))(GL_TH_DP, GLsync sync);
   GLboolean (*GL_TH_FN(glIsTransformFeedback))(GL_TH_DP, GLuint id);
   GLboolean (*GL_TH_FN(glIsVertexArray))(GL_TH_DP, GLuint array);
   void * (*GL_TH_FN(glMapBufferRange))(GL_TH_DP, GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
   void (*GL_TH_FN(glPauseTransformFeedback))(GL_TH_DP);
   void (*GL_TH_FN(glProgramBinary))(GL_TH_DP, GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
   void (*GL_TH_FN(glProgramParameteri))(GL_TH_DP, GLuint program, GLenum pname, GLint value);
   void (*GL_TH_FN(glReadBuffer))(GL_TH_DP, GLenum src);
#ifndef GL_GLES
   void (*GL_TH_FN(glRenderbufferStorageMultisample))(GL_TH_DP, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
#endif
   void (*GL_TH_FN(glResumeTransformFeedback))(GL_TH_DP);
   void (*GL_TH_FN(glSamplerParameterf))(GL_TH_DP, GLuint sampler, GLenum pname, GLfloat param);
   void (*GL_TH_FN(glSamplerParameterfv))(GL_TH_DP, GLuint sampler, GLenum pname, const GLfloat * params);
   void (*GL_TH_FN(glSamplerParameteri))(GL_TH_DP, GLuint sampler, GLenum pname, GLint param);
   void (*GL_TH_FN(glSamplerParameteriv))(GL_TH_DP, GLuint sampler, GLenum pname, const GLint * params);
   void (*GL_TH_FN(glTexImage3D))(GL_TH_DP, GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * data);
   void (*GL_TH_FN(glTexStorage2D))(GL_TH_DP, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
   void (*GL_TH_FN(glTexStorage3D))(GL_TH_DP, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
   void (*GL_TH_FN(glTexSubImage3D))(GL_TH_DP, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * data);
   void (*GL_TH_FN(glTransformFeedbackVaryings))(GL_TH_DP, GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
   void (*GL_TH_FN(glUniform1ui))(GL_TH_DP, GLint location, GLuint v0);
   void (*GL_TH_FN(glUniform1uiv))(GL_TH_DP, GLint location, GLsizei count, const GLuint *value);
   void (*GL_TH_FN(glUniform2ui))(GL_TH_DP, GLint location, GLuint v0, GLuint v1);
   void (*GL_TH_FN(glUniform2uiv))(GL_TH_DP, GLint location, GLsizei count, const GLuint *value);
   void (*GL_TH_FN(glUniform3ui))(GL_TH_DP, GLint location, GLuint v0, GLuint v1, GLuint v2);
   void (*GL_TH_FN(glUniform3uiv))(GL_TH_DP, GLint location, GLsizei count, const GLuint *value);
   void (*GL_TH_FN(glUniform4ui))(GL_TH_DP, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
   void (*GL_TH_FN(glUniform4uiv))(GL_TH_DP, GLint location, GLsizei count, const GLuint *value);
   void (*GL_TH_FN(glUniformBlockBinding))(GL_TH_DP, GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
   void (*GL_TH_FN(glUniformMatrix2x3fv))(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glUniformMatrix3x2fv))(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glUniformMatrix2x4fv))(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glUniformMatrix4x2fv))(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glUniformMatrix3x4fv))(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glUniformMatrix4x3fv))(GL_TH_DP, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   GLboolean (*GL_TH_FN(glUnmapBuffer))(GL_TH_DP, GLenum target);
   void (*GL_TH_FN(glVertexAttribDivisor))(GL_TH_DP, GLuint index, GLuint divisor);
   void (*GL_TH_FN(glVertexAttribI4i))(GL_TH_DP, GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);
   void (*GL_TH_FN(glVertexAttribI4iv))(GL_TH_DP, GLuint index, const GLint *v);
   void (*GL_TH_FN(glVertexAttribI4ui))(GL_TH_DP, GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
   void (*GL_TH_FN(glVertexAttribI4uiv))(GL_TH_DP, GLuint index, const GLuint *v);
   void (*GL_TH_FN(glVertexAttribIPointer))(GL_TH_DP, GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
   void (*GL_TH_FN(glWaitSync))(GL_TH_DP, GLsync sync, GLbitfield flags, EvasGLuint64 timeout);
   void (*GL_TH_FN(glDispatchCompute))(GL_TH_DP, GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
   void (*GL_TH_FN(glDispatchComputeIndirect))(GL_TH_DP, GLintptr indirect);
   void (*GL_TH_FN(glDrawArraysIndirect))(GL_TH_DP, GLenum mode, const void *indirect);
   void (*GL_TH_FN(glDrawElementsIndirect))(GL_TH_DP, GLenum mode, GLenum type, const void *indirect);
   void (*GL_TH_FN(glFramebufferParameteri))(GL_TH_DP, GLenum target, GLenum pname, GLint param);
   void (*GL_TH_FN(glGetFramebufferParameteriv))(GL_TH_DP, GLenum target, GLenum pname, GLint *params);
   void (*GL_TH_FN(glGetProgramInterfaceiv))(GL_TH_DP, GLuint program, GLenum programInterface, GLenum pname, GLint *params);
   GLuint (*GL_TH_FN(glGetProgramResourceIndex))(GL_TH_DP, GLuint program, GLenum programInterface, const GLchar *name);
   void (*GL_TH_FN(glGetProgramResourceName))(GL_TH_DP, GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
   void (*GL_TH_FN(glGetProgramResourceiv))(GL_TH_DP, GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params);
   GLint (*GL_TH_FN(glGetProgramResourceLocation))(GL_TH_DP, GLuint program, GLenum programInterface, const GLchar *name);
   void (*GL_TH_FN(glUseProgramStages))(GL_TH_DP, GLuint pipeline, GLbitfield stages, GLuint program);
   void (*GL_TH_FN(glActiveShaderProgram))(GL_TH_DP, GLuint pipeline, GLuint program);
   GLuint (*GL_TH_FN(glCreateShaderProgramv))(GL_TH_DP, GLenum type, GLsizei count, const GLchar *const*strings);
   void (*GL_TH_FN(glBindProgramPipeline))(GL_TH_DP, GLuint pipeline);
   void (*GL_TH_FN(glDeleteProgramPipelines))(GL_TH_DP, GLsizei n, const GLuint *pipelines);
   void (*GL_TH_FN(glGenProgramPipelines))(GL_TH_DP, GLsizei n, GLuint *pipelines);
   GLboolean (*GL_TH_FN(glIsProgramPipeline))(GL_TH_DP, GLuint pipeline);
   void (*GL_TH_FN(glGetProgramPipelineiv))(GL_TH_DP, GLuint pipeline, GLenum pname, GLint *params);
   void (*GL_TH_FN(glProgramUniform1i))(GL_TH_DP, GLuint program, GLint location, GLint v0);
   void (*GL_TH_FN(glProgramUniform2i))(GL_TH_DP, GLuint program, GLint location, GLint v0, GLint v1);
   void (*GL_TH_FN(glProgramUniform3i))(GL_TH_DP, GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
   void (*GL_TH_FN(glProgramUniform4i))(GL_TH_DP, GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
   void (*GL_TH_FN(glProgramUniform1ui))(GL_TH_DP, GLuint program, GLint location, GLuint v0);
   void (*GL_TH_FN(glProgramUniform2ui))(GL_TH_DP, GLuint program, GLint location, GLuint v0, GLuint v1);
   void (*GL_TH_FN(glProgramUniform3ui))(GL_TH_DP, GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
   void (*GL_TH_FN(glProgramUniform4ui))(GL_TH_DP, GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
   void (*GL_TH_FN(glProgramUniform1f))(GL_TH_DP, GLuint program, GLint location, GLfloat v0);
   void (*GL_TH_FN(glProgramUniform2f))(GL_TH_DP, GLuint program, GLint location, GLfloat v0, GLfloat v1);
   void (*GL_TH_FN(glProgramUniform3f))(GL_TH_DP, GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
   void (*GL_TH_FN(glProgramUniform4f))(GL_TH_DP, GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
   void (*GL_TH_FN(glProgramUniform1iv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLint *value);
   void (*GL_TH_FN(glProgramUniform2iv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLint *value);
   void (*GL_TH_FN(glProgramUniform3iv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLint *value);
   void (*GL_TH_FN(glProgramUniform4iv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLint *value);
   void (*GL_TH_FN(glProgramUniform1uiv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLuint *value);
   void (*GL_TH_FN(glProgramUniform2uiv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLuint *value);
   void (*GL_TH_FN(glProgramUniform3uiv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLuint *value);
   void (*GL_TH_FN(glProgramUniform4uiv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLuint *value);
   void (*GL_TH_FN(glProgramUniform1fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLfloat *value);
   void (*GL_TH_FN(glProgramUniform2fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLfloat *value);
   void (*GL_TH_FN(glProgramUniform3fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLfloat *value);
   void (*GL_TH_FN(glProgramUniform4fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, const GLfloat *value);
   void (*GL_TH_FN(glProgramUniformMatrix2fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glProgramUniformMatrix3fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glProgramUniformMatrix4fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glProgramUniformMatrix2x3fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glProgramUniformMatrix3x2fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glProgramUniformMatrix2x4fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glProgramUniformMatrix4x2fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glProgramUniformMatrix3x4fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glProgramUniformMatrix4x3fv))(GL_TH_DP, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
   void (*GL_TH_FN(glValidateProgramPipeline))(GL_TH_DP, GLuint pipeline);
   void (*GL_TH_FN(glGetProgramPipelineInfoLog))(GL_TH_DP, GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
   void (*GL_TH_FN(glBindImageTexture))(GL_TH_DP, GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
   void (*GL_TH_FN(glGetBooleani_v))(GL_TH_DP, GLenum target, GLuint index, GLboolean *data);
   void (*GL_TH_FN(glMemoryBarrier))(GL_TH_DP, GLbitfield barriers);
   void (*GL_TH_FN(glMemoryBarrierByRegion))(GL_TH_DP, GLbitfield barriers);
   void (*GL_TH_FN(glTexStorage2DMultisample))(GL_TH_DP, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
   void (*GL_TH_FN(glGetMultisamplefv))(GL_TH_DP, GLenum pname, GLuint index, GLfloat *val);
   void (*GL_TH_FN(glSampleMaski))(GL_TH_DP, GLuint maskNumber, GLbitfield mask);
#ifndef GL_GLES
   void (*GL_TH_FN(glGetTexLevelParameteriv))(GL_TH_DP, GLenum target, GLint level, GLenum pname, GLint *params);
#endif
   void (*GL_TH_FN(glGetTexLevelParameterfv))(GL_TH_DP, GLenum target, GLint level, GLenum pname, GLfloat *params);
   void (*GL_TH_FN(glBindVertexBuffer))(GL_TH_DP, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
   void (*GL_TH_FN(glVertexAttribFormat))(GL_TH_DP, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
   void (*GL_TH_FN(glVertexAttribIFormat))(GL_TH_DP, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
   void (*GL_TH_FN(glVertexAttribBinding))(GL_TH_DP, GLuint attribindex, GLuint bindingindex);
   void (*GL_TH_FN(glVertexBindingDivisor))(GL_TH_DP, GLuint bindingindex, GLuint divisor);
   void (*GL_TH_FN(glEGLImageTargetTexture2DOES))(GL_TH_DP, GLenum target, void *image);
   void (*GL_TH_FN(glEGLImageTargetRenderbufferStorageOES))(GL_TH_DP, GLenum target, void *image);
   EvasGLImage (*GL_TH_FN(evasglCreateImage))(GL_TH_DP, int target, void* buffer, const int *attrib_list);
   void (*GL_TH_FN(evasglDestroyImage))(GL_TH_DP, EvasGLImage image);
   EvasGLImage (*GL_TH_FN(evasglCreateImageForContext))(GL_TH_DP, Evas_GL *evas_gl, Evas_GL_Context *ctx, int target, void* buffer, const int *attrib_list);
   EvasGLSync (*GL_TH_FN(evasglCreateSync))(GL_TH_DP, Evas_GL *evas_gl, unsigned int type, const int *attrib_list);
   Eina_Bool (*GL_TH_FN(evasglDestroySync))(GL_TH_DP, Evas_GL *evas_gl, EvasGLSync sync);
   int (*GL_TH_FN(evasglClientWaitSync))(GL_TH_DP, Evas_GL *evas_gl, EvasGLSync sync, int flags, EvasGLTime timeout);
   Eina_Bool (*GL_TH_FN(evasglGetSyncAttrib))(GL_TH_DP, Evas_GL *evas_gl, EvasGLSync sync, int attribute, int *value);
   Eina_Bool (*GL_TH_FN(evasglSignalSync))(GL_TH_DP, Evas_GL *evas_gl, EvasGLSync sync, unsigned mode);
   int (*GL_TH_FN(evasglWaitSync))(GL_TH_DP, Evas_GL *evas_gl, EvasGLSync sync, int flags);
   Eina_Bool (*GL_TH_FN(evasglBindWaylandDisplay))(GL_TH_DP, Evas_GL *evas_gl, void *wl_display);
   Eina_Bool (*GL_TH_FN(evasglUnbindWaylandDisplay))(GL_TH_DP, Evas_GL *evas_gl, void *wl_display);
   Eina_Bool (*GL_TH_FN(evasglQueryWaylandBuffer))(GL_TH_DP, Evas_GL *evas_gl, void *buffer, int attribute, int *value);
} Evas_GL_Thread_GL_Generated_Func;


static Evas_GL_Thread_GL_Generated_Func th_gl_gen_func;
Eina_Bool th_gl_gen_func_initialized = EINA_FALSE;

void *
gl_generated_func_get()
{
   if (!th_gl_gen_func_initialized)
     {
#define THREAD_FUNCTION_ASSIGN(func) th_gl_gen_func.func = func;

        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glActiveTexture));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glAttachShader));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindAttribLocation));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindBuffer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindFramebuffer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindRenderbuffer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindTexture));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBlendColor));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBlendEquation));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBlendEquationSeparate));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBlendFunc));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBlendFuncSeparate));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBufferData));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBufferSubData));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCheckFramebufferStatus));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClear));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClearColor));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClearDepthf));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClearStencil));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glColorMask));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCompileShader));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCompressedTexImage2D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCompressedTexSubImage2D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCopyTexImage2D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCopyTexSubImage2D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCreateProgram));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCreateShader));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCullFace));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteBuffers));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteFramebuffers));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteProgram));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteRenderbuffers));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteShader));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteTextures));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDepthFunc));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDepthMask));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDepthRangef));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDetachShader));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDisable));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDisableVertexAttribArray));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawArrays));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawElements));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glEnable));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glEnableVertexAttribArray));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFinish));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFlush));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFramebufferRenderbuffer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFramebufferTexture2D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFrontFace));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenBuffers));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenerateMipmap));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenFramebuffers));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenRenderbuffers));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenTextures));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetActiveAttrib));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetActiveUniform));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetAttachedShaders));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetAttribLocation));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetBooleanv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetBufferParameteriv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetError));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetFloatv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetFramebufferAttachmentParameteriv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetIntegerv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetProgramiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetProgramInfoLog));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetRenderbufferParameteriv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetShaderiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetShaderInfoLog));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetShaderPrecisionFormat));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetShaderSource));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetString));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexParameterfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexParameteriv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetUniformfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetUniformiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetUniformLocation));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetVertexAttribfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetVertexAttribiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetVertexAttribPointerv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glHint));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsBuffer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsEnabled));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsFramebuffer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsProgram));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsRenderbuffer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsShader));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsTexture));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLineWidth));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLinkProgram));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPixelStorei));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPolygonOffset));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glReadPixels));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glReleaseShaderCompiler));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glRenderbufferStorage));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glSampleCoverage));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glScissor));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glShaderBinary));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glShaderSource));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glStencilFunc));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glStencilFuncSeparate));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glStencilMask));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glStencilMaskSeparate));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glStencilOp));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glStencilOpSeparate));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexImage2D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexParameterf));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexParameterfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexParameteri));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexParameteriv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexSubImage2D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform1f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform1fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform1i));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform1iv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform2f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform2fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform2i));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform2iv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform3f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform3fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform3i));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform3iv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform4f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform4fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform4i));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform4iv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniformMatrix2fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniformMatrix3fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniformMatrix4fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUseProgram));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glValidateProgram));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttrib1f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttrib1fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttrib2f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttrib2fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttrib3f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttrib3fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttrib4f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttrib4fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttribPointer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glViewport));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glEvasGLImageTargetTexture2DOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glEvasGLImageTargetRenderbufferStorageOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetProgramBinaryOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramBinaryOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMapBufferOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUnmapBufferOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetBufferPointervOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexImage3DOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexSubImage3DOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCopyTexSubImage3DOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCompressedTexImage3DOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCompressedTexSubImage3DOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFramebufferTexture3DOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetPerfMonitorGroupsAMD));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetPerfMonitorCountersAMD));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetPerfMonitorGroupStringAMD));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetPerfMonitorCounterStringAMD));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetPerfMonitorCounterInfoAMD));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenPerfMonitorsAMD));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeletePerfMonitorsAMD));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glSelectPerfMonitorCountersAMD));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBeginPerfMonitorAMD));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glEndPerfMonitorAMD));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetPerfMonitorCounterDataAMD));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDiscardFramebufferEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMultiDrawArraysEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMultiDrawElementsEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteFencesNV));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenFencesNV));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsFenceNV));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTestFenceNV));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetFenceivNV));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFinishFenceNV));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glSetFenceNV));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetDriverControlsQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetDriverControlStringQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glEnableDriverControlQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDisableDriverControlQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glExtGetTexturesQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glExtGetBuffersQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glExtGetRenderbuffersQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glExtGetFramebuffersQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glExtGetTexLevelParameterivQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glExtTexObjectStateOverrideiQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glExtGetTexSubImageQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glExtGetBufferPointervQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glExtGetShadersQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glExtGetProgramsQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glExtIsProgramBinaryQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glExtGetProgramBinarySourceQCOM));
#ifndef GL_GLES
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glAlphaFunc));
#endif
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClipPlanef));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glColor4f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFogf));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFogfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFrustumf));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetClipPlanef));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetLightfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetMaterialfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexEnvfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLightModelf));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLightModelfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLightf));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLightfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLoadMatrixf));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMaterialf));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMaterialfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMultMatrixf));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMultiTexCoord4f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glNormal3f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glOrthof));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPointParameterf));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPointParameterfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPointSize));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPointSizePointerOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glRotatef));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glScalef));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexEnvf));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexEnvfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTranslatef));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glAlphaFuncx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClearColorx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClearDepthx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClientActiveTexture));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClipPlanex));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glColor4ub));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glColor4x));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glColorPointer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDepthRangex));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDisableClientState));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glEnableClientState));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFogx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFogxv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFrustumx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetClipPlanex));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetFixedv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetLightxv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetMaterialxv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetPointerv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexEnviv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexEnvxv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexParameterxv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLightModelx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLightModelxv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLightx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLightxv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLineWidthx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLoadIdentity));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLoadMatrixx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLogicOp));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMaterialx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMaterialxv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMatrixMode));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMultMatrixx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMultiTexCoord4x));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glNormal3x));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glNormalPointer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glOrthox));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPointParameterx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPointParameterxv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPointSizex));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPolygonOffsetx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPopMatrix));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPushMatrix));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glRotatex));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glSampleCoveragex));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glScalex));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glShadeModel));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexCoordPointer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexEnvi));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexEnvx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexEnviv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexEnvxv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexParameterx));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexParameterxv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTranslatex));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexPointer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBlendEquationSeparateOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBlendFuncSeparateOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBlendEquationOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawTexsOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawTexiOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawTexxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawTexsvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawTexivOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawTexxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawTexfOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawTexfvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glAlphaFuncxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClearColorxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClearDepthxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClipPlanexOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glColor4xOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDepthRangexOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFogxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFogxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFrustumxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetClipPlanexOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetFixedvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetLightxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetMaterialxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexEnvxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexParameterxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLightModelxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLightModelxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLightxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLightxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLineWidthxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLoadMatrixxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMaterialxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMaterialxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMultMatrixxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMultiTexCoord4xOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glNormal3xOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glOrthoxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPointParameterxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPointParameterxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPointSizexOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPolygonOffsetxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glRotatexOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glSampleCoveragexOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glScalexOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexEnvxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexEnvxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexParameterxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexParameterxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTranslatexOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsRenderbufferOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindRenderbufferOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteRenderbuffersOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenRenderbuffersOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glRenderbufferStorageOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetRenderbufferParameterivOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsFramebufferOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindFramebufferOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteFramebuffersOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenFramebuffersOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCheckFramebufferStatusOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFramebufferRenderbufferOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFramebufferTexture2DOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetFramebufferAttachmentParameterivOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenerateMipmapOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCurrentPaletteMatrixOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glLoadPaletteFromModelViewMatrixOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMatrixIndexPointerOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glWeightPointerOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glQueryMatrixxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDepthRangefOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFrustumfOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glOrthofOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClipPlanefOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetClipPlanefOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClearDepthfOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexGenfOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexGenfvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexGeniOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexGenivOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexGenxOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexGenxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexGenfvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexGenivOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexGenxvOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindVertexArrayOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteVertexArraysOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenVertexArraysOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsVertexArrayOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCopyTextureLevelsAPPLE));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glRenderbufferStorageMultisampleAPPLE));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glResolveMultisampleFramebufferAPPLE));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFenceSyncAPPLE));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsSyncAPPLE));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteSyncAPPLE));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClientWaitSyncAPPLE));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glWaitSyncAPPLE));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetInteger64vAPPLE));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetSyncivAPPLE));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMapBufferRangeEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFlushMappedBufferRangeEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glRenderbufferStorageMultisampleEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFramebufferTexture2DMultisampleEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetGraphicsResetStatusEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glReadnPixelsEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetnUniformfvEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetnUniformivEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexStorage1DEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexStorage2DEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexStorage3DEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTextureStorage1DEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTextureStorage2DEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTextureStorage3DEXT));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClipPlanefIMG));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClipPlanexIMG));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glRenderbufferStorageMultisampleIMG));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFramebufferTexture2DMultisampleIMG));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glActivateTile));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glStartTilingQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glEndTilingQCOM));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBeginQuery));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBeginTransformFeedback));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindBufferBase));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindBufferRange));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindSampler));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindTransformFeedback));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindVertexArray));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBlitFramebuffer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClearBufferfi));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClearBufferfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClearBufferiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClearBufferuiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glClientWaitSync));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCompressedTexImage3D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCompressedTexSubImage3D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCopyBufferSubData));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCopyTexSubImage3D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteQueries));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteSamplers));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteSync));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteTransformFeedbacks));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteVertexArrays));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawArraysInstanced));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawBuffers));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawElementsInstanced));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawRangeElements));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glEndQuery));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glEndTransformFeedback));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFenceSync));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFlushMappedBufferRange));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFramebufferTextureLayer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenQueries));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenSamplers));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenTransformFeedbacks));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenVertexArrays));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetActiveUniformBlockiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetActiveUniformBlockName));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetActiveUniformsiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetBufferParameteri64v));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetBufferPointerv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetFragDataLocation));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetInteger64i_v));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetInteger64v));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetIntegeri_v));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetInternalformativ));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetProgramBinary));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetQueryiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetQueryObjectuiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetSamplerParameterfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetSamplerParameteriv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetStringi));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetSynciv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTransformFeedbackVarying));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetUniformBlockIndex));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetUniformIndices));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetUniformuiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetVertexAttribIiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetVertexAttribIuiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glInvalidateFramebuffer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glInvalidateSubFramebuffer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsQuery));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsSampler));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsSync));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsTransformFeedback));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsVertexArray));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMapBufferRange));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glPauseTransformFeedback));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramBinary));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramParameteri));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glReadBuffer));
#ifndef GL_GLES
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glRenderbufferStorageMultisample));
#endif
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glResumeTransformFeedback));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glSamplerParameterf));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glSamplerParameterfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glSamplerParameteri));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glSamplerParameteriv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexImage3D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexStorage2D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexStorage3D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexSubImage3D));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTransformFeedbackVaryings));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform1ui));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform1uiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform2ui));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform2uiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform3ui));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform3uiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform4ui));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniform4uiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniformBlockBinding));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniformMatrix2x3fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniformMatrix3x2fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniformMatrix2x4fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniformMatrix4x2fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniformMatrix3x4fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUniformMatrix4x3fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUnmapBuffer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttribDivisor));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttribI4i));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttribI4iv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttribI4ui));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttribI4uiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttribIPointer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glWaitSync));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDispatchCompute));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDispatchComputeIndirect));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawArraysIndirect));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDrawElementsIndirect));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glFramebufferParameteri));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetFramebufferParameteriv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetProgramInterfaceiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetProgramResourceIndex));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetProgramResourceName));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetProgramResourceiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetProgramResourceLocation));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glUseProgramStages));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glActiveShaderProgram));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glCreateShaderProgramv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindProgramPipeline));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glDeleteProgramPipelines));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGenProgramPipelines));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glIsProgramPipeline));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetProgramPipelineiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform1i));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform2i));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform3i));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform4i));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform1ui));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform2ui));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform3ui));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform4ui));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform1f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform2f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform3f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform4f));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform1iv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform2iv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform3iv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform4iv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform1uiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform2uiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform3uiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform4uiv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform1fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform2fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform3fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniform4fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniformMatrix2fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniformMatrix3fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniformMatrix4fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniformMatrix2x3fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniformMatrix3x2fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniformMatrix2x4fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniformMatrix4x2fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniformMatrix3x4fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glProgramUniformMatrix4x3fv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glValidateProgramPipeline));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetProgramPipelineInfoLog));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindImageTexture));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetBooleani_v));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMemoryBarrier));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glMemoryBarrierByRegion));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glTexStorage2DMultisample));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetMultisamplefv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glSampleMaski));
#ifndef GL_GLES
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexLevelParameteriv));
#endif
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glGetTexLevelParameterfv));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glBindVertexBuffer));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttribFormat));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttribIFormat));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexAttribBinding));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glVertexBindingDivisor));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glEGLImageTargetTexture2DOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(glEGLImageTargetRenderbufferStorageOES));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(evasglCreateImage));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(evasglDestroyImage));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(evasglCreateImageForContext));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(evasglCreateSync));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(evasglDestroySync));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(evasglClientWaitSync));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(evasglGetSyncAttrib));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(evasglSignalSync));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(evasglWaitSync));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(evasglBindWaylandDisplay));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(evasglUnbindWaylandDisplay));
        THREAD_FUNCTION_ASSIGN(GL_TH_FN(evasglQueryWaylandBuffer));

#undef THREAD_FUNCTION_ASSIGN

        th_gl_gen_func_initialized = EINA_TRUE;
     }

   return &th_gl_gen_func;
}
