struct @beta Efl2.Text.Attribute.Handle;

// FIXME: maybe for both this an item, do'nt have insert, delete or any of those, but rather have those in the textblock object?
// - Do we even want refcount?
class @beta Efl2.Text.Attribute.Factory implements Efl2.Text.Font.Properties, Efl2.Text.Style.Properties {
   [[Annotation factory API

       Long-lived you keep it and reuse it as needed
   ]]
   methods {
      reset {
         [[Resets the factory context
         ]]
      }

      load {
         [[Sets the factory context from a handle
         ]]
         params {
            handle: const(ptr(Efl2.Text.Attribute.Handle)); [[Attribute handle]]
         }
      }

      // FIXME: rename?
      update {
         [[Sets the factory context to an handle
         ]]
         params {
            handle: ptr(Efl2.Text.Attribute.Handle); [[Attribute handle]]
         }
      }

      // FIXME: cursor_?
      insert {
         [[Creates an attribute from the current factory context and inserts it into the range marked by the cursors
         ]]
         return: ptr(Efl2.Text.Attribute.Handle); [[The handle to the attribute]]
         params {
            cur1: const(Efl2.Text.Cursor); [[Start of range]]
            cur2: const(Efl2.Text.Cursor); [[End of range]]
         }
      }

      // FIXME: not sure if great. It's used for style
      create {
         [[Creates an attribute from the current factory context without inserting
         ]]
         return: ptr(Efl2.Text.Attribute.Handle); [[The handle to the attribute]]
      }

      // FIXME: cursor_?
      range_attributes_get @static {
         [[Returns an iterator of all the handles in a range.
         ]]
         params {
              @in start: const(Efl2.Text.Cursor); [[Start of range]]
              @in end: const(Efl2.Text.Cursor); [[End of range]]
         }
         return: iterator<Efl2.Text.Attribute.Handle> @owned; [[The handles of the attributes]]
      }

      // FIXME: cursor_?
      attribute_range_get @static {
         [[Gets the attribute's range and set the cursors
         ]]
         params {
              start: Efl2.Text.Cursor; [[Start of range]]
              end: Efl2.Text.Cursor; [[End of range]]
         }
      }

      ref @static {
         [[Increase the attribute's refcount
         ]]
         params {
              handle: ptr(Efl2.Text.Attribute.Handle); [[Handle to the attribute to delete from the object]]
         }
         return: ptr(Efl2.Text.Attribute.Handle); [[The handle passed (also returned for convenience]]
      }

      unref @static {
         [[Decrease the attribute's refcount
         ]]
         params {
              handle: ptr(Efl2.Text.Attribute.Handle); [[Handle to the attribute to delete from the object]]
         }
      }

      remove @static {
         [[Removes the attribute from the text object
         ]]
         params {
              handle: ptr(Efl2.Text.Attribute.Handle); [[Handle to the attribute to delete from the object]]
         }
      }
   }
   implements {
       Efl2.Text.Font.Properties.font_family { set; get; }
       Efl2.Text.Font.Properties.font_size { set; get; }
       Efl2.Text.Font.Properties.font_source { set; get; }
       Efl2.Text.Font.Properties.font_fallbacks { set; get; }
       Efl2.Text.Font.Properties.font_weight { set; get; }
       Efl2.Text.Font.Properties.font_slant { set; get; }
       Efl2.Text.Font.Properties.font_width { set; get; }
       Efl2.Text.Font.Properties.font_lang { set; get; }
       Efl2.Text.Font.Properties.font_bitmap_scalable { set; get; }
       Efl2.Text.Style.Properties.foreground_color { set; get; }
       Efl2.Text.Style.Properties.background_type { set; get; }
       Efl2.Text.Style.Properties.background_color { set; get; }
       Efl2.Text.Style.Properties.underline_type { set; get; }
       Efl2.Text.Style.Properties.underline_color { set; get; }
       Efl2.Text.Style.Properties.underline_height { set; get; }
       Efl2.Text.Style.Properties.underline_dashed_gap { set; get; }
       Efl2.Text.Style.Properties.underline_dashed_color { set; get; }
       Efl2.Text.Style.Properties.underline_dashed_width { set; get; }
       Efl2.Text.Style.Properties.underline2_color { set; get; }
       Efl2.Text.Style.Properties.strikethrough_type { set; get; }
       Efl2.Text.Style.Properties.strikethrough_color { set; get; }
       Efl2.Text.Style.Properties.shadow_direction { set; get; }
       Efl2.Text.Style.Properties.shadow_color { set; get; }
       Efl2.Text.Style.Properties.glow_color { set; get; }
       Efl2.Text.Style.Properties.glow2_color { set; get; }
       Efl2.Text.Style.Properties.line_spacing { set; get; }
       Efl2.Text.Style.Properties.line_spacing_factor { set; get; }
       Efl2.Text.Style.Properties.line_height { set; get; }
       Efl2.Text.Style.Properties.line_height_factor { set; get; }
       Efl2.Text.Style.Properties.tab_width { set; get; }
   }
}
