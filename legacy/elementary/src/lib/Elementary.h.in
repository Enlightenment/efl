/*
 *
 * vim:ts=8:sw=3:sts=3:expandtab:cino=>5n-3f0^-2{2(0W1st0
 */

/**
@file Elementary.h.in
@brief Elementary Widget Library
*/

/**
@mainpage Elementary
@image html  elementary.png
@version @PACKAGE_VERSION@
@author Carsten Haitzler <raster@@rasterman.com>
@author Gustavo Sverzut Barbieri <barbieri@@profusion.mobi>
@author Cedric Bail <cedric.bail@@free.fr>
@author Vincent Torri <vtorri@@univ-evry.fr>
@author Daniel Kolesa <quaker66@@gmail.com>
@author Jaime Thomas <avi.thomas@@gmail.com>
@author Swisscom - http://www.swisscom.ch/
@author Christopher Michael <devilhorns@@comcast.net>
@author Marco Trevisan (Treviño) <mail@@3v1n0.net>
@author Michael Bouchaud <michael.bouchaud@@gmail.com>
@author Jonathan Atton (Watchwolf) <jonathan.atton@@gmail.com>
@author Brian Wang <brian.wang.0721@@gmail.com>
@author Mike Blumenkrantz (zmike) <mike@@zentific.com>
@author Samsung Electronics <tbd>
@author Samsung SAIT <tbd>
@author Brett Nash <nash@@nash.id.au>
@author Bruno Dilly <bdilly@@profusion.mobi>
@author Rafael Fonseca <rfonseca@@profusion.mobi>
@author Chuneon Park <hermet@@hermet.pe.kr>
@author Woohyun Jung <wh0705.jung@@samsung.com>
@author Jaehwan Kim <jae.hwan.kim@@samsung.com>
@author Wonguk Jeong <wonguk.jeong@@samsung.com>
@author Leandro A. F. Pereira <leandro@@profusion.mobi>
@author Helen Fornazier <helen.fornazier@@profusion.mobi>
@author Gustavo Lima Chaves <glima@@profusion.mobi>
@author Fabiano Fidêncio <fidencio@@profusion.mobi>
@author Tiago Falcão <tiago@@profusion.mobi>
@author Otavio Pontes <otavio@@profusion.mobi>
@author Viktor Kojouharov <vkojouharov@@gmail.com>
@author Daniel Juyung Seo (SeoZ) <juyung.seo@@samsung.com> <seojuyung2@@gmail.com>
@author Sangho Park <sangho.g.park@@samsung.com> <gouache95@@gmail.com>
@author Rajeev Ranjan (Rajeev) <rajeev.r@@samsung.com> <rajeev.jnnce@@gmail.com>
@author Seunggyun Kim <sgyun.kim@@samsung.com> <tmdrbs@@gmail.com>
@author Sohyun Kim <anna1014.kim@@samsung.com> <sohyun.anna@@gmail.com>
@author Jihoon Kim <jihoon48.kim@@samsung.com>
@author Jeonghyun Yun (arosis) <jh0506.yun@@samsung.com>
@author Tom Hacohen <tom@@stosb.com>
@author Aharon Hillel <a.hillel@@partner.samsung.com>
@author Jonathan Atton (Watchwolf) <jonathan.atton@@gmail.com>
@author Shinwoo Kim <kimcinoo@@gmail.com>
@author Govindaraju SM <govi.sm@@samsung.com> <govism@@gmail.com>
@author Prince Kumar Dubey <prince.dubey@@samsung.com> <prince.dubey@@gmail.com>
@date 2008-2011

@section intro What is Elementary?

This is a VERY SIMPLE toolkit. It is not meant for writing extensive desktop
applications (yet). Small simple ones with simple needs.

It is meant to make the programmers work almost brainless but give them lots
of flexibility.

License: LGPL v2 (see COPYING in the base of Elementary's source). This
applies to all files in the source here.

Acknowledgements: There is a lot that goes into making a widget set, and
they don't happen out of nothing. It's like trying to make everyone
everywhere happy, regardless of age, gender, race or nationality - and
that is really tough. So thanks to people and organisations behind this,
aslisted in the Authors section above.

@verbatim
Pants
@endverbatim
*/

#ifndef ELEMENTARY_H
#define ELEMENTARY_H

/**
 * @file Elementary.h
 * @brief Elementary's API
 *
 * Elementary API.
 */

@ELM_UNIX_DEF@ ELM_UNIX
@ELM_WIN32_DEF@ ELM_WIN32
@ELM_WINCE_DEF@ ELM_WINCE
@ELM_EDBUS_DEF@ ELM_EDBUS
@ELM_EFREET_DEF@ ELM_EFREET
@ELM_ETHUMB_DEF@ ELM_ETHUMB
@ELM_EMAP_DEF@ ELM_EMAP
@ELM_DEBUG_DEF@ ELM_DEBUG
@ELM_ALLOCA_H_DEF@ ELM_ALLOCA_H
@ELM_LIBINTL_H_DEF@ ELM_LIBINTL_H

/* Standard headers for standard system calls etc. */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/param.h>
#include <dlfcn.h>
#include <math.h>
#include <fnmatch.h>
#include <limits.h>
#include <ctype.h>
#include <time.h>
#include <dirent.h>
#include <pwd.h>
#include <errno.h>

#ifdef ELM_UNIX
# include <locale.h>
# ifdef ELM_LIBINTL_H
#  include <libintl.h>
# endif
# include <signal.h>
# include <grp.h>
# include <glob.h>
#endif

#ifdef ELM_ALLOCA_H
# include <alloca.h>
#endif

#if defined (ELM_WIN32) || defined (ELM_WINCE)
# include <malloc.h>
# ifndef alloca
#  define alloca _alloca
# endif
#endif


/* EFL headers */
#include <Eina.h>
#include <Eet.h>
#include <Evas.h>
#include <Evas_GL.h>
#include <Ecore.h>
#include <Ecore_Evas.h>
#include <Ecore_File.h>
#include <Ecore_IMF.h>
#include <Edje.h>

#ifdef ELM_EDBUS
# include <E_DBus.h>
#endif

#ifdef ELM_EFREET
# include <Efreet.h>
# include <Efreet_Mime.h>
# include <Efreet_Trash.h>
#endif

#ifdef ELM_ETHUMB
# include <Ethumb_Client.h>
#endif

#ifdef ELM_EMAP
# include <EMap.h>
#endif

#ifdef EAPI
# undef EAPI
#endif

#ifdef _WIN32
# ifdef ELEMENTARY_BUILD
#  ifdef DLL_EXPORT
#   define EAPI __declspec(dllexport)
#  else
#   define EAPI
#  endif /* ! DLL_EXPORT */
# else
#  define EAPI __declspec(dllimport)
# endif /* ! EFL_EVAS_BUILD */
#else
# ifdef __GNUC__
#  if __GNUC__ >= 4
#   define EAPI __attribute__ ((visibility("default")))
#  else
#   define EAPI
#  endif
# else
#  define EAPI
# endif
#endif /* ! _WIN32 */


/* allow usage from c++ */
#ifdef __cplusplus
extern "C" {
#endif

#define ELM_VERSION_MAJOR @VMAJ@
#define ELM_VERSION_MINOR @VMIN@

   typedef struct _Elm_Version
     {
        int major;
        int minor;
        int micro;
        int revision;
     } Elm_Version;

   EAPI extern Elm_Version *elm_version;

/* handy macros */
#define ELM_RECTS_INTERSECT(x, y, w, h, xx, yy, ww, hh) (((x) < ((xx) + (ww))) && ((y) < ((yy) + (hh))) && (((x) + (w)) > (xx)) && (((y) + (h)) > (yy)))
#define ELM_PI 3.14159265358979323846

   /**
    * @defgroup General General
    *
    * @brief General Elementary API. Functions that don't relate to
    * Elementary objects specifically.
    *
    * Here are documented functions which init/shutdown the library,
    * that apply to generic Elementary objects, that deal with
    * configuration, et cetera.
    *
    * @ref general_functions_example_page "This" example contemplates
    * some of these functions.
    */

   /**
    * @addtogroup General
    * @{
    */

  /**
   * Defines couple of standard Evas_Object layers to be used
   * with evas_object_layer_set().
   *
   * @note whenever extending with new values, try to keep some padding
   *       to siblings so there is room for further extensions.
   */
  typedef enum _Elm_Object_Layer
    {
       ELM_OBJECT_LAYER_BACKGROUND = EVAS_LAYER_MIN + 64, /**< where to place backgrounds */
       ELM_OBJECT_LAYER_DEFAULT = 0, /**< Evas_Object default layer (and thus for Elementary) */
       ELM_OBJECT_LAYER_FOCUS = EVAS_LAYER_MAX - 128, /**< where focus object visualization is */
       ELM_OBJECT_LAYER_TOOLTIP = EVAS_LAYER_MAX - 64, /**< where to show tooltips */
       ELM_OBJECT_LAYER_CURSOR = EVAS_LAYER_MAX - 32, /**< where to show cursors */
       ELM_OBJECT_LAYER_LAST /**< last layer known by Elementary */
    } Elm_Object_Layer;

/**************************************************************************/
   EAPI extern int ELM_ECORE_EVENT_ETHUMB_CONNECT;

   /**
    * Emitted when any Elementary's policy value is changed.
    */
   EAPI extern int ELM_EVENT_POLICY_CHANGED;

   /**
    * @typedef Elm_Event_Policy_Changed
    *
    * Data on the event when an Elementary policy has changed
    */
    typedef struct _Elm_Event_Policy_Changed Elm_Event_Policy_Changed;

   /**
    * @struct _Elm_Event_Policy_Changed
    *
    * Data on the event when an Elementary policy has changed
    */
    struct _Elm_Event_Policy_Changed
     {
        unsigned int policy; /**< the policy identifier */
        int          new_value; /**< value the policy had before the change */
        int          old_value; /**< new value the policy got */
    };

   /**
    * Policy identifiers.
    */
    typedef enum _Elm_Policy
    {
        ELM_POLICY_QUIT, /**< under which circunstances the application
                          * should quit automatically. @see
                          * Elm_Policy_Quit.
                          */
        ELM_POLICY_LAST
    } Elm_Policy; /**< Elementary policy identifiers/groups enumeration.  @see elm_policy_set()
 */

   typedef enum _Elm_Policy_Quit
     {
        ELM_POLICY_QUIT_NONE = 0, /**< never quit the application
                                   * automatically */
        ELM_POLICY_QUIT_LAST_WINDOW_CLOSED /**< quit when the
                                            * application's last
                                            * window is closed */
     } Elm_Policy_Quit; /**< Possible values for the #ELM_POLICY_QUIT policy */

   typedef enum _Elm_Focus_Direction
     {
        ELM_FOCUS_PREVIOUS,
        ELM_FOCUS_NEXT
     } Elm_Focus_Direction;

   typedef enum _Elm_Text_Format
     {
        ELM_TEXT_FORMAT_PLAIN_UTF8,
        ELM_TEXT_FORMAT_MARKUP_UTF8
     } Elm_Text_Format;

   /**
    * Line wrapping types.
    */
   typedef enum _Elm_Wrap_Type
     {
        ELM_WRAP_NONE = 0, /**< No wrap - value is zero */
        ELM_WRAP_CHAR, /**< Char wrap - wrap between characters */
        ELM_WRAP_WORD, /**< Word wrap - wrap in allowed wrapping points (as defined in the unicode standard) */
        ELM_WRAP_MIXED, /**< Mixed wrap - Word wrap, and if that fails, char wrap. */
        ELM_WRAP_LAST
     } Elm_Wrap_Type;


   /**
    * Called back when a widget's tooltip is activated and needs content.
    * @param data user-data given to elm_object_tooltip_content_cb_set()
    * @param obj owner widget.
    * @param tooltip The tooltip object (affix content to this!)
    */
   typedef Evas_Object *(*Elm_Tooltip_Content_Cb) (void *data, Evas_Object *obj, Evas_Object *tooltip);

   /**
    * Called back when a widget's item tooltip is activated and needs content.
    * @param data user-data given to elm_object_tooltip_content_cb_set()
    * @param obj owner widget.
    * @param tooltip The tooltip object (affix content to this!)
    * @param item context dependent item. As an example, if tooltip was
    *        set on Elm_List_Item, then it is of this type.
    */
   typedef Evas_Object *(*Elm_Tooltip_Item_Content_Cb) (void *data, Evas_Object *obj, Evas_Object *tooltip, void *item);

   typedef Eina_Bool (*Elm_Event_Cb) (void *data, Evas_Object *obj, Evas_Object *src, Evas_Callback_Type type, void *event_info);

#ifndef ELM_LIB_QUICKLAUNCH
#define ELM_MAIN() int main(int argc, char **argv) {elm_init(argc, argv); return elm_main(argc, argv);} /**< macro to be used after the elm_main() function */
#else
#define ELM_MAIN() int main(int argc, char **argv) {return elm_quicklaunch_fallback(argc, argv);} /**< macro to be used after the elm_main() function */
#endif

/**************************************************************************/
   /* General calls */

   /**
    * Initialize Elementary
    *
    * @param[in] argc System's argument count value
    * @param[in] argv System's pointer to array of argument strings
    * @return The init counter value.
    *
    * This function initializes Elementary and increments a counter of
    * the number of calls to it. It returs the new counter's value.
    *
    * @warning This call is exported only for use by the @c ELM_MAIN()
    * macro. There is no need to use this if you use this macro (which
    * is highly advisable). An elm_main() should contain the entry
    * point code for your application, having the same prototype as
    * elm_init(), and @b not being static (putting the @c EAPI symbol
    * in front of its type declaration is advisable). The @c
    * ELM_MAIN() call should be placed just after it.
    *
    * Example:
    * @dontinclude bg_example_01.c
    * @skip static void
    * @until ELM_MAIN
    *
    * See the full @ref bg_example_01_c "example".
    *
    * @see elm_shutdown().
    * @ingroup General
    */
   EAPI int          elm_init(int argc, char **argv);

   /**
    * Shut down Elementary
    *
    * @return The init counter value.
    *
    * This should be called at the end of your application, just
    * before it ceases to do any more processing. This will clean up
    * any permanent resources your application may have allocated via
    * Elementary that would otherwise persist.
    *
    * @see elm_init() for an example
    *
    * @ingroup General
    */
   EAPI int          elm_shutdown(void);

   /**
    * Run Elementary's main loop
    *
    * This call should be issued just after all initialization is
    * completed. This function will not return until elm_exit() is
    * called. It will keep looping, running the main
    * (event/processing) loop for Elementary.
    *
    * @see elm_init() for an example
    *
    * @ingroup General
    */
   EAPI void         elm_run(void);

   /**
    * Exit Elementary's main loop
    *
    * If this call is issued, it will flag the main loop to cease
    * processing and return back to its parent function (usually your
    * elm_main() function).
    *
    * @see elm_init() for an example. There, just after a request to
    * close the window comes, the main loop will be left.
    *
    * @note By using the #ELM_POLICY_QUIT on your Elementary
    * applications, you'll this function called automatically for you.
    *
    * @ingroup General
    */
   EAPI void         elm_exit(void);

   /**
    * Provide information in order to make Elementary determine the @b
    * run time location of the software in question, so other data files
    * such as images, sound files, executable utilities, libraries,
    * modules and locale files can be found.
    *
    * @param mainfunc This is your application's main function name,
    *        whose binary's location is to be found. Providing @c NULL
    *        will make Elementary not to use it
    * @param dom This will be used as the application's "domain", in the
    *        form of a prefix to any environment variables that may
    *        override prefix detection and the directory name, inside the
    *        standard share or data directories, where the software's
    *        data files will be looked for.
    * @param checkfile This is an (optional) magic file's path to check
    *        for existence (and it must be located in the data directory,
    *        under the share directory provided above). Its presence will
    *        help determine the prefix found was correct. Pass @c NULL if
    *        the check is not to be done.
    *
    * This function allows one to re-locate the application somewhere
    * else after compilation, if the developer wishes for easier
    * distribution of pre-compiled binaries.
    *
    * The prefix system is designed to locate where the given software is
    * installed (under a common path prefix) at run time and then report
    * specific locations of this prefix and common directories inside
    * this prefix like the binary, library, data and locale directories,
    * through the @c elm_app_*_get() family of functions.
    *
    * Call elm_app_info_set() early on before you change working
    * directory or anything about @c argv[0], so it gets accurate
    * information.
    *
    * It will then try and trace back which file @p mainfunc comes from,
    * if provided, to determine the application's prefix directory.
    *
    * The @p dom parameter provides a string prefix to prepend before
    * environment variables, allowing a fallback to @b specific
    * environment variables to locate the software. You would most
    * probably provide a lowercase string there, because it will also
    * serve as directory domain, explained next. For environment
    * variables purposes, this string is made uppercase. For example if
    * @c "myapp" is provided as the prefix, then the program would expect
    * @c "MYAPP_PREFIX" as a master environment variable to specify the
    * exact install prefix for the software, or more specific environment
    * variables like @c "MYAPP_BIN_DIR", @c "MYAPP_LIB_DIR", @c
    * "MYAPP_DATA_DIR" and @c "MYAPP_LOCALE_DIR", which could be set by
    * the user or scripts before launching. If not provided (@c NULL),
    * environment variables will not be used to override compiled-in
    * defaults or auto detections.
    *
    * The @p dom string also provides a subdirectory inside the system
    * shared data directory for data files. For example, if the system
    * directory is @c /usr/local/share, then this directory name is
    * appended, creating @c /usr/local/share/myapp, if it @p was @c
    * "myapp". It is expected the application installs data files in
    * this directory.
    *
    * The @p checkfile is a file name or path of something inside the
    * share or data directory to be used to test that the prefix
    * detection worked. For example, your app will install a wallpaper
    * image as @c /usr/local/share/myapp/images/wallpaper.jpg and so to
    * check that this worked, provide @c "images/wallpaper.jpg" as the @p
    * checkfile string.
    *
    * @see elm_app_compile_bin_dir_set()
    * @see elm_app_compile_lib_dir_set()
    * @see elm_app_compile_data_dir_set()
    * @see elm_app_compile_locale_set()
    * @see elm_app_prefix_dir_get()
    * @see elm_app_bin_dir_get()
    * @see elm_app_lib_dir_get()
    * @see elm_app_data_dir_get()
    * @see elm_app_locale_dir_get()
    */
   EAPI void         elm_app_info_set(void *mainfunc, const char *dom, const char *checkfile);

   /**
    * Provide information on the @b fallback application's binaries
    * directory, on scenarios where they get overriden by
    * elm_app_info_set().
    *
    * @param dir The path to the default binaries directory (compile time
    * one)
    *
    * @note Elementary will as well use this path to determine actual
    * names of binaries' directory paths, maybe changing it to be @c
    * something/local/bin instead of @c something/bin, only, for
    * example.
    *
    * @warning You should call this function @b before
    * elm_app_info_set().
    */
   EAPI void         elm_app_compile_bin_dir_set(const char *dir);

   /**
    * Provide information on the @b fallback application's libraries
    * directory, on scenarios where they get overriden by
    * elm_app_info_set().
    *
    * @param dir The path to the default libraries directory (compile
    * time one)
    *
    * @note Elementary will as well use this path to determine actual
    * names of libraries' directory paths, maybe changing it to be @c
    * something/lib32 or @c something/lib64 instead of @c something/lib,
    * only, for example.
    *
    * @warning You should call this function @b before
    * elm_app_info_set().
    */
   EAPI void         elm_app_compile_lib_dir_set(const char *dir);

   /**
    * Provide information on the @b fallback application's data
    * directory, on scenarios where they get overriden by
    * elm_app_info_set().
    *
    * @param dir The path to the default data directory (compile time
    * one)
    *
    * @note Elementary will as well use this path to determine actual
    * names of data directory paths, maybe changing it to be @c
    * something/local/share instead of @c something/share, only, for
    * example.
    *
    * @warning You should call this function @b before
    * elm_app_info_set().
    */
   EAPI void         elm_app_compile_data_dir_set(const char *dir);

   /**
    * Provide information on the @b fallback application's locale
    * directory, on scenarios where they get overriden by
    * elm_app_info_set().
    *
    * @param dir The path to the default locale directory (compile time
    * one)
    *
    * @warning You should call this function @b before
    * elm_app_info_set().
    */
   EAPI void         elm_app_compile_locale_set(const char *dir);

   /**
    * Retrieve the application's run time prefix directory, as set by
    * elm_app_info_set() and the way (environment) the application was
    * run from.
    *
    * @return The directory prefix the application is actually using
    */
   EAPI const char  *elm_app_prefix_dir_get(void);

   /**
    * Retrieve the application's run time binaries prefix directory, as
    * set by elm_app_info_set() and the way (environment) the application
    * was run from.
    *
    * @return The binaries directory prefix the application is actually
    * using
    */
   EAPI const char  *elm_app_bin_dir_get(void);

   /**
    * Retrieve the application's run time libraries prefix directory, as
    * set by elm_app_info_set() and the way (environment) the application
    * was run from.
    *
    * @return The libraries directory prefix the application is actually
    * using
    */
   EAPI const char  *elm_app_lib_dir_get(void);

   /**
    * Retrieve the application's run time data prefix directory, as
    * set by elm_app_info_set() and the way (environment) the application
    * was run from.
    *
    * @return The data directory prefix the application is actually
    * using
    */
   EAPI const char  *elm_app_data_dir_get(void);

   /**
    * Retrieve the application's run time locale prefix directory, as
    * set by elm_app_info_set() and the way (environment) the application
    * was run from.
    *
    * @return The locale directory prefix the application is actually
    * using
    */
   EAPI const char  *elm_app_locale_dir_get(void);

   EAPI void         elm_quicklaunch_mode_set(Eina_Bool ql_on);
   EAPI Eina_Bool    elm_quicklaunch_mode_get(void);
   EAPI int          elm_quicklaunch_init(int argc, char **argv);
   EAPI int          elm_quicklaunch_sub_init(int argc, char **argv);
   EAPI int          elm_quicklaunch_sub_shutdown(void);
   EAPI int          elm_quicklaunch_shutdown(void);
   EAPI void         elm_quicklaunch_seed(void);
   EAPI Eina_Bool    elm_quicklaunch_prepare(int argc, char **argv);
   EAPI Eina_Bool    elm_quicklaunch_fork(int argc, char **argv, char *cwd, void (postfork_func) (void *data), void *postfork_data);
   EAPI void         elm_quicklaunch_cleanup(void);
   EAPI int          elm_quicklaunch_fallback(int argc, char **argv);
   EAPI char        *elm_quicklaunch_exe_path_get(const char *exe);

   EAPI Eina_Bool    elm_need_efreet(void);
   EAPI Eina_Bool    elm_need_e_dbus(void);
   EAPI Eina_Bool    elm_need_ethumb(void);

   /**
    * Set a new policy's value (for a given policy group/identifier).
    *
    * @param policy policy identifier, as in @ref Elm_Policy.
    * @param value policy value, which depends on the identifier
    *
    * @return @c EINA_TRUE on success or @c EINA_FALSE, on error.
    *
    * Elementary policies define applications' behavior,
    * somehow. These behaviors are divided in policy groups (see
    * #Elm_Policy enumeration). This call will emit the Ecore event
    * #ELM_EVENT_POLICY_CHANGED, which can be hooked at with
    * handlers. An #Elm_Event_Policy_Changed struct will be passed,
    * then.
    *
    * @note Currently, we have only one policy identifier/group
    * (#ELM_POLICY_QUIT), which has two possible values.
    *
    * @ingroup General
    */
   EAPI Eina_Bool    elm_policy_set(unsigned int policy, int value);

   /**
    * Gets the policy value set for given policy identifier.
    *
    * @param policy policy identifier, as in #Elm_Policy.
    * @return The currently set policy value, for that
    * identifier. Will be @c 0 if @p policy passed is invalid.
    *
    * @ingroup General
    */
   EAPI int          elm_policy_get(unsigned int policy);

   /**
    * Set a label of an object
    *
    * @param obj The Elementary object
    * @param item The label id to set (NULL for the default label)
    * @param label The new text of the label
    *
    * @note Elementary objects may have many labels (e.g. Action Slider)
    *
    * @ingroup General
    */
   EAPI void         elm_object_text_part_set(Evas_Object *obj, const char *item, const char *label);

#define elm_object_text_set(obj, label) elm_object_text_part_set((obj), NULL, (label))

   /**
    * Get a label of an object
    *
    * @param obj The Elementary object
    * @param item The label id to get (NULL for the default label)
    * @return text of the label or
    *         NULL for any error
    *
    * @note Elementary objects may have many labels (e.g. Action Slider)
    *
    * @ingroup General
    */
   EAPI const char  *elm_object_text_part_get(const Evas_Object *obj, const char *item);

#define elm_object_text_get(obj) elm_object_text_part_get((obj), NULL)

   /**
    * @}
    */

   EAPI void         elm_all_flush(void);
   EAPI int          elm_cache_flush_interval_get(void);
   EAPI void         elm_cache_flush_interval_set(int size);
   EAPI void         elm_cache_flush_interval_all_set(int size);
   EAPI Eina_Bool    elm_cache_flush_enabled_get(void);
   EAPI void         elm_cache_flush_enabled_set(Eina_Bool enabled);
   EAPI void         elm_cache_flush_enabled_all_set(Eina_Bool enabled);
   EAPI int          elm_font_cache_get(void);
   EAPI void         elm_font_cache_set(int size);
   EAPI void         elm_font_cache_all_set(int size);
   EAPI int          elm_image_cache_get(void);
   EAPI void         elm_image_cache_set(int size);
   EAPI void         elm_image_cache_all_set(int size);
   EAPI int          elm_edje_file_cache_get(void);
   EAPI void         elm_edje_file_cache_set(int size);
   EAPI void         elm_edje_file_cache_all_set(int size);
   EAPI int          elm_edje_collection_cache_get(void);
   EAPI void         elm_edje_collection_cache_set(int size);
   EAPI void         elm_edje_collection_cache_all_set(int size);

   /**
    * @defgroup Scaling Selective Widget Scaling
    *
    * Different widgets can be scaled independently. These functions
    * allow you to manipulate this scaling on a per-widget basis. The
    * object and all its children get their scaling factors multiplied
    * by the scale factor set. This is multiplicative, in that if a
    * child also has a scale size set it is in turn multiplied by its
    * parent's scale size. @c 1.0 means “don't scale”, @c 2.0 is
    * double size, @c 0.5 is half, etc.
    *
    * @ref general_functions_example_page "This" example contemplates
    * some of these functions.
    */

   /**
    * Set the scaling factor for a given Elementary object
    *
    * @param obj The Elementary to operate on
    * @param scale Scale factor (from @c 0.0 up, with @c 1.0 meaning
    * no scaling)
    *
    * @ingroup Scaling
    */
   EAPI void         elm_object_scale_set(Evas_Object *obj, double scale) EINA_ARG_NONNULL(1);

   /**
    * Get the scaling factor for a given Elementary object
    *
    * @param obj The object
    * @return The scaling factor set by elm_object_scale_set()
    *
    * @ingroup Scaling
    */
   EAPI double       elm_object_scale_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_object_mirrored_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_mirrored_set(Evas_Object *obj, Eina_Bool mirrored) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_object_mirrored_automatic_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_mirrored_automatic_set(Evas_Object *obj, Eina_Bool automatic) EINA_ARG_NONNULL(1);
   /**
    * Set the style to use by a widget
    *
    * Sets the style name that will define the appearance of a widget. Styles
    * vary from widget to widget and may also be defined by other themes
    * by means of extensions and overlays.
    *
    * @param obj The Elementary widget to style
    * @param style The style name to use
    *
    * @see elm_theme_extension_add()
    * @see elm_theme_overlay_add()
    *
    * @ingroup Theme
    */
   EAPI void         elm_object_style_set(Evas_Object *obj, const char *style) EINA_ARG_NONNULL(1);
   /**
    * Get the style used by the widget
    *
    * This gets the style being used for that widget. Note that the string
    * pointer is only valid as longas the object is valid and the style doesn't
    * change.
    *
    * @param obj The Elementary widget to query for its style
    * @return The style name used
    *
    * @see elm_object_style_set()
    *
    * @ingroup Theme
    */
   EAPI const char  *elm_object_style_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @defgroup Styles Styles
    *
    * Widgets can have different styles of look. These generic API's
    * set styles of widgets, if they support them (and if the theme(s)
    * do).
    *
    * @ref general_functions_example_page "This" example contemplates
    * some of these functions.
    */

   /**
    * Set the disabled state of an Elementary object.
    *
    * @param obj The Elementary object to operate on
    * @param disabled The state to put in in: @c EINA_TRUE for
    *        disabled, @c EINA_FALSE for enabled
    *
    * Elementary objects can be @b disabled, in which state they won't
    * receive input and, in general, will be themed differently from
    * their normal state, usually greyed out. Useful for contexts
    * where you don't want your users to interact with some of the
    * parts of you interface.
    *
    * This sets the state for the widget, either disabling it or
    * enabling it back.
    *
    * @ingroup Styles
    */
   EAPI void         elm_object_disabled_set(Evas_Object *obj, Eina_Bool disabled) EINA_ARG_NONNULL(1);

   /**
    * Get the disabled state of an Elementary object.
    *
    * @param obj The Elementary object to operate on
    * @return @c EINA_TRUE, if the widget is disabled, @c EINA_FALSE
    *            if it's enabled (or on errors)
    *
    * This gets the state of the widget, which might be enabled or disabled.
    *
    * @ingroup Styles
    */
   EAPI Eina_Bool    elm_object_disabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @defgroup WidgetNavigation Widget Tree Navigation.
    *
    * How to check if an Evas Object is an Elementary widget? How to
    * get the first elementary widget that is parent of the given
    * object?  These are all covered in widget tree navigation.
    *
    * @ref general_functions_example_page "This" example contemplates
    * some of these functions.
    */

   EAPI Eina_Bool    elm_object_widget_check(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the first parent of the given object that is an Elementary
    * widget.
    *
    * @param obj the Elementary object to query parent from.
    * @return the parent object that is an Elementary widget, or @c
    *         NULL, if it was not found.
    *
    * Use this to query for an object's parent widget.
    *
    * @note Most of Elementary users wouldn't be mixing non-Elementary
    * smart objects in the objects tree of an application, as this is
    * an advanced usage of Elementary with Evas. So, except for the
    * application's window, which is the root of that tree, all other
    * objects would have valid Elementary widget parents.
    *
    * @ingroup WidgetNavigation
    */
   EAPI Evas_Object *elm_object_parent_widget_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_object_top_widget_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_object_widget_type_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   EAPI double       elm_scale_get(void);
   EAPI void         elm_scale_set(double scale);
   EAPI void         elm_scale_all_set(double scale);

   EAPI Eina_Bool    elm_mirrored_get(void);
   EAPI void         elm_mirrored_set(Eina_Bool mirrored);

   EAPI Eina_Bool    elm_config_save(void);
   EAPI void         elm_config_reload(void);

   EAPI const char  *elm_profile_current_get(void);
   EAPI const char  *elm_profile_dir_get(const char *profile, Eina_Bool is_user);
   EAPI void         elm_profile_dir_free(const char *p_dir);
   EAPI Eina_List   *elm_profile_list_get(void);
   EAPI void         elm_profile_list_free(Eina_List *l);
   EAPI void         elm_profile_set(const char *profile);
   EAPI void         elm_profile_all_set(const char *profile);

   EAPI const char  *elm_engine_current_get(void);
   EAPI void         elm_engine_set(const char *engine);

  typedef struct _Elm_Text_Class
    {
       const char *name;
       const char *desc;
    } Elm_Text_Class;

  typedef struct _Elm_Font_Overlay
    {
       const char     *text_class;
       const char     *font;
       Evas_Font_Size  size;
    } Elm_Font_Overlay;

  typedef struct _Elm_Font_Properties
    {
       const char *name;
       Eina_List  *styles;
    } Elm_Font_Properties;

   EAPI const Eina_List     *elm_text_classes_list_get(void);
   EAPI void                 elm_text_classes_list_free(const Eina_List *list);

   EAPI const Eina_List     *elm_font_overlay_list_get(void);
   EAPI void                 elm_font_overlay_set(const char *text_class, const char *font, Evas_Font_Size size);
   EAPI void                 elm_font_overlay_unset(const char *text_class);
   EAPI void                 elm_font_overlay_apply(void);
   EAPI void                 elm_font_overlay_all_apply(void);

   EAPI Elm_Font_Properties *elm_font_properties_get(const char *font) EINA_ARG_NONNULL(1);
   EAPI void                 elm_font_properties_free(Elm_Font_Properties *efp) EINA_ARG_NONNULL(1);
   EAPI const char          *elm_font_fontconfig_name_get(const char *name, const char *style) EINA_ARG_NONNULL(1);
   EAPI void                 elm_font_fontconfig_name_free(const char *name) EINA_ARG_NONNULL(1);
   EAPI Eina_Hash           *elm_font_available_hash_add(Eina_List *list);
   EAPI void                 elm_font_available_hash_del(Eina_Hash *hash);

   /**
    * @defgroup Fingers Fingers
    *
    * Elementary is designed to be finger-friendly for touchscreens,
    * and so in addition to scaling for display resolution, it can
    * also scale based on finger "resolution" (or size). You can then
    * customize the granularity of the areas meant to receive clicks
    * on touchscreens.
    *
    * Different profiles may have pre-set values for finger sizes.
    *
    * @ref general_functions_example_page "This" example contemplates
    * some of these functions.
    */

   /**
    * Get the configured "finger size"
    *
    * @return The finger size
    *
    * This gets the globally configured finger size, <b>in pixels</b>
    *
    * @ingroup Fingers
    */
   EAPI Evas_Coord       elm_finger_size_get(void);
   EAPI void             elm_finger_size_set(Evas_Coord size);
   EAPI void             elm_finger_size_all_set(Evas_Coord size);

   /**
    * @defgroup Focus Focus
    *
    * An Elementary application has, at all times, one (and only one)
    * @b focused object. This is what determines where the input
    * events go to within the application's window. Also, focused
    * objects can be decorated differently, in order to signal to the
    * user where the input is, at a given moment.
    *
    * Elementary applications also have the concept of <b>focus
    * chain</b>: one can cycle through all the windows' focusable
    * objects by input (tab key) or programmatically. The default
    * focus chain for an application is the one define by the order in
    * which the widgets where added in code. One will cycle through
    * top level widgets, and, for each one containg sub-objects, cycle
    * through them all, before returning to the level
    * above. Elementary also allows one to set @b custom focus chains
    * for their applications.
    *
    * Besides the focused decoration a widget may exhibit, when it
    * gets focus, Elementary has a @b global focus highlight object
    * that can be enabled for a window. If one chooses to do so, this
    * extra highlight effect will surround the current focused object,
    * too.
    *
    * @note Some Elementary widgets are @b unfocusable, after
    * creation, by their very nature: they are not meant to be
    * interacted with input events, but are there just for visual
    * purposes.
    *
    * @ref general_functions_example_page "This" example contemplates
    * some of these functions.
    */

   EAPI Eina_Bool        elm_focus_highlight_enabled_get(void);
   EAPI void             elm_focus_highlight_enabled_set(Eina_Bool enable);
   EAPI Eina_Bool        elm_focus_highlight_animate_get(void);
   EAPI void             elm_focus_highlight_animate_set(Eina_Bool animate);

   /**
    * Get the whether an Elementary object has the focus or not.
    *
    * @param obj The Elementary object to get the information from
    * @return @c EINA_TRUE, if the object is focused, @c EINA_FALSE if
    *            not (and on errors).
    *
    * @see elm_object_focus()
    *
    * @ingroup Focus
    */
   EAPI Eina_Bool        elm_object_focus_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Make a given Elementary object the focused one.
    *
    * @param obj The Elementary object to make focused.
    *
    * @note This object, if it can handle focus, will take the focus
    * away from the one who had it previously and will, for now on, be
    * the one receiving input events.
    *
    * @see elm_object_focus_get()
    *
    * @ingroup Focus
    */
   EAPI void             elm_object_focus(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Remove the focus from an Elementary object
    *
    * @param obj The Elementary to take focus from
    *
    * This removes the focus from @p obj, passing it back to the
    * previous element in the focus chain list.
    *
    * @see elm_object_focus() and elm_object_focus_custom_chain_get()
    *
    * @ingroup Focus
    */
   EAPI void             elm_object_unfocus(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the ability for an Element object to be focused
    *
    * @param obj The Elementary object to operate on
    * @param enable @c EINA_TRUE if the object can be focused, @c
    *        EINA_FALSE if not (and on errors)
    *
    * This sets whether the object @p obj is able to take focus or
    * not. Unfocusable objects do nothing when programmatically
    * focused, being the nearest focusable parent object the one
    * really getting focus. Also, when they receive mouse input, they
    * will get the event, but not take away the focus from where it
    * was previously.
    *
    * @ingroup Focus
    */
   EAPI void             elm_object_focus_allow_set(Evas_Object *obj, Eina_Bool enable) EINA_ARG_NONNULL(1);

   /**
    * Get whether an Elementary object is focusable or not
    *
    * @param obj The Elementary object to operate on
    * @return @c EINA_TRUE if the object is allowed to be focused, @c
    *             EINA_FALSE if not (and on errors)
    *
    * @note Objects which are meant to be interacted with by input
    * events are created able to be focused, by default. All the
    * others are not.
    *
    * @ingroup Focus
    */
   EAPI Eina_Bool        elm_object_focus_allow_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   EAPI void             elm_object_focus_custom_chain_set(Evas_Object *obj, Eina_List *objs) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_focus_custom_chain_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List *elm_object_focus_custom_chain_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_focus_custom_chain_append(Evas_Object *obj, Evas_Object *child, Evas_Object *relative_child) EINA_ARG_NONNULL(1, 2);
   EAPI void             elm_object_focus_custom_chain_prepend(Evas_Object *obj, Evas_Object *child, Evas_Object *relative_child) EINA_ARG_NONNULL(1, 2);
   EAPI void             elm_object_focus_cycle(Evas_Object *obj, Elm_Focus_Direction dir) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_focus_direction_go(Evas_Object *obj, int x, int y) EINA_ARG_NONNULL(1);

   EAPI Eina_Bool        elm_scroll_bounce_enabled_get(void);
   EAPI void             elm_scroll_bounce_enabled_set(Eina_Bool enabled);
   EAPI void             elm_scroll_bounce_enabled_all_set(Eina_Bool enabled);
   EAPI double           elm_scroll_bounce_friction_get(void);
   EAPI void             elm_scroll_bounce_friction_set(double friction);
   EAPI void             elm_scroll_bounce_friction_all_set(double friction);
   EAPI double           elm_scroll_page_scroll_friction_get(void);
   EAPI void             elm_scroll_page_scroll_friction_set(double friction);
   EAPI void             elm_scroll_page_scroll_friction_all_set(double friction);
   EAPI double           elm_scroll_bring_in_scroll_friction_get(void);
   EAPI void             elm_scroll_bring_in_scroll_friction_set(double friction);
   EAPI void             elm_scroll_bring_in_scroll_friction_all_set(double friction);
   EAPI double           elm_scroll_zoom_friction_get(void);
   EAPI void             elm_scroll_zoom_friction_set(double friction);
   EAPI void             elm_scroll_zoom_friction_all_set(double friction);
   EAPI Eina_Bool        elm_scroll_thumbscroll_enabled_get(void);
   EAPI void             elm_scroll_thumbscroll_enabled_set(Eina_Bool enabled);
   EAPI void             elm_scroll_thumbscroll_enabled_all_set(Eina_Bool enabled);
   EAPI unsigned int     elm_scroll_thumbscroll_threshold_get(void);
   EAPI void             elm_scroll_thumbscroll_threshold_set(unsigned int threshold);
   EAPI void             elm_scroll_thumbscroll_threshold_all_set(unsigned int threshold);
   EAPI double           elm_scroll_thumbscroll_momentum_threshold_get(void);
   EAPI void             elm_scroll_thumbscroll_momentum_threshold_set(double threshold);
   EAPI void             elm_scroll_thumbscroll_momentum_threshold_all_set(double threshold);
   EAPI double           elm_scroll_thumbscroll_friction_get(void);
   EAPI void             elm_scroll_thumbscroll_friction_set(double friction);
   EAPI void             elm_scroll_thumbscroll_friction_all_set(double friction);
   EAPI double           elm_scroll_thumbscroll_border_friction_get(void);
   EAPI void             elm_scroll_thumbscroll_border_friction_set(double friction);
   EAPI void             elm_scroll_thumbscroll_border_friction_all_set(double friction);

   EAPI void             elm_object_scroll_hold_push(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_scroll_hold_pop(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_scroll_freeze_push(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_scroll_freeze_pop(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_scroll_lock_x_set(Evas_Object *obj, Eina_Bool lock) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_scroll_lock_y_set(Evas_Object *obj, Eina_Bool lock) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_object_scroll_lock_x_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_object_scroll_lock_y_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   EAPI void             elm_object_signal_emit(Evas_Object *obj, const char *emission, const char *source) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_signal_callback_add(Evas_Object *obj, const char *emission, const char *source, Edje_Signal_Cb func, void *data) EINA_ARG_NONNULL(1, 4);
   EAPI void            *elm_object_signal_callback_del(Evas_Object *obj, const char *emission, const char *source, Edje_Signal_Cb func) EINA_ARG_NONNULL(1, 4);

   EAPI void             elm_object_event_callback_add(Evas_Object *obj, Elm_Event_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);
   EAPI void            *elm_object_event_callback_del(Evas_Object *obj, Elm_Event_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);

   /**
    * Adjust size of an element for finger usage.
    *
    * @param times_w How many fingers should fit horizontally
    * @param w Pointer to the width size to adjust
    * @param times_h How many fingers should fit vertically
    * @param h Pointer to the height size to adjust
    *
    * This takes width and height sizes (in pixels) as input and a
    * size multiple (which is how many fingers you want to place
    * within the area, being "finger" the size set by
    * elm_finger_size_set()), and adjusts the size to be large enough
    * to accommodate the resulting size -- if it doesn't already
    * accommodate it. On return the @p w and @p h sizes pointed to by
    * these parameters will be modified, on those conditions.
    *
    * @note This is kind of a low level Elementary call, most useful
    * on size evaluation times for widgets. An external user wouldn't
    * be calling, most of the time.
    *
    * @ingroup Fingers
    */
   EAPI void             elm_coords_finger_size_adjust(int times_w, Evas_Coord *w, int times_h, Evas_Coord *h);

   EAPI double           elm_longpress_timeout_get(void);
   EAPI void             elm_longpress_timeout_set(double longpress_timeout);

   /* debug
    * don't use it unless you are sure
    */
   EAPI void             elm_object_tree_dump(const Evas_Object *top);
   EAPI void             elm_object_tree_dot_dump(const Evas_Object *top, const char *file);


   /* theme */
   /**
    * @defgroup Theme Theme
    *
    * Elementary uses Edje to theme its widgets, naturally. But for the most
    * part this is hidden behind a simpler interface that lets the user set
    * extensions and choose the style of widgets in a much easier way.
    *
    * Instead of thinking in terms of paths to Edje files and their groups
    * each time you want to change the appearance of a widget, Elementary
    * works so you can add any theme file with extensions or replace the
    * main theme at one point in the application, and then just set the style
    * of widgets with elm_object_style_set() and related functions. Elementary
    * will then look in its list of themes for a matching group and apply it,
    * and when the theme changes midway through the application, all widgets
    * will be updated accordingly.
    *
    * There are three concepts you need to know to understand how Elementary
    * theming works: default theme, extensions and overlays.
    *
    * Default theme, obviously enough, is the one that provides the default
    * look of all widgets. End users can change the theme used by Elementary
    * by setting the @c ELM_THEME environment variable before running an
    * application, or globally for all programs using the @c elementary_config
    * utility. Applications can change the default theme using elm_theme_set(),
    * but this can go against the user wishes, so it's not an adviced practice.
    *
    * Ideally, applications should find everything they need in the already
    * provided theme, but there may be occasions when that's not enough and
    * custom styles are required to correctly express the idea. For this
    * cases, Elementary has extensions.
    *
    * Extensions allow the application developer to write styles of its own
    * to apply to some widgets. This requires knowledge of how each widget
    * is themed, as extensions will always replace the entire group used by
    * the widget, so important signals and parts need to be there for the
    * object to behave properly (see documentation of Edje for details).
    * Once the theme for the extension is done, the application needs to add
    * it to the list of themes Elementary will look into, using
    * elm_theme_extension_add(), and set the style of the desired widgets as
    * he would normally with elm_object_style_set().
    *
    * Overlays, on the other hand, can replace the look of all widgets by
    * overriding the default style. Like extensions, it's up to the application
    * developer to write the theme for the widgets it wants, the difference
    * being that when looking for the theme, Elementary will check first the
    * list of overlays, then the set theme and lastly the list of extensions,
    * so with overlays it's possible to replace the default view and every
    * widget will be affected. This is very much alike to setting the whole
    * theme for the application and will probably clash with the end user
    * options, not to mention the risk of ending up with not matching styles
    * across the program. Unless there's a very special reason to use them,
    * overlays should be avoided for the resons exposed before.
    *
    * All these theme lists are handled by ::Elm_Theme instances. Elementary
    * keeps one default internally and every function that receives one of
    * these can be called with NULL to refer to this default (except for
    * elm_theme_free()). It's possible to create a new instance of a
    * ::Elm_Theme to set other theme for a specific widget (and all of its
    * children), but this is as discouraged, if not even more so, than using
    * overlays. Don't use this unless you really know what you are doing.
    *
    * But to be less negative about things, you can look at the following
    * examples:
    * @li @ref theme_example_01 "Using extensions"
    * @li @ref theme_example_02 "Using overlays"
    *
    * @{
    */
   /**
    * @typedef Elm_Theme
    *
    * Opaque handler for the list of themes Elementary looks for when
    * rendering widgets.
    *
    * Stay out of this unless you really know what you are doing. For most
    * cases, sticking to the default is all a developer needs.
    */
   typedef struct _Elm_Theme Elm_Theme;

   /**
    * Create a new specific theme
    *
    * This creates an empty specific theme that only uses the default theme. A
    * specific theme has its own private set of extensions and overlays too
    * (which are empty by default). Specific themes do not fall back to themes
    * of parent objects. They are not intended for this use. Use styles, overlays
    * and extensions when needed, but avoid specific themes unless there is no
    * other way (example: you want to have a preview of a new theme you are
    * selecting in a "theme selector" window. The preview is inside a scroller
    * and should display what the theme you selected will look like, but not
    * actually apply it yet. The child of the scroller will have a specific
    * theme set to show this preview before the user decides to apply it to all
    * applications).
    */
   EAPI Elm_Theme       *elm_theme_new(void);
   /**
    * Free a specific theme
    *
    * @param th The theme to free
    *
    * This frees a theme created with elm_theme_new().
    */
   EAPI void             elm_theme_free(Elm_Theme *th);
   /**
    * Copy the theme fom the source to the destination theme
    *
    * @param th The source theme to copy from
    * @param thdst The destination theme to copy data to
    *
    * This makes a one-time static copy of all the theme config, extensions
    * and overlays from @p th to @p thdst. If @p th references a theme, then
    * @p thdst is also set to reference it, with all the theme settings,
    * overlays and extensions that @p th had.
    */
   EAPI void             elm_theme_copy(Elm_Theme *th, Elm_Theme *thdst);
   /**
    * Tell the source theme to reference the ref theme
    *
    * @param th The theme that will do the referencing
    * @param thref The theme that is the reference source
    *
    * This clears @p th to be empty and then sets it to refer to @p thref
    * so @p th acts as an override to @p thref, but where its overrides
    * don't apply, it will fall through to @pthref for configuration.
    */
   EAPI void             elm_theme_ref_set(Elm_Theme *th, Elm_Theme *thref);
   /**
    * Return the theme referred to
    *
    * @param th The theme to get the reference from
    * @return The referenced theme handle
    *
    * This gets the theme set as the reference theme by elm_theme_ref_set().
    * If no theme is set as a reference, NULL is returned.
    */
   EAPI Elm_Theme       *elm_theme_ref_get(Elm_Theme *th);
   /**
    * Return the default theme
    *
    * @return The default theme handle
    *
    * This returns the internal default theme setup handle that all widgets
    * use implicitly unless a specific theme is set. This is also often use
    * as a shorthand of NULL.
    */
   EAPI Elm_Theme       *elm_theme_default_get(void);
   /**
    * Prepends a theme overlay to the list of overlays
    *
    * @param th The theme to add to, or if NULL, the default theme
    * @param item The Edje file path to be used
    *
    * Use this if your application needs to provide some custom overlay theme
    * (An Edje file that replaces some default styles of widgets) where adding
    * new styles, or changing system theme configuration is not possible. Do
    * NOT use this instead of a proper system theme configuration. Use proper
    * configuration files, profiles, environment variables etc. to set a theme
    * so that the theme can be altered by simple confiugration by a user. Using
    * this call to achieve that effect is abusing the API and will create lots
    * of trouble.
    *
    * @see elm_theme_extension_add()
    */
   EAPI void             elm_theme_overlay_add(Elm_Theme *th, const char *item);
   /**
    * Delete a theme overlay from the list of overlays
    *
    * @param th The theme to delete from, or if NULL, the default theme
    * @param item The name of the theme overlay
    *
    * @see elm_theme_overlay_add()
    */
   EAPI void             elm_theme_overlay_del(Elm_Theme *th, const char *item);
   /**
    * Appends a theme extension to the list of extensions.
    *
    * @param th The theme to add to, or if NULL, the default theme
    * @param item The Edje file path to be used
    *
    * This is intended when an application needs more styles of widgets or new
    * widget themes that the default does not provide (or may not provide). The
    * application has "extended" usage by coming up with new custom style names
    * for widgets for specific uses, but as these are not "standard", they are
    * not guaranteed to be provided by a default theme. This means the
    * application is required to provide these extra elements itself in specific
    * Edje files. This call adds one of those Edje files to the theme search
    * path to be search after the default theme. The use of this call is
    * encouraged when default styles do not meet the needs of the application.
    * Use this call instead of elm_theme_overlay_add() for almost all cases.
    *
    * @see elm_object_style_set()
    */
   EAPI void             elm_theme_extension_add(Elm_Theme *th, const char *item);
   /**
    * Deletes a theme extension from the list of extensions.
    *
    * @param th The theme to delete from, or if NULL, the default theme
    * @param item The name of the theme extension
    *
    * @see elm_theme_extension_add()
    */
   EAPI void             elm_theme_extension_del(Elm_Theme *th, const char *item);
   /**
    * Set the theme search order for the given theme
    *
    * @param th The theme to set the search order, or if NULL, the default theme
    * @param theme Theme search string
    *
    * This sets the search string for the theme in path-notation from first
    * theme to search, to last, delimited by the : character. Example:
    *
    * "shiny:/path/to/file.edj:default"
    *
    * See the ELM_THEME environment variable for more information.
    *
    * @see elm_theme_get()
    * @see elm_theme_list_get()
    */
   EAPI void             elm_theme_set(Elm_Theme *th, const char *theme);
   /**
    * Return the theme search order
    *
    * @param th The theme to get the search order, or if NULL, the default theme
    * @return The internal search order path
    *
    * This function returns a colon separated string of theme elements as
    * returned by elm_theme_list_get().
    *
    * @see elm_theme_set()
    * @see elm_theme_list_get()
    */
   EAPI const char      *elm_theme_get(Elm_Theme *th);
   /**
    * Return a list of theme elements to be used in a theme.
    *
    * @param th Theme to get the list of theme elements from.
    * @return The internal list of theme elements
    *
    * This returns the internal list of theme elements (will only be valid as
    * long as the theme is not modified by elm_theme_set() or theme is not
    * freed by elm_theme_free(). This is a list of strings which must not be
    * altered as they are also internal. If @p th is NULL, then the default
    * theme element list is returned.
    *
    * A theme element can consist of a full or relative path to a .edj file,
    * or a name, without extension, for a theme to be searched in the known
    * theme paths for Elemementary.
    *
    * @see elm_theme_set()
    * @see elm_theme_get()
    */
   EAPI const Eina_List *elm_theme_list_get(const Elm_Theme *th);
   /**
    * Return the full patrh for a theme element
    *
    * @param f The theme element name
    * @param in_search_path Pointer to a boolean to indicate if item is in the search path or not
    * @return The full path to the file found.
    *
    * This returns a string you should free with free() on success, NULL on
    * failure. This will search for the given theme element, and if it is a
    * full or relative path element or a simple searchable name. The returned
    * path is the full path to the file, if searched, and the file exists, or it
    * is simply the full path given in the element or a resolved path if
    * relative to home. The @p in_search_path boolean pointed to is set to
    * EINA_TRUE if the file was a searchable file andis in the search path,
    * and EINA_FALSE otherwise.
    */
   EAPI char            *elm_theme_list_item_path_get(const char *f, Eina_Bool *in_search_path);
   /**
    * Flush the current theme.
    *
    * @param th Theme to flush
    *
    * This flushes caches that let elementary know where to find theme elements
    * in the given theme. If @p th is NULL, then the default theme is flushed.
    * Call this function if source theme data has changed in such a way as to
    * make any caches Elementary kept invalid.
    */
   EAPI void             elm_theme_flush(Elm_Theme *th);
   /**
    * This flushes all themes (default and specific ones).
    *
    * This will flush all themes in the current application context, by calling
    * elm_theme_flush() on each of them.
    */
   EAPI void             elm_theme_full_flush(void);
   /**
    * Set the theme for all elementary using applications on the current display
    *
    * @param theme The name of the theme to use. Format same as the ELM_THEME
    * environment variable.
    */
   EAPI void             elm_theme_all_set(const char *theme);
   /**
    * Return a list of theme elements in the theme search path
    *
    * @return A list of strings that are the theme element names.
    *
    * This lists all available theme files in the standard Elementary search path
    * for theme elements, and returns them in alphabetical order as theme
    * element names in a list of strings. Free this with
    * elm_theme_name_available_list_free() when you are done with the list.
    */
   EAPI Eina_List       *elm_theme_name_available_list_new(void);
   /**
    * Free the list returned by elm_theme_name_available_list_new()
    *
    * This frees the list of themes returned by
    * elm_theme_name_available_list_new(). Once freed the list should no longer
    * be used. a new list mys be created.
    */
   EAPI void             elm_theme_name_available_list_free(Eina_List *list);
   /**
    * Set a specific theme to be used for this object and its children
    *
    * @param obj The object to set the theme on
    * @param th The theme to set
    *
    * This sets a specific theme that will be used for the given object and any
    * child objects it has. If @p th is NULL then the theme to be used is
    * cleared and the object will inherit its theme from its parent (which
    * ultimately will use the default theme if no specific themes are set).
    *
    * Use special themes with great care as this will annoy users and make
    * configuration difficult. Avoid any custom themes at all if it can be
    * helped.
    */
   EAPI void             elm_object_theme_set(Evas_Object *obj, Elm_Theme *th) EINA_ARG_NONNULL(1);
   /**
    * Get the specific theme to be used
    *
    * @param obj The object to get the specific theme from
    * @return The specifc theme set.
    *
    * This will return a specific theme set, or NULL if no specific theme is
    * set on that object. It will not return inherited themes from parents, only
    * the specific theme set for that specific object. See elm_object_theme_set()
    * for more information.
    */
   EAPI Elm_Theme       *elm_object_theme_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* win */
   typedef enum _Elm_Win_Type
     {
        ELM_WIN_BASIC,
        ELM_WIN_DIALOG_BASIC,
        ELM_WIN_DESKTOP,
        ELM_WIN_DOCK,
        ELM_WIN_TOOLBAR,
        ELM_WIN_MENU,
        ELM_WIN_UTILITY,
        ELM_WIN_SPLASH,
        ELM_WIN_DROPDOWN_MENU,
        ELM_WIN_POPUP_MENU,
        ELM_WIN_TOOLTIP,
        ELM_WIN_NOTIFICATION,
        ELM_WIN_COMBO,
        ELM_WIN_DND,
        ELM_WIN_INLINED_IMAGE,
     } Elm_Win_Type;

   typedef enum _Elm_Win_Keyboard_Mode
     {
        ELM_WIN_KEYBOARD_UNKNOWN,
        ELM_WIN_KEYBOARD_OFF,
        ELM_WIN_KEYBOARD_ON,
        ELM_WIN_KEYBOARD_ALPHA,
        ELM_WIN_KEYBOARD_NUMERIC,
        ELM_WIN_KEYBOARD_PIN,
        ELM_WIN_KEYBOARD_PHONE_NUMBER,
        ELM_WIN_KEYBOARD_HEX,
        ELM_WIN_KEYBOARD_TERMINAL,
        ELM_WIN_KEYBOARD_PASSWORD,
        ELM_WIN_KEYBOARD_IP,
        ELM_WIN_KEYBOARD_HOST,
        ELM_WIN_KEYBOARD_FILE,
        ELM_WIN_KEYBOARD_URL,
        ELM_WIN_KEYBOARD_KEYPAD,
        ELM_WIN_KEYBOARD_J2ME
     } Elm_Win_Keyboard_Mode;

   typedef enum _Elm_Illume_Command
     {
        ELM_ILLUME_COMMAND_FOCUS_BACK,
        ELM_ILLUME_COMMAND_FOCUS_FORWARD,
        ELM_ILLUME_COMMAND_FOCUS_HOME,
        ELM_ILLUME_COMMAND_CLOSE
     } Elm_Illume_Command;

   EAPI Evas_Object *elm_win_add(Evas_Object *parent, const char *name, Elm_Win_Type type);
   EAPI void         elm_win_resize_object_add(Evas_Object *obj, Evas_Object *subobj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_resize_object_del(Evas_Object *obj, Evas_Object *subobj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_title_set(Evas_Object *obj, const char *title) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_win_title_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_autodel_set(Evas_Object *obj, Eina_Bool autodel) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_autodel_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_activate(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_lower(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_raise(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_borderless_set(Evas_Object *obj, Eina_Bool borderless) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_borderless_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_shaped_set(Evas_Object *obj, Eina_Bool shaped) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_shaped_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_alpha_set(Evas_Object *obj, Eina_Bool alpha) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_transparent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_transparent_set(Evas_Object *obj, Eina_Bool transparent) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_alpha_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_override_set(Evas_Object *obj, Eina_Bool override) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_override_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_fullscreen_set(Evas_Object *obj, Eina_Bool fullscreen) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_fullscreen_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_maximized_set(Evas_Object *obj, Eina_Bool maximized) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_maximized_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_iconified_set(Evas_Object *obj, Eina_Bool iconified) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_iconified_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_layer_set(Evas_Object *obj, int layer) EINA_ARG_NONNULL(1);
   EAPI int          elm_win_layer_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_rotation_set(Evas_Object *obj, int rotation) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_rotation_with_resize_set(Evas_Object *obj, int rotation) EINA_ARG_NONNULL(1);
   EAPI int          elm_win_rotation_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_sticky_set(Evas_Object *obj, Eina_Bool sticky) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_sticky_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_conformant_set(Evas_Object *obj, Eina_Bool conformant) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_conformant_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_quickpanel_set(Evas_Object *obj, Eina_Bool quickpanel) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_quickpanel_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_quickpanel_priority_major_set(Evas_Object *obj, int priority) EINA_ARG_NONNULL(1);
   EAPI int          elm_win_quickpanel_priority_major_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_quickpanel_priority_minor_set(Evas_Object *obj, int priority) EINA_ARG_NONNULL(1);
   EAPI int          elm_win_quickpanel_priority_minor_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_quickpanel_zone_set(Evas_Object *obj, int zone) EINA_ARG_NONNULL(1);
   EAPI int          elm_win_quickpanel_zone_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_prop_focus_skip_set(Evas_Object *obj, Eina_Bool skip) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_illume_command_send(Evas_Object *obj, Elm_Illume_Command command, void *params) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_win_inlined_image_object_get(Evas_Object *obj);
   EAPI void         elm_win_focus_highlight_enabled_set(Evas_Object *obj, Eina_Bool enabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_focus_highlight_enabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_focus_highlight_style_set(Evas_Object *obj, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_win_focus_highlight_style_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /*...
    * ecore_x_icccm_hints_set -> accepts_focus (add to ecore_evas)
    * ecore_x_icccm_hints_set -> window_group (add to ecore_evas)
    * ecore_x_icccm_size_pos_hints_set -> request_pos (add to ecore_evas)
    * ecore_x_icccm_client_leader_set -> l (add to ecore_evas)
    * ecore_x_icccm_window_role_set -> role (add to ecore_evas)
    * ecore_x_icccm_transient_for_set -> forwin (add to ecore_evas)
    * ecore_x_netwm_window_type_set -> type (add to ecore_evas)
    *
    * (add to ecore_x) set netwm argb icon! (add to ecore_evas)
    * (blank mouse, private mouse obj, defaultmouse)
    *
    */
   EAPI void                  elm_win_keyboard_mode_set(Evas_Object *obj, Elm_Win_Keyboard_Mode mode) EINA_ARG_NONNULL(1);
   EAPI Elm_Win_Keyboard_Mode elm_win_keyboard_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_win_keyboard_win_set(Evas_Object *obj, Eina_Bool is_keyboard) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_win_keyboard_win_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   EAPI void                  elm_win_screen_position_get(const Evas_Object *obj, int *x, int *y) EINA_ARG_NONNULL(1);

   EAPI Evas_Object          *elm_win_inwin_add(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_win_inwin_activate(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_win_inwin_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_win_inwin_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_win_inwin_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* available styles:
    * default
    * minimal
    * minimal_vertical
    */
   /* X specific calls - won't work on non-x engines (return 0) */
   EAPI Ecore_X_Window elm_win_xwindow_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "delete,request" - the user requested to delete the window
    * "focus,in" - window got focus
    * "focus,out" - window lost focus
    * "moved" - window that holds the canvas was moved
    */

   /**
    * @defgroup Bg Bg
    *
    * @image html img/icon/bg/preview-00.png
    * @image latex img/icon/bg/preview-00.png
    *
    * @brief Background object, used for setting a solid color, image or Edje
    * group as background to a window or any container object.
    *
    * The bg object is used for setting a solid background to a window or
    * packing into any container object. It works just like an image, but has
    * some properties useful to a background, like setting it to tiled,
    * centered, scaled or stretched.
    *
    * Here is some sample code using it:
    * @li @ref bg_01_example_page
    * @li @ref bg_02_example_page
    * @li @ref bg_03_example_page
    */

   /* bg */
   typedef enum _Elm_Bg_Option
     {
        ELM_BG_OPTION_CENTER,  /**< center the background */
        ELM_BG_OPTION_SCALE,   /**< scale the background retaining aspect ratio */
        ELM_BG_OPTION_STRETCH, /**< stretch the background to fill */
        ELM_BG_OPTION_TILE     /**< tile background at its original size */
     } Elm_Bg_Option;

   /**
    * Add a new background to the parent
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    *
    * @ingroup Bg
    */
   EAPI Evas_Object  *elm_bg_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Set the file (image or edje) used for the background
    *
    * @param obj The bg object
    * @param file The file path
    * @param group Optional key (group in Edje) within the file
    *
    * This sets the image file used in the background object. The image (or edje)
    * will be stretched (retaining aspect if its an image file) to completely fill
    * the bg object. This may mean some parts are not visible.
    *
    * @note  Once the image of @p obj is set, a previously set one will be deleted,
    * even if @p file is NULL.
    *
    * @ingroup Bg
    */
   EAPI void          elm_bg_file_set(Evas_Object *obj, const char *file, const char *group) EINA_ARG_NONNULL(1);

   /**
    * Get the file (image or edje) used for the background
    *
    * @param obj The bg object
    * @param file The file path
    * @param group Optional key (group in Edje) within the file
    *
    * @ingroup Bg
    */
   EAPI void          elm_bg_file_get(const Evas_Object *obj, const char **file, const char **group) EINA_ARG_NONNULL(1);

   /**
    * Set the option used for the background image
    *
    * @param obj The bg object
    * @param option The desired background option (TILE, SCALE)
    *
    * This sets the option used for manipulating the display of the background
    * image. The image can be tiled or scaled.
    *
    * @ingroup Bg
    */
   EAPI void          elm_bg_option_set(Evas_Object *obj, Elm_Bg_Option option) EINA_ARG_NONNULL(1);

   /**
    * Get the option used for the background image
    *
    * @param obj The bg object
    * @return The desired background option (CENTER, SCALE, STRETCH or TILE)
    *
    * @ingroup Bg
    */
   EAPI Elm_Bg_Option elm_bg_option_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the option used for the background color
    *
    * @param obj The bg object
    * @param r
    * @param g
    * @param b
    *
    * This sets the color used for the background rectangle. Its range goes
    * from 0 to 255.
    *
    * @ingroup Bg
    */
   EAPI void          elm_bg_color_set(Evas_Object *obj, int r, int g, int b) EINA_ARG_NONNULL(1);
   /**
    * Get the option used for the background color
    *
    * @param obj The bg object
    * @param r
    * @param g
    * @param b
    *
    * @ingroup Bg
    */
   EAPI void          elm_bg_color_get(const Evas_Object *obj, int *r, int *g, int *b) EINA_ARG_NONNULL(1);

   /**
    * Set the overlay object used for the background object.
    *
    * @param obj The bg object
    * @param overlay The overlay object
    *
    * This provides a way for elm_bg to have an 'overlay' that will be on top
    * of the bg. Once the over object is set, a previously set one will be
    * deleted, even if you set the new one to NULL. If you want to keep that
    * old content object, use the elm_bg_overlay_unset() function.
    *
    * @ingroup Bg
    */

   EAPI void          elm_bg_overlay_set(Evas_Object *obj, Evas_Object *overlay) EINA_ARG_NONNULL(1);

   /**
    * Get the overlay object used for the background object.
    *
    * @param obj The bg object
    * @return The content that is being used
    *
    * Return the content object which is set for this widget
    *
    * @ingroup Bg
    */
   EAPI Evas_Object  *elm_bg_overlay_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the overlay object used for the background object.
    *
    * @param obj The bg object
    * @return The content that was being used
    *
    * Unparent and return the overlay object which was set for this widget
    *
    * @ingroup Bg
    */
   EAPI Evas_Object  *elm_bg_overlay_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the size of the pixmap representation of the image.
    *
    * This option just makes sense if an image is going to be set in the bg.
    *
    * @param obj The bg object
    * @param w The new width of the image pixmap representation.
    * @param h The new height of the image pixmap representation.
    *
    * This function sets a new size for pixmap representation of the given bg
    * image. It allows the image to be loaded already in the specified size,
    * reducing the memory usage and load time when loading a big image with load
    * size set to a smaller size.
    *
    * NOTE: this is just a hint, the real size of the pixmap may differ
    * depending on the type of image being loaded, being bigger than requested.
    *
    * @ingroup Bg
    */
   EAPI void          elm_bg_load_size_set(Evas_Object *obj, Evas_Coord w, Evas_Coord h) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    */

   /**
    * @defgroup Icon Icon
    *
    * @image html img/icon/button/preview-00.png
    * @image latex img/icon/button/preview-00.png
    *
    * An object that provides standard icon images (delete, edit, arrows, etc.)
    * or a custom file (PNG, JPG, EDJE, etc.) used for an icon.
    *
    * The icon image requested can be in the elementary theme, or in the
    * freedesktop.org paths. It's possible to set the order of preference from
    * where the image will be used.
    *
    * This API is very similar to @ref Image, but with ready to use images.
    *
    * Default images provided by the theme are described below.
    *
    * The first list contains icons that were first intended to be used in
    * toolbars, but can be used in many other places too:
    * @li home
    * @li close
    * @li apps
    * @li arrow_up
    * @li arrow_down
    * @li arrow_left
    * @li arrow_right
    * @li chat
    * @li clock
    * @li delete
    * @li edit
    * @li refresh
    * @li folder
    * @li file
    *
    * Now some icons that were designed to be used in menus (but again, you can
    * use them anywhere else):
    * @li menu/home
    * @li menu/close
    * @li menu/apps
    * @li menu/arrow_up
    * @li menu/arrow_down
    * @li menu/arrow_left
    * @li menu/arrow_right
    * @li menu/chat
    * @li menu/clock
    * @li menu/delete
    * @li menu/edit
    * @li menu/refresh
    * @li menu/folder
    * @li menu/file
    *
    * And here we have some media player specific icons:
    * @li media_player/forward
    * @li media_player/info
    * @li media_player/next
    * @li media_player/pause
    * @li media_player/play
    * @li media_player/prev
    * @li media_player/rewind
    * @li media_player/stop
    *
    * Signals that you can add callbacks for are:
    *
    * "clicked" - This is called when a user has clicked the icon
    *
    * An example of usage for this API follows:
    * @li @ref tutorial_icon
    */

   /**
    * @addtogroup Icon
    * @{
    */

   typedef enum _Elm_Icon_Type
     {
        ELM_ICON_NONE,
        ELM_ICON_FILE,
        ELM_ICON_STANDARD
     } Elm_Icon_Type;
   /**
    * @enum _Elm_Icon_Lookup_Order
    * @typedef Elm_Icon_Lookup_Order
    *
    * Lookup order used by elm_icon_standard_set(). Should look for icons in the
    * theme, FDO paths, or both?
    *
    * @ingroup Icon
    */
   typedef enum _Elm_Icon_Lookup_Order
     {
        ELM_ICON_LOOKUP_FDO_THEME, /**< icon look up order: freedesktop, theme */
        ELM_ICON_LOOKUP_THEME_FDO, /**< icon look up order: theme, freedesktop */
        ELM_ICON_LOOKUP_FDO,       /**< icon look up order: freedesktop */
        ELM_ICON_LOOKUP_THEME      /**< icon look up order: theme */
     } Elm_Icon_Lookup_Order;

   /**
    * Add a new icon object to the parent.
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    *
    * @see elm_icon_file_set()
    *
    * @ingroup Icon
    */
   EAPI Evas_Object          *elm_icon_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the file that will be used as icon.
    *
    * @param obj The icon object
    * @param file The path to file that will be used as icon image
    * @param group The group that the icon belongs to in edje file
    *
    * @return (@c EINA_TRUE = success, @c EINA_FALSE = error)
    *
    * @note The icon image set by this function can be changed by
    * elm_icon_standard_set().
    *
    * @see elm_icon_file_get()
    *
    * @ingroup Icon
    */
   EAPI Eina_Bool             elm_icon_file_set(Evas_Object *obj, const char *file, const char *group) EINA_ARG_NONNULL(1, 2);
   /**
    * Set a location in memory to be used as an icon
    *
    * @param obj The icon object
    * @param img The binary data that will be used as an image
    * @param size The size of binary data @p img
    * @param format Optional format of @p img to pass to the image loader
    * @param key Optional key of @p img to pass to the image loader (eg. if @p img is an edje file)
    *
    * @return (@c EINA_TRUE = success, @c EINA_FALSE = error)
    *
    * @note The icon image set by this function can be changed by
    * elm_icon_standard_set().
    *
    * @ingroup Icon
    */
   EAPI Eina_Bool             elm_icon_memfile_set(Evas_Object *obj, const void *img, size_t size, const char *format, const char *key);  EINA_ARG_NONNULL(1, 2);
   /**
    * Get the file that will be used as icon.
    *
    * @param obj The icon object
    * @param file The path to file that will be used as icon icon image
    * @param group The group that the icon belongs to in edje file
    *
    * @see elm_icon_file_set()
    *
    * @ingroup Icon
    */
   EAPI void                  elm_icon_file_get(const Evas_Object *obj, const char **file, const char **group) EINA_ARG_NONNULL(1);
   EAPI void                  elm_icon_thumb_set(const Evas_Object *obj, const char *file, const char *group) EINA_ARG_NONNULL(1, 2);
   /**
    * Set the icon by icon standards names.
    *
    * @param obj The icon object
    * @param name The icon name
    *
    * @return (@c EINA_TRUE = success, @c EINA_FALSE = error)
    *
    * For example, freedesktop.org defines standard icon names such as "home",
    * "network", etc. There can be different icon sets to match those icon
    * keys. The @p name given as parameter is one of these "keys", and will be
    * used to look in the freedesktop.org paths and elementary theme. One can
    * change the lookup order with elm_icon_order_lookup_set().
    *
    * If name is not found in any of the expected locations and it is the
    * absolute path of an image file, this image will be used.
    *
    * @note The icon image set by this function can be changed by
    * elm_icon_file_set().
    *
    * @see elm_icon_standard_get()
    * @see elm_icon_file_set()
    *
    * @ingroup Icon
    */
   EAPI Eina_Bool             elm_icon_standard_set(Evas_Object *obj, const char *name) EINA_ARG_NONNULL(1);
   /**
    * Get the icon name set by icon standard names.
    *
    * @param obj The icon object
    * @return The icon name
    *
    * If the icon image was set using elm_icon_file_set() instead of
    * elm_icon_standard_set(), then this function will return @c NULL.
    *
    * @see elm_icon_standard_set()
    *
    * @ingroup Icon
    */
   EAPI const char           *elm_icon_standard_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the smooth effect for an icon object.
    *
    * @param obj The icon object
    * @param smooth @c EINA_TRUE if smooth scaling should be used, @c EINA_FALSE
    * otherwise. Default is @c EINA_TRUE.
    *
    * Set the scaling algorithm to be used when scaling the icon image. Smooth
    * scaling provides a better resulting image, but is slower.
    *
    * The smooth scaling should be disabled when making animations that change
    * the icon size, since they will be faster. Animations that don't require
    * resizing of the icon can keep the smooth scaling enabled (even if the icon
    * is already scaled, since the scaled icon image will be cached).
    *
    * @see elm_icon_smooth_get()
    *
    * @ingroup Icon
    */
   EAPI void                  elm_icon_smooth_set(Evas_Object *obj, Eina_Bool smooth) EINA_ARG_NONNULL(1);
   /**
    * Get the smooth effect for an icon object.
    *
    * @param obj The icon object
    * @return @c EINA_TRUE if smooth scaling is enabled, @c EINA_FALSE otherwise.
    *
    * @see elm_icon_smooth_set()
    *
    * @ingroup Icon
    */
   EAPI Eina_Bool             elm_icon_smooth_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Disable scaling of this object.
    *
    * @param obj The icon object.
    * @param no_scale @c EINA_TRUE if the object is not scalable, @c EINA_FALSE
    * otherwise. Default is @c EINA_FALSE.
    *
    * This function disables scaling of the icon object through the function
    * elm_object_scale_set(). However, this does not affect the object
    * size/resize in any way. For that effect, take a look at
    * elm_icon_scale_set().
    *
    * @see elm_icon_no_scale_get()
    * @see elm_icon_scale_set()
    * @see elm_object_scale_set()
    *
    * @ingroup Icon
    */
   EAPI void                  elm_icon_no_scale_set(Evas_Object *obj, Eina_Bool no_scale) EINA_ARG_NONNULL(1);
   /**
    * Get whether scaling is disabled on the object.
    *
    * @param obj The icon object
    * @return @c EINA_TRUE if scaling is disabled, @c EINA_FALSE otherwise
    *
    * @see elm_icon_no_scale_set()
    *
    * @ingroup Icon
    */
   EAPI Eina_Bool             elm_icon_no_scale_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set if the object is (up/down) resizeable.
    *
    * @param obj The icon object
    * @param scale_up A bool to set if the object is resizeable up. Default is
    * @c EINA_TRUE.
    * @param scale_down A bool to set if the object is resizeable down. Default
    * is @c EINA_TRUE.
    *
    * This function limits the icon object resize ability. If @p scale_up is set to
    * @c EINA_FALSE, the object can't have its height or width resized to a value
    * higher than the original icon size. Same is valid for @p scale_down.
    *
    * @see elm_icon_scale_get()
    *
    * @ingroup Icon
    */
   EAPI void                  elm_icon_scale_set(Evas_Object *obj, Eina_Bool scale_up, Eina_Bool scale_down) EINA_ARG_NONNULL(1);
   /**
    * Get if the object is (up/down) resizeable.
    *
    * @param obj The icon object
    * @param scale_up A bool to set if the object is resizeable up
    * @param scale_down A bool to set if the object is resizeable down
    *
    * @see elm_icon_scale_set()
    *
    * @ingroup Icon
    */
   EAPI void                  elm_icon_scale_get(const Evas_Object *obj, Eina_Bool *scale_up, Eina_Bool *scale_down) EINA_ARG_NONNULL(1);
   /**
    * Set if the icon fill the entire object area.
    *
    * @param obj The icon object
    * @param fill_outside @c EINA_TRUE if the object is filled outside,
    * @c EINA_FALSE otherwise. Default is @c EINA_FALSE.
    *
    * When the icon object is resized to a different aspect ratio from the
    * original icon image, the icon image will still keep its aspect. This flag
    * tells how the image should fill the object's area. They are: keep the
    * entire icon inside the limits of height and width of the object (@p
    * fill_outside is @c EINA_FALSE) or let the extra width or height go outside
    * of the object, and the icon will fill the entire object (@p fill_outside
    * is @c EINA_TRUE).
    *
    * @note Unlike @ref Image, there's no option in icon to set the aspect ratio
    * retain property to false. Thus, the icon image will always keep its
    * original aspect ratio.
    *
    * @see elm_icon_fill_outside_get()
    * @see elm_image_fill_outside_set()
    *
    * @ingroup Icon
    */
   EAPI void                  elm_icon_fill_outside_set(Evas_Object *obj, Eina_Bool fill_outside) EINA_ARG_NONNULL(1);
   /**
    * Get if the object is filled outside.
    *
    * @param obj The icon object
    * @return @c EINA_TRUE if the object is filled outside, @c EINA_FALSE otherwise.
    *
    * @see elm_icon_fill_outside_set()
    *
    * @ingroup Icon
    */
   EAPI Eina_Bool             elm_icon_fill_outside_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the prescale size for the icon.
    *
    * @param obj The icon object
    * @param size The prescale size. This value is used for both width and
    * height.
    *
    * This function sets a new size for pixmap representation of the given
    * icon. It allows the icon to be loaded already in the specified size,
    * reducing the memory usage and load time when loading a big icon with load
    * size set to a smaller size.
    *
    * It's equivalent to the elm_bg_load_size_set() function for bg.
    *
    * @note this is just a hint, the real size of the pixmap may differ
    * depending on the type of icon being loaded, being bigger than requested.
    *
    * @see elm_icon_prescale_get()
    * @see elm_bg_load_size_set()
    *
    * @ingroup Icon
    */
   EAPI void                  elm_icon_prescale_set(Evas_Object *obj, int size) EINA_ARG_NONNULL(1);
   /**
    * Get the prescale size for the icon.
    *
    * @param obj The icon object
    * @return The prescale size
    *
    * @see elm_icon_prescale_set()
    *
    * @ingroup Icon
    */
   EAPI int                   elm_icon_prescale_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Sets the icon lookup order used by elm_icon_standard_set().
    *
    * @param obj The icon object
    * @param order The icon lookup order (can be one of
    * ELM_ICON_LOOKUP_FDO_THEME, ELM_ICON_LOOKUP_THEME_FDO, ELM_ICON_LOOKUP_FDO
    * or ELM_ICON_LOOKUP_THEME)
    *
    * @see elm_icon_order_lookup_get()
    * @see Elm_Icon_Lookup_Order
    *
    * @ingroup Icon
    */
   EAPI void                  elm_icon_order_lookup_set(Evas_Object *obj, Elm_Icon_Lookup_Order order) EINA_ARG_NONNULL(1);
   /**
    * Gets the icon lookup order.
    *
    * @param obj The icon object
    * @return The icon lookup order
    *
    * @see elm_icon_order_lookup_set()
    * @see Elm_Icon_Lookup_Order
    *
    * @ingroup Icon
    */
   EAPI Elm_Icon_Lookup_Order elm_icon_order_lookup_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

   /**
    * @defgroup Image Image
    *
    * @image html img/image/button/preview-00.png
    * @image latex img/image/button/preview-00.png
    *
    * An object that allows one to load an image file to it. It can be used
    * anywhere like any other elementary widget.
    *
    * This widget provides most of the functionality provided from @ref Bg or @ref
    * Icon, but with a slightly different API (use the one that fits better your
    * needs).
    *
    * The features not provided by those two other image widgets are:
    * @li allowing to get the basic @c Evas_Object with elm_image_object_get();
    * @li change the object orientation with elm_image_orient_set();
    * @li and turning the image editable with elm_image_editable_set().
    *
    * Signals that you can add callbacks for are:
    *
    * @li @c "clicked" - This is called when a user has clicked the image
    *
    * An example of usage for this API follows:
    * @li @ref tutorial_image
    */

   /**
    * @addtogroup Image
    * @{
    */

   /**
    * @enum _Elm_Image_Orient
    * @typedef Elm_Image_Orient
    *
    * Possible orientation options for elm_image_orient_set().
    *
    * @image html elm_image_orient_set.png
    * @image latex elm_image_orient_set.eps width=\textwidth
    *
    * @ingroup Image
    */
   typedef enum _Elm_Image_Orient
     {
        ELM_IMAGE_ORIENT_NONE, /**< no orientation change */
        ELM_IMAGE_ROTATE_90_CW, /**< rotate 90 degrees clockwise */
        ELM_IMAGE_ROTATE_180_CW, /**< rotate 180 degrees clockwise */
        ELM_IMAGE_ROTATE_90_CCW, /**< rotate 90 degrees counter-clockwise (i.e. 270 degrees clockwise) */
        ELM_IMAGE_FLIP_HORIZONTAL, /**< flip image horizontally */
        ELM_IMAGE_FLIP_VERTICAL, /**< flip image vertically */
        ELM_IMAGE_FLIP_TRANSPOSE, /**< flip the image along the y = (side - x) line*/
        ELM_IMAGE_FLIP_TRANSVERSE /**< flip the image along the y = x line */
     } Elm_Image_Orient;

   /**
    * Add a new image to the parent.
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    *
    * @see elm_image_file_set()
    *
    * @ingroup Image
    */
   EAPI Evas_Object     *elm_image_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the file that will be used as image.
    *
    * @param obj The image object
    * @param file The path to file that will be used as image
    * @param group The group that the image belongs in edje file (if it's an
    * edje image)
    *
    * @return (@c EINA_TRUE = success, @c EINA_FALSE = error)
    *
    * @see elm_image_file_get()
    *
    * @ingroup Image
    */
   EAPI Eina_Bool        elm_image_file_set(Evas_Object *obj, const char *file, const char *group) EINA_ARG_NONNULL(1, 2);
   /**
    * Get the file that will be used as image.
    *
    * @param obj The image object
    * @param file The path to file
    * @param group The group that the image belongs in edje file
    *
    * @see elm_image_file_set()
    *
    * @ingroup Image
    */
   EAPI void             elm_image_file_get(const Evas_Object *obj, const char **file, const char **group) EINA_ARG_NONNULL(1);
   /**
    * Set the smooth effect for an image.
    *
    * @param obj The image object
    * @param smooth @c EINA_TRUE if smooth scaling should be used, @c EINA_FALSE
    * otherwise. Default is @c EINA_TRUE.
    *
    * Set the scaling algorithm to be used when scaling the image. Smooth
    * scaling provides a better resulting image, but is slower.
    *
    * The smooth scaling should be disabled when making animations that change
    * the image size, since it will be faster. Animations that don't require
    * resizing of the image can keep the smooth scaling enabled (even if the
    * image is already scaled, since the scaled image will be cached).
    *
    * @see elm_image_smooth_get()
    *
    * @ingroup Image
    */
   EAPI void             elm_image_smooth_set(Evas_Object *obj, Eina_Bool smooth) EINA_ARG_NONNULL(1);
   /**
    * Get the smooth effect for an image.
    *
    * @param obj The image object
    * @return @c EINA_TRUE if smooth scaling is enabled, @c EINA_FALSE otherwise.
    *
    * @see elm_image_smooth_get()
    *
    * @ingroup Image
    */
   EAPI Eina_Bool        elm_image_smooth_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Gets the current size of the image.
    *
    * @param obj The image object.
    * @param w Pointer to store width, or NULL.
    * @param h Pointer to store height, or NULL.
    *
    * This is the real size of the image, not the size of the object.
    *
    * On error, neither w or h will be written.
    *
    * @ingroup Image
    */
   EAPI void             elm_image_object_size_get(const Evas_Object *obj, int *w, int *h) EINA_ARG_NONNULL(1);
   /**
    * Disable scaling of this object.
    *
    * @param obj The image object.
    * @param no_scale @c EINA_TRUE if the object is not scalable, @c EINA_FALSE
    * otherwise. Default is @c EINA_FALSE.
    *
    * This function disables scaling of the elm_image widget through the
    * function elm_object_scale_set(). However, this does not affect the widget
    * size/resize in any way. For that effect, take a look at
    * elm_image_scale_set().
    *
    * @see elm_image_no_scale_get()
    * @see elm_image_scale_set()
    * @see elm_object_scale_set()
    *
    * @ingroup Image
    */
   EAPI void             elm_image_no_scale_set(Evas_Object *obj, Eina_Bool no_scale) EINA_ARG_NONNULL(1);
   /**
    * Get whether scaling is disabled on the object.
    *
    * @param obj The image object
    * @return @c EINA_TRUE if scaling is disabled, @c EINA_FALSE otherwise
    *
    * @see elm_image_no_scale_set()
    *
    * @ingroup Image
    */
   EAPI Eina_Bool        elm_image_no_scale_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set if the object is (up/down) resizeable.
    *
    * @param obj The image object
    * @param scale_up A bool to set if the object is resizeable up. Default is
    * @c EINA_TRUE.
    * @param scale_down A bool to set if the object is resizeable down. Default
    * is @c EINA_TRUE.
    *
    * This function limits the image resize ability. If @p scale_up is set to
    * @c EINA_FALSE, the object can't have its height or width resized to a value
    * higher than the original image size. Same is valid for @p scale_down.
    *
    * @see elm_image_scale_get()
    *
    * @ingroup Image
    */
   EAPI void             elm_image_scale_set(Evas_Object *obj, Eina_Bool scale_up, Eina_Bool scale_down) EINA_ARG_NONNULL(1);
   /**
    * Get if the object is (up/down) resizeable.
    *
    * @param obj The image object
    * @param scale_up A bool to set if the object is resizeable up
    * @param scale_down A bool to set if the object is resizeable down
    *
    * @see elm_image_scale_set()
    *
    * @ingroup Image
    */
   EAPI void             elm_image_scale_get(const Evas_Object *obj, Eina_Bool *scale_up, Eina_Bool *scale_down) EINA_ARG_NONNULL(1);
   /**
    * Set if the image fill the entire object area when keeping the aspect ratio.
    *
    * @param obj The image object
    * @param fill_outside @c EINA_TRUE if the object is filled outside,
    * @c EINA_FALSE otherwise. Default is @c EINA_FALSE.
    *
    * When the image should keep its aspect ratio even if resized to another
    * aspect ratio, there are two possibilities to resize it: keep the entire
    * image inside the limits of height and width of the object (@p fill_outside
    * is @c EINA_FALSE) or let the extra width or height go outside of the object,
    * and the image will fill the entire object (@p fill_outside is @c EINA_TRUE).
    *
    * @note This option will have no effect if
    * elm_image_aspect_ratio_retained_set() is set to @c EINA_FALSE.
    *
    * @see elm_image_fill_outside_get()
    * @see elm_image_aspect_ratio_retained_set()
    *
    * @ingroup Image
    */
   EAPI void             elm_image_fill_outside_set(Evas_Object *obj, Eina_Bool fill_outside) EINA_ARG_NONNULL(1);
   /**
    * Get if the object is filled outside
    *
    * @param obj The image object
    * @return @c EINA_TRUE if the object is filled outside, @c EINA_FALSE otherwise.
    *
    * @see elm_image_fill_outside_set()
    *
    * @ingroup Image
    */
   EAPI Eina_Bool        elm_image_fill_outside_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the prescale size for the image
    *
    * @param obj The image object
    * @param size The prescale size. This value is used for both width and
    * height.
    *
    * This function sets a new size for pixmap representation of the given
    * image. It allows the image to be loaded already in the specified size,
    * reducing the memory usage and load time when loading a big image with load
    * size set to a smaller size.
    *
    * It's equivalent to the elm_bg_load_size_set() function for bg.
    *
    * @note this is just a hint, the real size of the pixmap may differ
    * depending on the type of image being loaded, being bigger than requested.
    *
    * @see elm_image_prescale_get()
    * @see elm_bg_load_size_set()
    *
    * @ingroup Image
    */
   EAPI void             elm_image_prescale_set(Evas_Object *obj, int size) EINA_ARG_NONNULL(1);
   /**
    * Get the prescale size for the image
    *
    * @param obj The image object
    * @return The prescale size
    *
    * @see elm_image_prescale_set()
    *
    * @ingroup Image
    */
   EAPI int              elm_image_prescale_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the image orientation.
    *
    * @param obj The image object
    * @param orient The image orientation
    * (one of #ELM_IMAGE_ORIENT_NONE, #ELM_IMAGE_ROTATE_90_CW,
    *  #ELM_IMAGE_ROTATE_180_CW, #ELM_IMAGE_ROTATE_90_CCW,
    *  #ELM_IMAGE_FLIP_HORIZONTAL, #ELM_IMAGE_FLIP_VERTICAL,
    *  #ELM_IMAGE_FLIP_TRANSPOSE, #ELM_IMAGE_FLIP_TRANSVERSE).
    *  Default is #ELM_IMAGE_ORIENT_NONE.
    *
    * This function allows to rotate or flip the given image.
    *
    * @see elm_image_orient_get()
    * @see @ref Elm_Image_Orient
    *
    * @ingroup Image
    */
   EAPI void             elm_image_orient_set(Evas_Object *obj, Elm_Image_Orient orient) EINA_ARG_NONNULL(1);
   /**
    * Get the image orientation.
    *
    * @param obj The image object
    * @return The image orientation
    * (one of #ELM_IMAGE_ORIENT_NONE, #ELM_IMAGE_ROTATE_90_CW,
    *  #ELM_IMAGE_ROTATE_180_CW, #ELM_IMAGE_ROTATE_90_CCW,
    *  #ELM_IMAGE_FLIP_HORIZONTAL, #ELM_IMAGE_FLIP_VERTICAL,
    *  #ELM_IMAGE_FLIP_TRANSPOSE, #ELM_IMAGE_FLIP_TRANSVERSE)
    *
    * @see elm_image_orient_set()
    * @see @ref Elm_Image_Orient
    *
    * @ingroup Image
    */
   EAPI Elm_Image_Orient elm_image_orient_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Make the image 'editable'.
    *
    * @param obj Image object.
    * @param set Turn on or off editability. Default is @c EINA_FALSE.
    *
    * This means the image is a valid drag target for drag and drop, and can be
    * cut or pasted too.
    *
    * @ingroup Image
    */
   EAPI void             elm_image_editable_set(Evas_Object *obj, Eina_Bool set) EINA_ARG_NONNULL(1);
   /**
    * Make the image 'editable'.
    *
    * @param obj Image object.
    * @return Editability.
    *
    * This means the image is a valid drag target for drag and drop, and can be
    * cut or pasted too.
    *
    * @ingroup Image
    */
   EAPI Eina_Bool        elm_image_editable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Get the basic Evas_Image object from this object (widget).
    *
    * @param obj The image object to get the inlined image from
    * @return The inlined image object, or NULL if none exists
    *
    * This function allows one to get the underlying @c Evas_Object of type
    * Image from this elementary widget. It can be useful to do things like get
    * the pixel data, save the image to a file, etc.
    *
    * @note Be careful to not manipulate it, as it is under control of
    * elementary.
    *
    * @ingroup Image
    */
   EAPI Evas_Object     *elm_image_object_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set whether the original aspect ratio of the image should be kept on resize.
    *
    * @param obj The image object.
    * @param retained @c EINA_TRUE if the image should retain the aspect,
    * @c EINA_FALSE otherwise.
    *
    * The original aspect ratio (width / height) of the image is usually
    * distorted to match the object's size. Enabling this option will retain
    * this original aspect, and the way that the image is fit into the object's
    * area depends on the option set by elm_image_fill_outside_set().
    *
    * @see elm_image_aspect_ratio_retained_get()
    * @see elm_image_fill_outside_set()
    *
    * @ingroup Image
    */
   EAPI void             elm_image_aspect_ratio_retained_set(Evas_Object *obj, Eina_Bool retained) EINA_ARG_NONNULL(1);
   /**
    * Get if the object retains the original aspect ratio.
    *
    * @param obj The image object.
    * @return @c EINA_TRUE if the object keeps the original aspect, @c EINA_FALSE
    * otherwise.
    *
    * @ingroup Image
    */
   EAPI Eina_Bool        elm_image_aspect_ratio_retained_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /* smart callbacks called:
    * "clicked" - the user clicked the image
    */

   /**
    * @}
    */

   /* glview */
   typedef void (*Elm_GLView_Func_Cb)(Evas_Object *obj);

   typedef enum _Elm_GLView_Mode
     {
        ELM_GLVIEW_ALPHA   = 1,
        ELM_GLVIEW_DEPTH   = 2,
        ELM_GLVIEW_STENCIL = 4
     } Elm_GLView_Mode;

   /**
    * Defines a policy for the glview resizing.
    *
    * @note Default is ELM_GLVIEW_RESIZE_POLICY_RECREATE
    */
   typedef enum _Elm_GLView_Resize_Policy
     {
        ELM_GLVIEW_RESIZE_POLICY_RECREATE = 1,      /**< Resize the internal surface along with the image */
        ELM_GLVIEW_RESIZE_POLICY_SCALE    = 2       /**< Only reize the internal image and not the surface */
     } Elm_GLView_Resize_Policy;

   typedef enum _Elm_GLView_Render_Policy
     {
        ELM_GLVIEW_RENDER_POLICY_ON_DEMAND = 1,     /**< Render only when there is a need for redrawing */
        ELM_GLVIEW_RENDER_POLICY_ALWAYS    = 2      /**< Render always even when it is not visible */
     } Elm_GLView_Render_Policy;


   EAPI Evas_Object     *elm_glview_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_size_set(Evas_Object *obj, Evas_Coord width, Evas_Coord height) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_size_get(const Evas_Object *obj, Evas_Coord *width, Evas_Coord *height) EINA_ARG_NONNULL(1);
   EAPI Evas_GL_API     *elm_glview_gl_api_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_glview_mode_set(Evas_Object *obj, Elm_GLView_Mode mode) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_glview_resize_policy_set(Evas_Object *obj, Elm_GLView_Resize_Policy policy) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_glview_render_policy_set(Evas_Object *obj, Elm_GLView_Render_Policy policy) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_init_func_set(Evas_Object *obj, Elm_GLView_Func_Cb func) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_del_func_set(Evas_Object *obj, Elm_GLView_Func_Cb func) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_resize_func_set(Evas_Object *obj, Elm_GLView_Func_Cb func) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_render_func_set(Evas_Object *obj, Elm_GLView_Func_Cb func) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_changed_set(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /* box */
   /**
    * @defgroup Box Box
    *
    * A box arranges objects in a linear fashion, governed by a layout function
    * that defines the details of this arrangement.
    *
    * By default, the box will use an internal function to set the layout to
    * a single row, either vertical or horizontal. This layout is affected
    * by a number of parameters, such as the homogeneous flag set by
    * elm_box_homogeneous_set(), the values given by elm_box_padding_set() and
    * elm_box_align_set() and the hints set to each object in the box.
    *
    * For this default layout, it's possible to change the orientation with
    * elm_box_horizontal_set(). The box will start in the vertical orientation,
    * placing its elements ordered from top to bottom. When horizontal is set,
    * the order will go from left to right. If the box is set to be
    * homogeneous, every object in it will be assigned the same space, that
    * of the largest object. Padding can be used to set some spacing between
    * the cell given to each object. The alignment of the box, set with
    * elm_box_align_set(), determines how the bounding box of all the elements
    * will be placed within the space given to the box widget itself.
    *
    * The size hints of each object also affect how they are placed and sized
    * within the box. evas_object_size_hint_min_set() will give the minimum
    * size the object can have, and the box will use it as the basis for all
    * latter calculations. Elementary widgets set their own minimum size as
    * needed, so there's rarely any need to use it manually.
    *
    * evas_object_size_hint_weight_set(), when not in homogeneous mode, is
    * used to tell whether the object will be allocated the minimum size it
    * needs or if the space given to it should be expanded. It's important
    * to realize that expanding the size given to the object is not the same
    * thing as resizing the object. It could very well end being a small
    * widget floating in a much larger empty space. If not set, the weight
    * for objects will normally be 0.0 for both axis, meaning the widget will
    * not be expanded. To take as much space possible, set the weight to
    * EVAS_HINT_EXPAND (defined to 1.0) for the desired axis to expand.
    *
    * Besides how much space each object is allocated, it's possible to control
    * how the widget will be placed within that space using
    * evas_object_size_hint_align_set(). By default, this value will be 0.5
    * for both axis, meaning the object will be centered, but any value from
    * 0.0 (left or top, for the @c x and @c y axis, respectively) to 1.0
    * (right or bottom) can be used. The special value EVAS_HINT_FILL, which
    * is -1.0, means the object will be resized to fill the entire space it
    * was allocated.
    *
    * In addition, customized functions to define the layout can be set, which
    * allow the application developer to organize the objects within the box
    * in any number of ways.
    *
    * The special elm_box_layout_transition() function can be used
    * to switch from one layout to another, animating the motion of the
    * children of the box.
    *
    * @note Objects should not be added to box objects using _add() calls.
    *
    * Some examples on how to use boxes follow:
    * @li @ref box_example_01
    * @li @ref box_example_02
    *
    * @{
    */
   /**
    * @typedef Elm_Box_Transition
    *
    * Opaque handler containing the parameters to perform an animated
    * transition of the layout the box uses.
    *
    * @see elm_box_transition_new()
    * @see elm_box_layout_set()
    * @see elm_box_layout_transition()
    */
   typedef struct _Elm_Box_Transition Elm_Box_Transition;

   /**
    * Add a new box to the parent
    *
    * By default, the box will be in vertical mode and non-homogeneous.
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object        *elm_box_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the horizontal orientation
    *
    * By default, box object arranges their contents vertically from top to
    * bottom.
    * By calling this function with @p horizontal as EINA_TRUE, the box will
    * become horizontal, arranging contents from left to right.
    *
    * @note This flag is ignored if a custom layout function is set.
    *
    * @param obj The box object
    * @param horizontal The horizontal flag (EINA_TRUE = horizontal,
    * EINA_FALSE = vertical)
    */
   EAPI void                elm_box_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   /**
    * Get the horizontal orientation
    *
    * @param obj The box object
    * @return EINA_TRUE if the box is set to horizontal mode, EINA_FALSE otherwise
    */
   EAPI Eina_Bool           elm_box_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the box to arrange its children homogeneously
    *
    * If enabled, homogeneous layout makes all items the same size, according
    * to the size of the largest of its children.
    *
    * @note This flag is ignored if a custom layout function is set.
    *
    * @param obj The box object
    * @param homogeneous The homogeneous flag
    */
   EAPI void                elm_box_homogeneous_set(Evas_Object *obj, Eina_Bool homogeneous) EINA_ARG_NONNULL(1);
   /**
    * Get whether the box is using homogeneous mode or not
    *
    * @param obj The box object
    * @return EINA_TRUE if it's homogeneous, EINA_FALSE otherwise
    */
   EAPI Eina_Bool           elm_box_homogeneous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void elm_box_homogenous_set(Evas_Object *obj, Eina_Bool homogenous) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool elm_box_homogenous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Add an object to the beginning of the pack list
    *
    * Pack @p subobj into the box @p obj, placing it first in the list of
    * children objects. The actual position the object will get on screen
    * depends on the layout used. If no custom layout is set, it will be at
    * the top or left, depending if the box is vertical or horizontal,
    * respectively.
    *
    * @param obj The box object
    * @param subobj The object to add to the box
    *
    * @see elm_box_pack_end()
    * @see elm_box_pack_before()
    * @see elm_box_pack_after()
    * @see elm_box_unpack()
    * @see elm_box_unpack_all()
    * @see elm_box_clear()
    */
   EAPI void                elm_box_pack_start(Evas_Object *obj, Evas_Object *subobj) EINA_ARG_NONNULL(1);
   /**
    * Add an object at the end of the pack list
    *
    * Pack @p subobj into the box @p obj, placing it last in the list of
    * children objects. The actual position the object will get on screen
    * depends on the layout used. If no custom layout is set, it will be at
    * the bottom or right, depending if the box is vertical or horizontal,
    * respectively.
    *
    * @param obj The box object
    * @param subobj The object to add to the box
    *
    * @see elm_box_pack_start()
    * @see elm_box_pack_before()
    * @see elm_box_pack_after()
    * @see elm_box_unpack()
    * @see elm_box_unpack_all()
    * @see elm_box_clear()
    */
   EAPI void                elm_box_pack_end(Evas_Object *obj, Evas_Object *subobj) EINA_ARG_NONNULL(1);
   /**
    * Adds an object to the box before the indicated object
    *
    * This will add the @p subobj to the box indicated before the object
    * indicated with @p before. If @p before is not already in the box, results
    * are undefined. Before means either to the left of the indicated object or
    * above it depending on orientation.
    *
    * @param obj The box object
    * @param subobj The object to add to the box
    * @param before The object before which to add it
    *
    * @see elm_box_pack_start()
    * @see elm_box_pack_end()
    * @see elm_box_pack_after()
    * @see elm_box_unpack()
    * @see elm_box_unpack_all()
    * @see elm_box_clear()
    */
   EAPI void                elm_box_pack_before(Evas_Object *obj, Evas_Object *subobj, Evas_Object *before) EINA_ARG_NONNULL(1);
   /**
    * Adds an object to the box after the indicated object
    *
    * This will add the @p subobj to the box indicated after the object
    * indicated with @p after. If @p after is not already in the box, results
    * are undefined. After means either to the right of the indicated object or
    * below it depending on orientation.
    *
    * @param obj The box object
    * @param subobj The object to add to the box
    * @param after The object after which to add it
    *
    * @see elm_box_pack_start()
    * @see elm_box_pack_end()
    * @see elm_box_pack_before()
    * @see elm_box_unpack()
    * @see elm_box_unpack_all()
    * @see elm_box_clear()
    */
   EAPI void                elm_box_pack_after(Evas_Object *obj, Evas_Object *subobj, Evas_Object *after) EINA_ARG_NONNULL(1);
   /**
    * Clear the box of all children
    *
    * Remove all the elements contained by the box, deleting the respective
    * objects.
    *
    * @param obj The box object
    *
    * @see elm_box_unpack()
    * @see elm_box_unpack_all()
    */
   EAPI void                elm_box_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Unpack a box item
    *
    * Remove the object given by @p subobj from the box @p obj without
    * deleting it.
    *
    * @param obj The box object
    *
    * @see elm_box_unpack_all()
    * @see elm_box_clear()
    */
   EAPI void                elm_box_unpack(Evas_Object *obj, Evas_Object *subobj) EINA_ARG_NONNULL(1);
   /**
    * Remove all items from the box, without deleting them
    *
    * Clear the box from all children, but don't delete the respective objects.
    * If no other references of the box children exist, the objects will never
    * be deleted, and thus the application will leak the memory. Make sure
    * when using this function that you hold a reference to all the objects
    * in the box @p obj.
    *
    * @param obj The box object
    *
    * @see elm_box_clear()
    * @see elm_box_unpack()
    */
   EAPI void                elm_box_unpack_all(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Retrieve a list of the objects packed into the box
    *
    * Returns a new @c Eina_List with a pointer to @c Evas_Object in its nodes.
    * The order of the list corresponds to the packing order the box uses.
    *
    * You must free this list with eina_list_free() once you are done with it.
    *
    * @param obj The box object
    */
   EAPI const Eina_List    *elm_box_children_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the space (padding) between the box's elements.
    *
    * Extra space in pixels that will be added between a box child and its
    * neighbors after its containing cell has been calculated. This padding
    * is set for all elements in the box, besides any possible padding that
    * individual elements may have through their size hints.
    *
    * @param obj The box object
    * @param horizontal The horizontal space between elements
    * @param vertical The vertical space between elements
    */
   EAPI void                elm_box_padding_set(Evas_Object *obj, Evas_Coord horizontal, Evas_Coord vertical) EINA_ARG_NONNULL(1);
   /**
    * Get the space (padding) between the box's elements.
    *
    * @param obj The box object
    * @param horizontal The horizontal space between elements
    * @param vertical The vertical space between elements
    *
    * @see elm_box_padding_set()
    */
   EAPI void                elm_box_padding_get(const Evas_Object *obj, Evas_Coord *horizontal, Evas_Coord *vertical) EINA_ARG_NONNULL(1);
   /**
    * Set the alignment of the whole bouding box of contents.
    *
    * Sets how the bounding box containing all the elements of the box, after
    * their sizes and position has been calculated, will be aligned within
    * the space given for the whole box widget.
    *
    * @param obj The box object
    * @param horizontal The horizontal alignment of elements
    * @param vertical The vertical alignment of elements
    */
   EAPI void                elm_box_align_set(Evas_Object *obj, double horizontal, double vertical) EINA_ARG_NONNULL(1);
   /**
    * Get the alignment of the whole bouding box of contents.
    *
    * @param obj The box object
    * @param horizontal The horizontal alignment of elements
    * @param vertical The vertical alignment of elements
    *
    * @see elm_box_align_set()
    */
   EAPI void                elm_box_align_get(const Evas_Object *obj, double *horizontal, double *vertical) EINA_ARG_NONNULL(1);

   /**
    * Set the layout defining function to be used by the box
    *
    * Whenever anything changes that requires the box in @p obj to recalculate
    * the size and position of its elements, the function @p cb will be called
    * to determine what the layout of the children will be.
    *
    * Once a custom function is set, everything about the children layout
    * is defined by it. The flags set by elm_box_horizontal_set() and
    * elm_box_homogeneous_set() no longer have any meaning, and the values
    * given by elm_box_padding_set() and elm_box_align_set() are up to this
    * layout function to decide if they are used and how. These last two
    * will be found in the @c priv parameter, of type @c Evas_Object_Box_Data,
    * passed to @p cb. The @c Evas_Object the function receives is not the
    * Elementary widget, but the internal Evas Box it uses, so none of the
    * functions described here can be used on it.
    *
    * Any of the layout functions in @c Evas can be used here, as well as the
    * special elm_box_layout_transition().
    *
    * The final @p data argument received by @p cb is the same @p data passed
    * here, and the @p free_data function will be called to free it
    * whenever the box is destroyed or another layout function is set.
    *
    * Setting @p cb to NULL will revert back to the default layout function.
    *
    * @param obj The box object
    * @param cb The callback function used for layout
    * @param data Data that will be passed to layout function
    * @param free_data Function called to free @p data
    *
    * @see elm_box_layout_transition()
    */
   EAPI void                elm_box_layout_set(Evas_Object *obj, Evas_Object_Box_Layout cb, const void *data, void (*free_data)(void *data)) EINA_ARG_NONNULL(1);
   /**
    * Special layout function that animates the transition from one layout to another
    *
    * Normally, when switching the layout function for a box, this will be
    * reflected immediately on screen on the next render, but it's also
    * possible to do this through an animated transition.
    *
    * This is done by creating an ::Elm_Box_Transition and setting the box
    * layout to this function.
    *
    * For example:
    * @code
    * Elm_Box_Transition *t = elm_box_transition_new(1.0,
    *                            evas_object_box_layout_vertical, // start
    *                            NULL, // data for initial layout
    *                            NULL, // free function for initial data
    *                            evas_object_box_layout_horizontal, // end
    *                            NULL, // data for final layout
    *                            NULL, // free function for final data
    *                            anim_end, // will be called when animation ends
    *                            NULL); // data for anim_end function\
    * elm_box_layout_set(box, elm_box_layout_transition, t,
    *                    elm_box_transition_free);
    * @endcode
    *
    * @note This function can only be used with elm_box_layout_set(). Calling
    * it directly will not have the expected results.
    *
    * @see elm_box_transition_new
    * @see elm_box_transition_free
    * @see elm_box_layout_set
    */
   EAPI void                elm_box_layout_transition(Evas_Object *obj, Evas_Object_Box_Data *priv, void *data);
   /**
    * Create a new ::Elm_Box_Transition to animate the switch of layouts
    *
    * If you want to animate the change from one layout to another, you need
    * to set the layout function of the box to elm_box_layout_transition(),
    * passing as user data to it an instance of ::Elm_Box_Transition with the
    * necessary information to perform this animation. The free function to
    * set for the layout is elm_box_transition_free().
    *
    * The parameters to create an ::Elm_Box_Transition sum up to how long
    * will it be, in seconds, a layout function to describe the initial point,
    * another for the final position of the children and one function to be
    * called when the whole animation ends. This last function is useful to
    * set the definitive layout for the box, usually the same as the end
    * layout for the animation, but could be used to start another transition.
    *
    * @param start_layout The layout function that will be used to start the animation
    * @param start_layout_data The data to be passed the @p start_layout function
    * @param start_layout_free_data Function to free @p start_layout_data
    * @param end_layout The layout function that will be used to end the animation
    * @param end_layout_free_data The data to be passed the @p end_layout function
    * @param end_layout_free_data Function to free @p end_layout_data
    * @param transition_end_cb Callback function called when animation ends
    * @param transition_end_data Data to be passed to @p transition_end_cb
    * @return An instance of ::Elm_Box_Transition
    *
    * @see elm_box_transition_new
    * @see elm_box_layout_transition
    */
   EAPI Elm_Box_Transition *elm_box_transition_new(const double duration, Evas_Object_Box_Layout start_layout, void *start_layout_data, void(*start_layout_free_data)(void *data), Evas_Object_Box_Layout end_layout, void *end_layout_data, void(*end_layout_free_data)(void *data), void(*transition_end_cb)(void *data), void *transition_end_data) EINA_ARG_NONNULL(2, 5);
   /**
    * Free a Elm_Box_Transition instance created with elm_box_transition_new().
    *
    * This function is mostly useful as the @c free_data parameter in
    * elm_box_layout_set() when elm_box_layout_transition().
    *
    * @param data The Elm_Box_Transition instance to be freed.
    *
    * @see elm_box_transition_new
    * @see elm_box_layout_transition
    */
   EAPI void                elm_box_transition_free(void *data);
   /**
    * @}
    */

   /* button */
   /**
    * @defgroup Button Button
    *
    * @image html img/widget/button/preview-00.png
    * @image html img/widget/button/preview-01.png
    * @image html img/widget/button/preview-02.png
    *
    * This is a push-button. Press it and run some function. It can contain
    * a simple label and icon object and it also has an autorepeat feature.
    *
    * This widgets emits the following signals:
    * @li "clicked": the user clicked the button (press/release).
    * @li "repeated": the user pressed the button without releasing it.
    * @li "pressed": button was pressed.
    * @li "unpressed": button was released after being pressed.
    * In all three cases, the @c event parameter of the callback will be
    * @c NULL.
    *
    * Also, defined in the default theme, the button has the following styles
    * available:
    * @li default: a normal button.
    * @li anchor: Like default, but the button fades away when the mouse is not
    * over it, leaving only the text or icon.
    * @li hoversel_vertical: Internally used by @ref Hoversel to give a
    * continuous look across its options.
    * @li hoversel_vertical_entry: Another internal for @ref Hoversel.
    *
    * Follow through a complete example @ref button_example_01 "here".
    * @{
    */
   /**
    * Add a new button to the parent's canvas
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object *elm_button_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the label used in the button
    *
    * The passed @p label can be NULL to clean any existing text in it and
    * leave the button as an icon only object.
    *
    * @param obj The button object
    * @param label The text will be written on the button
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_button_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   /**
    * Get the label set for the button
    *
    * The string returned is an internal pointer and should not be freed or
    * altered. It will also become invalid when the button is destroyed.
    * The string returned, if not NULL, is a stringshare, so if you need to
    * keep it around even after the button is destroyed, you can use
    * eina_stringshare_ref().
    *
    * @param obj The button object
    * @return The text set to the label, or NULL if nothing is set
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_button_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the icon used for the button
    *
    * Setting a new icon will delete any other that was previously set, making
    * any reference to them invalid. If you need to maintain the previous
    * object alive, unset it first with elm_button_icon_unset().
    *
    * @param obj The button object
    * @param icon The icon object for the button
    */
   EAPI void         elm_button_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   /**
    * Get the icon used for the button
    *
    * Return the icon object which is set for this widget. If the button is
    * destroyed or another icon is set, the returned object will be deleted
    * and any reference to it will be invalid.
    *
    * @param obj The button object
    * @return The icon object that is being used
    *
    * @see elm_button_icon_unset()
    */
   EAPI Evas_Object *elm_button_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Remove the icon set without deleting it and return the object
    *
    * This function drops the reference the button holds of the icon object
    * and returns this last object. It is used in case you want to remove any
    * icon, or set another one, without deleting the actual object. The button
    * will be left without an icon set.
    *
    * @param obj The button object
    * @return The icon object that was being used
    */
   EAPI Evas_Object *elm_button_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Turn on/off the autorepeat event generated when the button is kept pressed
    *
    * When off, no autorepeat is performed and buttons emit a normal @c clicked
    * signal when they are clicked.
    *
    * When on, keeping a button pressed will continuously emit a @c repeated
    * signal until the button is released. The time it takes until it starts
    * emitting the signal is given by
    * elm_button_autorepeat_initial_timeout_set(), and the time between each
    * new emission by elm_button_autorepeat_gap_timeout_set().
    *
    * @param obj The button object
    * @param on  A bool to turn on/off the event
    */
   EAPI void         elm_button_autorepeat_set(Evas_Object *obj, Eina_Bool on) EINA_ARG_NONNULL(1);
   /**
    * Get whether the autorepeat feature is enabled
    *
    * @param obj The button object
    * @return EINA_TRUE if autorepeat is on, EINA_FALSE otherwise
    *
    * @see elm_button_autorepeat_set()
    */
   EAPI Eina_Bool    elm_button_autorepeat_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the initial timeout before the autorepeat event is generated
    *
    * Sets the timeout, in seconds, since the button is pressed until the
    * first @c repeated signal is emitted. If @p t is 0.0 or less, there
    * won't be any delay and the even will be fired the moment the button is
    * pressed.
    *
    * @param obj The button object
    * @param t   Timeout in seconds
    *
    * @see elm_button_autorepeat_set()
    * @see elm_button_autorepeat_gap_timeout_set()
    */
   EAPI void         elm_button_autorepeat_initial_timeout_set(Evas_Object *obj, double t) EINA_ARG_NONNULL(1);
   /**
    * Get the initial timeout before the autorepeat event is generated
    *
    * @param obj The button object
    * @return Timeout in seconds
    *
    * @see elm_button_autorepeat_initial_timeout_set()
    */
   EAPI double       elm_button_autorepeat_initial_timeout_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the interval between each generated autorepeat event
    *
    * After the first @c repeated event is fired, all subsequent ones will
    * follow after a delay of @p t seconds for each.
    *
    * @param obj The button object
    * @param t   Interval in seconds
    *
    * @see elm_button_autorepeat_initial_timeout_set()
    */
   EAPI void         elm_button_autorepeat_gap_timeout_set(Evas_Object *obj, double t) EINA_ARG_NONNULL(1);
   /**
    * Get the interval between each generated autorepeat event
    *
    * @param obj The button object
    * @return Interval in seconds
    */
   EAPI double       elm_button_autorepeat_gap_timeout_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /**
    * @defgroup File_Selector_Button File Selector Button
    *
    * @image html img/widget/fileselector_button/preview-00.png
    * @image html img/widget/fileselector_button/preview-01.png
    * @image html img/widget/fileselector_button/preview-02.png
    *
    * This is a button that, when clicked, creates an Elementary
    * window (or inner window) <b> with a @ref Fileselector "file
    * selector widget" within</b>. When a file is chosen, the (inner)
    * window is closed and the button emits a signal having the
    * selected file as it's @c event_info.
    *
    * This widget encapsulates operations on its internal file
    * selector on its own API. There is less control over its file
    * selector than that one would have instatiating one directly.
    *
    * The following styles are available for this button:
    * @li @c "default"
    * @li @c "anchor"
    * @li @c "hoversel_vertical"
    * @li @c "hoversel_vertical_entry"
    *
    * Smart callbacks one can register to:
    * - @c "file,chosen" - the user has selected a path, whose string
    *   pointer comes as the @c event_info data (a stringshared
    *   string)
    *
    * Here is an example on its usage:
    * @li @ref fileselector_button_example
    *
    * @see @ref File_Selector_Entry for a similar widget.
    * @{
    */

   /**
    * Add a new file selector button widget to the given parent
    * Elementary (container) object
    *
    * @param parent The parent object
    * @return a new file selector button widget handle or @c NULL, on
    * errors
    */
   EAPI Evas_Object *elm_fileselector_button_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Set the label for a given file selector button widget
    *
    * @param obj The file selector button widget
    * @param label The text label to be displayed on @p obj
    *
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_fileselector_button_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);

   /**
    * Get the label set for a given file selector button widget
    *
    * @param obj The file selector button widget
    * @return The button label
    *
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_fileselector_button_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the icon on a given file selector button widget
    *
    * @param obj The file selector button widget
    * @param icon The icon object for the button
    *
    * Once the icon object is set, a previously set one will be
    * deleted. If you want to keep the latter, use the
    * elm_fileselector_button_icon_unset() function.
    *
    * @see elm_fileselector_button_icon_get()
    */
   EAPI void         elm_fileselector_button_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);

   /**
    * Get the icon set for a given file selector button widget
    *
    * @param obj The file selector button widget
    * @return The icon object currently set on @p obj or @c NULL, if
    * none is
    *
    * @see elm_fileselector_button_icon_set()
    */
   EAPI Evas_Object *elm_fileselector_button_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Unset the icon used in a given file selector button widget
    *
    * @param obj The file selector button widget
    * @return The icon object that was being used on @p obj or @c
    * NULL, on errors
    *
    * Unparent and return the icon object which was set for this
    * widget.
    *
    * @see elm_fileselector_button_icon_set()
    */
   EAPI Evas_Object *elm_fileselector_button_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the title for a given file selector button widget's window
    *
    * @param obj The file selector button widget
    * @param title The title string
    *
    * This will change the window's title, when the file selector pops
    * out after a click on the button. Those windows have the default
    * (unlocalized) value of @c "Select a file" as titles.
    *
    * @note It will only take any effect if the file selector
    * button widget is @b not under "inwin mode".
    *
    * @see elm_fileselector_button_window_title_get()
    */
   EAPI void         elm_fileselector_button_window_title_set(Evas_Object *obj, const char *title) EINA_ARG_NONNULL(1);

   /**
    * Get the title set for a given file selector button widget's
    * window
    *
    * @param obj The file selector button widget
    * @return Title of the file selector button's window
    *
    * @see elm_fileselector_button_window_title_get() for more details
    */
   EAPI const char  *elm_fileselector_button_window_title_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the size of a given file selector button widget's window,
    * holding the file selector itself.
    *
    * @param obj The file selector button widget
    * @param width The window's width
    * @param height The window's height
    *
    * @note it will only take any effect if the file selector button
    * widget is @b not under "inwin mode". The default size for the
    * window (when applicable) is 400x400 pixels.
    *
    * @see elm_fileselector_button_window_size_get()
    */
   EAPI void         elm_fileselector_button_window_size_set(Evas_Object *obj, Evas_Coord width, Evas_Coord height) EINA_ARG_NONNULL(1);

   /**
    * Get the size of a given file selector button widget's window,
    * holding the file selector itself.
    *
    * @param obj The file selector button widget
    * @param width Pointer into which to store the width value
    * @param height Pointer into which to store the height value
    *
    * @note Use @c NULL pointers on the size values you're not
    * interested in: they'll be ignored by the function.
    *
    * @see elm_fileselector_button_window_size_set(), for more details
    */
   EAPI void         elm_fileselector_button_window_size_get(const Evas_Object *obj, Evas_Coord *width, Evas_Coord *height) EINA_ARG_NONNULL(1);

   /**
    * Set the initial file system path for a given file selector
    * button widget
    *
    * @param obj The file selector button widget
    * @param path The path string
    *
    * It must be a <b>directory</b> path, which will have the contents
    * displayed initially in the file selector's view, when invoked
    * from @p obj. The default initial path is the @c "HOME"
    * environment variable's value.
    *
    * @see elm_fileselector_button_path_get()
    */
   EAPI void         elm_fileselector_button_path_set(Evas_Object *obj, const char *path) EINA_ARG_NONNULL(1);

   /**
    * Get the initial file system path set for a given file selector
    * button widget
    *
    * @param obj The file selector button widget
    * @return path The path string
    *
    * @see elm_fileselector_button_path_set() for more details
    */
   EAPI const char  *elm_fileselector_button_path_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Enable/disable a tree view in the given file selector button
    * widget's internal file selector
    *
    * @param obj The file selector button widget
    * @param expand @c EINA_TRUE to enable tree view, @c EINA_FALSE to
    * disable
    *
    * This has the same effect as elm_fileselector_expandable_set(),
    * but now applied to a file selector button's internal file
    * selector.
    *
    * @note There's no way to put a file selector button's internal
    * file selector in "grid mode", as one may do with "pure" file
    * selectors.
    *
    * @see elm_fileselector_expandable_get()
    */
   EAPI void         elm_fileselector_button_expandable_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);

   /**
    * Get whether tree view is enabled for the given file selector
    * button widget's internal file selector
    *
    * @param obj The file selector button widget
    * @return @c EINA_TRUE if @p obj widget's internal file selector
    * is in tree view, @c EINA_FALSE otherwise (and or errors)
    *
    * @see elm_fileselector_expandable_set() for more details
    */
   EAPI Eina_Bool    elm_fileselector_button_expandable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set whether a given file selector button widget's internal file
    * selector is to display folders only or the directory contents,
    * as well.
    *
    * @param obj The file selector button widget
    * @param only @c EINA_TRUE to make @p obj widget's internal file
    * selector only display directories, @c EINA_FALSE to make files
    * to be displayed in it too
    *
    * This has the same effect as elm_fileselector_folder_only_set(),
    * but now applied to a file selector button's internal file
    * selector.
    *
    * @see elm_fileselector_folder_only_get()
    */
   EAPI void         elm_fileselector_button_folder_only_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);

   /**
    * Get whether a given file selector button widget's internal file
    * selector is displaying folders only or the directory contents,
    * as well.
    *
    * @param obj The file selector button widget
    * @return @c EINA_TRUE if @p obj widget's internal file
    * selector is only displaying directories, @c EINA_FALSE if files
    * are being displayed in it too (and on errors)
    *
    * @see elm_fileselector_button_folder_only_set() for more details
    */
   EAPI Eina_Bool    elm_fileselector_button_folder_only_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Enable/disable the file name entry box where the user can type
    * in a name for a file, in a given file selector button widget's
    * internal file selector.
    *
    * @param obj The file selector button widget
    * @param is_save @c EINA_TRUE to make @p obj widget's internal
    * file selector a "saving dialog", @c EINA_FALSE otherwise
    *
    * This has the same effect as elm_fileselector_is_save_set(),
    * but now applied to a file selector button's internal file
    * selector.
    *
    * @see elm_fileselector_is_save_get()
    */
   EAPI void         elm_fileselector_button_is_save_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);

   /**
    * Get whether the given file selector button widget's internal
    * file selector is in "saving dialog" mode
    *
    * @param obj The file selector button widget
    * @return @c EINA_TRUE, if @p obj widget's internal file selector
    * is in "saving dialog" mode, @c EINA_FALSE otherwise (and on
    * errors)
    *
    * @see elm_fileselector_button_is_save_set() for more details
    */
   EAPI Eina_Bool    elm_fileselector_button_is_save_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set whether a given file selector button widget's internal file
    * selector will raise an Elementary "inner window", instead of a
    * dedicated Elementary window. By default, it won't.
    *
    * @param obj The file selector button widget
    * @param value @c EINA_TRUE to make it use an inner window, @c
    * EINA_TRUE to make it use a dedicated window
    *
    * @see elm_win_inwin_add() for more information on inner windows
    * @see elm_fileselector_button_inwin_mode_get()
    */
   EAPI void         elm_fileselector_button_inwin_mode_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);

   /**
    * Get whether a given file selector button widget's internal file
    * selector will raise an Elementary "inner window", instead of a
    * dedicated Elementary window.
    *
    * @param obj The file selector button widget
    * @return @c EINA_TRUE if will use an inner window, @c EINA_TRUE
    * if it will use a dedicated window
    *
    * @see elm_fileselector_button_inwin_mode_set() for more details
    */
   EAPI Eina_Bool    elm_fileselector_button_inwin_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

    /**
    * @defgroup File_Selector_Entry File Selector Entry
    *
    * @image html img/widget/fileselector_entry/preview-00.png
    * @image latex img/widget/fileselector_entry/preview-00.eps
    *
    * This is an entry made to be filled with or display a <b>file
    * system path string</b>. Besides the entry itself, the widget has
    * a @ref File_Selector_Button "file selector button" on its side,
    * which will raise an internal @ref Fileselector "file selector widget",
    * when clicked, for path selection aided by file system
    * navigation.
    *
    * This file selector may appear in an Elementary window or in an
    * inner window. When a file is chosen from it, the (inner) window
    * is closed and the selected file's path string is exposed both as
    * an smart event and as the new text on the entry.
    *
    * This widget encapsulates operations on its internal file
    * selector on its own API. There is less control over its file
    * selector than that one would have instatiating one directly.
    *
    * Smart callbacks one can register to:
    * - @c "changed" - The text within the entry was changed
    * - @c "activated" - The entry has had editing finished and
    *   changes are to be "committed"
    * - @c "press" - The entry has been clicked
    * - @c "longpressed" - The entry has been clicked (and held) for a
    *   couple seconds
    * - @c "clicked" - The entry has been clicked
    * - @c "clicked,double" - The entry has been double clicked
    * - @c "focused" - The entry has received focus
    * - @c "unfocused" - The entry has lost focus
    * - @c "selection,paste" - A paste action has occurred on the
    *   entry
    * - @c "selection,copy" - A copy action has occurred on the entry
    * - @c "selection,cut" - A cut action has occurred on the entry
    * - @c "unpressed" - The file selector entry's button was released
    *   after being pressed.
    * - @c "file,chosen" - The user has selected a path via the file
    *   selector entry's internal file selector, whose string pointer
    *   comes as the @c event_info data (a stringshared string)
    *
    * Here is an example on its usage:
    * @li @ref fileselector_entry_example
    *
    * @see @ref File_Selector_Button for a similar widget.
    * @{
    */

   /**
    * Add a new file selector entry widget to the given parent
    * Elementary (container) object
    *
    * @param parent The parent object
    * @return a new file selector entry widget handle or @c NULL, on
    * errors
    */
   EAPI Evas_Object *elm_fileselector_entry_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Set the label for a given file selector entry widget's button
    *
    * @param obj The file selector entry widget
    * @param label The text label to be displayed on @p obj widget's
    * button
    *
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_fileselector_entry_button_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);

   /**
    * Get the label set for a given file selector entry widget's button
    *
    * @param obj The file selector entry widget
    * @return The widget button's label
    *
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_fileselector_entry_button_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the icon on a given file selector entry widget's button
    *
    * @param obj The file selector entry widget
    * @param icon The icon object for the entry's button
    *
    * Once the icon object is set, a previously set one will be
    * deleted. If you want to keep the latter, use the
    * elm_fileselector_entry_button_icon_unset() function.
    *
    * @see elm_fileselector_entry_button_icon_get()
    */
   EAPI void         elm_fileselector_entry_button_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);

   /**
    * Get the icon set for a given file selector entry widget's button
    *
    * @param obj The file selector entry widget
    * @return The icon object currently set on @p obj widget's button
    * or @c NULL, if none is
    *
    * @see elm_fileselector_entry_button_icon_set()
    */
   EAPI Evas_Object *elm_fileselector_entry_button_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Unset the icon used in a given file selector entry widget's
    * button
    *
    * @param obj The file selector entry widget
    * @return The icon object that was being used on @p obj widget's
    * button or @c NULL, on errors
    *
    * Unparent and return the icon object which was set for this
    * widget's button.
    *
    * @see elm_fileselector_entry_button_icon_set()
    */
   EAPI Evas_Object *elm_fileselector_entry_button_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the title for a given file selector entry widget's window
    *
    * @param obj The file selector entry widget
    * @param title The title string
    *
    * This will change the window's title, when the file selector pops
    * out after a click on the entry's button. Those windows have the
    * default (unlocalized) value of @c "Select a file" as titles.
    *
    * @note It will only take any effect if the file selector
    * entry widget is @b not under "inwin mode".
    *
    * @see elm_fileselector_entry_window_title_get()
    */
   EAPI void         elm_fileselector_entry_window_title_set(Evas_Object *obj, const char *title) EINA_ARG_NONNULL(1);

   /**
    * Get the title set for a given file selector entry widget's
    * window
    *
    * @param obj The file selector entry widget
    * @return Title of the file selector entry's window
    *
    * @see elm_fileselector_entry_window_title_get() for more details
    */
   EAPI const char  *elm_fileselector_entry_window_title_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the size of a given file selector entry widget's window,
    * holding the file selector itself.
    *
    * @param obj The file selector entry widget
    * @param width The window's width
    * @param height The window's height
    *
    * @note it will only take any effect if the file selector entry
    * widget is @b not under "inwin mode". The default size for the
    * window (when applicable) is 400x400 pixels.
    *
    * @see elm_fileselector_entry_window_size_get()
    */
   EAPI void         elm_fileselector_entry_window_size_set(Evas_Object *obj, Evas_Coord width, Evas_Coord height) EINA_ARG_NONNULL(1);

   /**
    * Get the size of a given file selector entry widget's window,
    * holding the file selector itself.
    *
    * @param obj The file selector entry widget
    * @param width Pointer into which to store the width value
    * @param height Pointer into which to store the height value
    *
    * @note Use @c NULL pointers on the size values you're not
    * interested in: they'll be ignored by the function.
    *
    * @see elm_fileselector_entry_window_size_set(), for more details
    */
   EAPI void         elm_fileselector_entry_window_size_get(const Evas_Object *obj, Evas_Coord *width, Evas_Coord *height) EINA_ARG_NONNULL(1);

   /**
    * Set the initial file system path and the entry's path string for
    * a given file selector entry widget
    *
    * @param obj The file selector entry widget
    * @param path The path string
    *
    * It must be a <b>directory</b> path, which will have the contents
    * displayed initially in the file selector's view, when invoked
    * from @p obj. The default initial path is the @c "HOME"
    * environment variable's value.
    *
    * @see elm_fileselector_entry_path_get()
    */
   EAPI void         elm_fileselector_entry_path_set(Evas_Object *obj, const char *path) EINA_ARG_NONNULL(1);

   /**
    * Get the entry's path string for a given file selector entry
    * widget
    *
    * @param obj The file selector entry widget
    * @return path The path string
    *
    * @see elm_fileselector_entry_path_set() for more details
    */
   EAPI const char  *elm_fileselector_entry_path_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Enable/disable a tree view in the given file selector entry
    * widget's internal file selector
    *
    * @param obj The file selector entry widget
    * @param expand @c EINA_TRUE to enable tree view, @c EINA_FALSE to
    * disable
    *
    * This has the same effect as elm_fileselector_expandable_set(),
    * but now applied to a file selector entry's internal file
    * selector.
    *
    * @note There's no way to put a file selector entry's internal
    * file selector in "grid mode", as one may do with "pure" file
    * selectors.
    *
    * @see elm_fileselector_expandable_get()
    */
   EAPI void         elm_fileselector_entry_expandable_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);

   /**
    * Get whether tree view is enabled for the given file selector
    * entry widget's internal file selector
    *
    * @param obj The file selector entry widget
    * @return @c EINA_TRUE if @p obj widget's internal file selector
    * is in tree view, @c EINA_FALSE otherwise (and or errors)
    *
    * @see elm_fileselector_expandable_set() for more details
    */
   EAPI Eina_Bool    elm_fileselector_entry_expandable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set whether a given file selector entry widget's internal file
    * selector is to display folders only or the directory contents,
    * as well.
    *
    * @param obj The file selector entry widget
    * @param only @c EINA_TRUE to make @p obj widget's internal file
    * selector only display directories, @c EINA_FALSE to make files
    * to be displayed in it too
    *
    * This has the same effect as elm_fileselector_folder_only_set(),
    * but now applied to a file selector entry's internal file
    * selector.
    *
    * @see elm_fileselector_folder_only_get()
    */
   EAPI void         elm_fileselector_entry_folder_only_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);

   /**
    * Get whether a given file selector entry widget's internal file
    * selector is displaying folders only or the directory contents,
    * as well.
    *
    * @param obj The file selector entry widget
    * @return @c EINA_TRUE if @p obj widget's internal file
    * selector is only displaying directories, @c EINA_FALSE if files
    * are being displayed in it too (and on errors)
    *
    * @see elm_fileselector_entry_folder_only_set() for more details
    */
   EAPI Eina_Bool    elm_fileselector_entry_folder_only_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Enable/disable the file name entry box where the user can type
    * in a name for a file, in a given file selector entry widget's
    * internal file selector.
    *
    * @param obj The file selector entry widget
    * @param is_save @c EINA_TRUE to make @p obj widget's internal
    * file selector a "saving dialog", @c EINA_FALSE otherwise
    *
    * This has the same effect as elm_fileselector_is_save_set(),
    * but now applied to a file selector entry's internal file
    * selector.
    *
    * @see elm_fileselector_is_save_get()
    */
   EAPI void         elm_fileselector_entry_is_save_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);

   /**
    * Get whether the given file selector entry widget's internal
    * file selector is in "saving dialog" mode
    *
    * @param obj The file selector entry widget
    * @return @c EINA_TRUE, if @p obj widget's internal file selector
    * is in "saving dialog" mode, @c EINA_FALSE otherwise (and on
    * errors)
    *
    * @see elm_fileselector_entry_is_save_set() for more details
    */
   EAPI Eina_Bool    elm_fileselector_entry_is_save_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set whether a given file selector entry widget's internal file
    * selector will raise an Elementary "inner window", instead of a
    * dedicated Elementary window. By default, it won't.
    *
    * @param obj The file selector entry widget
    * @param value @c EINA_TRUE to make it use an inner window, @c
    * EINA_TRUE to make it use a dedicated window
    *
    * @see elm_win_inwin_add() for more information on inner windows
    * @see elm_fileselector_entry_inwin_mode_get()
    */
   EAPI void         elm_fileselector_entry_inwin_mode_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);

   /**
    * Get whether a given file selector entry widget's internal file
    * selector will raise an Elementary "inner window", instead of a
    * dedicated Elementary window.
    *
    * @param obj The file selector entry widget
    * @return @c EINA_TRUE if will use an inner window, @c EINA_TRUE
    * if it will use a dedicated window
    *
    * @see elm_fileselector_entry_inwin_mode_set() for more details
    */
   EAPI Eina_Bool    elm_fileselector_entry_inwin_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the initial file system path for a given file selector entry
    * widget
    *
    * @param obj The file selector entry widget
    * @param path The path string
    *
    * It must be a <b>directory</b> path, which will have the contents
    * displayed initially in the file selector's view, when invoked
    * from @p obj. The default initial path is the @c "HOME"
    * environment variable's value.
    *
    * @see elm_fileselector_entry_path_get()
    */
   EAPI void         elm_fileselector_entry_selected_set(Evas_Object *obj, const char *path) EINA_ARG_NONNULL(1);

   /**
    * Get the parent directory's path to the latest file selection on
    * a given filer selector entry widget
    *
    * @param obj The file selector object
    * @return The (full) path of the directory of the last selection
    * on @p obj widget, a @b stringshared string
    *
    * @see elm_fileselector_entry_path_set()
    */
   EAPI const char  *elm_fileselector_entry_selected_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

   /* scroller policy */
   typedef enum _Elm_Scroller_Policy
     {
        ELM_SCROLLER_POLICY_AUTO = 0,
        ELM_SCROLLER_POLICY_ON,
        ELM_SCROLLER_POLICY_OFF,
        ELM_SCROLLER_POLICY_LAST
     } Elm_Scroller_Policy;

   EAPI Evas_Object *elm_scroller_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_content_set(Evas_Object *obj, Evas_Object *child) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_scroller_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_scroller_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_custom_widget_base_theme_set(Evas_Object *obj, const char *widget, const char *base) EINA_ARG_NONNULL(1, 2, 3);
   EAPI void         elm_scroller_content_min_limit(Evas_Object *obj, Eina_Bool w, Eina_Bool h) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_region_show(Evas_Object *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_policy_set(Evas_Object *obj, Elm_Scroller_Policy policy_h, Elm_Scroller_Policy policy_v) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_policy_get(const Evas_Object *obj, Elm_Scroller_Policy *policy_h, Elm_Scroller_Policy *policy_v) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_region_get(const Evas_Object *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_child_size_get(const Evas_Object *obj, Evas_Coord *w, Evas_Coord *h) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_page_relative_set(Evas_Object *obj, double h_pagerel, double v_pagerel) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_page_size_set(Evas_Object *obj, Evas_Coord h_pagesize, Evas_Coord v_pagesize) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_region_bring_in(Evas_Object *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_propagate_events_set(Evas_Object *obj, Eina_Bool propagation);
   EAPI Eina_Bool    elm_scroller_propagate_events_get(const Evas_Object *obj);
   /* smart callbacks called:
    * "edge,left" - the left edge of the content has been reached
    * "edge,right" - the right edge of the content has been reached
    * "edge,top" - the top edge of the content has been reached
    * "edge,bottom" - the bottom edge of the content has been reached
    * "scroll" - the content has been scrolled (moved)
    * "scroll,anim,start" - scrolling animation has started
    * "scroll,anim,stop" - scrolling animation has stopped
    * "scroll,drag,start" - dragging the contents around has started
    * "scroll,drag,stop" - dragging the contents around has stopped
    */

   /**
    * @defgroup Label Label
    *
    * @image html img/widget/label/preview-00.png
    * @image latex img/widget/label/preview-00.eps
    *
    * @brief Widget to display text, with simple html-like markup.
    *
    * The Label widget @b doesn't allow text to overflow its boundaries, if the
    * text doesn't fit the geometry of the label it will be ellipsized or be
    * cut. Elementary provides several themes for this widget:
    * @li default - No animation
    * @li marker - Centers the text in the label and make it bold by default
    * @li slide_long - The entire text appears from the right of the screen and
    * slides until it disappears in the left of the screen(reappering on the
    * right again).
    * @li slide_short - The text appears in the left of the label and slides to
    * the right to show the overflow. When all of the text has been shown the
    * position is reset.
    * @li slide_bounce - The text appears in the left of the label and slides to
    * the right to show the overflow. When all of the text has been shown the
    * animation reverses, moving the text to the left.
    *
    * Custom themes can of course invent new markup tags and style them any way
    * they like.
    *
    * See @ref tutorial_label for a demonstration of how to use a label widget.
    * @{
    */
   /**
    * @brief Add a new label to the parent
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object *elm_label_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the label on the label object
    *
    * @param obj The label object
    * @param label The label will be used on the label object
    * @deprecated See elm_object_text_set()
    */
   EINA_DEPRECATED EAPI void elm_label_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1); /* deprecated, use elm_object_text_set instead */
   /**
    * @brief Get the label used on the label object
    *
    * @param obj The label object
    * @return The string inside the label
    * @deprecated See elm_object_text_get()
    */
   EINA_DEPRECATED EAPI const char *elm_label_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1); /* deprecated, use elm_object_text_get instead */
   /**
    * @brief Set the wrapping behavior of the label
    *
    * @param obj The label object
    * @param wrap To wrap text or not
    *
    * By default no wrapping is done. Possible values for @p wrap are:
    * @li ELM_WRAP_NONE - No wrapping
    * @li ELM_WRAP_CHAR - wrap between characters
    * @li ELM_WRAP_WORD - wrap between words
    * @li ELM_WRAP_MIXED - Word wrap, and if that fails, char wrap
    */
   EAPI void         elm_label_line_wrap_set(Evas_Object *obj, Elm_Wrap_Type wrap) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the wrapping behavior of the label
    *
    * @param obj The label object
    * @return Wrap type
    *
    * @see elm_label_line_wrap_set()
    */
   EAPI Elm_Wrap_Type elm_label_line_wrap_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set wrap width of the label
    *
    * @param obj The label object
    * @param w The wrap width in pixels at a minimum where words need to wrap
    *
    * This function sets the maximum width size hint of the label.
    *
    * @warning This is only relevant if the label is inside a container.
    */
   EAPI void         elm_label_wrap_width_set(Evas_Object *obj, Evas_Coord w) EINA_ARG_NONNULL(1);
   /**
    * @brief Get wrap width of the label
    *
    * @param obj The label object
    * @return The wrap width in pixels at a minimum where words need to wrap
    *
    * @see elm_label_wrap_width_set()
    */
   EAPI Evas_Coord   elm_label_wrap_width_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set wrap height of the label
    *
    * @param obj The label object
    * @param h The wrap height in pixels at a minimum where words need to wrap
    *
    * This function sets the maximum height size hint of the label.
    *
    * @warning This is only relevant if the label is inside a container.
    */
   EAPI void         elm_label_wrap_height_set(Evas_Object *obj, Evas_Coord h) EINA_ARG_NONNULL(1);
   /**
    * @brief get wrap width of the label
    *
    * @param obj The label object
    * @return The wrap height in pixels at a minimum where words need to wrap
    */
   EAPI Evas_Coord   elm_label_wrap_height_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the font size on the label object.
    *
    * @param obj The label object
    * @param size font size
    *
    * @warning NEVER use this. It is for hyper-special cases only. use styles
    * instead. e.g. "big", "medium", "small" - or better name them by use:
    * "title", "footnote", "quote" etc.
    */
   EAPI void         elm_label_fontsize_set(Evas_Object *obj, int fontsize) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the text color on the label object
    *
    * @param obj The label object
    * @param r Red property background color of The label object
    * @param g Green property background color of The label object
    * @param b Blue property background color of The label object
    * @param a Alpha property background color of The label object
    *
    * @warning NEVER use this. It is for hyper-special cases only. use styles
    * instead. e.g. "big", "medium", "small" - or better name them by use:
    * "title", "footnote", "quote" etc.
    */
   EAPI void         elm_label_text_color_set(Evas_Object *obj, unsigned int r, unsigned int g, unsigned int b, unsigned int a) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the text align on the label object
    *
    * @param obj The label object
    * @param align align mode ("left", "center", "right")
    *
    * @warning NEVER use this. It is for hyper-special cases only. use styles
    * instead. e.g. "big", "medium", "small" - or better name them by use:
    * "title", "footnote", "quote" etc.
    */
   EAPI void         elm_label_text_align_set(Evas_Object *obj, const char *alignmode) EINA_ARG_NONNULL(1);
   /**
    * @brief Set background color of the label
    *
    * @param obj The label object
    * @param r Red property background color of The label object
    * @param g Green property background color of The label object
    * @param b Blue property background color of The label object
    * @param a Alpha property background alpha of The label object
    *
    * @warning NEVER use this. It is for hyper-special cases only. use styles
    * instead. e.g. "big", "medium", "small" - or better name them by use:
    * "title", "footnote", "quote" etc.
    */
   EAPI void         elm_label_background_color_set(Evas_Object *obj, unsigned int r, unsigned int g, unsigned int b, unsigned int a) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the ellipsis behavior of the label
    *
    * @param obj The label object
    * @param ellipsis To ellipsis text or not
    *
    * If set to true and the text doesn't fit in the label an ellipsis("...")
    * will be shown at the end of the widget.
    *
    * @warning This doesn't work with slide(elm_label_slide_set()) or if the
    * choosen wrap method was ELM_WRAP_WORD.
    */
   EAPI void         elm_label_ellipsis_set(Evas_Object *obj, Eina_Bool ellipsis) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the text slide of the label
    *
    * @param obj The label object
    * @param slide To start slide or stop
    *
    * If set to true the text of the label will slide throught the length of
    * label.
    *
    * @warning This must be called before elm_label_slide_set().
    * @warning This only work with the themes "slide_short", "slide_long" and
    * "slide_bounce".
    */
   EAPI void         elm_label_slide_set(Evas_Object *obj, Eina_Bool slide) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the text slide mode of the label
    *
    * @param obj The label object
    * @return slide slide mode value
    *
    * @see elm_label_slide_set()
    */
   EAPI Eina_Bool    elm_label_slide_get(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the slide duration(speed) of the label
    *
    * @param obj The label object
    * @return The duration in seconds in moving text from slide begin position
    * to slide end position
    */
   EAPI void         elm_label_slide_duration_set(Evas_Object *obj, double duration) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the slide duration(speed) of the label
    *
    * @param obj The label object
    * @return The duration time in moving text from slide begin position to slide end position
    *
    * @see elm_label_slide_duration_set()
    */
   EAPI double       elm_label_slide_duration_get(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /**
    * @defgroup Toggle
    *
    * @image html img/widget/toggle/preview-00.png
    * @image latex img/widget/toggle/preview-00.eps
    *
    * @brief A toggle is a slider which can be used to toggle between
    * two values.  It has two states: on and off.
    *
    * Signals that you can add callbacks for are:
    * @li "changed" - Whenever the toggle value has been changed.  Is not called
    *                 until the toggle is released by the cursor (assuming it
    *                 has been triggered by the cursor in the first place).
    *
    * @ref tutorial_toggle show how to use a toggle.
    * @{
    */
   /**
    * @brief Add a toggle to @p parent.
    *
    * @param parent The parent object
    *
    * @return The toggle object
    */
   EAPI Evas_Object *elm_toggle_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Sets the label to be displayed with the toggle.
    *
    * @param obj The toggle object
    * @param label The label to be displayed
    *
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_toggle_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   /**
    * @brief Gets the label of the toggle
    *
    * @param obj  toggle object
    * @return The label of the toggle
    *
    * @deprecated use elm_object_text_get() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_toggle_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the icon used for the toggle
    *
    * @param obj The toggle object
    * @param icon The icon object for the button
    *
    * Once the icon object is set, a previously set one will be deleted
    * If you want to keep that old content object, use the
    * elm_toggle_icon_unset() function.
    */
   EAPI void         elm_toggle_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the icon used for the toggle
    *
    * @param obj The toggle object
    * @return The icon object that is being used
    *
    * Return the icon object which is set for this widget.
    *
    * @see elm_toggle_icon_set()
    */
   EAPI Evas_Object *elm_toggle_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Unset the icon used for the toggle
    *
    * @param obj The toggle object
    * @return The icon object that was being used
    *
    * Unparent and return the icon object which was set for this widget.
    *
    * @see elm_toggle_icon_set()
    */
   EAPI Evas_Object *elm_toggle_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Sets the labels to be associated with the on and off states of the toggle.
    *
    * @param obj The toggle object
    * @param onlabel The label displayed when the toggle is in the "on" state
    * @param offlabel The label displayed when the toggle is in the "off" state
    */
   EAPI void         elm_toggle_states_labels_set(Evas_Object *obj, const char *onlabel, const char *offlabel) EINA_ARG_NONNULL(1);
   /**
    * @brief Gets the labels associated with the on and off states of the toggle.
    *
    * @param obj The toggle object
    * @param onlabel A char** to place the onlabel of @p obj into
    * @param offlabel A char** to place the offlabel of @p obj into
    */
   EAPI void         elm_toggle_states_labels_get(const Evas_Object *obj, const char **onlabel, const char **offlabel) EINA_ARG_NONNULL(1);
   /**
    * @brief Sets the state of the toggle to @p state.
    *
    * @param obj The toggle object
    * @param state The state of @p obj
    */
   EAPI void         elm_toggle_state_set(Evas_Object *obj, Eina_Bool state) EINA_ARG_NONNULL(1);
   /**
    * @brief Gets the state of the toggle to @p state.
    *
    * @param obj The toggle object
    * @return The state of @p obj
    */
   EAPI Eina_Bool    elm_toggle_state_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Sets the state pointer of the toggle to @p statep.
    *
    * @param obj The toggle object
    * @param statep The state pointer of @p obj
    */
   EAPI void         elm_toggle_state_pointer_set(Evas_Object *obj, Eina_Bool *statep) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /**
    * @page tutorial_frame Frame example
    * @dontinclude frame_example_01.c
    *
    * In this example we are going to create 4 Frames with different styles and
    * add a rectangle of different color in each.
    *
    * We start we the usual setup code:
    * @until show(bg)
    *
    * And then create one rectangle:
    * @until show
    *
    * To add it in our first frame, which since it doesn't have it's style
    * specifically set uses the default style:
    * @until show
    *
    * And then create another rectangle:
    * @until show
    *
    * To add it in our second frame, which uses the "pad_small" style, note that
    * even tough we are setting a text for this frame it won't be show, only the
    * default style shows the Frame's title:
    * @until show
    * @note The "pad_small", "pad_medium", "pad_large" and "pad_huge" styles are
    * very similar, their only difference is the size of the empty area around
    * the content of the frame.
    *
    * And then create yet another rectangle:
    * @until show
    *
    * To add it in our third frame, which uses the "outdent_top" style, note
    * that even tough we are setting a text for this frame it won't be show,
    * only the default style shows the Frame's title:
    * @until show
    *
    * And then create one last rectangle:
    * @until show
    *
    * To add it in our fourth and final frame, which uses the "outdent_bottom"
    * style, note that even tough we are setting a text for this frame it won't
    * be show, only the default style shows the Frame's title:
    * @until show
    *
    * And now we are left with just some more setup code:
    * @until ELM_MAIN()
    *
    * Our example will look like this:
    *
    * @image html screenshots/frame_example_01.png
    * @image latex screenshots/frame_example_01.eps width=\textwidth
    *
    * @example frame_example_01.c
    */
   /**
    * @defgroup Frame Frame
    *
    * @image html img/widget/frame/preview-00.png
    * @image latex img/widget/frame/preview-00.eps
    *
    * @brief Frame is a widget that holds some content and has a title.
    *
    * The default look is a frame with a title, but Frame supports multple
    * styles:
    * @li default
    * @li pad_small
    * @li pad_medium
    * @li pad_large
    * @li pad_huge
    * @li outdent_top
    * @li outdent_bottom
    *
    * Of all this styles only default shows the title. Frame emits no signals.
    *
    * For a detailed example see the @ref tutorial_frame.
    *
    * @{
    */
   /**
    * @brief Add a new frame to the parent
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object *elm_frame_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the frame label
    *
    * @param obj The frame object
    * @param label The label of this frame object
    *
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_frame_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the frame label
    *
    * @param obj The frame object
    *
    * @return The label of this frame objet or NULL if unable to get frame
    *
    * @deprecated use elm_object_text_get() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_frame_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the content of the frame widget
    *
    * Once the content object is set, a previously set one will be deleted.
    * If you want to keep that old content object, use the
    * elm_frame_content_unset() function.
    *
    * @param obj The frame object
    * @param content The content will be filled in this frame object
    */
   EAPI void         elm_frame_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the content of the frame widget
    *
    * Return the content object which is set for this widget
    *
    * @param obj The frame object
    * @return The content that is being used
    */
   EAPI Evas_Object *elm_frame_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Unset the content of the frame widget
    *
    * Unparent and return the content object which was set for this widget
    *
    * @param obj The frame object
    * @return The content that was being used
    */
   EAPI Evas_Object *elm_frame_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* table */
   EAPI Evas_Object *elm_table_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_homogeneous_set(Evas_Object *obj, Eina_Bool homogeneous) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_table_homogeneous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void elm_table_homogenous_set(Evas_Object *obj, Eina_Bool homogenous) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool elm_table_homogenous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_padding_set(Evas_Object *obj, Evas_Coord horizontal, Evas_Coord vertical) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_padding_get(const Evas_Object *obj, Evas_Coord *horizontal, Evas_Coord *vertical) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_pack(Evas_Object *obj, Evas_Object *subobj, int x, int y, int w, int h) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_unpack(Evas_Object *obj, Evas_Object *subobj) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_clear(Evas_Object *obj, Eina_Bool clear) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_pack_set(Evas_Object *subobj, int x, int y, int w, int h) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_pack_get(Evas_Object *subobj, int *x, int *y, int *w, int *h) EINA_ARG_NONNULL(1);

   /**
    * @defgroup Gengrid Gengrid (Generic grid)
    *
    * This widget aims to position objects in a grid layout while
    * actually creating and rendering only the visible ones, using the
    * same idea as the @ref Genlist "genlist": the user defines a @b
    * class for each item, specifying functions that will be called at
    * object creation, deletion, etc. When those items are selected by
    * the user, a callback function is issued. Users may interact with
    * a gengrid via the mouse (by clicking on items to select them and
    * clicking on the grid's viewport and swiping to pan the whole
    * view) or via the keyboard, navigating through item with the
    * arrow keys.
    *
    * @section Gengrid_Layouts Gengrid layouts
    *
    * Gengrids may layout its items in one of two possible layouts:
    * - horizontal or
    * - vertical.
    *
    * When in "horizontal mode", items will be placed in @b columns,
    * from top to bottom and, when the space for a column is filled,
    * another one is started on the right, thus expanding the grid
    * horizontally, making for horizontal scrolling. When in "vertical
    * mode" , though, items will be placed in @b rows, from left to
    * right and, when the space for a row is filled, another one is
    * started below, thus expanding the grid vertically (and making
    * for vertical scrolling).
    *
    * @section Gengrid_Items Gengrid items
    *
    * An item in a gengrid can have 0 or more text labels (they can be
    * regular text or textblock Evas objects - that's up to the style
    * to determine), 0 or more icons (which are simply objects
    * swallowed into the gengrid item's theming Edje object) and 0 or
    * more <b>boolean states</b>, which have the behavior left to the
    * user to define. The Edje part names for each of these properties
    * will be looked up, in the theme file for the gengrid, under the
    * Edje (string) data items named @c "labels", @c "icons" and @c
    * "states", respectively. For each of those properties, if more
    * than one part is provided, they must have names listed separated
    * by spaces in the data fields. For the default gengrid item
    * theme, we have @b one label part (@c "elm.text"), @b two icon
    * parts (@c "elm.swalllow.icon" and @c "elm.swallow.end") and @b
    * no state parts.
    *
    * A gengrid item may be at one of several styles. Elementary
    * provides one by default - "default", but this can be extended by
    * system or application custom themes/overlays/extensions (see
    * @ref Theme "themes" for more details).
    *
    * @section Gengrid_Item_Class Gengrid item classes
    *
    * In order to have the ability to add and delete items on the fly,
    * gengrid implements a class (callback) system where the
    * application provides a structure with information about that
    * type of item (gengrid may contain multiple different items with
    * different classes, states and styles). Gengrid will call the
    * functions in this struct (methods) when an item is "realized"
    * (i.e., created dynamically, while the user is scrolling the
    * grid). All objects will simply be deleted when no longer needed
    * with evas_object_del(). The #Elm_GenGrid_Item_Class structure
    * contains the following members:
    * - @c item_style - This is a constant string and simply defines
    * the name of the item style. It @b must be specified and the
    * default should be @c "default".
    * - @c func.label_get - This function is called when an item
    * object is actually created. The @c data parameter will point to
    * the same data passed to elm_gengrid_item_append() and related
    * item creation functions. The @c obj parameter is the gengrid
    * object itself, while the @c part one is the name string of one
    * of the existing text parts in the Edje group implementing the
    * item's theme. This function @b must return a strdup'()ed string,
    * as the caller will free() it when done. See
    * #GridItemLabelGetFunc.
    * - @c func.icon_get - This function is called when an item object
    * is actually created. The @c data parameter will point to the
    * same data passed to elm_gengrid_item_append() and related item
    * creation functions. The @c obj parameter is the gengrid object
    * itself, while the @c part one is the name string of one of the
    * existing (icon) swallow parts in the Edje group implementing the
    * item's theme. It must return @c NULL, when no icon is desired,
    * or a valid object handle, otherwise. The object will be deleted
    * by the gengrid on its deletion or when the item is "unrealized".
    * See #GridItemIconGetFunc.
    * - @c func.state_get - This function is called when an item
    * object is actually created. The @c data parameter will point to
    * the same data passed to elm_gengrid_item_append() and related
    * item creation functions. The @c obj parameter is the gengrid
    * object itself, while the @c part one is the name string of one
    * of the state parts in the Edje group implementing the item's
    * theme. Return @c EINA_FALSE for false/off or @c EINA_TRUE for
    * true/on. Gengrids will emit a signal to its theming Edje object
    * with @c "elm,state,XXX,active" and @c "elm" as "emission" and
    * "source" arguments, respectively, when the state is true (the
    * default is false), where @c XXX is the name of the (state) part.
    * See #GridItemStateGetFunc.
    * - @c func.del - This is called when elm_gengrid_item_del() is
    * called on an item or elm_gengrid_clear() is called on the
    * gengrid. This is intended for use when gengrid items are
    * deleted, so any data attached to the item (e.g. its data
    * parameter on creation) can be deleted. See #GridItemDelFunc.
    *
    * @section Gengrid_Usage_Hints Usage hints
    *
    * If the user wants to have multiple items selected at the same
    * time, elm_gengrid_multi_select_set() will permit it. If the
    * gengrid is single-selection only (the default), then
    * elm_gengrid_select_item_get() will return the selected item or
    * @c NULL, if none is selected. If the gengrid is under
    * multi-selection, then elm_gengrid_selected_items_get() will
    * return a list (that is only valid as long as no items are
    * modified (added, deleted, selected or unselected) of child items
    * on a gengrid.
    *
    * If an item changes (internal (boolean) state, label or icon
    * changes), then use elm_gengrid_item_update() to have gengrid
    * update the item with the new state. A gengrid will re-"realize"
    * the item, thus calling the functions in the
    * #Elm_Gengrid_Item_Class set for that item.
    *
    * To programmatically (un)select an item, use
    * elm_gengrid_item_selected_set(). To get its selected state use
    * elm_gengrid_item_selected_get(). To make an item disabled
    * (unable to be selected and appear differently) use
    * elm_gengrid_item_disabled_set() to set this and
    * elm_gengrid_item_disabled_get() to get the disabled state.
    *
    * Grid cells will only have their selection smart callbacks called
    * when firstly getting selected. Any further clicks will do
    * nothing, unless you enable the "always select mode", with
    * elm_gengrid_always_select_mode_set(), thus making every click to
    * issue selection callbacks. elm_gengrid_no_select_mode_set() will
    * turn off the ability to select items entirely in the widget and
    * they will neither appear selected nor call the selection smart
    * callbacks.
    *
    * Remember that you can create new styles and add your own theme
    * augmentation per application with elm_theme_extension_add(). If
    * you absolutely must have a specific style that overrides any
    * theme the user or system sets up you can use
    * elm_theme_overlay_add() to add such a file.
    *
    * @section Gengrid_Smart_Events Gengrid smart events
    *
    * Smart events that you can add callbacks for are:
    * - @c "activated" - The user has double-clicked or pressed
    *   (enter|return|spacebar) on an item. The @c event_info parameter
    *   is the gengrid item that was activated.
    * - @c "clicked,double" - The user has double-clicked an item.
    *   The @c event_info parameter is the gengrid item that was double-clicked.
    * - @c "selected" - The user has made an item selected. The
    *   @c event_info parameter is the gengrid item that was selected.
    * - @c "unselected" - The user has made an item unselected. The
    *   @c event_info parameter is the gengrid item that was unselected.
    * - @c "realized" - This is called when the item in the gengrid
    *   has its implementing Evas object instantiated, de facto. @c
    *   event_info is the gengrid item that was created. The object
    *   may be deleted at any time, so it is highly advised to the
    *   caller @b not to use the object pointer returned from
    *   elm_gengrid_item_object_get(), because it may point to freed
    *   objects.
    * - @c "unrealized" - This is called when the implementing Evas
    *   object for this item is deleted. @c event_info is the gengrid
    *   item that was deleted.
    * - @c "changed" - Called when an item is added, removed, resized
    *   or moved and when the gengrid is resized or gets "horizontal"
    *   property changes.
    * - @c "drag,start,up" - Called when the item in the gengrid has
    *   been dragged (not scrolled) up.
    * - @c "drag,start,down" - Called when the item in the gengrid has
    *   been dragged (not scrolled) down.
    * - @c "drag,start,left" - Called when the item in the gengrid has
    *   been dragged (not scrolled) left.
    * - @c "drag,start,right" - Called when the item in the gengrid has
    *   been dragged (not scrolled) right.
    * - @c "drag,stop" - Called when the item in the gengrid has
    *   stopped being dragged.
    * - @c "drag" - Called when the item in the gengrid is being
    *   dragged.
    * - @c "scroll" - called when the content has been scrolled
    *   (moved).
    * - @c "scroll,drag,start" - called when dragging the content has
    *   started.
    * - @c "scroll,drag,stop" - called when dragging the content has
    *   stopped.
    *
    * List of gendrid examples:
    * @li @ref gengrid_example
    */

   typedef struct _Elm_Gengrid_Item_Class Elm_Gengrid_Item_Class; /**< Gengrid item class definition structs */
   typedef struct _Elm_Gengrid_Item_Class_Func Elm_Gengrid_Item_Class_Func; /**< Class functions for gengrid item classes. */
   typedef struct _Elm_Gengrid_Item Elm_Gengrid_Item; /**< Gengrid item handles */
   typedef char        *(*GridItemLabelGetFunc) (void *data, Evas_Object *obj, const char *part); /**< Label fetching class function for gengrid item classes. */
   typedef Evas_Object *(*GridItemIconGetFunc)  (void *data, Evas_Object *obj, const char *part); /**< Icon fetching class function for gengrid item classes. */
   typedef Eina_Bool    (*GridItemStateGetFunc) (void *data, Evas_Object *obj, const char *part); /**< State fetching class function for gengrid item classes. */
   typedef void         (*GridItemDelFunc)      (void *data, Evas_Object *obj); /**< Deletion class function for gengrid item classes. */

   /**
    * @struct _Elm_Gengrid_Item_Class
    *
    * Gengrid item class definition. See @ref Gengrid_Item_Class for
    * field details.
    */
   struct _Elm_Gengrid_Item_Class
     {
        const char             *item_style;
        struct _Elm_Gengrid_Item_Class_Func
          {
             GridItemLabelGetFunc  label_get;
             GridItemIconGetFunc   icon_get;
             GridItemStateGetFunc  state_get;
             GridItemDelFunc       del;
          } func;
     }; /**< #Elm_Gengrid_Item_Class member definitions */

   /**
    * Add a new gengrid widget to the given parent Elementary
    * (container) object
    *
    * @param parent The parent object
    * @return a new gengrid widget handle or @c NULL, on errors
    *
    * This function inserts a new gengrid widget on the canvas.
    *
    * @see elm_gengrid_item_size_set()
    * @see elm_gengrid_horizontal_set()
    * @see elm_gengrid_item_append()
    * @see elm_gengrid_item_del()
    * @see elm_gengrid_clear()
    *
    * @ingroup Gengrid
    */
   EAPI Evas_Object       *elm_gengrid_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Set the size for the items of a given gengrid widget
    *
    * @param obj The gengrid object.
    * @param w The items' width.
    * @param h The items' height;
    *
    * A gengrid, after creation, has still no information on the size
    * to give to each of its cells. So, you most probably will end up
    * with squares one @ref Fingers "finger" wide, the default
    * size. Use this function to force a custom size for you items,
    * making them as big as you wish.
    *
    * @see elm_gengrid_item_size_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_size_set(Evas_Object *obj, Evas_Coord w, Evas_Coord h) EINA_ARG_NONNULL(1);

   /**
    * Get the size set for the items of a given gengrid widget
    *
    * @param obj The gengrid object.
    * @param w Pointer to a variable where to store the items' width.
    * @param h Pointer to a variable where to store the items' height.
    *
    * @note Use @c NULL pointers on the size values you're not
    * interested in: they'll be ignored by the function.
    *
    * @see elm_gengrid_item_size_get() for more details
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_size_get(const Evas_Object *obj, Evas_Coord *w, Evas_Coord *h) EINA_ARG_NONNULL(1);

   /**
    * Set the items grid's alignment within a given gengrid widget
    *
    * @param obj The gengrid object.
    * @param align_x Alignment in the horizontal axis (0 <= align_x <= 1).
    * @param align_y Alignment in the vertical axis (0 <= align_y <= 1).
    *
    * This sets the alignment of the whole grid of items of a gengrid
    * within its given viewport. By default, those values are both
    * 0.5, meaning that the gengrid will have its items grid placed
    * exactly in the middle of its viewport.
    *
    * @note If given alignment values are out of the cited ranges,
    * they'll be changed to the nearest boundary values on the valid
    * ranges.
    *
    * @see elm_gengrid_align_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_align_set(Evas_Object *obj, double align_x, double align_y) EINA_ARG_NONNULL(1);

   /**
    * Get the items grid's alignment values within a given gengrid
    * widget
    *
    * @param obj The gengrid object.
    * @param align_x Pointer to a variable where to store the
    * horizontal alignment.
    * @param align_y Pointer to a variable where to store the vertical
    * alignment.
    *
    * @note Use @c NULL pointers on the alignment values you're not
    * interested in: they'll be ignored by the function.
    *
    * @see elm_gengrid_align_set() for more details
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_align_get(const Evas_Object *obj, double *align_x, double *align_y) EINA_ARG_NONNULL(1);

   /**
    * Set whether a given gengrid widget is or not able have items
    * @b reordered
    *
    * @param obj The gengrid object
    * @param reorder_mode Use @c EINA_TRUE to turn reoderding on,
    * @c EINA_FALSE to turn it off
    *
    * If a gengrid is set to allow reordering, a click held for more
    * than 0.5 over a given item will highlight it specially,
    * signalling the gengrid has entered the reordering state. From
    * that time on, the user will be able to, while still holding the
    * mouse button down, move the item freely in the gengrid's
    * viewport, replacing to said item to the locations it goes to.
    * The replacements will be animated and, whenever the user
    * releases the mouse button, the item being replaced gets a new
    * definitive place in the grid.
    *
    * @see elm_gengrid_reorder_mode_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_reorder_mode_set(Evas_Object *obj, Eina_Bool reorder_mode) EINA_ARG_NONNULL(1);

   /**
    * Get whether a given gengrid widget is or not able have items
    * @b reordered
    *
    * @param obj The gengrid object
    * @return @c EINA_TRUE, if reoderding is on, @c EINA_FALSE if it's
    * off
    *
    * @see elm_gengrid_reorder_mode_set() for more details
    *
    * @ingroup Gengrid
    */
   EAPI Eina_Bool          elm_gengrid_reorder_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Append a new item in a given gengrid widget.
    *
    * @param obj The gengrid object.
    * @param gic The item class for the item.
    * @param data The item data.
    * @param func Convenience function called when the item is
    * selected.
    * @param func_data Data to be passed to @p func.
    * @return A handle to the item added or @c NULL, on errors.
    *
    * This adds an item to the beginning of the gengrid.
    *
    * @see elm_gengrid_item_prepend()
    * @see elm_gengrid_item_insert_before()
    * @see elm_gengrid_item_insert_after()
    * @see elm_gengrid_item_del()
    *
    * @ingroup Gengrid
    */
   EAPI Elm_Gengrid_Item  *elm_gengrid_item_append(Evas_Object *obj, const Elm_Gengrid_Item_Class *gic, const void *data, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);

   /**
    * Prepend a new item in a given gengrid widget.
    *
    * @param obj The gengrid object.
    * @param gic The item class for the item.
    * @param data The item data.
    * @param func Convenience function called when the item is
    * selected.
    * @param func_data Data to be passed to @p func.
    * @return A handle to the item added or @c NULL, on errors.
    *
    * This adds an item to the end of the gengrid.
    *
    * @see elm_gengrid_item_append()
    * @see elm_gengrid_item_insert_before()
    * @see elm_gengrid_item_insert_after()
    * @see elm_gengrid_item_del()
    *
    * @ingroup Gengrid
    */
   EAPI Elm_Gengrid_Item  *elm_gengrid_item_prepend(Evas_Object *obj, const Elm_Gengrid_Item_Class *gic, const void *data, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);

   /**
    * Insert an item before another in a gengrid widget
    *
    * @param obj The gengrid object.
    * @param gic The item class for the item.
    * @param data The item data.
    * @param relative The item to place this new one before.
    * @param func Convenience function called when the item is
    * selected.
    * @param func_data Data to be passed to @p func.
    * @return A handle to the item added or @c NULL, on errors.
    *
    * This inserts an item before another in the gengrid.
    *
    * @see elm_gengrid_item_append()
    * @see elm_gengrid_item_prepend()
    * @see elm_gengrid_item_insert_after()
    * @see elm_gengrid_item_del()
    *
    * @ingroup Gengrid
    */
   EAPI Elm_Gengrid_Item  *elm_gengrid_item_insert_before(Evas_Object *obj, const Elm_Gengrid_Item_Class *gic, const void *data, Elm_Gengrid_Item *relative, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);

   /**
    * Insert an item after another in a gengrid widget
    *
    * @param obj The gengrid object.
    * @param gic The item class for the item.
    * @param data The item data.
    * @param relative The item to place this new one after.
    * @param func Convenience function called when the item is
    * selected.
    * @param func_data Data to be passed to @p func.
    * @return A handle to the item added or @c NULL, on errors.
    *
    * This inserts an item after another in the gengrid.
    *
    * @see elm_gengrid_item_append()
    * @see elm_gengrid_item_prepend()
    * @see elm_gengrid_item_insert_after()
    * @see elm_gengrid_item_del()
    *
    * @ingroup Gengrid
    */
   EAPI Elm_Gengrid_Item  *elm_gengrid_item_insert_after(Evas_Object *obj, const Elm_Gengrid_Item_Class *gic, const void *data, Elm_Gengrid_Item *relative, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);

   EAPI Elm_Gengrid_Item  *elm_gengrid_item_sorted_insert(Evas_Object *obj, const Elm_Gengrid_Item_Class *gic, const void *data, Eina_Compare_Cb comp, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);

   EAPI Elm_Gengrid_Item  *elm_gengrid_item_direct_sorted_insert(Evas_Object *obj, const Elm_Gengrid_Item_Class *gic, const void *data, Eina_Compare_Cb comp, Evas_Smart_Cb func, const void *func_data);

   /**
    * Set whether items on a given gengrid widget are to get their
    * selection callbacks issued for @b every subsequent selection
    * click on them or just for the first click.
    *
    * @param obj The gengrid object
    * @param always_select @c EINA_TRUE to make items "always
    * selected", @c EINA_FALSE, otherwise
    *
    * By default, grid items will only call their selection callback
    * function when firstly getting selected, any subsequent further
    * clicks will do nothing. With this call, you make those
    * subsequent clicks also to issue the selection callbacks.
    *
    * @note <b>Double clicks</b> will @b always be reported on items.
    *
    * @see elm_gengrid_always_select_mode_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_always_select_mode_set(Evas_Object *obj, Eina_Bool always_select) EINA_ARG_NONNULL(1);

   /**
    * Get whether items on a given gengrid widget have their selection
    * callbacks issued for @b every subsequent selection click on them
    * or just for the first click.
    *
    * @param obj The gengrid object.
    * @return @c EINA_TRUE if the gengrid items are "always selected",
    * @c EINA_FALSE, otherwise
    *
    * @see elm_gengrid_always_select_mode_set() for more details
    *
    * @ingroup Gengrid
    */
   EAPI Eina_Bool          elm_gengrid_always_select_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set whether items on a given gengrid widget can be selected or not.
    *
    * @param obj The gengrid object
    * @param no_select @c EINA_TRUE to make items selectable,
    * @c EINA_FALSE otherwise
    *
    * This will make items in @obj selectable or not. In the latter
    * case, any user interacion on the gendrid items will neither make
    * them appear selected nor them call their selection callback
    * functions.
    *
    * @see elm_gengrid_no_select_mode_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_no_select_mode_set(Evas_Object *obj, Eina_Bool no_select) EINA_ARG_NONNULL(1);

   /**
    * Get whether items on a given gengrid widget can be selected or
    * not.
    *
    * @param obj The gengrid object
    * @return @c EINA_TRUE, if items are selectable, @c EINA_FALSE
    * otherwise
    *
    * @see elm_gengrid_no_select_mode_set() for more details
    *
    * @ingroup Gengrid
    */
   EAPI Eina_Bool          elm_gengrid_no_select_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Enable or disable multi-selection in a given gengrid widget
    *
    * @param obj The gengrid object.
    * @param multi @c EINA_TRUE, to enable multi-selection,
    * @c EINA_FALSE to disable it.
    *
    * Multi-selection is the ability for one to have @b more than one
    * item selected, on a given gengrid, simultaneously. When it is
    * enabled, a sequence of clicks on different items will make them
    * all selected, progressively. A click on an already selected item
    * will unselect it. If interecting via the keyboard,
    * multi-selection is enabled while holding the "Shift" key.
    *
    * @note By default, multi-selection is @b disabled on gengrids
    *
    * @see elm_gengrid_multi_select_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_multi_select_set(Evas_Object *obj, Eina_Bool multi) EINA_ARG_NONNULL(1);

   /**
    * Get whether multi-selection is enabled or disabled for a given
    * gengrid widget
    *
    * @param obj The gengrid object.
    * @return @c EINA_TRUE, if multi-selection is enabled, @c
    * EINA_FALSE otherwise
    *
    * @see elm_gengrid_multi_select_set() for more details
    *
    * @ingroup Gengrid
    */
   EAPI Eina_Bool          elm_gengrid_multi_select_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Enable or disable bouncing effect for a given gengrid widget
    *
    * @param obj The gengrid object
    * @param h_bounce @c EINA_TRUE, to enable @b horizontal bouncing,
    * @c EINA_FALSE to disable it
    * @param v_bounce @c EINA_TRUE, to enable @b vertical bouncing,
    * @c EINA_FALSE to disable it
    *
    * The bouncing effect occurs whenever one reaches the gengrid's
    * edge's while panning it -- it will scroll past its limits a
    * little bit and return to the edge again, in a animated for,
    * automatically.
    *
    * @note By default, gengrids have bouncing enabled on both axis
    *
    * @see elm_gengrid_bounce_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);

   /**
    * Get whether bouncing effects are enabled or disabled, for a
    * given gengrid widget, on each axis
    *
    * @param obj The gengrid object
    * @param h_bounce Pointer to a variable where to store the
    * horizontal bouncing flag.
    * @param v_bounce Pointer to a variable where to store the
    * vertical bouncing flag.
    *
    * @see elm_gengrid_bounce_set() for more details
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);

   /**
    * Set a given gengrid widget's scrolling page size, relative to
    * its viewport size.
    *
    * @param obj The gengrid object
    * @param h_pagerel The horizontal page (relative) size
    * @param v_pagerel The vertical page (relative) size
    *
    * The gengrid's scroller is capable of binding scrolling by the
    * user to "pages". It means that, while scrolling and, specially
    * after releasing the mouse button, the grid will @b snap to the
    * nearest displaying page's area. When page sizes are set, the
    * grid's continuous content area is split into (equal) page sized
    * pieces.
    *
    * This function sets the size of a page <b>relatively to the
    * viewport dimensions</b> of the gengrid, for each axis. A value
    * @c 1.0 means "the exact viewport's size", in that axis, while @c
    * 0.0 turns paging off in that axis. Likewise, @c 0.5 means "half
    * a viewport". Sane usable values are, than, between @c 0.0 and @c
    * 1.0. Values beyond those will make it behave behave
    * inconsistently. If you only want one axis to snap to pages, use
    * the value @c 0.0 for the other one.
    *
    * There is a function setting page size values in @b absolute
    * values, too -- elm_gengrid_page_size_set(). Naturally, its use
    * is mutually exclusive to this one.
    *
    * @see elm_gengrid_page_relative_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_page_relative_set(Evas_Object *obj, double h_pagerel, double v_pagerel) EINA_ARG_NONNULL(1);

   /**
    * Get a given gengrid widget's scrolling page size, relative to
    * its viewport size.
    *
    * @param obj The gengrid object
    * @param h_pagerel Pointer to a variable where to store the
    * horizontal page (relative) size
    * @param v_pagerel Pointer to a variable where to store the
    * vertical page (relative) size
    *
    * @see elm_gengrid_page_relative_set() for more details
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_page_relative_get(const Evas_Object *obj, double *h_pagerel, double *v_pagerel) EINA_ARG_NONNULL(1);

   /**
    * Set a given gengrid widget's scrolling page size
    *
    * @param obj The gengrid object
    * @param h_pagerel The horizontal page size, in pixels
    * @param v_pagerel The vertical page size, in pixels
    *
    * The gengrid's scroller is capable of binding scrolling by the
    * user to "pages". It means that, while scrolling and, specially
    * after releasing the mouse button, the grid will @b snap to the
    * nearest displaying page's area. When page sizes are set, the
    * grid's continuous content area is split into (equal) page sized
    * pieces.
    *
    * This function sets the size of a page of the gengrid, in pixels,
    * for each axis. Sane usable values are, between @c 0 and the
    * dimensions of @p obj, for each axis. Values beyond those will
    * make it behave behave inconsistently. If you only want one axis
    * to snap to pages, use the value @c 0 for the other one.
    *
    * There is a function setting page size values in @b relative
    * values, too -- elm_gengrid_page_relative_set(). Naturally, its
    * use is mutually exclusive to this one.
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_page_size_set(Evas_Object *obj, Evas_Coord h_pagesize, Evas_Coord v_pagesize) EINA_ARG_NONNULL(1);

   /**
    * Set for what direction a given gengrid widget will expand while
    * placing its items.
    *
    * @param obj The gengrid object.
    * @param setting @c EINA_TRUE to make the gengrid expand
    * horizontally, @c EINA_FALSE to expand vertically.
    *
    * When in "horizontal mode" (@c EINA_TRUE), items will be placed
    * in @b columns, from top to bottom and, when the space for a
    * column is filled, another one is started on the right, thus
    * expanding the grid horizontally. When in "vertical mode"
    * (@c EINA_FALSE), though, items will be placed in @b rows, from left
    * to right and, when the space for a row is filled, another one is
    * started below, thus expanding the grid vertically.
    *
    * @see elm_gengrid_horizontal_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_horizontal_set(Evas_Object *obj, Eina_Bool setting) EINA_ARG_NONNULL(1);

   /**
    * Get for what direction a given gengrid widget will expand while
    * placing its items.
    *
    * @param obj The gengrid object.
    * @return @c EINA_TRUE, if @p obj is set to expand horizontally,
    * @c EINA_FALSE if it's set to expand vertically.
    *
    * @see elm_gengrid_horizontal_set() for more detais
    *
    * @ingroup Gengrid
    */
   EAPI Eina_Bool          elm_gengrid_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the first item in a given gengrid widget
    *
    * @param obj The gengrid object
    * @return The first item's handle or @c NULL, if there are no
    * items in @p obj (and on errors)
    *
    * This returns the first item in the @p obj's internal list of
    * items.
    *
    * @see elm_gengrid_last_item_get()
    *
    * @ingroup Gengrid
    */
   EAPI Elm_Gengrid_Item  *elm_gengrid_first_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the last item in a given gengrid widget
    *
    * @param obj The gengrid object
    * @return The last item's handle or @c NULL, if there are no
    * items in @p obj (and on errors)
    *
    * This returns the last item in the @p obj's internal list of
    * items.
    *
    * @see elm_gengrid_first_item_get()
    *
    * @ingroup Gengrid
    */
   EAPI Elm_Gengrid_Item  *elm_gengrid_last_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the @b next item in a gengrid widget's internal list of items,
    * given a handle to one of those items.
    *
    * @param item The gengrid item to fetch next from
    * @return The item after @p item, or @c NULL if there's none (and
    * on errors)
    *
    * This returns the item placed after the @p item, on the container
    * gengrid.
    *
    * @see elm_gengrid_item_prev_get()
    *
    * @ingroup Gengrid
    */
   EAPI Elm_Gengrid_Item  *elm_gengrid_item_next_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Get the @b previous item in a gengrid widget's internal list of items,
    * given a handle to one of those items.
    *
    * @param item The gengrid item to fetch previous from
    * @return The item before @p item, or @c NULL if there's none (and
    * on errors)
    *
    * This returns the item placed before the @p item, on the container
    * gengrid.
    *
    * @see elm_gengrid_item_next_get()
    *
    * @ingroup Gengrid
    */
   EAPI Elm_Gengrid_Item  *elm_gengrid_item_prev_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Get the gengrid object's handle which contains a given gengrid
    * item
    *
    * @param item The item to fetch the container from
    * @return The gengrid (parent) object
    *
    * This returns the gengrid object itself that an item belongs to.
    *
    * @ingroup Gengrid
    */
   EAPI Evas_Object       *elm_gengrid_item_gengrid_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Remove a gengrid item from the its parent, deleting it.
    *
    * @param item The item to be removed.
    * @return @c EINA_TRUE on success or @c EINA_FALSE, otherwise.
    *
    * @see elm_gengrid_clear(), to remove all items in a gengrid at
    * once.
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_del(Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Update the contents of a given gengrid item
    *
    * @param item The gengrid item
    *
    * This updates an item by calling all the item class functions
    * again to get the icons, labels and states. Use this when the
    * original item data has changed and you want thta changes to be
    * reflected.
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_update(Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI const Elm_Gengrid_Item_Class *elm_gengrid_item_item_class_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_item_class_set(Elm_Gengrid_Item *item, const Elm_Gengrid_Item_Class *gic) EINA_ARG_NONNULL(1, 2);

   /**
    * Return the data associated to a given gengrid item
    *
    * @param item The gengrid item.
    * @return the data associated to this item.
    *
    * This returns the @c data value passed on the
    * elm_gengrid_item_append() and related item addition calls.
    *
    * @see elm_gengrid_item_append()
    * @see elm_gengrid_item_data_set()
    *
    * @ingroup Gengrid
    */
   EAPI void              *elm_gengrid_item_data_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the data associated to a given gengrid item
    *
    * @param item The gengrid item
    * @param data The new data pointer to set on it
    *
    * This @b overrides the @c data value passed on the
    * elm_gengrid_item_append() and related item addition calls. This
    * function @b won't call elm_gengrid_item_update() automatically,
    * so you'd issue it afterwards if you want to hove the item
    * updated to reflect the that new data.
    *
    * @see elm_gengrid_item_data_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_data_set(Elm_Gengrid_Item *item, const void *data) EINA_ARG_NONNULL(1);

   /**
    * Get a given gengrid item's position, relative to the whole
    * gengrid's grid area.
    *
    * @param item The Gengrid item.
    * @param x Pointer to variable where to store the item's <b>row
    * number</b>.
    * @param y Pointer to variable where to store the item's <b>column
    * number</b>.
    *
    * This returns the "logical" position of the item whithin the
    * gengrid. For example, @c (0, 1) would stand for first row,
    * second column.
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_pos_get(const Elm_Gengrid_Item *item, unsigned int *x, unsigned int *y) EINA_ARG_NONNULL(1);

   /**
    * Set whether a given gengrid item is selected or not
    *
    * @param item The gengrid item
    * @param selected Use @c EINA_TRUE, to make it selected, @c
    * EINA_FALSE to make it unselected
    *
    * This sets the selected state of an item. If multi selection is
    * not enabled on the containing gengrid and @p selected is @c
    * EINA_TRUE, any other previously selected items will get
    * unselected in favor of this new one.
    *
    * @see elm_gengrid_item_selected_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_selected_set(Elm_Gengrid_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);

   /**
    * Get whether a given gengrid item is selected or not
    *
    * @param item The gengrid item
    * @return @c EINA_TRUE, if it's selected, @c EINA_FALSE otherwise
    *
    * @see elm_gengrid_item_selected_set() for more details
    *
    * @ingroup Gengrid
    */
   EAPI Eina_Bool          elm_gengrid_item_selected_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Get the real Evas object created to implement the view of a
    * given gengrid item
    *
    * @param item The gengrid item.
    * @return the Evas object implementing this item's view.
    *
    * This returns the actual Evas object used to implement the
    * specified gengrid item's view. This may be @c NULL, as it may
    * not have been created or may have been deleted, at any time, by
    * the gengrid. <b>Do not modify this object</b> (move, resize,
    * show, hide, etc.), as the gengrid is controlling it. This
    * function is for querying, emitting custom signals or hooking
    * lower level callbacks for events on that object. Do not delete
    * this object under any circumstances.
    *
    * @see elm_gengrid_item_data_get()
    *
    * @ingroup Gengrid
    */
   EAPI const Evas_Object *elm_gengrid_item_object_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Show the portion of a gengrid's internal grid containing a given
    * item, @b immediately.
    *
    * @param item The item to display
    *
    * This causes gengrid to @b redraw its viewport's contents to the
    * region contining the given @p item item, if it is not fully
    * visible.
    *
    * @see elm_gengrid_item_bring_in()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_show(Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Animatedly bring in, to the visible are of a gengrid, a given
    * item on it.
    *
    * @param item The gengrid item to display
    *
    * This causes gengrig to jump to the given @p item item and show
    * it (by scrolling), if it is not fully visible. This will use
    * animation to do so and take a period of time to complete.
    *
    * @see elm_gengrid_item_show()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_bring_in(Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set whether a given gengrid item is disabled or not.
    *
    * @param item The gengrid item
    * @param disabled Use @c EINA_TRUE, true disable it, @c EINA_FALSE
    * to enable it back.
    *
    * A disabled item cannot be selected or unselected. It will also
    * change its appearance, to signal the user it's disabled.
    *
    * @see elm_gengrid_item_disabled_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_disabled_set(Elm_Gengrid_Item *item, Eina_Bool disabled) EINA_ARG_NONNULL(1);

   /**
    * Get whether a given gengrid item is disabled or not.
    *
    * @param item The gengrid item
    * @return @c EINA_TRUE, if it's disabled, @c EINA_FALSE otherwise
    * (and on errors).
    *
    * @see elm_gengrid_item_disabled_set() for more details
    *
    * @ingroup Gengrid
    */
   EAPI Eina_Bool          elm_gengrid_item_disabled_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the text to be shown in a given gengrid item's tooltips.
    *
    * @param item The gengrid item
    * @param text The text to set in the content
    *
    * This call will setup the text to be used as tooltip to that item
    * (analogous to elm_object_tooltip_text_set(), but being item
    * tooltips with higher precedence than object tooltips). It can
    * have only one tooltip at a time, so any previous tooltip data
    * will get removed.
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_tooltip_text_set(Elm_Gengrid_Item *item, const char *text) EINA_ARG_NONNULL(1);

   /**
    * Set the content to be shown in a given gengrid item's tooltips
    *
    * @param item The gengrid item.
    * @param func The function returning the tooltip contents.
    * @param data What to provide to @a func as callback data/context.
    * @param del_cb Called when data is not needed anymore, either when
    *        another callback replaces @func, the tooltip is unset with
    *        elm_gengrid_item_tooltip_unset() or the owner @p item
    *        dies. This callback receives as its first parameter the
    *        given @p data, being @c event_info the item handle.
    *
    * This call will setup the tooltip's contents to @p item
    * (analogous to elm_object_tooltip_content_cb_set(), but being
    * item tooltips with higher precedence than object tooltips). It
    * can have only one tooltip at a time, so any previous tooltip
    * content will get removed. @p func (with @p data) will be called
    * every time Elementary needs to show the tooltip and it should
    * return a valid Evas object, which will be fully managed by the
    * tooltip system, getting deleted when the tooltip is gone.
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_tooltip_content_cb_set(Elm_Gengrid_Item *item, Elm_Tooltip_Item_Content_Cb func, const void *data, Evas_Smart_Cb del_cb) EINA_ARG_NONNULL(1);

   /**
    * Unset a tooltip from a given gengrid item
    *
    * @param item gengrid item to remove a previously set tooltip from.
    *
    * This call removes any tooltip set on @p item. The callback
    * provided as @c del_cb to
    * elm_gengrid_item_tooltip_content_cb_set() will be called to
    * notify it is not used anymore (and have resources cleaned, if
    * need be).
    *
    * @see elm_gengrid_item_tooltip_content_cb_set()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_tooltip_unset(Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set a different @b style for a given gengrid item's tooltip.
    *
    * @param item gengrid item with tooltip set
    * @param style the <b>theme style</b> to use on tooltips (e.g. @c
    * "default", @c "transparent", etc)
    *
    * Tooltips can have <b>alternate styles</b> to be displayed on,
    * which are defined by the theme set on Elementary. This function
    * works analogously as elm_object_tooltip_style_set(), but here
    * applied only to gengrid item objects. The default style for
    * tooltips is @c "default".
    *
    * @note before you set a style you should define a tooltip with
    *       elm_gengrid_item_tooltip_content_cb_set() or
    *       elm_gengrid_item_tooltip_text_set()
    *
    * @see elm_gengrid_item_tooltip_style_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_tooltip_style_set(Elm_Gengrid_Item *item, const char *style) EINA_ARG_NONNULL(1);

   /**
    * Get the style set a given gengrid item's tooltip.
    *
    * @param item gengrid item with tooltip already set on.
    * @return style the theme style in use, which defaults to
    *         "default". If the object does not have a tooltip set,
    *         then @c NULL is returned.
    *
    * @see elm_gengrid_item_tooltip_style_set() for more details
    *
    * @ingroup Gengrid
    */
   EAPI const char        *elm_gengrid_item_tooltip_style_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   /**
    * @brief Disable size restrictions on an object's tooltip
    * @param item The tooltip's anchor object
    * @param disable If EINA_TRUE, size restrictions are disabled
    * @return EINA_FALSE on failure, EINA_TRUE on success
    *
    * This function allows a tooltip to expand beyond its parant window's canvas.
    * It will instead be limited only by the size of the display.
    */
   EAPI Eina_Bool          elm_gengrid_item_tooltip_size_restrict_disable(Elm_Gengrid_Item *item, Eina_Bool disable);
   /**
    * @brief Retrieve size restriction state of an object's tooltip
    * @param item The tooltip's anchor object
    * @return If EINA_TRUE, size restrictions are disabled
    *
    * This function returns whether a tooltip is allowed to expand beyond
    * its parant window's canvas.
    * It will instead be limited only by the size of the display.
    */
   EAPI Eina_Bool          elm_gengrid_item_tooltip_size_restrict_disabled_get(const Elm_Gengrid_Item *item);
   /**
    * Set the type of mouse pointer/cursor decoration to be shown,
    * when the mouse pointer is over the given gengrid widget item
    *
    * @param item gengrid item to customize cursor on
    * @param cursor the cursor type's name
    *
    * This function works analogously as elm_object_cursor_set(), but
    * here the cursor's changing area is restricted to the item's
    * area, and not the whole widget's. Note that that item cursors
    * have precedence over widget cursors, so that a mouse over @p
    * item will always show cursor @p type.
    *
    * If this function is called twice for an object, a previously set
    * cursor will be unset on the second call.
    *
    * @see elm_object_cursor_set()
    * @see elm_gengrid_item_cursor_get()
    * @see elm_gengrid_item_cursor_unset()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_cursor_set(Elm_Gengrid_Item *item, const char *cursor) EINA_ARG_NONNULL(1);

   /**
    * Get the type of mouse pointer/cursor decoration set to be shown,
    * when the mouse pointer is over the given gengrid widget item
    *
    * @param item gengrid item with custom cursor set
    * @return the cursor type's name or @c NULL, if no custom cursors
    * were set to @p item (and on errors)
    *
    * @see elm_object_cursor_get()
    * @see elm_gengrid_item_cursor_set() for more details
    * @see elm_gengrid_item_cursor_unset()
    *
    * @ingroup Gengrid
    */
   EAPI const char        *elm_gengrid_item_cursor_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Unset any custom mouse pointer/cursor decoration set to be
    * shown, when the mouse pointer is over the given gengrid widget
    * item, thus making it show the @b default cursor again.
    *
    * @param item a gengrid item
    *
    * Use this call to undo any custom settings on this item's cursor
    * decoration, bringing it back to defaults (no custom style set).
    *
    * @see elm_object_cursor_unset()
    * @see elm_gengrid_item_cursor_set() for more details
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_cursor_unset(Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set a different @b style for a given custom cursor set for a
    * gengrid item.
    *
    * @param item gengrid item with custom cursor set
    * @param style the <b>theme style</b> to use (e.g. @c "default",
    * @c "transparent", etc)
    *
    * This function only makes sense when one is using custom mouse
    * cursor decorations <b>defined in a theme file</b> , which can
    * have, given a cursor name/type, <b>alternate styles</b> on
    * it. It works analogously as elm_object_cursor_style_set(), but
    * here applied only to gengrid item objects.
    *
    * @warning Before you set a cursor style you should have defined a
    *       custom cursor previously on the item, with
    *       elm_gengrid_item_cursor_set()
    *
    * @see elm_gengrid_item_cursor_engine_only_set()
    * @see elm_gengrid_item_cursor_style_get()
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_cursor_style_set(Elm_Gengrid_Item *item, const char *style) EINA_ARG_NONNULL(1);

   /**
    * Get the current @b style set for a given gengrid item's custom
    * cursor
    *
    * @param item gengrid item with custom cursor set.
    * @return style the cursor style in use. If the object does not
    *         have a cursor set, then @c NULL is returned.
    *
    * @see elm_gengrid_item_cursor_style_set() for more details
    *
    * @ingroup Gengrid
    */
   EAPI const char        *elm_gengrid_item_cursor_style_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set if the (custom) cursor for a given gengrid item should be
    * searched in its theme, also, or should only rely on the
    * rendering engine.
    *
    * @param item item with custom (custom) cursor already set on
    * @param engine_only Use @c EINA_TRUE to have cursors looked for
    * only on those provided by the rendering engine, @c EINA_FALSE to
    * have them searched on the widget's theme, as well.
    *
    * @note This call is of use only if you've set a custom cursor
    * for gengrid items, with elm_gengrid_item_cursor_set().
    *
    * @note By default, cursors will only be looked for between those
    * provided by the rendering engine.
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_item_cursor_engine_only_set(Elm_Gengrid_Item *item, Eina_Bool engine_only) EINA_ARG_NONNULL(1);

   /**
    * Get if the (custom) cursor for a given gengrid item is being
    * searched in its theme, also, or is only relying on the rendering
    * engine.
    *
    * @param item a gengrid item
    * @return @c EINA_TRUE, if cursors are being looked for only on
    * those provided by the rendering engine, @c EINA_FALSE if they
    * are being searched on the widget's theme, as well.
    *
    * @see elm_gengrid_item_cursor_engine_only_set(), for more details
    *
    * @ingroup Gengrid
    */
   EAPI Eina_Bool          elm_gengrid_item_cursor_engine_only_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Remove all items from a given gengrid widget
    *
    * @param obj The gengrid object.
    *
    * This removes (and deletes) all items in @p obj, leaving it
    * empty.
    *
    * @see elm_gengrid_item_del(), to remove just one item.
    *
    * @ingroup Gengrid
    */
   EAPI void               elm_gengrid_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the selected item in a given gengrid widget
    *
    * @param obj The gengrid object.
    * @return The selected item's handleor @c NULL, if none is
    * selected at the moment (and on errors)
    *
    * This returns the selected item in @p obj. If multi selection is
    * enabled on @p obj (@see elm_gengrid_multi_select_set()), only
    * the first item in the list is selected, which might not be very
    * useful. For that case, see elm_gengrid_selected_items_get().
    *
    * @ingroup Gengrid
    */
   EAPI Elm_Gengrid_Item  *elm_gengrid_selected_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get <b>a list</b> of selected items in a given gengrid
    *
    * @param obj The gengrid object.
    * @return The list of selected items or @c NULL, if none is
    * selected at the moment (and on errors)
    *
    * This returns a list of the selected items, in the order that
    * they appear in the grid. This list is only valid as long as no
    * more items are selected or unselected (or unselected implictly
    * by deletion). The list contains #Elm_Gengrid_Item pointers as
    * data, naturally.
    *
    * @see @elm_gengrid_selected_item_get()
    *
    * @ingroup Gengrid
    */
   EAPI const Eina_List   *elm_gengrid_selected_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @defgroup Clock Clock
    *
    * @image html img/widget/clock/preview-00.png
    * @image latex img/widget/clock/preview-00.eps
    *
    * This is a @b digital clock widget. In its default theme, it has a
    * vintage "flipping numbers clock" appearance, which will animate
    * sheets of individual algarisms individually as time goes by.
    *
    * A newly created clock will fetch system's time (already
    * considering local time adjustments) to start with, and will tick
    * accondingly. It may or may not show seconds.
    *
    * Clocks have an @b edition mode. When in it, the sheets will
    * display extra arrow indications on the top and bottom and the
    * user may click on them to raise or lower the time values. After
    * it's told to exit edition mode, it will keep ticking with that
    * new time set (it keeps the difference from local time).
    *
    * Also, when under edition mode, user clicks on the cited arrows
    * which are @b held for some time will make the clock to flip the
    * sheet, thus editing the time, continuosly and automatically for
    * the user. The interval between sheet flips will keep growing in
    * time, so that it helps the user to reach a time which is distant
    * from the one set.
    *
    * The time display is, by default, in military mode (24h), but an
    * am/pm indicator may be optionally shown, too, when it will
    * switch to 12h.
    *
    * Smart callbacks one can register to:
    * - "changed" - the clock's user changed the time
    *
    * Here is an example on its usage:
    * @li @ref clock_example
    */

   /**
    * @addtogroup Clock
    * @{
    */

   /**
    * Identifiers for which clock digits should be editable, when a
    * clock widget is in edition mode. Values may be ORed together to
    * make a mask, naturally.
    *
    * @see elm_clock_edit_set()
    * @see elm_clock_digit_edit_set()
    */
   typedef enum _Elm_Clock_Digedit
     {
        ELM_CLOCK_NONE         = 0, /**< Default value. Means that all digits are editable, when in edition mode. */
        ELM_CLOCK_HOUR_DECIMAL = 1 << 0, /**< Decimal algarism of hours value should be editable */
        ELM_CLOCK_HOUR_UNIT    = 1 << 1, /**< Unit algarism of hours value should be editable */
        ELM_CLOCK_MIN_DECIMAL  = 1 << 2, /**< Decimal algarism of minutes value should be editable */
        ELM_CLOCK_MIN_UNIT     = 1 << 3, /**< Unit algarism of minutes value should be editable */
        ELM_CLOCK_SEC_DECIMAL  = 1 << 4, /**< Decimal algarism of seconds value should be editable */
        ELM_CLOCK_SEC_UNIT     = 1 << 5, /**< Unit algarism of seconds value should be editable */
        ELM_CLOCK_ALL          = (1 << 6) - 1 /**< All digits should be editable */
     } Elm_Clock_Digedit;

   /**
    * Add a new clock widget to the given parent Elementary
    * (container) object
    *
    * @param parent The parent object
    * @return a new clock widget handle or @c NULL, on errors
    *
    * This function inserts a new clock widget on the canvas.
    *
    * @ingroup Clock
    */
   EAPI Evas_Object      *elm_clock_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Set a clock widget's time, programmatically
    *
    * @param obj The clock widget object
    * @param hrs The hours to set
    * @param min The minutes to set
    * @param sec The secondes to set
    *
    * This function updates the time that is showed by the clock
    * widget.
    *
    *  Values @b must be set within the following ranges:
    * - 0 - 23, for hours
    * - 0 - 59, for minutes
    * - 0 - 59, for seconds,
    *
    * even if the clock is not in "military" mode.
    *
    * @warning The behavior for values set out of those ranges is @b
    * indefined.
    *
    * @ingroup Clock
    */
   EAPI void              elm_clock_time_set(Evas_Object *obj, int hrs, int min, int sec) EINA_ARG_NONNULL(1);

   /**
    * Get a clock widget's time values
    *
    * @param obj The clock object
    * @param[out] hrs Pointer to the variable to get the hours value
    * @param[out] min Pointer to the variable to get the minutes value
    * @param[out] sec Pointer to the variable to get the seconds value
    *
    * This function gets the time set for @p obj, returning
    * it on the variables passed as the arguments to function
    *
    * @note Use @c NULL pointers on the time values you're not
    * interested in: they'll be ignored by the function.
    *
    * @ingroup Clock
    */
   EAPI void              elm_clock_time_get(const Evas_Object *obj, int *hrs, int *min, int *sec) EINA_ARG_NONNULL(1);

   /**
    * Set whether a given clock widget is under <b>edition mode</b> or
    * under (default) displaying-only mode.
    *
    * @param obj The clock object
    * @param edit @c EINA_TRUE to put it in edition, @c EINA_FALSE to
    * put it back to "displaying only" mode
    *
    * This function makes a clock's time to be editable or not <b>by
    * user interaction</b>. When in edition mode, clocks @b stop
    * ticking, until one brings them back to canonical mode. The
    * elm_clock_digit_edit_set() function will influence which digits
    * of the clock will be editable. By default, all of them will be
    * (#ELM_CLOCK_NONE).
    *
    * @note am/pm sheets, if being shown, will @b always be editable
    * under edition mode.
    *
    * @see elm_clock_edit_get()
    *
    * @ingroup Clock
    */
   EAPI void              elm_clock_edit_set(Evas_Object *obj, Eina_Bool edit) EINA_ARG_NONNULL(1);

   /**
    * Retrieve whether a given clock widget is under <b>edition
    * mode</b> or under (default) displaying-only mode.
    *
    * @param obj The clock object
    * @param edit @c EINA_TRUE, if it's in edition mode, @c EINA_FALSE
    * otherwise
    *
    * This function retrieves whether the clock's time can be edited
    * or not by user interaction.
    *
    * @see elm_clock_edit_set() for more details
    *
    * @ingroup Clock
    */
   EAPI Eina_Bool         elm_clock_edit_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set what digits of the given clock widget should be editable
    * when in edition mode.
    *
    * @param obj The clock object
    * @param digedit Bit mask indicating the digits to be editable
    * (values in #Elm_Clock_Digedit).
    *
    * If the @p digedit param is #ELM_CLOCK_NONE, editing will be
    * disabled on @p obj (same effect as elm_clock_edit_set(), with @c
    * EINA_FALSE).
    *
    * @see elm_clock_digit_edit_get()
    *
    * @ingroup Clock
    */
   EAPI void              elm_clock_digit_edit_set(Evas_Object *obj, Elm_Clock_Digedit digedit) EINA_ARG_NONNULL(1);

   /**
    * Retrieve what digits of the given clock widget should be
    * editable when in edition mode.
    *
    * @param obj The clock object
    * @return Bit mask indicating the digits to be editable
    * (values in #Elm_Clock_Digedit).
    *
    * @see elm_clock_digit_edit_set() for more details
    *
    * @ingroup Clock
    */
   EAPI Elm_Clock_Digedit elm_clock_digit_edit_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set if the given clock widget must show hours in military or
    * am/pm mode
    *
    * @param obj The clock object
    * @param am_pm @c EINA_TRUE to put it in am/pm mode, @c EINA_FALSE
    * to military mode
    *
    * This function sets if the clock must show hours in military or
    * am/pm mode. In some countries like Brazil the military mode
    * (00-24h-format) is used, in opposition to the USA, where the
    * am/pm mode is more commonly used.
    *
    * @see elm_clock_show_am_pm_get()
    *
    * @ingroup Clock
    */
   EAPI void              elm_clock_show_am_pm_set(Evas_Object *obj, Eina_Bool am_pm) EINA_ARG_NONNULL(1);

   /**
    * Get if the given clock widget shows hours in military or am/pm
    * mode
    *
    * @param obj The clock object
    * @return @c EINA_TRUE, if in am/pm mode, @c EINA_FALSE if in
    * military
    *
    * This function gets if the clock shows hours in military or am/pm
    * mode.
    *
    * @see elm_clock_show_am_pm_set() for more details
    *
    * @ingroup Clock
    */
   EAPI Eina_Bool         elm_clock_show_am_pm_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set if the given clock widget must show time with seconds or not
    *
    * @param obj The clock object
    * @param seconds @c EINA_TRUE to show seconds, @c EINA_FALSE otherwise
    *
    * This function sets if the given clock must show or not elapsed
    * seconds. By default, they are @b not shown.
    *
    * @see elm_clock_show_seconds_get()
    *
    * @ingroup Clock
    */
   EAPI void              elm_clock_show_seconds_set(Evas_Object *obj, Eina_Bool seconds) EINA_ARG_NONNULL(1);

   /**
    * Get whether the given clock widget is showing time with seconds
    * or not
    *
    * @param obj The clock object
    * @return @c EINA_TRUE if it's showing seconds, @c EINA_FALSE otherwise
    *
    * This function gets whether @p obj is showing or not the elapsed
    * seconds.
    *
    * @see elm_clock_show_seconds_set()
    *
    * @ingroup Clock
    */
   EAPI Eina_Bool         elm_clock_show_seconds_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the interval on time updates for an user mouse button hold
    * on clock widgets' time edition.
    *
    * @param obj The clock object
    * @param interval The (first) interval value in seconds
    *
    * This interval value is @b decreased while the user holds the
    * mouse pointer either incrementing or decrementing a given the
    * clock digit's value.
    *
    * This helps the user to get to a given time distant from the
    * current one easier/faster, as it will start to flip quicker and
    * quicker on mouse button holds.
    *
    * The calculation for the next flip interval value, starting from
    * the one set with this call, is the previous interval divided by
    * 1.05, so it decreases a little bit.
    *
    * The default starting interval value for automatic flips is
    * @b 0.85 seconds.
    *
    * @see elm_clock_interval_get()
    *
    * @ingroup Clock
    */
   EAPI void              elm_clock_interval_set(Evas_Object *obj, double interval) EINA_ARG_NONNULL(1);

   /**
    * Get the interval on time updates for an user mouse button hold
    * on clock widgets' time edition.
    *
    * @param obj The clock object
    * @return The (first) interval value, in seconds, set on it
    *
    * @see elm_clock_interval_set() for more details
    *
    * @ingroup Clock
    */
   EAPI double            elm_clock_interval_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

   /**
    * @defgroup Layout Layout
    *
    * @image html img/widget/layout/preview-00.png
    * @image latex img/widget/layout/preview-00.eps width=\textwidth
    *
    * @image html img/layout-predefined.png
    * @image latex img/layout-predefined.eps width=\textwidth
    *
    * This is a container widget that takes a standard Edje design file and
    * wraps it very thinly in a widget.
    *
    * An Edje design (theme) file has a very wide range of possibilities to
    * describe the behavior of elements added to the Layout. Check out the Edje
    * documentation and the EDC reference to get more information about what can
    * be done with Edje.
    *
    * Just like @ref List, @ref Box, and other container widgets, any
    * object added to the Layout will become its child, meaning that it will be
    * deleted if the Layout is deleted, move if the Layout is moved, and so on.
    *
    * The Layout widget can contain as many Contents, Boxes or Tables as
    * described in its theme file. For instance, objects can be added to
    * different Tables by specifying the respective Table part names. The same
    * is valid for Content and Box.
    *
    * The objects added as child of the Layout will behave as described in the
    * part description where they were added. There are 3 possible types of
    * parts where a child can be added:
    *
    * @section secContent Content (SWALLOW part)
    *
    * Only one object can be added to the @c SWALLOW part (but you still can
    * have many @c SWALLOW parts and one object on each of them). Use the @c
    * elm_layout_content_* set of functions to set, retrieve and unset objects
    * as content of the @c SWALLOW. After being set to this part, the object
    * size, position, visibility, clipping and other description properties
    * will be totally controled by the description of the given part (inside
    * the Edje theme file).
    *
    * One can use @c evas_object_size_hint_* functions on the child to have some
    * kind of control over its behavior, but the resulting behavior will still
    * depend heavily on the @c SWALLOW part description.
    *
    * The Edje theme also can change the part description, based on signals or
    * scripts running inside the theme. This change can also be animated. All of
    * this will affect the child object set as content accordingly. The object
    * size will be changed if the part size is changed, it will animate move if
    * the part is moving, and so on.
    *
    * The following picture demonstrates a Layout widget with a child object
    * added to its @c SWALLOW:
    *
    * @image html layout_swallow.png
    * @image latex layout_swallow.png width=\textwidth
    *
    * @section secBox Box (BOX part)
    *
    * An Edje @c BOX part is very similar to the Elementary @ref Box widget. It
    * allows one to add objects to the box and have them distributed along its
    * area, accordingly to the specified @a layout property (now by @a layout we
    * mean the chosen layouting design of the Box, not the Layout widget
    * itself).
    *
    * A similar effect for having a box with its position, size and other things
    * controled by the Layout theme would be to create an Elementary @ref Box
    * widget and add it as a Content in the @c SWALLOW part.
    *
    * The main difference of using the Layout Box is that its behavior, the box
    * properties like layouting format, padding, align, etc. will be all
    * controled by the theme. This means, for example, that a signal could be
    * sent to the Layout theme (with elm_object_signal_emit()) and the theme
    * handled the signal by changing the box padding, or align, or both. Using
    * the Elementary @ref Box widget is not necessarily harder or easier, it
    * just depends on the circunstances and requirements.
    *
    * The Layout Box can be used through the @c elm_layout_box_* set of
    * functions.
    *
    * The following picture demonstrates a Layout widget with many child objects
    * added to its @c BOX part:
    *
    * @image html layout_box.png
    * @image latex layout_box.png width=\textwidth
    *
    * @section secTable Table (TABLE part)
    *
    * Just like the @ref secBox, the Layout Table is very similar to the
    * Elementary @ref Table widget. It allows one to add objects to the Table
    * specifying the row and column where the object should be added, and any
    * column or row span if necessary.
    *
    * Again, we could have this design by adding a @ref Table widget to the @c
    * SWALLOW part using elm_layout_content_set(). The same difference happens
    * here when choosing to use the Layout Table (a @c TABLE part) instead of
    * the @ref Table plus @c SWALLOW part. It's just a matter of convenience.
    *
    * The Layout Table can be used through the @c elm_layout_table_* set of
    * functions.
    *
    * The following picture demonstrates a Layout widget with many child objects
    * added to its @c TABLE part:
    *
    * @image html layout_table.png
    * @image latex layout_table.png width=\textwidth
    *
    * @section secPredef Predefined Layouts
    *
    * Another interesting thing about the Layout widget is that it offers some
    * predefined themes that come with the default Elementary theme. These
    * themes can be set by the call elm_layout_theme_set(), and provide some
    * basic functionality depending on the theme used.
    *
    * Most of them already send some signals, some already provide a toolbar or
    * back and next buttons.
    *
    * These are available predefined theme layouts. All of them have class = @c
    * layout, group = @c application, and style = one of the following options:
    *
    * @li @c toolbar-content - application with toolbar and main content area
    * @li @c toolbar-content-back - application with toolbar and main content
    * area with a back button and title area
    * @li @c toolbar-content-back-next - application with toolbar and main
    * content area with a back and next buttons and title area
    * @li @c content-back - application with a main content area with a back
    * button and title area
    * @li @c content-back-next - application with a main content area with a
    * back and next buttons and title area
    * @li @c toolbar-vbox - application with toolbar and main content area as a
    * vertical box
    * @li @c toolbar-table - application with toolbar and main content area as a
    * table
    *
    * @section secExamples Examples
    *
    * Some examples of the Layout widget can be found here:
    * @li @ref layout_example_01
    * @li @ref layout_example_02
    * @li @ref layout_example_03
    * @li @ref layout_example_edc
    *
    */

   /**
    * Add a new layout to the parent
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    *
    * @see elm_layout_file_set()
    * @see elm_layout_theme_set()
    *
    * @ingroup Layout
    */
   EAPI Evas_Object       *elm_layout_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the file that will be used as layout
    *
    * @param obj The layout object
    * @param file The path to file (edj) that will be used as layout
    * @param group The group that the layout belongs in edje file
    *
    * @return (1 = success, 0 = error)
    *
    * @ingroup Layout
    */
   EAPI Eina_Bool          elm_layout_file_set(Evas_Object *obj, const char *file, const char *group) EINA_ARG_NONNULL(1);
   /**
    * Set the edje group from the elementary theme that will be used as layout
    *
    * @param obj The layout object
    * @param clas the clas of the group
    * @param group the group
    * @param style the style to used
    *
    * @return (1 = success, 0 = error)
    *
    * @ingroup Layout
    */
   EAPI Eina_Bool          elm_layout_theme_set(Evas_Object *obj, const char *clas, const char *group, const char *style) EINA_ARG_NONNULL(1);
   /**
    * Set the layout content.
    *
    * @param obj The layout object
    * @param swallow The swallow part name in the edje file
    * @param content The child that will be added in this layout object
    *
    * Once the content object is set, a previously set one will be deleted.
    * If you want to keep that old content object, use the
    * elm_layout_content_unset() function.
    *
    * @note In an Edje theme, the part used as a content container is called @c
    * SWALLOW. This is why the parameter name is called @p swallow, but it is
    * expected to be a part name just like the second parameter of
    * elm_layout_box_append().
    *
    * @see elm_layout_box_append()
    * @see elm_layout_content_get()
    * @see elm_layout_content_unset()
    * @see @ref secBox
    *
    * @ingroup Layout
    */
   EAPI void               elm_layout_content_set(Evas_Object *obj, const char *swallow, Evas_Object *content) EINA_ARG_NONNULL(1);
   /**
    * Get the child object in the given content part.
    *
    * @param obj The layout object
    * @param swallow The SWALLOW part to get its content
    *
    * @return The swallowed object or NULL if none or an error occurred
    *
    * @see elm_layout_content_set()
    *
    * @ingroup Layout
    */
   EAPI Evas_Object       *elm_layout_content_get(const Evas_Object *obj, const char *swallow) EINA_ARG_NONNULL(1);
   /**
    * Unset the layout content.
    *
    * @param obj The layout object
    * @param swallow The swallow part name in the edje file
    * @return The content that was being used
    *
    * Unparent and return the content object which was set for this part.
    *
    * @see elm_layout_content_set()
    *
    * @ingroup Layout
    */
   EAPI Evas_Object       *elm_layout_content_unset(Evas_Object *obj, const char *swallow) EINA_ARG_NONNULL(1);
   /**
    * Set the text of the given part
    *
    * @param obj The layout object
    * @param part The TEXT part where to set the text
    * @param text The text to set
    *
    * @ingroup Layout
    * @deprecated use elm_object_text_* instead.
    */
   EINA_DEPRECATED EAPI void               elm_layout_text_set(Evas_Object *obj, const char *part, const char *text) EINA_ARG_NONNULL(1);
   /**
    * Get the text set in the given part
    *
    * @param obj The layout object
    * @param part The TEXT part to retrieve the text off
    *
    * @return The text set in @p part
    *
    * @ingroup Layout
    * @deprecated use elm_object_text_* instead.
    */
   EINA_DEPRECATED EAPI const char        *elm_layout_text_get(const Evas_Object *obj, const char *part) EINA_ARG_NONNULL(1);
   /**
    * Append child to layout box part.
    *
    * @param obj the layout object
    * @param part the box part to which the object will be appended.
    * @param child the child object to append to box.
    *
    * Once the object is appended, it will become child of the layout. Its
    * lifetime will be bound to the layout, whenever the layout dies the child
    * will be deleted automatically. One should use elm_layout_box_remove() to
    * make this layout forget about the object.
    *
    * @see elm_layout_box_prepend()
    * @see elm_layout_box_insert_before()
    * @see elm_layout_box_insert_at()
    * @see elm_layout_box_remove()
    *
    * @ingroup Layout
    */
   EAPI void               elm_layout_box_append(Evas_Object *obj, const char *part, Evas_Object *child) EINA_ARG_NONNULL(1);
   /**
    * Prepend child to layout box part.
    *
    * @param obj the layout object
    * @param part the box part to prepend.
    * @param child the child object to prepend to box.
    *
    * Once the object is prepended, it will become child of the layout. Its
    * lifetime will be bound to the layout, whenever the layout dies the child
    * will be deleted automatically. One should use elm_layout_box_remove() to
    * make this layout forget about the object.
    *
    * @see elm_layout_box_append()
    * @see elm_layout_box_insert_before()
    * @see elm_layout_box_insert_at()
    * @see elm_layout_box_remove()
    *
    * @ingroup Layout
    */
   EAPI void               elm_layout_box_prepend(Evas_Object *obj, const char *part, Evas_Object *child) EINA_ARG_NONNULL(1);
   /**
    * Insert child to layout box part before a reference object.
    *
    * @param obj the layout object
    * @param part the box part to insert.
    * @param child the child object to insert into box.
    * @param reference another reference object to insert before in box.
    *
    * Once the object is inserted, it will become child of the layout. Its
    * lifetime will be bound to the layout, whenever the layout dies the child
    * will be deleted automatically. One should use elm_layout_box_remove() to
    * make this layout forget about the object.
    *
    * @see elm_layout_box_append()
    * @see elm_layout_box_prepend()
    * @see elm_layout_box_insert_before()
    * @see elm_layout_box_remove()
    *
    * @ingroup Layout
    */
   EAPI void               elm_layout_box_insert_before(Evas_Object *obj, const char *part, Evas_Object *child, const Evas_Object *reference) EINA_ARG_NONNULL(1);
   /**
    * Insert child to layout box part at a given position.
    *
    * @param obj the layout object
    * @param part the box part to insert.
    * @param child the child object to insert into box.
    * @param pos the numeric position >=0 to insert the child.
    *
    * Once the object is inserted, it will become child of the layout. Its
    * lifetime will be bound to the layout, whenever the layout dies the child
    * will be deleted automatically. One should use elm_layout_box_remove() to
    * make this layout forget about the object.
    *
    * @see elm_layout_box_append()
    * @see elm_layout_box_prepend()
    * @see elm_layout_box_insert_before()
    * @see elm_layout_box_remove()
    *
    * @ingroup Layout
    */
   EAPI void               elm_layout_box_insert_at(Evas_Object *obj, const char *part, Evas_Object *child, unsigned int pos) EINA_ARG_NONNULL(1);
   /**
    * Remove a child of the given part box.
    *
    * @param obj The layout object
    * @param part The box part name to remove child.
    * @param child The object to remove from box.
    * @return The object that was being used, or NULL if not found.
    *
    * The object will be removed from the box part and its lifetime will
    * not be handled by the layout anymore. This is equivalent to
    * elm_layout_content_unset() for box.
    *
    * @see elm_layout_box_append()
    * @see elm_layout_box_remove_all()
    *
    * @ingroup Layout
    */
   EAPI Evas_Object       *elm_layout_box_remove(Evas_Object *obj, const char *part, Evas_Object *child) EINA_ARG_NONNULL(1, 2, 3);
   /**
    * Remove all child of the given part box.
    *
    * @param obj The layout object
    * @param part The box part name to remove child.
    * @param clear If EINA_TRUE, then all objects will be deleted as
    *        well, otherwise they will just be removed and will be
    *        dangling on the canvas.
    *
    * The objects will be removed from the box part and their lifetime will
    * not be handled by the layout anymore. This is equivalent to
    * elm_layout_box_remove() for all box children.
    *
    * @see elm_layout_box_append()
    * @see elm_layout_box_remove()
    *
    * @ingroup Layout
    */
   EAPI void               elm_layout_box_remove_all(Evas_Object *obj, const char *part, Eina_Bool clear) EINA_ARG_NONNULL(1, 2);
   /**
    * Insert child to layout table part.
    *
    * @param obj the layout object
    * @param part the box part to pack child.
    * @param child_obj the child object to pack into table.
    * @param col the column to which the child should be added. (>= 0)
    * @param row the row to which the child should be added. (>= 0)
    * @param colspan how many columns should be used to store this object. (>=
    *        1)
    * @param rowspan how many rows should be used to store this object. (>= 1)
    *
    * Once the object is inserted, it will become child of the table. Its
    * lifetime will be bound to the layout, and whenever the layout dies the
    * child will be deleted automatically. One should use
    * elm_layout_table_remove() to make this layout forget about the object.
    *
    * If @p colspan or @p rowspan are bigger than 1, that object will occupy
    * more space than a single cell. For instance, the following code:
    * @code
    * elm_layout_table_pack(layout, "table_part", child, 0, 1, 3, 1);
    * @endcode
    *
    * Would result in an object being added like the following picture:
    *
    * @image html layout_colspan.png
    * @image latex layout_colspan.eps width=\textwidth
    *
    * @see elm_layout_table_unpack()
    * @see elm_layout_table_clear()
    *
    * @ingroup Layout
    */
   EAPI void               elm_layout_table_pack(Evas_Object *obj, const char *part, Evas_Object *child_obj, unsigned short col, unsigned short row, unsigned short colspan, unsigned short rowspan) EINA_ARG_NONNULL(1);
   /**
    * Unpack (remove) a child of the given part table.
    *
    * @param obj The layout object
    * @param part The table part name to remove child.
    * @param child_obj The object to remove from table.
    * @return The object that was being used, or NULL if not found.
    *
    * The object will be unpacked from the table part and its lifetime
    * will not be handled by the layout anymore. This is equivalent to
    * elm_layout_content_unset() for table.
    *
    * @see elm_layout_table_pack()
    * @see elm_layout_table_clear()
    *
    * @ingroup Layout
    */
   EAPI Evas_Object       *elm_layout_table_unpack(Evas_Object *obj, const char *part, Evas_Object *child_obj) EINA_ARG_NONNULL(1, 2, 3);
   /**
    * Remove all child of the given part table.
    *
    * @param obj The layout object
    * @param part The table part name to remove child.
    * @param clear If EINA_TRUE, then all objects will be deleted as
    *        well, otherwise they will just be removed and will be
    *        dangling on the canvas.
    *
    * The objects will be removed from the table part and their lifetime will
    * not be handled by the layout anymore. This is equivalent to
    * elm_layout_table_unpack() for all table children.
    *
    * @see elm_layout_table_pack()
    * @see elm_layout_table_unpack()
    *
    * @ingroup Layout
    */
   EAPI void               elm_layout_table_clear(Evas_Object *obj, const char *part, Eina_Bool clear) EINA_ARG_NONNULL(1, 2);
   /**
    * Get the edje layout
    *
    * @param obj The layout object
    *
    * @return A Evas_Object with the edje layout settings loaded
    * with function elm_layout_file_set
    *
    * This returns the edje object. It is not expected to be used to then
    * swallow objects via edje_object_part_swallow() for example. Use
    * elm_layout_content_set() instead so child object handling and sizing is
    * done properly.
    *
    * @note This function should only be used if you really need to call some
    * low level Edje function on this edje object. All the common stuff (setting
    * text, emitting signals, hooking callbacks to signals, etc.) can be done
    * with proper elementary functions.
    *
    * @see elm_object_signal_callback_add()
    * @see elm_object_signal_emit()
    * @see elm_object_text_part_set()
    * @see elm_layout_content_set()
    * @see elm_layout_box_append()
    * @see elm_layout_table_pack()
    * @see elm_layout_data_get()
    *
    * @ingroup Layout
    */
   EAPI Evas_Object       *elm_layout_edje_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Get the edje data from the given layout
    *
    * @param obj The layout object
    * @param key The data key
    *
    * @return The edje data string
    *
    * This function fetches data specified inside the edje theme of this layout.
    * This function return NULL if data is not found.
    *
    * In EDC this comes from a data block within the group block that @p
    * obj was loaded from. E.g.
    *
    * @code
    * collections {
    *   group {
    *     name: "a_group";
    *     data {
    *       item: "key1" "value1";
    *       item: "key2" "value2";
    *     }
    *   }
    * }
    * @endcode
    *
    * @ingroup Layout
    */
   EAPI const char        *elm_layout_data_get(const Evas_Object *obj, const char *key) EINA_ARG_NONNULL(1, 2);
   /**
    * Eval sizing
    *
    * @param obj The layout object
    *
    * Manually forces a sizing re-evaluation. This is useful when the minimum
    * size required by the edje theme of this layout has changed. The change on
    * the minimum size required by the edje theme is not immediately reported to
    * the elementary layout, so one needs to call this function in order to tell
    * the widget (layout) that it needs to reevaluate its own size.
    *
    * The minimum size of the theme is calculated based on minimum size of
    * parts, the size of elements inside containers like box and table, etc. All
    * of this can change due to state changes, and that's when this function
    * should be called.
    *
    * Also note that a standard signal of "size,eval" "elm" emitted from the
    * edje object will cause this to happen too.
    *
    * @ingroup Layout
    */
   EAPI void               elm_layout_sizing_eval(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_layout_part_cursor_set(Evas_Object *obj, const char *part_name, const char *cursor) EINA_ARG_NONNULL(1, 2);
   EAPI const char        *elm_layout_part_cursor_get(const Evas_Object *obj, const char *part_name) EINA_ARG_NONNULL(1, 2);
   EAPI void               elm_layout_part_cursor_unset(Evas_Object *obj, const char *part_name) EINA_ARG_NONNULL(1, 2);
   EAPI Eina_Bool          elm_layout_part_cursor_style_set(Evas_Object *obj, const char *part_name, const char *style) EINA_ARG_NONNULL(1, 2);
   EAPI const char        *elm_layout_part_cursor_style_get(const Evas_Object *obj, const char *part_name) EINA_ARG_NONNULL(1, 2);
   EAPI Eina_Bool          elm_layout_part_cursor_engine_only_set(Evas_Object *obj, const char *part_name, Eina_Bool engine_only) EINA_ARG_NONNULL(1, 2);
   EAPI Eina_Bool          elm_layout_part_cursor_engine_only_get(const Evas_Object *obj, const char *part_name) EINA_ARG_NONNULL(1, 2);
/**
 * @def elm_layout_icon_set
 * Convienience macro to set the icon object in a layout that follows the
 * Elementary naming convention for its parts.
 *
 * @ingroup Layout
 */
#define elm_layout_icon_set(_ly, _obj) \
  do { \
    const char *sig; \
    elm_layout_content_set((_ly), "elm.swallow.icon", (_obj)); \
    if ((_obj)) sig = "elm,state,icon,visible"; \
    else sig = "elm,state,icon,hidden"; \
    elm_object_signal_emit((_ly), sig, "elm"); \
  } while (0)

/**
 * @def elm_layout_icon_get
 * Convienience macro to get the icon object from a layout that follows the
 * Elementary naming convention for its parts.
 *
 * @ingroup Layout
 */
#define elm_layout_icon_get(_ly) \
  elm_layout_content_get((_ly), "elm.swallow.icon")

/**
 * @def elm_layout_end_set
 * Convienience macro to set the end object in a layout that follows the
 * Elementary naming convention for its parts.
 *
 * @ingroup Layout
 */
#define elm_layout_end_set(_ly, _obj) \
  do { \
    const char *sig; \
    elm_layout_content_set((_ly), "elm.swallow.end", (_obj)); \
    if ((_obj)) sig = "elm,state,end,visible"; \
    else sig = "elm,state,end,hidden"; \
    elm_object_signal_emit((_ly), sig, "elm"); \
  } while (0)

/**
 * @def elm_layout_end_get
 * Convienience macro to get the end object in a layout that follows the
 * Elementary naming convention for its parts.
 *
 * @ingroup Layout
 */
#define elm_layout_end_get(_ly) \
  elm_layout_content_get((_ly), "elm.swallow.end")

/**
 * @def elm_layout_label_set
 * Convienience macro to set the label in a layout that follows the
 * Elementary naming convention for its parts.
 *
 * @ingroup Layout
 * @deprecate use elm_object_text_* instead.
 */
#define elm_layout_label_set(_ly, _txt) \
  elm_layout_text_set((_ly), "elm.text", (_txt))

/**
 * @def elm_layout_label_get
 * Convienience macro to get the label in a layout that follows the
 * Elementary naming convention for its parts.
 *
 * @ingroup Layout
 * @deprecate use elm_object_text_* instead.
 */
#define elm_layout_label_get(_ly) \
  elm_layout_text_get((_ly), "elm.text")

   /* smart callbacks called:
    * "theme,changed" - when elm theme is changed.
    */

   /* notify */
   typedef enum _Elm_Notify_Orient
     {
        ELM_NOTIFY_ORIENT_TOP,
        ELM_NOTIFY_ORIENT_CENTER,
        ELM_NOTIFY_ORIENT_BOTTOM,
        ELM_NOTIFY_ORIENT_LEFT,
        ELM_NOTIFY_ORIENT_RIGHT,
        ELM_NOTIFY_ORIENT_TOP_LEFT,
        ELM_NOTIFY_ORIENT_TOP_RIGHT,
        ELM_NOTIFY_ORIENT_BOTTOM_LEFT,
        ELM_NOTIFY_ORIENT_BOTTOM_RIGHT,
        ELM_NOTIFY_ORIENT_LAST
     } Elm_Notify_Orient;
   EAPI Evas_Object      *elm_notify_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void              elm_notify_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object      *elm_notify_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object      *elm_notify_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_notify_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Evas_Object      *elm_notify_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_notify_orient_set(Evas_Object *obj, Elm_Notify_Orient orient) EINA_ARG_NONNULL(1);
   EAPI Elm_Notify_Orient elm_notify_orient_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_notify_timeout_set(Evas_Object *obj, double timeout) EINA_ARG_NONNULL(1);
   EAPI double            elm_notify_timeout_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_notify_repeat_events_set(Evas_Object *obj, Eina_Bool repeat) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool         elm_notify_repeat_events_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "timeout" - when timeout happens on notify and it's hidden
    * "block,clicked" - when it's hidden by a click outside of the notify's view
    */

   /**
    * @defgroup Hover Hover
    *
    * @image html img/widget/hover/preview-00.png
    * @image latex img/widget/hover/preview-00.eps
    *
    * A Hover object will hover over its @p parent object at the @p target
    * location. Anything in the background will be given a darker coloring to
    * indicate that the hover object is on top (at the default theme). When the
    * hover is clicked it is dismissed(hidden), if the contents of the hover are
    * clicked that @b doesn't cause the hover to be dismissed.
    *
    * @note The hover object will take up the entire space of @p target
    * object.
    *
    * Elementary has the following styles for the hover widget:
    * @li default
    * @li popout
    * @li menu
    * @li hoversel_vertical
    *
    * The following are the available position for content:
    * @li left
    * @li top-left
    * @li top
    * @li top-right
    * @li right
    * @li bottom-right
    * @li bottom
    * @li bottom-left
    * @li middle
    * @li smart
    *
    * Signals that you can add callbacks for are:
    * @li "clicked" - the user clicked the empty space in the hover to dismiss
    * @li "smart,changed" - a content object placed under the "smart"
    *                   policy was replaced to a new slot direction.
    *
    * See @ref tutorial_hover for more information.
    *
    * @{
    */
   typedef enum _Elm_Hover_Axis
     {
        ELM_HOVER_AXIS_NONE, /**< ELM_HOVER_AXIS_NONE -- no prefered orientation */
        ELM_HOVER_AXIS_HORIZONTAL, /**< ELM_HOVER_AXIS_HORIZONTAL -- horizontal */
        ELM_HOVER_AXIS_VERTICAL, /**< ELM_HOVER_AXIS_VERTICAL -- vertical */
        ELM_HOVER_AXIS_BOTH /**< ELM_HOVER_AXIS_BOTH -- both */
     } Elm_Hover_Axis;
   /**
    * @brief Adds a hover object to @p parent
    *
    * @param parent The parent object
    * @return The hover object or NULL if one could not be created
    */
   EAPI Evas_Object *elm_hover_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Sets the target object for the hover.
    *
    * @param obj The hover object
    * @param target The object to center the hover onto. The hover
    *
    * This function will cause the hover to be centered on the target object.
    */
   EAPI void         elm_hover_target_set(Evas_Object *obj, Evas_Object *target) EINA_ARG_NONNULL(1);
   /**
    * @brief Gets the target object for the hover.
    *
    * @param obj The hover object
    * @param parent The object to locate the hover over.
    *
    * @see elm_hover_target_set()
    */
   EAPI Evas_Object *elm_hover_target_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Sets the parent object for the hover.
    *
    * @param obj The hover object
    * @param parent The object to locate the hover over.
    *
    * This function will cause the hover to take up the entire space that the
    * parent object fills.
    */
   EAPI void         elm_hover_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Gets the parent object for the hover.
    *
    * @param obj The hover object
    * @return The parent object to locate the hover over.
    *
    * @see elm_hover_parent_set()
    */
   EAPI Evas_Object *elm_hover_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Sets the content of the hover object and the direction in which it
    * will pop out.
    *
    * @param obj The hover object
    * @param swallow The direction that the object will be displayed
    * at. Accepted values are "left", "top-left", "top", "top-right",
    * "right", "bottom-right", "bottom", "bottom-left", "middle" and
    * "smart".
    * @param content The content to place at @p swallow
    *
    * Once the content object is set for a given direction, a previously
    * set one (on the same direction) will be deleted. If you want to
    * keep that old content object, use the elm_hover_content_unset()
    * function.
    *
    * All directions may have contents at the same time, except for
    * "smart". This is a special placement hint and its use case
    * independs of the calculations coming from
    * elm_hover_best_content_location_get(). Its use is for cases when
    * one desires only one hover content, but with a dinamic special
    * placement within the hover area. The content's geometry, whenever
    * it changes, will be used to decide on a best location not
    * extrapolating the hover's parent object view to show it in (still
    * being the hover's target determinant of its medium part -- move and
    * resize it to simulate finger sizes, for example). If one of the
    * directions other than "smart" are used, a previously content set
    * using it will be deleted, and vice-versa.
    */
   EAPI void         elm_hover_content_set(Evas_Object *obj, const char *swallow, Evas_Object *content) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the content of the hover object, in a given direction.
    *
    * Return the content object which was set for this widget in the
    * @p swallow direction.
    *
    * @param obj The hover object
    * @param swallow The direction that the object was display at.
    * @return The content that was being used
    *
    * @see elm_hover_content_set()
    */
   EAPI Evas_Object *elm_hover_content_get(const Evas_Object *obj, const char *swallow) EINA_ARG_NONNULL(1);
   /**
    * @brief Unset the content of the hover object, in a given direction.
    *
    * Unparent and return the content object set at @p swallow direction.
    *
    * @param obj The hover object
    * @param swallow The direction that the object was display at.
    * @return The content that was being used.
    *
    * @see elm_hover_content_set()
    */
   EAPI Evas_Object *elm_hover_content_unset(Evas_Object *obj, const char *swallow) EINA_ARG_NONNULL(1);
   /**
    * @brief Returns the best swallow location for content in the hover.
    *
    * @param obj The hover object
    * @param pref_axis The preferred orientation axis for the hover object to use
    * @return The edje location to place content into the hover or @c
    *         NULL, on errors.
    *
    * Best is defined here as the location at which there is the most available
    * space.
    *
    * @p pref_axis may be one of
    * - @c ELM_HOVER_AXIS_NONE -- no prefered orientation
    * - @c ELM_HOVER_AXIS_HORIZONTAL -- horizontal
    * - @c ELM_HOVER_AXIS_VERTICAL -- vertical
    * - @c ELM_HOVER_AXIS_BOTH -- both
    *
    * If ELM_HOVER_AXIS_HORIZONTAL is choosen the returned position will
    * nescessarily be along the horizontal axis("left" or "right"). If
    * ELM_HOVER_AXIS_VERTICAL is choosen the returned position will nescessarily
    * be along the vertical axis("top" or "bottom"). Chossing
    * ELM_HOVER_AXIS_BOTH or ELM_HOVER_AXIS_NONE has the same effect and the
    * returned position may be in either axis.
    *
    * @see elm_hover_content_set()
    */
   EAPI const char  *elm_hover_best_content_location_get(const Evas_Object *obj, Elm_Hover_Axis pref_axis) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* entry */
   /**
    * @defgroup Entry Entry
    *
    * @image html img/widget/entry/preview-00.png
    * @image latex img/widget/entry/preview-00.eps width=\textwidth
    * @image html img/widget/entry/preview-01.png
    * @image latex img/widget/entry/preview-01.eps width=\textwidth
    * @image html img/widget/entry/preview-02.png
    * @image latex img/widget/entry/preview-02.eps width=\textwidth
    * @image html img/widget/entry/preview-03.png
    * @image latex img/widget/entry/preview-03.eps width=\textwidth
    *
    * An entry is a convenience widget which shows a box that the user can
    * enter text into. Entries by default don't scroll, so they grow to
    * accomodate the entire text, resizing the parent window as needed. This
    * can be changed with the elm_entry_scrollable_set() function.
    *
    * They can also be single line or multi line (the default) and when set
    * to multi line mode they support text wrapping in any of the modes
    * indicated by #Elm_Wrap_Type.
    *
    * Other features include password mode, filtering of inserted text with
    * elm_entry_text_filter_append() and related functions, inline "items" and
    * formatted markup text.
    *
    * @section entry-markup Formatted text
    *
    * The markup tags supported by the Entry are defined by the theme, but
    * even when writing new themes or extensions it's a good idea to stick to
    * a sane default, to maintain coherency and avoid application breakages.
    * Currently defined by the default theme are the following tags:
    * @li \<br\>: Inserts a line break.
    * @li \<ps\>: Inserts a paragraph separator. This is preferred over line
    * breaks.
    * @li \<tab\>: Inserts a tab.
    * @li \<em\>...\</em\>: Emphasis. Sets the @em oblique style for the
    * enclosed text.
    * @li \<b\>...\</b\>: Sets the @b bold style for the enclosed text.
    * @li \<link\>...\</link\>: Underlines the enclosed text.
    * @li \<hilight\>...\</hilight\>: Hilights the enclosed text.
    *
    * @section entry-special Special markups
    *
    * Besides those used to format text, entries support two special markup
    * tags used to insert clickable portions of text or items inlined within
    * the text.
    *
    * @subsection entry-anchors Anchors
    *
    * Anchors are similar to HTML anchors. Text can be surrounded by \<a\> and
    * \</a\> tags and an event will be generated when this text is clicked,
    * like this:
    *
    * @code
    * This text is outside <a href=anc-01>but this one is an anchor</a>
    * @endcode
    *
    * The @c href attribute in the opening tag gives the name that will be
    * used to identify the anchor and it can be any valid utf8 string.
    *
    * When an anchor is clicked, an @c "anchor,clicked" signal is emitted with
    * an #Elm_Entry_Anchor_Info in the @c event_info parameter for the
    * callback function. The same applies for "anchor,in" (mouse in), "anchor,out"
    * (mouse out), "anchor,down" (mouse down), and "anchor,up" (mouse up) events on
    * an anchor.
    *
    * @subsection entry-items Items
    *
    * Inlined in the text, any other @c Evas_Object can be inserted by using
    * \<item\> tags this way:
    *
    * @code
    * <item size=16x16 vsize=full href=emoticon/haha></item>
    * @endcode
    *
    * Just like with anchors, the @c href identifies each item, but these need,
    * in addition, to indicate their size, which is done using any one of
    * @c size, @c absize or @c relsize attributes. These attributes take their
    * value in the WxH format, where W is the width and H the height of the
    * item.
    *
    * @li absize: Absolute pixel size for the item. Whatever value is set will
    * be the item's size regardless of any scale value the object may have
    * been set to. The final line height will be adjusted to fit larger items.
    * @li size: Similar to @c absize, but it's adjusted to the scale value set
    * for the object.
    * @li relsize: Size is adjusted for the item to fit within the current
    * line height.
    *
    * Besides their size, items are specificed a @c vsize value that affects
    * how their final size and position are calculated. The possible values
    * are:
    * @li ascent: Item will be placed within the line's baseline and its
    * ascent. That is, the height between the line where all characters are
    * positioned and the highest point in the line. For @c size and @c absize
    * items, the descent value will be added to the total line height to make
    * them fit. @c relsize items will be adjusted to fit within this space.
    * @li full: Items will be placed between the descent and ascent, or the
    * lowest point in the line and its highest.
    *
    * The next image shows different configurations of items and how they
    * are the previously mentioned options affect their sizes. In all cases,
    * the green line indicates the ascent, blue for the baseline and red for
    * the descent.
    *
    * @image html entry_item.png
    * @image latex entry_item.eps width=\textwidth
    *
    * And another one to show how size differs from absize. In the first one,
    * the scale value is set to 1.0, while the second one is using one of 2.0.
    *
    * @image html entry_item_scale.png
    * @image latex entry_item_scale.eps width=\textwidth
    *
    * After the size for an item is calculated, the entry will request an
    * object to place in its space. For this, the functions set with
    * elm_entry_item_provider_append() and related functions will be called
    * in order until one of them returns a @c non-NULL value. If no providers
    * are available, or all of them return @c NULL, then the entry falls back
    * to one of the internal defaults, provided the name matches with one of
    * them.
    *
    * All of the following are currently supported:
    *
    * - emoticon/angry
    * - emoticon/angry-shout
    * - emoticon/crazy-laugh
    * - emoticon/evil-laugh
    * - emoticon/evil
    * - emoticon/goggle-smile
    * - emoticon/grumpy
    * - emoticon/grumpy-smile
    * - emoticon/guilty
    * - emoticon/guilty-smile
    * - emoticon/haha
    * - emoticon/half-smile
    * - emoticon/happy-panting
    * - emoticon/happy
    * - emoticon/indifferent
    * - emoticon/kiss
    * - emoticon/knowing-grin
    * - emoticon/laugh
    * - emoticon/little-bit-sorry
    * - emoticon/love-lots
    * - emoticon/love
    * - emoticon/minimal-smile
    * - emoticon/not-happy
    * - emoticon/not-impressed
    * - emoticon/omg
    * - emoticon/opensmile
    * - emoticon/smile
    * - emoticon/sorry
    * - emoticon/squint-laugh
    * - emoticon/surprised
    * - emoticon/suspicious
    * - emoticon/tongue-dangling
    * - emoticon/tongue-poke
    * - emoticon/uh
    * - emoticon/unhappy
    * - emoticon/very-sorry
    * - emoticon/what
    * - emoticon/wink
    * - emoticon/worried
    * - emoticon/wtf
    *
    * Alternatively, an item may reference an image by its path, using
    * the URI form @c file:///path/to/an/image.png and the entry will then
    * use that image for the item.
    *
    * @section entry-files Loading and saving files
    *
    * Entries have convinience functions to load text from a file and save
    * changes back to it after a short delay. The automatic saving is enabled
    * by default, but can be disabled with elm_entry_autosave_set() and files
    * can be loaded directly as plain text or have any markup in them
    * recognized. See elm_entry_file_set() for more details.
    *
    * @section entry-signals Emitted signals
    *
    * This widget emits the following signals:
    *
    * @li "changed": The text within the entry was changed.
    * @li "activated": The enter key was pressed on a single line entry.
    * @li "press": A mouse button has been pressed on the entry.
    * @li "longpressed": A mouse button has been pressed and held for a couple
    * seconds.
    * @li "clicked": The entry has been clicked (mouse press and release).
    * @li "clicked,double": The entry has been double clicked.
    * @li "clicked,triple": The entry has been triple clicked.
    * @li "focused": The entry has received focus.
    * @li "unfocused": The entry has lost focus.
    * @li "selection,paste": A paste of the clipboard contents was requested.
    * @li "selection,copy": A copy of the selected text into the clipboard was
    * requested.
    * @li "selection,cut": A cut of the selected text into the clipboard was
    * requested.
    * @li "selection,start": A selection has begun and no previous selection
    * existed.
    * @li "selection,changed": The current selection has changed.
    * @li "selection,cleared": The current selection has been cleared.
    * @li "cursor,changed": The cursor has changed position.
    * @li "anchor,clicked": An anchor has been clicked. The event_info
    * parameter for the callback will be an #Elm_Entry_Anchor_Info.
    * @li "anchor,in": Mouse cursor has moved into an anchor. The event_info
    * parameter for the callback will be an #Elm_Entry_Anchor_Info.
    * @li "anchor,out": Mouse cursor has moved out of an anchor. The event_info
    * parameter for the callback will be an #Elm_Entry_Anchor_Info.
    * @li "anchor,up": Mouse button has been unpressed on an anchor. The event_info
    * parameter for the callback will be an #Elm_Entry_Anchor_Info.
    * @li "anchor,down": Mouse button has been pressed on an anchor. The event_info
    * parameter for the callback will be an #Elm_Entry_Anchor_Info.
    * @li "preedit,changed": The preedit string has changed.
    *
    * @section entry-examples
    *
    * An overview of the Entry API can be seen in @ref entry_example_01
    *
    * @{
    */
   /**
    * @typedef Elm_Entry_Anchor_Info
    *
    * The info sent in the callback for the "anchor,clicked" signals emitted
    * by entries.
    */
   typedef struct _Elm_Entry_Anchor_Info Elm_Entry_Anchor_Info;
   /**
    * @struct _Elm_Entry_Anchor_Info
    *
    * The info sent in the callback for the "anchor,clicked" signals emitted
    * by entries.
    */
   struct _Elm_Entry_Anchor_Info
     {
        const char *name; /**< The name of the anchor, as stated in its href */
        int         button; /**< The mouse button used to click on it */
        Evas_Coord  x, /**< Anchor geometry, relative to canvas */
                    y, /**< Anchor geometry, relative to canvas */
                    w, /**< Anchor geometry, relative to canvas */
                    h; /**< Anchor geometry, relative to canvas */
     };
   /**
    * @typedef Elm_Entry_Filter_Cb
    * This callback type is used by entry filters to modify text.
    * @param data The data specified as the last param when adding the filter
    * @param entry The entry object
    * @param text A pointer to the location of the text being filtered. This data can be modified,
    * but any additional allocations must be managed by the user.
    * @see elm_entry_text_filter_append
    * @see elm_entry_text_filter_prepend
    */
   typedef void (*Elm_Entry_Filter_Cb)(void *data, Evas_Object *entry, char **text);

   /**
    * This adds an entry to @p parent object.
    *
    * By default, entries are:
    * @li not scrolled
    * @li multi-line
    * @li word wrapped
    * @li autosave is enabled
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object *elm_entry_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Sets the entry to single line mode.
    *
    * In single line mode, entries don't ever wrap when the text reaches the
    * edge, and instead they keep growing horizontally. Pressing the @c Enter
    * key will generate an @c "activate" event instead of adding a new line.
    *
    * When @p single_line is @c EINA_FALSE, line wrapping takes effect again
    * and pressing enter will break the text into a different line
    * without generating any events.
    *
    * @param obj The entry object
    * @param single_line If true, the text in the entry
    * will be on a single line.
    */
   EAPI void         elm_entry_single_line_set(Evas_Object *obj, Eina_Bool single_line) EINA_ARG_NONNULL(1);
   /**
    * Gets whether the entry is set to be single line.
    *
    * @param obj The entry object
    * @return single_line If true, the text in the entry is set to display
    * on a single line.
    *
    * @see elm_entry_single_line_set()
    */
   EAPI Eina_Bool    elm_entry_single_line_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Sets the entry to password mode.
    *
    * In password mode, entries are implicitly single line and the display of
    * any text in them is replaced with asterisks (*).
    *
    * @param obj The entry object
    * @param password If true, password mode is enabled.
    */
   EAPI void         elm_entry_password_set(Evas_Object *obj, Eina_Bool password) EINA_ARG_NONNULL(1);
   /**
    * Gets whether the entry is set to password mode.
    *
    * @param obj The entry object
    * @return If true, the entry is set to display all characters
    * as asterisks (*).
    *
    * @see elm_entry_password_set()
    */
   EAPI Eina_Bool    elm_entry_password_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This sets the text displayed within the entry to @p entry.
    *
    * @param obj The entry object
    * @param entry The text to be displayed
    *
    * @deprecated Use elm_object_text_set() instead.
    */
   EAPI void         elm_entry_entry_set(Evas_Object *obj, const char *entry) EINA_ARG_NONNULL(1);
   /**
    * This returns the text currently shown in object @p entry.
    * See also elm_entry_entry_set().
    *
    * @param obj The entry object
    * @return The currently displayed text or NULL on failure
    *
    * @deprecated Use elm_object_text_get() instead.
    */
   EAPI const char  *elm_entry_entry_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Appends @p entry to the text of the entry.
    *
    * Adds the text in @p entry to the end of any text already present in the
    * widget.
    *
    * The appended text is subject to any filters set for the widget.
    *
    * @param obj The entry object
    * @param entry The text to be displayed
    *
    * @see elm_entry_text_filter_append()
    */
   EAPI void         elm_entry_entry_append(Evas_Object *obj, const char *entry) EINA_ARG_NONNULL(1);
   /**
    * Gets whether the entry is empty.
    *
    * Empty means no text at all. If there are any markup tags, like an item
    * tag for which no provider finds anything, and no text is displayed, this
    * function still returns EINA_FALSE.
    *
    * @param obj The entry object
    * @return EINA_TRUE if the entry is empty, EINA_FALSE otherwise.
    */
   EAPI Eina_Bool    elm_entry_is_empty(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Gets any selected text within the entry.
    *
    * If there's any selected text in the entry, this function returns it as
    * a string in markup format. NULL is returned if no selection exists or
    * if an error occurred.
    *
    * The returned value points to an internal string and should not be freed
    * or modified in any way. If the @p entry object is deleted or its
    * contents are changed, the returned pointer should be considered invalid.
    *
    * @param obj The entry object
    * @return The selected text within the entry or NULL on failure
    */
   EAPI const char  *elm_entry_selection_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Inserts the given text into the entry at the current cursor position.
    *
    * This inserts text at the cursor position as if it was typed
    * by the user (note that this also allows markup which a user
    * can't just "type" as it would be converted to escaped text, so this
    * call can be used to insert things like emoticon items or bold push/pop
    * tags, other font and color change tags etc.)
    *
    * If any selection exists, it will be replaced by the inserted text.
    *
    * The inserted text is subject to any filters set for the widget.
    *
    * @param obj The entry object
    * @param entry The text to insert
    *
    * @see elm_entry_text_filter_append()
    */
   EAPI void         elm_entry_entry_insert(Evas_Object *obj, const char *entry) EINA_ARG_NONNULL(1);
   /**
    * Set the line wrap type to use on multi-line entries.
    *
    * Sets the wrap type used by the entry to any of the specified in
    * #Elm_Wrap_Type. This tells how the text will be implicitly cut into a new
    * line (without inserting a line break or paragraph separator) when it
    * reaches the far edge of the widget.
    *
    * Note that this only makes sense for multi-line entries. A widget set
    * to be single line will never wrap.
    *
    * @param obj The entry object
    * @param wrap The wrap mode to use. See #Elm_Wrap_Type for details on them
    */
   EAPI void         elm_entry_line_wrap_set(Evas_Object *obj, Elm_Wrap_Type wrap) EINA_ARG_NONNULL(1);
   /**
    * Gets the wrap mode the entry was set to use.
    *
    * @param obj The entry object
    * @return Wrap type
    *
    * @see also elm_entry_line_wrap_set()
    */
   EAPI Elm_Wrap_Type elm_entry_line_wrap_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Sets if the entry is to be editable or not.
    *
    * By default, entries are editable and when focused, any text input by the
    * user will be inserted at the current cursor position. But calling this
    * function with @p editable as EINA_FALSE will prevent the user from
    * inputting text into the entry.
    *
    * The only way to change the text of a non-editable entry is to use
    * elm_object_text_set(), elm_entry_entry_insert() and other related
    * functions.
    *
    * @param obj The entry object
    * @param editable If EINA_TRUE, user input will be inserted in the entry,
    * if not, the entry is read-only and no user input is allowed.
    */
   EAPI void         elm_entry_editable_set(Evas_Object *obj, Eina_Bool editable) EINA_ARG_NONNULL(1);
   /**
    * Gets whether the entry is editable or not.
    *
    * @param obj The entry object
    * @return If true, the entry is editable by the user.
    * If false, it is not editable by the user
    *
    * @see elm_entry_editable_set()
    */
   EAPI Eina_Bool    elm_entry_editable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This drops any existing text selection within the entry.
    *
    * @param obj The entry object
    */
   EAPI void         elm_entry_select_none(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This selects all text within the entry.
    *
    * @param obj The entry object
    */
   EAPI void         elm_entry_select_all(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This moves the cursor one place to the right within the entry.
    *
    * @param obj The entry object
    * @return EINA_TRUE upon success, EINA_FALSE upon failure
    */
   EAPI Eina_Bool    elm_entry_cursor_next(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This moves the cursor one place to the left within the entry.
    *
    * @param obj The entry object
    * @return EINA_TRUE upon success, EINA_FALSE upon failure
    */
   EAPI Eina_Bool    elm_entry_cursor_prev(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This moves the cursor one line up within the entry.
    *
    * @param obj The entry object
    * @return EINA_TRUE upon success, EINA_FALSE upon failure
    */
   EAPI Eina_Bool    elm_entry_cursor_up(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This moves the cursor one line down within the entry.
    *
    * @param obj The entry object
    * @return EINA_TRUE upon success, EINA_FALSE upon failure
    */
   EAPI Eina_Bool    elm_entry_cursor_down(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This moves the cursor to the beginning of the entry.
    *
    * @param obj The entry object
    */
   EAPI void         elm_entry_cursor_begin_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This moves the cursor to the end of the entry.
    *
    * @param obj The entry object
    */
   EAPI void         elm_entry_cursor_end_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This moves the cursor to the beginning of the current line.
    *
    * @param obj The entry object
    */
   EAPI void         elm_entry_cursor_line_begin_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This moves the cursor to the end of the current line.
    *
    * @param obj The entry object
    */
   EAPI void         elm_entry_cursor_line_end_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This begins a selection within the entry as though
    * the user were holding down the mouse button to make a selection.
    *
    * @param obj The entry object
    */
   EAPI void         elm_entry_cursor_selection_begin(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This ends a selection within the entry as though
    * the user had just released the mouse button while making a selection.
    *
    * @param obj The entry object
    */
   EAPI void         elm_entry_cursor_selection_end(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Gets whether a format node exists at the current cursor position.
    *
    * A format node is anything that defines how the text is rendered. It can
    * be a visible format node, such as a line break or a paragraph separator,
    * or an invisible one, such as bold begin or end tag.
    * This function returns whether any format node exists at the current
    * cursor position.
    *
    * @param obj The entry object
    * @return EINA_TRUE if the current cursor position contains a format node,
    * EINA_FALSE otherwise.
    *
    * @see elm_entry_cursor_is_visible_format_get()
    */
   EAPI Eina_Bool    elm_entry_cursor_is_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Gets if the current cursor position holds a visible format node.
    *
    * @param obj The entry object
    * @return EINA_TRUE if the current cursor is a visible format, EINA_FALSE
    * if it's an invisible one or no format exists.
    *
    * @see elm_entry_cursor_is_format_get()
    */
   EAPI Eina_Bool    elm_entry_cursor_is_visible_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Gets the character pointed by the cursor at its current position.
    *
    * This function returns a string with the utf8 character stored at the
    * current cursor position.
    * Only the text is returned, any format that may exist will not be part
    * of the return value.
    *
    * @param obj The entry object
    * @return The text pointed by the cursors.
    */
   EAPI const char  *elm_entry_cursor_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This function returns the geometry of the cursor.
    *
    * It's useful if you want to draw something on the cursor (or where it is),
    * or for example in the case of scrolled entry where you want to show the
    * cursor.
    *
    * @param obj The entry object
    * @param x returned geometry
    * @param y returned geometry
    * @param w returned geometry
    * @param h returned geometry
    * @return EINA_TRUE upon success, EINA_FALSE upon failure
    */
   EAPI Eina_Bool    elm_entry_cursor_geometry_get(const Evas_Object *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h) EINA_ARG_NONNULL(1);
   /**
    * Sets the cursor position in the entry to the given value
    *
    * The value in @p pos is the index of the character position within the
    * contents of the string as returned by elm_entry_cursor_pos_get().
    *
    * @param obj The entry object
    * @param pos The position of the cursor
    */
   EAPI void         elm_entry_cursor_pos_set(Evas_Object *obj, int pos) EINA_ARG_NONNULL(1);
   /**
    * Retrieves the current position of the cursor in the entry
    *
    * @param obj The entry object
    * @return The cursor position
    */
   EAPI int          elm_entry_cursor_pos_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This executes a "cut" action on the selected text in the entry.
    *
    * @param obj The entry object
    */
   EAPI void         elm_entry_selection_cut(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This executes a "copy" action on the selected text in the entry.
    *
    * @param obj The entry object
    */
   EAPI void         elm_entry_selection_copy(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This executes a "paste" action in the entry.
    *
    * @param obj The entry object
    */
   EAPI void         elm_entry_selection_paste(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This clears and frees the items in a entry's contextual (longpress)
    * menu.
    *
    * @param obj The entry object
    *
    * @see elm_entry_context_menu_item_add()
    */
   EAPI void         elm_entry_context_menu_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This adds an item to the entry's contextual menu.
    *
    * A longpress on an entry will make the contextual menu show up, if this
    * hasn't been disabled with elm_entry_context_menu_disabled_set().
    * By default, this menu provides a few options like enabling selection mode,
    * which is useful on embedded devices that need to be explicit about it,
    * and when a selection exists it also shows the copy and cut actions.
    *
    * With this function, developers can add other options to this menu to
    * perform any action they deem necessary.
    *
    * @param obj The entry object
    * @param label The item's text label
    * @param icon_file The item's icon file
    * @param icon_type The item's icon type
    * @param func The callback to execute when the item is clicked
    * @param data The data to associate with the item for related functions
    */
   EAPI void         elm_entry_context_menu_item_add(Evas_Object *obj, const char *label, const char *icon_file, Elm_Icon_Type icon_type, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   /**
    * This disables the entry's contextual (longpress) menu.
    *
    * @param obj The entry object
    * @param disabled If true, the menu is disabled
    */
   EAPI void         elm_entry_context_menu_disabled_set(Evas_Object *obj, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   /**
    * This returns whether the entry's contextual (longpress) menu is
    * disabled.
    *
    * @param obj The entry object
    * @return If true, the menu is disabled
    */
   EAPI Eina_Bool    elm_entry_context_menu_disabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This appends a custom item provider to the list for that entry
    *
    * This appends the given callback. The list is walked from beginning to end
    * with each function called given the item href string in the text. If the
    * function returns an object handle other than NULL (it should create an
    * object to do this), then this object is used to replace that item. If
    * not the next provider is called until one provides an item object, or the
    * default provider in entry does.
    *
    * @param obj The entry object
    * @param func The function called to provide the item object
    * @param data The data passed to @p func
    *
    * @see @ref entry-items
    */
   EAPI void         elm_entry_item_provider_append(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *entry, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * This prepends a custom item provider to the list for that entry
    *
    * This prepends the given callback. See elm_entry_item_provider_append() for
    * more information
    *
    * @param obj The entry object
    * @param func The function called to provide the item object
    * @param data The data passed to @p func
    */
   EAPI void         elm_entry_item_provider_prepend(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *entry, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * This removes a custom item provider to the list for that entry
    *
    * This removes the given callback. See elm_entry_item_provider_append() for
    * more information
    *
    * @param obj The entry object
    * @param func The function called to provide the item object
    * @param data The data passed to @p func
    */
   EAPI void         elm_entry_item_provider_remove(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *entry, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * Append a filter function for text inserted in the entry
    *
    * Append the given callback to the list. This functions will be called
    * whenever any text is inserted into the entry, with the text to be inserted
    * as a parameter. The callback function is free to alter the text in any way
    * it wants, but it must remember to free the given pointer and update it.
    * If the new text is to be discarded, the function can free it and set its
    * text parameter to NULL. This will also prevent any following filters from
    * being called.
    *
    * @param obj The entry object
    * @param func The function to use as text filter
    * @param data User data to pass to @p func
    */
   EAPI void         elm_entry_text_filter_append(Evas_Object *obj, Elm_Entry_Filter_Cb func, void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * Prepend a filter function for text insdrted in the entry
    *
    * Prepend the given callback to the list. See elm_entry_text_filter_append()
    * for more information
    *
    * @param obj The entry object
    * @param func The function to use as text filter
    * @param data User data to pass to @p func
    */
   EAPI void         elm_entry_text_filter_prepend(Evas_Object *obj, Elm_Entry_Filter_Cb func, void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * Remove a filter from the list
    *
    * Removes the given callback from the filter list. See
    * elm_entry_text_filter_append() for more information.
    *
    * @param obj The entry object
    * @param func The filter function to remove
    * @param data The user data passed when adding the function
    */
   EAPI void         elm_entry_text_filter_remove(Evas_Object *obj, Elm_Entry_Filter_Cb func, void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * This converts a markup (HTML-like) string into UTF-8.
    *
    * The returned string is a malloc'ed buffer and it should be freed when
    * not needed anymore.
    *
    * @param s The string (in markup) to be converted
    * @return The converted string (in UTF-8). It should be freed.
    */
   EAPI char        *elm_entry_markup_to_utf8(const char *s) EINA_MALLOC EINA_WARN_UNUSED_RESULT;
   /**
    * This converts a UTF-8 string into markup (HTML-like).
    *
    * The returned string is a malloc'ed buffer and it should be freed when
    * not needed anymore.
    *
    * @param s The string (in UTF-8) to be converted
    * @return The converted string (in markup). It should be freed.
    */
   EAPI char        *elm_entry_utf8_to_markup(const char *s) EINA_MALLOC EINA_WARN_UNUSED_RESULT;
   /**
    * This sets the file (and implicitly loads it) for the text to display and
    * then edit. All changes are written back to the file after a short delay if
    * the entry object is set to autosave (which is the default).
    *
    * If the entry had any other file set previously, any changes made to it
    * will be saved if the autosave feature is enabled, otherwise, the file
    * will be silently discarded and any non-saved changes will be lost.
    *
    * @param obj The entry object
    * @param file The path to the file to load and save
    * @param format The file format
    */
   EAPI void         elm_entry_file_set(Evas_Object *obj, const char *file, Elm_Text_Format format) EINA_ARG_NONNULL(1);
   /**
    * Gets the file being edited by the entry.
    *
    * This function can be used to retrieve any file set on the entry for
    * edition, along with the format used to load and save it.
    *
    * @param obj The entry object
    * @param file The path to the file to load and save
    * @param format The file format
    */
   EAPI void         elm_entry_file_get(const Evas_Object *obj, const char **file, Elm_Text_Format *format) EINA_ARG_NONNULL(1);
   /**
    * This function writes any changes made to the file set with
    * elm_entry_file_set()
    *
    * @param obj The entry object
    */
   EAPI void         elm_entry_file_save(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This sets the entry object to 'autosave' the loaded text file or not.
    *
    * @param obj The entry object
    * @param autosave Autosave the loaded file or not
    *
    * @see elm_entry_file_set()
    */
   EAPI void         elm_entry_autosave_set(Evas_Object *obj, Eina_Bool autosave) EINA_ARG_NONNULL(1);
   /**
    * This gets the entry object's 'autosave' status.
    *
    * @param obj The entry object
    * @return Autosave the loaded file or not
    *
    * @see elm_entry_file_set()
    */
   EAPI Eina_Bool    elm_entry_autosave_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Control pasting of text and images for the widget.
    *
    * Normally the entry allows both text and images to be pasted.  By setting
    * textonly to be true, this prevents images from being pasted.
    *
    * Note this only changes the behaviour of text.
    *
    * @param obj The entry object
    * @param textonly paste mode - EINA_TRUE is text only, EINA_FALSE is
    * text+image+other.
    */
   EAPI void         elm_entry_cnp_textonly_set(Evas_Object *obj, Eina_Bool textonly) EINA_ARG_NONNULL(1);
   /**
    * Getting elm_entry text paste/drop mode.
    *
    * In textonly mode, only text may be pasted or dropped into the widget.
    *
    * @param obj The entry object
    * @return If the widget only accepts text from pastes.
    */
   EAPI Eina_Bool    elm_entry_cnp_textonly_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Enable or disable scrolling in entry
    *
    * Normally the entry is not scrollable unless you enable it with this call.
    *
    * @param obj The entry object
    * @param scroll EINA_TRUE if it is to be scrollable, EINA_FALSE otherwise
    */
   EAPI void         elm_entry_scrollable_set(Evas_Object *obj, Eina_Bool scroll);
   /**
    * Get the scrollable state of the entry
    *
    * Normally the entry is not scrollable. This gets the scrollable state
    * of the entry. See elm_entry_scrollable_set() for more information.
    *
    * @param obj The entry object
    * @return The scrollable state
    */
   EAPI Eina_Bool    elm_entry_scrollable_get(const Evas_Object *obj);
   /**
    * This sets a widget to be displayed to the left of a scrolled entry.
    *
    * @param obj The scrolled entry object
    * @param icon The widget to display on the left side of the scrolled
    * entry.
    *
    * @note A previously set widget will be destroyed.
    * @note If the object being set does not have minimum size hints set,
    * it won't get properly displayed.
    *
    * @see elm_entry_end_set()
    */
   EAPI void         elm_entry_icon_set(Evas_Object *obj, Evas_Object *icon);
   /**
    * Gets the leftmost widget of the scrolled entry. This object is
    * owned by the scrolled entry and should not be modified.
    *
    * @param obj The scrolled entry object
    * @return the left widget inside the scroller
    */
   EAPI Evas_Object *elm_entry_icon_get(const Evas_Object *obj);
   /**
    * Unset the leftmost widget of the scrolled entry, unparenting and
    * returning it.
    *
    * @param obj The scrolled entry object
    * @return the previously set icon sub-object of this entry, on
    * success.
    *
    * @see elm_entry_icon_set()
    */
   EAPI Evas_Object *elm_entry_icon_unset(Evas_Object *obj);
   /**
    * Sets the visibility of the left-side widget of the scrolled entry,
    * set by @elm_entry_icon_set().
    *
    * @param obj The scrolled entry object
    * @param setting EINA_TRUE if the object should be displayed,
    * EINA_FALSE if not.
    */
   EAPI void         elm_entry_icon_visible_set(Evas_Object *obj, Eina_Bool setting);
   /**
    * This sets a widget to be displayed to the end of a scrolled entry.
    *
    * @param obj The scrolled entry object
    * @param end The widget to display on the right side of the scrolled
    * entry.
    *
    * @note A previously set widget will be destroyed.
    * @note If the object being set does not have minimum size hints set,
    * it won't get properly displayed.
    *
    * @see elm_entry_icon_set
    */
   EAPI void         elm_entry_end_set(Evas_Object *obj, Evas_Object *end);
   /**
    * Gets the endmost widget of the scrolled entry. This object is owned
    * by the scrolled entry and should not be modified.
    *
    * @param obj The scrolled entry object
    * @return the right widget inside the scroller
    */
   EAPI Evas_Object *elm_entry_end_get(const Evas_Object *obj);
   /**
    * Unset the endmost widget of the scrolled entry, unparenting and
    * returning it.
    *
    * @param obj The scrolled entry object
    * @return the previously set icon sub-object of this entry, on
    * success.
    *
    * @see elm_entry_icon_set()
    */
   EAPI Evas_Object *elm_entry_end_unset(Evas_Object *obj);
   /**
    * Sets the visibility of the end widget of the scrolled entry, set by
    * @elm_entry_end_set().
    *
    * @param obj The scrolled entry object
    * @param setting EINA_TRUE if the object should be displayed,
    * EINA_FALSE if not.
    */
   EAPI void         elm_entry_end_visible_set(Evas_Object *obj, Eina_Bool setting);
   /**
    * This sets the scrolled entry's scrollbar policy (ie. enabling/disabling
    * them).
    *
    * Setting an entry to single-line mode with elm_entry_single_line_set()
    * will automatically disable the display of scrollbars when the entry
    * moves inside its scroller.
    *
    * @param obj The scrolled entry object
    * @param h The horizontal scrollbar policy to apply
    * @param v The vertical scrollbar policy to apply
    */
   EAPI void         elm_entry_scrollbar_policy_set(Evas_Object *obj, Elm_Scroller_Policy h, Elm_Scroller_Policy v);
   /**
    * This enables/disables bouncing within the entry.
    *
    * This function sets whether the entry will bounce when scrolling reaches
    * the end of the contained entry.
    *
    * @param obj The scrolled entry object
    * @param h The horizontal bounce state
    * @param v The vertical bounce state
    */
   EAPI void         elm_entry_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce);
   /**
    * Get the bounce mode
    *
    * @param obj The Entry object
    * @param h_bounce Allow bounce horizontally
    * @param v_bounce Allow bounce vertically
    */
   EAPI void         elm_entry_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce);

   /* pre-made filters for entries */
   /**
    * @typedef Elm_Entry_Filter_Limit_Size
    *
    * Data for the elm_entry_filter_limit_size() entry filter.
    */
   typedef struct _Elm_Entry_Filter_Limit_Size Elm_Entry_Filter_Limit_Size;
   /**
    * @struct _Elm_Entry_Filter_Limit_Size
    *
    * Data for the elm_entry_filter_limit_size() entry filter.
    */
   struct _Elm_Entry_Filter_Limit_Size
     {
        int max_char_count; /**< The maximum number of characters allowed. */
        int max_byte_count; /**< The maximum number of bytes allowed*/
     };
   /**
    * Filter inserted text based on user defined character and byte limits
    *
    * Add this filter to an entry to limit the characters that it will accept
    * based the the contents of the provided #Elm_Entry_Filter_Limit_Size.
    * The funtion works on the UTF-8 representation of the string, converting
    * it from the set markup, thus not accounting for any format in it.
    *
    * The user must create an #Elm_Entry_Filter_Limit_Size structure and pass
    * it as data when setting the filter. In it, it's possible to set limits
    * by character count or bytes (any of them is disabled if 0), and both can
    * be set at the same time. In that case, it first checks for characters,
    * then bytes.
    *
    * The function will cut the inserted text in order to allow only the first
    * number of characters that are still allowed. The cut is made in
    * characters, even when limiting by bytes, in order to always contain
    * valid ones and avoid half unicode characters making it in.
    *
    * This filter, like any others, does not apply when setting the entry text
    * directly with elm_object_text_set() (or the deprecated
    * elm_entry_entry_set()).
    */
   EAPI void         elm_entry_filter_limit_size(void *data, Evas_Object *entry, char **text) EINA_ARG_NONNULL(1, 2, 3);
   /**
    * @typedef Elm_Entry_Filter_Accept_Set
    *
    * Data for the elm_entry_filter_accept_set() entry filter.
    */
   typedef struct _Elm_Entry_Filter_Accept_Set Elm_Entry_Filter_Accept_Set;
   /**
    * @struct _Elm_Entry_Filter_Accept_Set
    *
    * Data for the elm_entry_filter_accept_set() entry filter.
    */
   struct _Elm_Entry_Filter_Accept_Set
     {
        const char *accepted; /**< Set of characters accepted in the entry. */
        const char *rejected; /**< Set of characters rejected from the entry. */
     };
   /**
    * Filter inserted text based on accepted or rejected sets of characters
    *
    * Add this filter to an entry to restrict the set of accepted characters
    * based on the sets in the provided #Elm_Entry_Filter_Accept_Set.
    * This structure contains both accepted and rejected sets, but they are
    * mutually exclusive.
    *
    * The @c accepted set takes preference, so if it is set, the filter will
    * only work based on the accepted characters, ignoring anything in the
    * @c rejected value. If @c accepted is @c NULL, then @c rejected is used.
    *
    * In both cases, the function filters by matching utf8 characters to the
    * raw markup text, so it can be used to remove formatting tags.
    *
    * This filter, like any others, does not apply when setting the entry text
    * directly with elm_object_text_set() (or the deprecated
    * elm_entry_entry_set()).
    */
   EAPI void         elm_entry_filter_accept_set(void *data, Evas_Object *entry, char **text) EINA_ARG_NONNULL(1, 3);
   /**
    * @}
    */

   /* composite widgets - these basically put together basic widgets above
    * in convenient packages that do more than basic stuff */

   /* anchorview */
   /**
    * @defgroup Anchorview Anchorview
    *
    * @image html img/widget/anchorview/preview-00.png
    * @image latex img/widget/anchorview/preview-00.eps
    *
    * Anchorview is for displaying text that contains markup with anchors
    * like <c>\<a href=1234\>something\</\></c> in it.
    *
    * Besides being styled differently, the anchorview widget provides the
    * necessary functionality so that clicking on these anchors brings up a
    * popup with user defined content such as "call", "add to contacts" or
    * "open web page". This popup is provided using the @ref Hover widget.
    *
    * This widget is very similar to @ref Anchorblock, so refer to that
    * widget for an example. The only difference Anchorview has is that the
    * widget is already provided with scrolling functionality, so if the
    * text set to it is too large to fit in the given space, it will scroll,
    * whereas the @ref Anchorblock widget will keep growing to ensure all the
    * text can be displayed.
    *
    * This widget emits the following signals:
    * @li "anchor,clicked": will be called when an anchor is clicked. The
    * @p event_info parameter on the callback will be a pointer of type
    * ::Elm_Entry_Anchorview_Info.
    *
    * See @ref Anchorblock for an example on how to use both of them.
    *
    * @see Anchorblock
    * @see Entry
    * @see Hover
    *
    * @{
    */
   /**
    * @typedef Elm_Entry_Anchorview_Info
    *
    * The info sent in the callback for "anchor,clicked" signals emitted by
    * the Anchorview widget.
    */
   typedef struct _Elm_Entry_Anchorview_Info Elm_Entry_Anchorview_Info;
   /**
    * @struct _Elm_Entry_Anchorview_Info
    *
    * The info sent in the callback for "anchor,clicked" signals emitted by
    * the Anchorview widget.
    */
   struct _Elm_Entry_Anchorview_Info
     {
        const char     *name; /**< Name of the anchor, as indicated in its href
                                   attribute */
        int             button; /**< The mouse button used to click on it */
        Evas_Object    *hover; /**< The hover object to use for the popup */
        struct {
             Evas_Coord    x, y, w, h;
        } anchor, /**< Geometry selection of text used as anchor */
          hover_parent; /**< Geometry of the object used as parent by the
                             hover */
        Eina_Bool       hover_left : 1; /**< Hint indicating if there's space
                                             for content on the left side of
                                             the hover. Before calling the
                                             callback, the widget will make the
                                             necessary calculations to check
                                             which sides are fit to be set with
                                             content, based on the position the
                                             hover is activated and its distance
                                             to the edges of its parent object
                                             */
        Eina_Bool       hover_right : 1; /**< Hint indicating content fits on
                                              the right side of the hover.
                                              See @ref hover_left */
        Eina_Bool       hover_top : 1; /**< Hint indicating content fits on top
                                            of the hover. See @ref hover_left */
        Eina_Bool       hover_bottom : 1; /**< Hint indicating content fits
                                               below the hover. See @ref
                                               hover_left */
     };
   /**
    * Add a new Anchorview object
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object *elm_anchorview_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the text to show in the anchorview
    *
    * Sets the text of the anchorview to @p text. This text can include markup
    * format tags, including <c>\<a href=anchorname\></c> to begin a segment of
    * text that will be specially styled and react to click events, ended with
    * either of \</a\> or \</\>. When clicked, the anchor will emit an
    * "anchor,clicked" signal that you can attach a callback to with
    * evas_object_smart_callback_add(). The name of the anchor given in the
    * event info struct will be the one set in the href attribute, in this
    * case, anchorname.
    *
    * Other markup can be used to style the text in different ways, but it's
    * up to the style defined in the theme which tags do what.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_anchorview_text_set(Evas_Object *obj, const char *text) EINA_ARG_NONNULL(1);
   /**
    * Get the markup text set for the anchorview
    *
    * Retrieves the text set on the anchorview, with markup tags included.
    *
    * @param obj The anchorview object
    * @return The markup text set or @c NULL if nothing was set or an error
    * occurred
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_anchorview_text_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the parent of the hover popup
    *
    * Sets the parent object to use by the hover created by the anchorview
    * when an anchor is clicked. See @ref Hover for more details on this.
    * If no parent is set, the same anchorview object will be used.
    *
    * @param obj The anchorview object
    * @param parent The object to use as parent for the hover
    */
   EAPI void         elm_anchorview_hover_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Get the parent of the hover popup
    *
    * Get the object used as parent for the hover created by the anchorview
    * widget. See @ref Hover for more details on this.
    *
    * @param obj The anchorview object
    * @return The object used as parent for the hover, NULL if none is set.
    */
   EAPI Evas_Object *elm_anchorview_hover_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the style that the hover should use
    *
    * When creating the popup hover, anchorview will request that it's
    * themed according to @p style.
    *
    * @param obj The anchorview object
    * @param style The style to use for the underlying hover
    *
    * @see elm_object_style_set()
    */
   EAPI void         elm_anchorview_hover_style_set(Evas_Object *obj, const char *style) EINA_ARG_NONNULL(1);
   /**
    * Get the style that the hover should use
    *
    * Get the style the hover created by anchorview will use.
    *
    * @param obj The anchorview object
    * @return The style to use by the hover. NULL means the default is used.
    *
    * @see elm_object_style_set()
    */
   EAPI const char  *elm_anchorview_hover_style_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Ends the hover popup in the anchorview
    *
    * When an anchor is clicked, the anchorview widget will create a hover
    * object to use as a popup with user provided content. This function
    * terminates this popup, returning the anchorview to its normal state.
    *
    * @param obj The anchorview object
    */
   EAPI void         elm_anchorview_hover_end(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set bouncing behaviour when the scrolled content reaches an edge
    *
    * Tell the internal scroller object whether it should bounce or not
    * when it reaches the respective edges for each axis.
    *
    * @param obj The anchorview object
    * @param h_bounce Whether to bounce or not in the horizontal axis
    * @param v_bounce Whether to bounce or not in the vertical axis
    *
    * @see elm_scroller_bounce_set()
    */
   EAPI void         elm_anchorview_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   /**
    * Get the set bouncing behaviour of the internal scroller
    *
    * Get whether the internal scroller should bounce when the edge of each
    * axis is reached scrolling.
    *
    * @param obj The anchorview object
    * @param h_bounce Pointer where to store the bounce state of the horizontal
    *                 axis
    * @param v_bounce Pointer where to store the bounce state of the vertical
    *                 axis
    *
    * @see elm_scroller_bounce_get()
    */
   EAPI void         elm_anchorview_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   /**
    * Appends a custom item provider to the given anchorview
    *
    * Appends the given function to the list of items providers. This list is
    * called, one function at a time, with the given @p data pointer, the
    * anchorview object and, in the @p item parameter, the item name as
    * referenced in its href string. Following functions in the list will be
    * called in order until one of them returns something different to NULL,
    * which should be an Evas_Object which will be used in place of the item
    * element.
    *
    * Items in the markup text take the form \<item relsize=16x16 vsize=full
    * href=item/name\>\</item\>
    *
    * @param obj The anchorview object
    * @param func The function to add to the list of providers
    * @param data User data that will be passed to the callback function
    *
    * @see elm_entry_item_provider_append()
    */
   EAPI void         elm_anchorview_item_provider_append(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *anchorview, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * Prepend a custom item provider to the given anchorview
    *
    * Like elm_anchorview_item_provider_append(), but it adds the function
    * @p func to the beginning of the list, instead of the end.
    *
    * @param obj The anchorview object
    * @param func The function to add to the list of providers
    * @param data User data that will be passed to the callback function
    */
   EAPI void         elm_anchorview_item_provider_prepend(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *anchorview, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * Remove a custom item provider from the list of the given anchorview
    *
    * Removes the function and data pairing that matches @p func and @p data.
    * That is, unless the same function and same user data are given, the
    * function will not be removed from the list. This allows us to add the
    * same callback several times, with different @p data pointers and be
    * able to remove them later without conflicts.
    *
    * @param obj The anchorview object
    * @param func The function to remove from the list
    * @param data The data matching the function to remove from the list
    */
   EAPI void         elm_anchorview_item_provider_remove(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *anchorview, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * @}
    */

   /* anchorblock */
   /**
    * @defgroup Anchorblock Anchorblock
    *
    * @image html img/widget/anchorblock/preview-00.png
    * @image latex img/widget/anchorblock/preview-00.eps
    *
    * Anchorblock is for displaying text that contains markup with anchors
    * like <c>\<a href=1234\>something\</\></c> in it.
    *
    * Besides being styled differently, the anchorblock widget provides the
    * necessary functionality so that clicking on these anchors brings up a
    * popup with user defined content such as "call", "add to contacts" or
    * "open web page". This popup is provided using the @ref Hover widget.
    *
    * This widget emits the following signals:
    * @li "anchor,clicked": will be called when an anchor is clicked. The
    * @p event_info parameter on the callback will be a pointer of type
    * ::Elm_Entry_Anchorblock_Info.
    *
    * @see Anchorview
    * @see Entry
    * @see Hover
    *
    * Since examples are usually better than plain words, we might as well
    * try @ref tutorial_anchorblock_example "one".
    */
   /**
    * @page tutorial_anchorblock_example Anchorblock/Anchorview example
    * This example will show both Anchorblock and @ref Anchorview,
    * since both are very similar and it's easier to show them once and side
    * by side, so the difference is more clear.
    *
    * We'll show the relevant snippets of the code here, but the full example
    * can be found here... sorry, @ref anchorblock_example_01.c "here".
    *
    * As for the actual example, it's just a simple window with an anchorblock
    * and an anchorview, both containing the same text. After including
    * Elementary.h and declaring some functions we'll need, we jump to our
    * elm_main (see ELM_MAIN) and create our window.
    * @dontinclude anchorblock_example_01.c
    * @skip int
    * @until const char
    * @until ;
    *
    * With the needed variables declared, we'll create the window and a box to
    * hold our widgets, but we don't need to go through that here.
    *
    * In order to make clear where the anchorblock ends and the anchorview
    * begins, they'll be each inside a @ref Frame. After creating the frame,
    * the anchorblock follows.
    * @skip elm_frame_add
    * @until elm_frame_content_set
    *
    * Nothing out of the ordinary there. What's worth mentioning is the call
    * to elm_anchorblock_hover_parent_set(). We are telling our widget that
    * when an anchor is clicked, the hover for the popup will cover the entire
    * window. This affects the area that will be obscured by the hover and
    * where clicking will dismiss it, as well as the calculations it does to
    * inform the best locations where to insert the popups content.
    * Other than that, the code is pretty standard. We also need to set our
    * callback for when an anchor is clicked, since it's our task to populate
    * the popup. There's no default for it.
    *
    * The anchorview is no different, we only change a few things so it looks
    * different.
    * @until elm_frame_content_set
    *
    * Then we run, so stuff works and close our main function in the usual way.
    * @until ELM_MAIN
    *
    * Now, a little note. Normally you would use either one of anchorblock or
    * anchorview, set your one callback to clicks and do your stuff in there.
    * In this example, however, there are a few tricks to make it easier to
    * show both widgets in one go (and to save me some typing). So we have
    * two callbacks, one per widget, that will call a common function to do
    * the rest. The trick is using ::Elm_Entry_Anchorblock_Info for the
    * anchorview too, since both are equal, and passing a callback to use
    * for our buttons to end the hover, because each widget has a different
    * function for it.
    * @until _anchorview_clicked_cb
    * @until }
    *
    * The meat of our popup is in the following function. We check what kind
    * of menu we need to show, based on the name set to the anchor in the
    * markup text. If there's no type (something went wrong, no valid contact
    * in the address list) we are just putting a button that does nothing, but
    * it's perfectly reasonable to just end the hover and call it quits.
    *
    * Our popup will consist of one main button in the middle of our hover,
    * and possibly a secondary button and a list of other options. We'll create
    * first our main button and check what kind of popup we need afterwards.
    * @skip static void
    * @skip static void
    * @until eina_stringshare_add
    * @until }
    *
    * Each button has two callbacks, one is our hack to close the hover
    * properly based on which widget it belongs to, the other a simple
    * printf that will show the action with the anchors own data. This is
    * not how you would usually do it. Instead, the common case is to have
    * one callback for the button that will know which function to call to end
    * things, but since we are doing it this way it's worth noting that
    * smart callbacks will be called in reverse in respect to the order they
    * were added, and since our @c btn_end_cb will close the hover, and thus
    * delete our buttons, the other callback wouldn't be called if we had
    * added it before.
    *
    * After our telephone popup, there are a few others that are practically
    * the same, so they won't be shown here.
    *
    * Once we are done with that, it's time to place our actions into our
    * hover. Main button goes in the middle without much questioning, and then
    * we see if we have a secondary button and a box of extra options.
    * Because I said so, secondary button goes on either side and box of
    * options either on top or below the main one, but to choose which
    * exactly, we use the hints our callback info has, which saves us from
    * having to do the math and see which side has more space available, with
    * a little special case where we delete our extra stuff if there's nowhere
    * to place it.
    * @skip url:
    * @skip }
    * @skip evas_object_smart
    * @until evas_object_del(box)
    * @until }
    * @until }
    *
    * The example will look like this:
    *
    * @image html screenshots/anchorblock_01.png
    * @image latex screenshots/anchorblock_01.eps width=\textwidth
    *
    * @example anchorblock_example_01.c
    */
   /**
    * @addtogroup Anchorblock
    * @{
    */
   /**
    * @typedef Elm_Entry_Anchorblock_Info
    *
    * The info sent in the callback for "anchor,clicked" signals emitted by
    * the Anchorblock widget.
    */
   typedef struct _Elm_Entry_Anchorblock_Info Elm_Entry_Anchorblock_Info;
   /**
    * @struct _Elm_Entry_Anchorblock_Info
    *
    * The info sent in the callback for "anchor,clicked" signals emitted by
    * the Anchorblock widget.
    */
   struct _Elm_Entry_Anchorblock_Info
     {
        const char     *name; /**< Name of the anchor, as indicated in its href
                                   attribute */
        int             button; /**< The mouse button used to click on it */
        Evas_Object    *hover; /**< The hover object to use for the popup */
        struct {
             Evas_Coord    x, y, w, h;
        } anchor, /**< Geometry selection of text used as anchor */
          hover_parent; /**< Geometry of the object used as parent by the
                             hover */
        Eina_Bool       hover_left : 1; /**< Hint indicating if there's space
                                             for content on the left side of
                                             the hover. Before calling the
                                             callback, the widget will make the
                                             necessary calculations to check
                                             which sides are fit to be set with
                                             content, based on the position the
                                             hover is activated and its distance
                                             to the edges of its parent object
                                             */
        Eina_Bool       hover_right : 1; /**< Hint indicating content fits on
                                              the right side of the hover.
                                              See @ref hover_left */
        Eina_Bool       hover_top : 1; /**< Hint indicating content fits on top
                                            of the hover. See @ref hover_left */
        Eina_Bool       hover_bottom : 1; /**< Hint indicating content fits
                                               below the hover. See @ref
                                               hover_left */
     };
   /**
    * Add a new Anchorblock object
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object *elm_anchorblock_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the text to show in the anchorblock
    *
    * Sets the text of the anchorblock to @p text. This text can include markup
    * format tags, including <c>\<a href=anchorname\></a></c> to begin a segment
    * of text that will be specially styled and react to click events, ended
    * with either of \</a\> or \</\>. When clicked, the anchor will emit an
    * "anchor,clicked" signal that you can attach a callback to with
    * evas_object_smart_callback_add(). The name of the anchor given in the
    * event info struct will be the one set in the href attribute, in this
    * case, anchorname.
    *
    * Other markup can be used to style the text in different ways, but it's
    * up to the style defined in the theme which tags do what.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_anchorblock_text_set(Evas_Object *obj, const char *text) EINA_ARG_NONNULL(1);
   /**
    * Get the markup text set for the anchorblock
    *
    * Retrieves the text set on the anchorblock, with markup tags included.
    *
    * @param obj The anchorblock object
    * @return The markup text set or @c NULL if nothing was set or an error
    * occurred
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_anchorblock_text_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the parent of the hover popup
    *
    * Sets the parent object to use by the hover created by the anchorblock
    * when an anchor is clicked. See @ref Hover for more details on this.
    *
    * @param obj The anchorblock object
    * @param parent The object to use as parent for the hover
    */
   EAPI void         elm_anchorblock_hover_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Get the parent of the hover popup
    *
    * Get the object used as parent for the hover created by the anchorblock
    * widget. See @ref Hover for more details on this.
    * If no parent is set, the same anchorblock object will be used.
    *
    * @param obj The anchorblock object
    * @return The object used as parent for the hover, NULL if none is set.
    */
   EAPI Evas_Object *elm_anchorblock_hover_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the style that the hover should use
    *
    * When creating the popup hover, anchorblock will request that it's
    * themed according to @p style.
    *
    * @param obj The anchorblock object
    * @param style The style to use for the underlying hover
    *
    * @see elm_object_style_set()
    */
   EAPI void         elm_anchorblock_hover_style_set(Evas_Object *obj, const char *style) EINA_ARG_NONNULL(1);
   /**
    * Get the style that the hover should use
    *
    * Get the style the hover created by anchorblock will use.
    *
    * @param obj The anchorblock object
    * @return The style to use by the hover. NULL means the default is used.
    *
    * @see elm_object_style_set()
    */
   EAPI const char  *elm_anchorblock_hover_style_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Ends the hover popup in the anchorblock
    *
    * When an anchor is clicked, the anchorblock widget will create a hover
    * object to use as a popup with user provided content. This function
    * terminates this popup, returning the anchorblock to its normal state.
    *
    * @param obj The anchorblock object
    */
   EAPI void         elm_anchorblock_hover_end(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Appends a custom item provider to the given anchorblock
    *
    * Appends the given function to the list of items providers. This list is
    * called, one function at a time, with the given @p data pointer, the
    * anchorblock object and, in the @p item parameter, the item name as
    * referenced in its href string. Following functions in the list will be
    * called in order until one of them returns something different to NULL,
    * which should be an Evas_Object which will be used in place of the item
    * element.
    *
    * Items in the markup text take the form \<item relsize=16x16 vsize=full
    * href=item/name\>\</item\>
    *
    * @param obj The anchorblock object
    * @param func The function to add to the list of providers
    * @param data User data that will be passed to the callback function
    *
    * @see elm_entry_item_provider_append()
    */
   EAPI void         elm_anchorblock_item_provider_append(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *anchorblock, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * Prepend a custom item provider to the given anchorblock
    *
    * Like elm_anchorblock_item_provider_append(), but it adds the function
    * @p func to the beginning of the list, instead of the end.
    *
    * @param obj The anchorblock object
    * @param func The function to add to the list of providers
    * @param data User data that will be passed to the callback function
    */
   EAPI void         elm_anchorblock_item_provider_prepend(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *anchorblock, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * Remove a custom item provider from the list of the given anchorblock
    *
    * Removes the function and data pairing that matches @p func and @p data.
    * That is, unless the same function and same user data are given, the
    * function will not be removed from the list. This allows us to add the
    * same callback several times, with different @p data pointers and be
    * able to remove them later without conflicts.
    *
    * @param obj The anchorblock object
    * @param func The function to remove from the list
    * @param data The data matching the function to remove from the list
    */
   EAPI void         elm_anchorblock_item_provider_remove(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *anchorblock, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * @}
    */

   /**
    * @defgroup Bubble Bubble
    *
    * @image html img/widget/bubble/preview-00.png
    * @image html img/widget/bubble/preview-01.png
    * @image html img/widget/bubble/preview-02.png
    *
    * @brief The Bubble is a widget to show text similarly to how speech is
    * represented in comics.
    *
    * The bubble widget contains 5 important visual elements:
    * @li The frame is a rectangle with rounded rectangles and an "arrow".
    * @li The @p icon is an image to which the frame's arrow points to.
    * @li The @p label is a text which appears to the right of the icon if the
    * corner is "top_left" or "bottom_left" and is right aligned to the frame
    * otherwise.
    * @li The @p info is a text which appears to the right of the label. Info's
    * font is of a ligther color than label.
    * @li The @p content is an evas object that is shown inside the frame.
    *
    * The position of the arrow, icon, label and info depends on which corner is
    * selected. The four available corners are:
    * @li "top_left" - Default
    * @li "top_right"
    * @li "bottom_left"
    * @li "bottom_right"
    *
    * Signals that you can add callbacks for are:
    * @li "clicked" - This is called when a user has clicked the bubble.
    *
    * For an example of using a buble see @ref bubble_01_example_page "this".
    *
    * @{
    */
   /**
    * Add a new bubble to the parent
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    *
    * This function adds a text bubble to the given parent evas object.
    */
   EAPI Evas_Object *elm_bubble_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the label of the bubble
    *
    * @param obj The bubble object
    * @param label The string to set in the label
    *
    * This function sets the title of the bubble. Where this appears depends on
    * the selected corner.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_bubble_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   /**
    * Get the label of the bubble
    *
    * @param obj The bubble object
    * @return The string of set in the label
    *
    * This function gets the title of the bubble.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_bubble_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the info of the bubble
    *
    * @param obj The bubble object
    * @param info The given info about the bubble
    *
    * This function sets the info of the bubble. Where this appears depends on
    * the selected corner.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_bubble_info_set(Evas_Object *obj, const char *info) EINA_ARG_NONNULL(1);
   /**
    * Get the info of the bubble
    *
    * @param obj The bubble object
    *
    * @return The "info" string of the bubble
    *
    * This function gets the info text.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_bubble_info_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the content to be shown in the bubble
    *
    * Once the content object is set, a previously set one will be deleted.
    * If you want to keep the old content object, use the
    * elm_bubble_content_unset() function.
    *
    * @param obj The bubble object
    * @param content The given content of the bubble
    *
    * This function sets the content shown on the middle of the bubble.
    */
   EAPI void         elm_bubble_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   /**
    * Get the content shown in the bubble
    *
    * Return the content object which is set for this widget.
    *
    * @param obj The bubble object
    * @return The content that is being used
    */
   EAPI Evas_Object *elm_bubble_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Unset the content shown in the bubble
    *
    * Unparent and return the content object which was set for this widget.
    *
    * @param obj The bubble object
    * @return The content that was being used
    */
   EAPI Evas_Object *elm_bubble_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the icon of the bubble
    *
    * Once the icon object is set, a previously set one will be deleted.
    * If you want to keep the old content object, use the
    * elm_icon_content_unset() function.
    *
    * @param obj The bubble object
    * @param icon The given icon for the bubble
    */
   EAPI void         elm_bubble_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   /**
    * Get the icon of the bubble
    *
    * @param obj The bubble object
    * @return The icon for the bubble
    *
    * This function gets the icon shown on the top left of bubble.
    */
   EAPI Evas_Object *elm_bubble_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Unset the icon of the bubble
    *
    * Unparent and return the icon object which was set for this widget.
    *
    * @param obj The bubble object
    * @return The icon that was being used
    */
   EAPI Evas_Object *elm_bubble_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the corner of the bubble
    *
    * @param obj The bubble object.
    * @param corner The given corner for the bubble.
    *
    * This function sets the corner of the bubble. The corner will be used to
    * determine where the arrow in the frame points to and where label, icon and
    * info arre shown.
    *
    * Possible values for corner are:
    * @li "top_left" - Default
    * @li "top_right"
    * @li "bottom_left"
    * @li "bottom_right"
    */
   EAPI void         elm_bubble_corner_set(Evas_Object *obj, const char *corner) EINA_ARG_NONNULL(1, 2);
   /**
    * Get the corner of the bubble
    *
    * @param obj The bubble object.
    * @return The given corner for the bubble.
    *
    * This function gets the selected corner of the bubble.
    */
   EAPI const char  *elm_bubble_corner_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* photo */
   EAPI Evas_Object *elm_photo_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_photo_file_set(Evas_Object *obj, const char *file) EINA_ARG_NONNULL(1);
   EAPI void         elm_photo_size_set(Evas_Object *obj, int size) EINA_ARG_NONNULL(1);
   EAPI void         elm_photo_fill_inside_set(Evas_Object *obj, Eina_Bool fill) EINA_ARG_NONNULL(1);
   EAPI void         elm_photo_editable_set(Evas_Object *obj, Eina_Bool set) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "clicked" - the user clicked the icon
    * "drag,start" - Someone started dragging the image out of the object
    * "drag,end" - Dragged item was dropped (somewhere)
    */

   /* gesture layer */
   /** @defgroup Elm_Gesture_Layer Gesture Layer */
   /**
    * @enum _Elm_Gesture_Types
    * Enum of supported gesture types.
    * @ingroup Elm_Gesture_Layer
    */
   typedef enum _Elm_Gesture_Types
     {
        ELM_GESTURE_FIRST = 0,

        ELM_GESTURE_N_TAPS, /**< N fingers single taps */
        ELM_GESTURE_N_DOUBLE_TAPS, /**< N fingers double-single taps */
        ELM_GESTURE_N_TRIPLE_TAPS, /**< N fingers triple-single taps */

        ELM_GESTURE_MOMENTUM, /**< Reports momentum in the dircetion of move */

        ELM_GESTURE_N_LINES, /**< N fingers line gesture */
        ELM_GESTURE_N_FLICKS, /**< N fingers flick gesture */

        ELM_GESTURE_ZOOM, /**< Zoom */
        ELM_GESTURE_ROTATE, /**< Rotate */

        ELM_GESTURE_LAST
     } Elm_Gesture_Types;

   /**
    * @enum _Elm_Gesture_State
    * Enum of gesture states.
    * @ingroup Elm_Gesture_Layer
    */
   typedef enum _Elm_Gesture_State
     {
        ELM_GESTURE_STATE_UNDEFINED = -1, /**< Gesture not STARTed */
        ELM_GESTURE_STATE_START,          /**< Gesture STARTed     */
        ELM_GESTURE_STATE_MOVE,           /**< Gesture is ongoing  */
        ELM_GESTURE_STATE_END,            /**< Gesture completed   */
        ELM_GESTURE_STATE_ABORT    /**< Onging gesture was ABORTed */
     } Elm_Gesture_State;

   /**
    * @struct _Elm_Gesture_Taps_Info
    * Struct holds taps info for user
    * @ingroup Elm_Gesture_Layer
    */
   struct _Elm_Gesture_Taps_Info
     {
        Evas_Coord x, y;         /**< Holds center point between fingers */
        unsigned int n;          /**< Number of fingers tapped           */
        unsigned int timestamp;  /**< event timestamp       */
     };

   /**
    * @typedef Elm_Gesture_Taps_Info
    * holds taps info for user
    * @ingroup Elm_Gesture_Layer
    */
   typedef struct _Elm_Gesture_Taps_Info Elm_Gesture_Taps_Info;

   /**
    * @struct _Elm_Gesture_Momentum_Info
    * Struct holds momentum info for user
    * x1 and y1 are not necessarily in sync
    * x1 holds x value of x direction starting point
    * and same holds for y1.
    * This is noticeable when doing V-shape movement
    * @ingroup Elm_Gesture_Layer
    */
   struct _Elm_Gesture_Momentum_Info
     {  /* Report line ends, timestamps, and momentum computed        */
        Evas_Coord x1; /**< Final-swipe direction starting point on X */
        Evas_Coord y1; /**< Final-swipe direction starting point on Y */
        Evas_Coord x2; /**< Final-swipe direction ending point on X   */
        Evas_Coord y2; /**< Final-swipe direction ending point on Y   */

        unsigned int tx; /**< Timestamp of start of final x-swipe */
        unsigned int ty; /**< Timestamp of start of final y-swipe */

        Evas_Coord mx; /**< Momentum on X */
        Evas_Coord my; /**< Momentum on Y */
     };

   /**
    * @typedef Elm_Gesture_Momentum_Info
    * holds momentum info for user
    * @ingroup Elm_Gesture_Layer
    */
    typedef struct _Elm_Gesture_Momentum_Info Elm_Gesture_Momentum_Info;

   /**
    * @struct _Elm_Gesture_Line_Info
    * Struct holds line info for user
    * @ingroup Elm_Gesture_Layer
    */
   struct _Elm_Gesture_Line_Info
     {  /* Report line ends, timestamps, and momentum computed      */
        Elm_Gesture_Momentum_Info momentum; /**< Line momentum info */
        unsigned int n;            /**< Number of fingers (lines)   */
        /* FIXME should be radians, bot degrees */
        double angle;              /**< Angle (direction) of lines  */
     };

   /**
    * @typedef _Elm_Gesture_Line_Info
    * Holds line info for user
    * @ingroup Elm_Gesture_Layer
    */
    typedef struct  _Elm_Gesture_Line_Info Elm_Gesture_Line_Info;

   /**
    * @struct _Elm_Gesture_Zoom_Info
    * Struct holds zoom info for user
    * @ingroup Elm_Gesture_Layer
    */
   struct _Elm_Gesture_Zoom_Info
     {
        Evas_Coord x, y;       /**< Holds zoom center point reported to user  */
        Evas_Coord radius; /**< Holds radius between fingers reported to user */
        double zoom;            /**< Zoom value: 1.0 means no zoom             */
        double momentum;        /**< Zoom momentum: zoom growth per second (NOT YET SUPPORTED) */
     };

   /**
    * @typedef Elm_Gesture_Zoom_Info
    * Holds zoom info for user
    * @ingroup Elm_Gesture_Layer
    */
   typedef struct _Elm_Gesture_Zoom_Info Elm_Gesture_Zoom_Info;

   /**
    * @struct _Elm_Gesture_Rotate_Info
    * Struct holds rotation info for user
    * @ingroup Elm_Gesture_Layer
    */
   struct _Elm_Gesture_Rotate_Info
     {
        Evas_Coord x, y;   /**< Holds zoom center point reported to user      */
        Evas_Coord radius; /**< Holds radius between fingers reported to user */
        double base_angle; /**< Holds start-angle */
        double angle;      /**< Rotation value: 0.0 means no rotation         */
        double momentum;   /**< Rotation momentum: rotation done per second (NOT YET SUPPORTED) */
     };

   /**
    * @typedef Elm_Gesture_Rotate_Info
    * Holds rotation info for user
    * @ingroup Elm_Gesture_Layer
    */
   typedef struct _Elm_Gesture_Rotate_Info Elm_Gesture_Rotate_Info;

   /**
    * @typedef Elm_Gesture_Event_Cb
    * User callback used to stream gesture info from gesture layer
    * @param data user data
    * @param event_info gesture report info
    * Returns a flag field to be applied on the causing event.
    * You should probably return EVAS_EVENT_FLAG_ON_HOLD if your widget acted
    * upon the event, in an irreversible way.
    *
    * @ingroup Elm_Gesture_Layer
    */
   typedef Evas_Event_Flags (*Elm_Gesture_Event_Cb) (void *data, void *event_info);

   /**
    * Use function to set callbacks to be notified about
    * change of state of gesture.
    * When a user registers a callback with this function
    * this means this gesture has to be tested.
    *
    * When ALL callbacks for a gesture are set to NULL
    * it means user isn't interested in gesture-state
    * and it will not be tested.
    *
    * @param obj Pointer to gesture-layer.
    * @param idx The gesture you would like to track its state.
    * @param cb callback function pointer.
    * @param cb_type what event this callback tracks: START, MOVE, END, ABORT.
    * @param data user info to be sent to callback (usually, Smart Data)
    *
    * @ingroup Elm_Gesture_Layer
    */
   EAPI void elm_gesture_layer_cb_set(Evas_Object *obj, Elm_Gesture_Types idx, Elm_Gesture_State cb_type, Elm_Gesture_Event_Cb cb, void *data) EINA_ARG_NONNULL(1);

   /**
    * Call this function to get repeat-events settings.
    *
    * @param obj Pointer to gesture-layer.
    *
    * @return repeat events settings.
    * @see elm_gesture_layer_hold_events_set()
    * @ingroup Elm_Gesture_Layer
    */
   EAPI Eina_Bool elm_gesture_layer_hold_events_get(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * This function called in order to make gesture-layer repeat events.
    * Set this of you like to get the raw events only if gestures were not detected.
    * Clear this if you like gesture layer to fwd events as testing gestures.
    *
    * @param obj Pointer to gesture-layer.
    * @param r Repeat: TRUE/FALSE
    *
    * @ingroup Elm_Gesture_Layer
    */
   EAPI void elm_gesture_layer_hold_events_set(Evas_Object *obj, Eina_Bool r) EINA_ARG_NONNULL(1);

   /**
    * This function sets step-value for zoom action.
    * Set step to any positive value.
    * Cancel step setting by setting to 0.0
    *
    * @param obj Pointer to gesture-layer.
    * @param s new zoom step value.
    *
    * @ingroup Elm_Gesture_Layer
    */
   EAPI void elm_gesture_layer_zoom_step_set(Evas_Object *obj, double s) EINA_ARG_NONNULL(1);

   /**
    * This function sets step-value for rotate action.
    * Set step to any positive value.
    * Cancel step setting by setting to 0.0
    *
    * @param obj Pointer to gesture-layer.
    * @param s new roatate step value.
    *
    * @ingroup Elm_Gesture_Layer
    */
   EAPI void elm_gesture_layer_rotate_step_set(Evas_Object *obj, double s) EINA_ARG_NONNULL(1);

   /**
    * This function called to attach gesture-layer to an Evas_Object.
    * @param obj Pointer to gesture-layer.
    * @param t Pointer to underlying object (AKA Target)
    *
    * @return TRUE, FALSE on success, failure.
    *
    * @ingroup Elm_Gesture_Layer
    */
   EAPI Eina_Bool elm_gesture_layer_attach(Evas_Object *obj, Evas_Object *t) EINA_ARG_NONNULL(1, 2);

   /**
    * Call this function to construct a new gesture-layer object.
    * This does not activate the gesture layer. You have to
    * call elm_gesture_layer_attach in order to 'activate' gesture-layer.
    *
    * @param parent the parent object.
    *
    * @return Pointer to new gesture-layer object.
    *
    * @ingroup Elm_Gesture_Layer
    */
   EAPI Evas_Object *elm_gesture_layer_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /* thumb */
   typedef enum _Elm_Thumb_Animation_Setting
     {
        ELM_THUMB_ANIMATION_START = 0, /* Play animation once */
        ELM_THUMB_ANIMATION_LOOP,      /* Keep playing animation until stop is requested */
        ELM_THUMB_ANIMATION_STOP,
        ELM_THUMB_ANIMATION_LAST
     } Elm_Thumb_Animation_Setting;

   EAPI Evas_Object                 *elm_thumb_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void                         elm_thumb_reload(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                         elm_thumb_file_set(Evas_Object *obj, const char *file, const char *key) EINA_ARG_NONNULL(1);
   EAPI void                         elm_thumb_file_get(const Evas_Object *obj, const char **file, const char **key) EINA_ARG_NONNULL(1);
   EAPI void                         elm_thumb_path_get(const Evas_Object *obj, const char **file, const char **key) EINA_ARG_NONNULL(1);
   EAPI void                         elm_thumb_animate_set(Evas_Object *obj, Elm_Thumb_Animation_Setting s) EINA_ARG_NONNULL(1);
   EAPI Elm_Thumb_Animation_Setting  elm_thumb_animate_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                        *elm_thumb_ethumb_client_get(void);
   EAPI Eina_Bool                    elm_thumb_ethumb_client_connected(void);
   EAPI Eina_Bool                    elm_thumb_editable_set(Evas_Object *obj, Eina_Bool edit) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool                    elm_thumb_editable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* available styles:
    * default
    * noframe
    */
   /* smart callbacks called:
    * "clicked" - This is called when a user has clicked the thumb without dragging around.
    * "clicked,double" - This is called when a user has double-clicked the thumb.
    * "press" - This is called when a user has pressed down the thumb.
    * "generate,start" - The thumbnail generation started.
    * "generate,stop" - The generation process stopped.
    * "generate,error" - The generation failed.
    * "load,error" - The thumbnail image loading failed.
    */

   /**
    * @defgroup Hoversel
    *
    * @image html img/widget/hoversel/preview-00.png
    * @image latex img/widget/hoversel/preview-00.eps
    *
    * A hoversel is a button that pops up a list of items (automatically
    * choosing the direction to display) that have a label and, optionally, an
    * icon to select from. It is a convenience widget to avoid the need to do
    * all the piecing together yourself. It is intended for a small number of
    * items in the hoversel menu (no more than 8), though is capable of many
    * more.
    *
    * Signals that you can add callbacks for are:
    * "clicked" - the user clicked the hoversel button and popped up the sel
    * "selected" - an item in the hoversel list is selected. event_info is the item
    * "dismissed" - the hover is dismissed
    *
    * See @ref tutorial_hoversel for an example.
    * @{
    */
   typedef struct _Elm_Hoversel_Item Elm_Hoversel_Item; /**< Item of Elm_Hoversel. Sub-type of Elm_Widget_Item */
   /**
    * @brief Add a new Hoversel object
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object       *elm_hoversel_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief This sets the hoversel to expand horizontally.
    *
    * @param obj The hoversel object
    * @param horizontal If true, the hover will expand horizontally to the
    * right.
    *
    * @note The initial button will display horizontally regardless of this
    * setting.
    */
   EAPI void               elm_hoversel_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   /**
    * @brief This returns whether the hoversel is set to expand horizontally.
    *
    * @param obj The hoversel object
    * @return If true, the hover will expand horizontally to the right.
    *
    * @see elm_hoversel_horizontal_set()
    */
   EAPI Eina_Bool          elm_hoversel_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the Hover parent
    *
    * @param obj The hoversel object
    * @param parent The parent to use
    *
    * Sets the hover parent object, the area that will be darkened when the
    * hoversel is clicked. Should probably be the window that the hoversel is
    * in. See @ref Hover objects for more information.
    */
   EAPI void               elm_hoversel_hover_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the Hover parent
    *
    * @param obj The hoversel object
    * @return The used parent
    *
    * Gets the hover parent object.
    *
    * @see elm_hoversel_hover_parent_set()
    */
   EAPI Evas_Object       *elm_hoversel_hover_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the hoversel button label
    *
    * @param obj The hoversel object
    * @param label The label text.
    *
    * This sets the label of the button that is always visible (before it is
    * clicked and expanded).
    *
    * @deprecated elm_object_text_set()
    */
   EINA_DEPRECATED EAPI void               elm_hoversel_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the hoversel button label
    *
    * @param obj The hoversel object
    * @return The label text.
    *
    * @deprecated elm_object_text_get()
    */
   EINA_DEPRECATED EAPI const char        *elm_hoversel_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the icon of the hoversel button
    *
    * @param obj The hoversel object
    * @param icon The icon object
    *
    * Sets the icon of the button that is always visible (before it is clicked
    * and expanded).  Once the icon object is set, a previously set one will be
    * deleted, if you want to keep that old content object, use the
    * elm_hoversel_icon_unset() function.
    *
    * @see elm_button_icon_set()
    */
   EAPI void               elm_hoversel_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the icon of the hoversel button
    *
    * @param obj The hoversel object
    * @return The icon object
    *
    * Get the icon of the button that is always visible (before it is clicked
    * and expanded). Also see elm_button_icon_get().
    *
    * @see elm_hoversel_icon_set()
    */
   EAPI Evas_Object       *elm_hoversel_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Get and unparent the icon of the hoversel button
    *
    * @param obj The hoversel object
    * @return The icon object that was being used
    *
    * Unparent and return the icon of the button that is always visible
    * (before it is clicked and expanded).
    *
    * @see elm_hoversel_icon_set()
    * @see elm_button_icon_unset()
    */
   EAPI Evas_Object       *elm_hoversel_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief This triggers the hoversel popup from code, the same as if the user
    * had clicked the button.
    *
    * @param obj The hoversel object
    */
   EAPI void               elm_hoversel_hover_begin(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief This dismisses the hoversel popup as if the user had clicked
    * outside the hover.
    *
    * @param obj The hoversel object
    */
   EAPI void               elm_hoversel_hover_end(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Returns whether the hoversel is expanded.
    *
    * @param obj The hoversel object
    * @return  This will return EINA_TRUE if the hoversel is expanded or
    * EINA_FALSE if it is not expanded.
    */
   EAPI Eina_Bool          elm_hoversel_expanded_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief This will remove all the children items from the hoversel.
    *
    * @param obj The hoversel object
    *
    * @warning Should @b not be called while the hoversel is active; use
    * elm_hoversel_expanded_get() to check first.
    *
    * @see elm_hoversel_item_del_cb_set()
    * @see elm_hoversel_item_del()
    */
   EAPI void               elm_hoversel_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the list of items within the given hoversel.
    *
    * @param obj The hoversel object
    * @return Returns a list of Elm_Hoversel_Item*
    *
    * @see elm_hoversel_item_add()
    */
   EAPI const Eina_List   *elm_hoversel_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Add an item to the hoversel button
    *
    * @param obj The hoversel object
    * @param label The text label to use for the item (NULL if not desired)
    * @param icon_file An image file path on disk to use for the icon or standard
    * icon name (NULL if not desired)
    * @param icon_type The icon type if relevant
    * @param func Convenience function to call when this item is selected
    * @param data Data to pass to item-related functions
    * @return A handle to the item added.
    *
    * This adds an item to the hoversel to show when it is clicked. Note: if you
    * need to use an icon from an edje file then use
    * elm_hoversel_item_icon_set() right after the this function, and set
    * icon_file to NULL here.
    *
    * For more information on what @p icon_file and @p icon_type are see the
    * @ref Icon "icon documentation".
    */
   EAPI Elm_Hoversel_Item *elm_hoversel_item_add(Evas_Object *obj, const char *label, const char *icon_file, Elm_Icon_Type icon_type, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   /**
    * @brief Delete an item from the hoversel
    *
    * @param item The item to delete
    *
    * This deletes the item from the hoversel (should not be called while the
    * hoversel is active; use elm_hoversel_expanded_get() to check first).
    *
    * @see elm_hoversel_item_add()
    * @see elm_hoversel_item_del_cb_set()
    */
   EAPI void               elm_hoversel_item_del(Elm_Hoversel_Item *item) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the function to be called when an item from the hoversel is
    * freed.
    *
    * @param item The item to set the callback on
    * @param func The function called
    *
    * That function will receive these parameters:
    * @li void *item_data
    * @li Evas_Object *the_item_object
    * @li Elm_Hoversel_Item *the_object_struct
    *
    * @see elm_hoversel_item_add()
    */
   EAPI void               elm_hoversel_item_del_cb_set(Elm_Hoversel_Item *it, Evas_Smart_Cb func) EINA_ARG_NONNULL(1);
   /**
    * @brief This returns the data pointer supplied with elm_hoversel_item_add()
    * that will be passed to associated function callbacks.
    *
    * @param item The item to get the data from
    * @return The data pointer set with elm_hoversel_item_add()
    *
    * @see elm_hoversel_item_add()
    */
   EAPI void              *elm_hoversel_item_data_get(const Elm_Hoversel_Item *it) EINA_ARG_NONNULL(1);
   /**
    * @brief This returns the label text of the given hoversel item.
    *
    * @param item The item to get the label
    * @return The label text of the hoversel item
    *
    * @see elm_hoversel_item_add()
    */
   EAPI const char        *elm_hoversel_item_label_get(const Elm_Hoversel_Item *it) EINA_ARG_NONNULL(1);
   /**
    * @brief This sets the icon for the given hoversel item.
    *
    * @param item The item to set the icon
    * @param icon_file An image file path on disk to use for the icon or standard
    * icon name
    * @param icon_group The edje group to use if @p icon_file is an edje file. Set this
    * to NULL if the icon is not an edje file
    * @param icon_type The icon type
    *
    * The icon can be loaded from the standard set, from an image file, or from
    * an edje file.
    *
    * @see elm_hoversel_item_add()
    */
   EAPI void               elm_hoversel_item_icon_set(Elm_Hoversel_Item *it, const char *icon_file, const char *icon_group, Elm_Icon_Type icon_type) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the icon object of the hoversel item
    *
    * @param item The item to get the icon from
    * @param icon_file The image file path on disk used for the icon or standard
    * icon name
    * @param icon_group The edje group used if @p icon_file is an edje file. NULL
    * if the icon is not an edje file
    * @param icon_type The icon type
    *
    * @see elm_hoversel_item_icon_set()
    * @see elm_hoversel_item_add()
    */
   EAPI void               elm_hoversel_item_icon_get(const Elm_Hoversel_Item *it, const char **icon_file, const char **icon_group, Elm_Icon_Type *icon_type) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* toolbar */
   typedef enum _Elm_Toolbar_Shrink_Mode
     {
        ELM_TOOLBAR_SHRINK_NONE,   /**< set toolbar minimun size to fit all the items */
        ELM_TOOLBAR_SHRINK_HIDE,   /**< hide excess items */
        ELM_TOOLBAR_SHRINK_SCROLL, /**< allow accessing excess items through a scroller */
        ELM_TOOLBAR_SHRINK_MENU    /**< inserts a button to pop up a menu with excess items */
     } Elm_Toolbar_Shrink_Mode;

   typedef struct _Elm_Toolbar_Item Elm_Toolbar_Item; /**< Item of Elm_Toolbar. Sub-type of Elm_Widget_Item */
   typedef struct _Elm_Toolbar_Item_State Elm_Toolbar_Item_State; /** State of a Elm_Toolbar_Item */

   EAPI Evas_Object            *elm_toolbar_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_icon_size_set(Evas_Object *obj, int icon_size) EINA_ARG_NONNULL(1);
   EAPI int                     elm_toolbar_icon_size_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_icon_order_lookup_set(Evas_Object *obj, Elm_Icon_Lookup_Order order) EINA_ARG_NONNULL(1);
   EAPI Elm_Icon_Lookup_Order   elm_toolbar_icon_order_lookup_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_no_select_mode_set(Evas_Object *obj, Eina_Bool no_select) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_no_select_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_append(Evas_Object *obj, const char *icon, const char *label, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_prepend(Evas_Object *obj, const char *icon, const char *label, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_insert_before(Evas_Object *obj, Elm_Toolbar_Item *before, const char *icon, const char *label, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_insert_after(Evas_Object *obj, Elm_Toolbar_Item *after, const char *icon, const char *label, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_first_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_last_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_next_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_prev_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI Evas_Object            *elm_toolbar_item_toolbar_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_priority_set(Elm_Toolbar_Item *item, int priority) EINA_ARG_NONNULL(1);
   EAPI int                     elm_toolbar_item_priority_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI const char             *elm_toolbar_item_icon_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI const char             *elm_toolbar_item_label_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_label_set(Elm_Toolbar_Item *item, const char *label) EINA_ARG_NONNULL(1);
   EAPI void                   *elm_toolbar_item_data_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_data_set(Elm_Toolbar_Item *item, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_find_by_label(const Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_item_selected_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_selected_set(Elm_Toolbar_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_selected_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_icon_set(Elm_Toolbar_Item *item, const char *icon) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_del(Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_del_cb_set(Elm_Toolbar_Item *item, Evas_Smart_Cb func) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_item_disabled_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_disabled_set(Elm_Toolbar_Item *item, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_separator_set(Elm_Toolbar_Item *item, Eina_Bool separator) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_item_separator_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_mode_shrink_set(Evas_Object *obj, Elm_Toolbar_Shrink_Mode shrink_mode) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Shrink_Mode elm_toolbar_mode_shrink_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_homogeneous_set(Evas_Object *obj, Eina_Bool homogeneous) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_homogeneous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void    elm_toolbar_homogenous_set(Evas_Object *obj, Eina_Bool homogenous) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool elm_toolbar_homogenous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_menu_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Evas_Object            *elm_toolbar_menu_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_align_set(Evas_Object *obj, double align) EINA_ARG_NONNULL(1);
   EAPI double                  elm_toolbar_align_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_menu_set(Elm_Toolbar_Item *item, Eina_Bool menu) EINA_ARG_NONNULL(1);
   EAPI Evas_Object            *elm_toolbar_item_menu_get(Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item_State *elm_toolbar_item_state_add(Elm_Toolbar_Item *item, const char *icon, const char *label, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_item_state_del(Elm_Toolbar_Item *item, Elm_Toolbar_Item_State *state) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_item_state_set(Elm_Toolbar_Item *it, Elm_Toolbar_Item_State *state) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_state_unset(Elm_Toolbar_Item *it) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item_State *elm_toolbar_item_state_get(const Elm_Toolbar_Item *it) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item_State *elm_toolbar_item_state_next(Elm_Toolbar_Item *it) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item_State *elm_toolbar_item_state_prev(Elm_Toolbar_Item *it) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_tooltip_text_set(Elm_Toolbar_Item *item, const char *text) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_tooltip_content_cb_set(Elm_Toolbar_Item *item, Elm_Tooltip_Item_Content_Cb func, const void *data, Evas_Smart_Cb del_cb) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_tooltip_unset(Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_tooltip_style_set(Elm_Toolbar_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char             *elm_toolbar_item_tooltip_style_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_cursor_set(Elm_Toolbar_Item *item, const char *cursor) EINA_ARG_NONNULL(1);
   EAPI const char             *elm_toolbar_item_cursor_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_cursor_unset(Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_cursor_style_set(Elm_Toolbar_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char             *elm_toolbar_item_cursor_style_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_cursor_engine_only_set(Elm_Toolbar_Item *item, Eina_Bool engine_only) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_item_cursor_engine_only_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "clicked" - when the user clicks on a toolbar item and becomes selected
    */
   /* available styles:
    * default
    * transparent (no background or shadow, just show the provided content)
    */

   /* tooltip */
   EAPI double       elm_tooltip_delay_get(void);
   EAPI Eina_Bool    elm_tooltip_delay_set(double delay);
   EAPI void         elm_object_tooltip_show(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_tooltip_hide(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_tooltip_text_set(Evas_Object *obj, const char *text) EINA_ARG_NONNULL(1, 2);
   EAPI void         elm_object_tooltip_content_cb_set(Evas_Object *obj, Elm_Tooltip_Content_Cb func, const void *data, Evas_Smart_Cb del_cb) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_tooltip_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_tooltip_style_set(Evas_Object *obj, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_object_tooltip_style_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_cursor_set(Evas_Object *obj, const char *cursor) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_object_cursor_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_cursor_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_cursor_style_set(Evas_Object *obj, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_object_cursor_style_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_cursor_engine_only_set(Evas_Object *obj, Eina_Bool engine_only) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_object_cursor_engine_only_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_tooltip_size_restrict_disable(Evas_Object *obj, Eina_Bool disable); EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_tooltip_size_restrict_disabled_get(const Evas_Object *obj); EINA_ARG_NONNULL(1);

   /* cursors */
   EAPI int          elm_cursor_engine_only_get(void);
   EAPI Eina_Bool    elm_cursor_engine_only_set(int engine_only);

   /* menu */
   typedef struct _Elm_Menu_Item Elm_Menu_Item; /**< Item of Elm_Menu. Sub-type of Elm_Widget_Item */
   EAPI Evas_Object       *elm_menu_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_menu_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_move(Evas_Object *obj, Evas_Coord x, Evas_Coord y) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_close(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List   *elm_menu_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_menu_item_object_get(const Elm_Menu_Item *it) EINA_ARG_NONNULL(1);
   EAPI Elm_Menu_Item     *elm_menu_item_add(Evas_Object *obj, Elm_Menu_Item *parent, const char *icon, const char *label, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Menu_Item     *elm_menu_item_add_object(Evas_Object *obj, Elm_Menu_Item *parent, Evas_Object *subobj, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_label_set(Elm_Menu_Item *item, const char *label) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_menu_item_label_get(const Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_icon_set(Elm_Menu_Item *item, const char *icon) EINA_ARG_NONNULL(1, 2);
   EAPI const char        *elm_menu_item_icon_get(const Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI const Evas_Object *elm_menu_item_object_icon_get(const Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_selected_set(Elm_Menu_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_menu_item_selected_get(const Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_disabled_set(Elm_Menu_Item *item, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_menu_item_disabled_get(const Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Menu_Item     *elm_menu_item_separator_add(Evas_Object *obj, Elm_Menu_Item *parent) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_menu_item_is_separator(Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_del(Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_del_cb_set(Elm_Menu_Item *it, Evas_Smart_Cb func) EINA_ARG_NONNULL(1);
   EAPI void              *elm_menu_item_data_get(const Elm_Menu_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_data_set(Elm_Menu_Item *item, const void *data) EINA_ARG_NONNULL(1);
   EAPI const Eina_List   *elm_menu_item_subitems_get(const Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI const Elm_Menu_Item *elm_menu_selected_item_get(const Evas_Object * obj) EINA_ARG_NONNULL(1);
   EAPI const Elm_Menu_Item *elm_menu_last_item_get(const Evas_Object * obj) EINA_ARG_NONNULL(1);
   EAPI const Elm_Menu_Item *elm_menu_first_item_get(const Evas_Object * obj) EINA_ARG_NONNULL(1);
   EAPI const Elm_Menu_Item *elm_menu_item_next_get(const Elm_Menu_Item *it) EINA_ARG_NONNULL(1);
   EAPI const Elm_Menu_Item *elm_menu_item_prev_get(const Elm_Menu_Item *it) EINA_ARG_NONNULL(1);

   /* smart callbacks called:
    * "clicked" - the user clicked the empty space in the menu to dismiss. event_info is NULL.
    */

   /**
    * @defgroup List List
    * @ingroup Elementary
    *
    * @image html img/widget/list/preview-00.png
    * @image latex img/widget/list/preview-00.eps width=\textwidth
    *
    * @image html img/list.png
    * @image latex img/list.eps width=\textwidth
    *
    * A list widget is a container whose children are displayed vertically or
    * horizontally, in order, and can be selected.
    * The list can accept only one or multiple items selection. Also has many
    * modes of items displaying.
    *
    * A list is a very simple type of list widget.  For more robust
    * lists, @ref Genlist should probably be used.
    *
    * Smart callbacks one can listen to:
    * - @c "activated" - The user has double-clicked or pressed
    *   (enter|return|spacebar) on an item. The @c event_info parameter
    *   is the item that was activated.
    * - @c "clicked,double" - The user has double-clicked an item.
    *   The @c event_info parameter is the item that was double-clicked.
    * - "selected" - when the user selected an item
    * - "unselected" - when the user unselected an item
    * - "longpressed" - an item in the list is long-pressed
    * - "scroll,edge,top" - the list is scrolled until the top edge
    * - "scroll,edge,bottom" - the list is scrolled until the bottom edge
    * - "scroll,edge,left" - the list is scrolled until the left edge
    * - "scroll,edge,right" - the list is scrolled until the right edge
    *
    * Available styles for it:
    * - @c "default"
    *
    * List of examples:
    * @li @ref list_example_01
    * @li @ref list_example_02
    * @li @ref list_example_03
    */

   /**
    * @addtogroup List
    * @{
    */

   /**
    * @enum _Elm_List_Mode
    * @typedef Elm_List_Mode
    *
    * Set list's resize behavior, transverse axis scroll and
    * items cropping. See each mode's description for more details.
    *
    * @note Default value is #ELM_LIST_SCROLL.
    *
    * Values <b> don't </b> work as bitmaks, only one can be choosen.
    *
    * @see elm_list_mode_set()
    * @see elm_list_mode_get()
    *
    * @ingroup List
    */
   typedef enum _Elm_List_Mode
     {
        ELM_LIST_COMPRESS = 0, /**< Won't set any of its size hints to inform how a possible container should resize it. Then, if it's not created as a "resize object", it might end with zero dimensions. The list will respect the container's geometry and, if any of its items won't fit into its transverse axis, one won't be able to scroll it in that direction. */
        ELM_LIST_SCROLL, /**< Default value. Won't set any of its size hints to inform how a possible container should resize it. Then, if it's not created as a "resize object", it might end with zero dimensions. The list will respect the container's geometry and, if any of its items won't fit into its transverse axis, one will be able to scroll it in that direction (large items will get cropped). */
        ELM_LIST_LIMIT, /**< Set a minimun size hint on the list object, so that containers may respect it (and resize itself to fit the child properly). More specifically, a minimum size hint will be set for its transverse axis, so that the @b largest item in that direction fits well. Can have effects bounded by setting the list object's maximum size hints. */
        ELM_LIST_EXPAND, /**< Besides setting a minimum size on the transverse axis, just like the previous mode, will set a minimum size on the longitudinal axis too, trying to reserve space to all its children to be visible at a time. Can have effects bounded by setting the list object's maximum size hints. */
        ELM_LIST_LAST /**< Indicates error if returned by elm_list_mode_get() */
     } Elm_List_Mode;

   typedef struct _Elm_List_Item Elm_List_Item; /**< Item of Elm_List. Sub-type of Elm_Widget_Item. Can be created with elm_list_item_append(), elm_list_item_prepend() and functions to add items in relative positions, like elm_list_item_insert_before(), and deleted with elm_list_item_del().  */

   /**
    * Add a new list widget to the given parent Elementary
    * (container) object.
    *
    * @param parent The parent object.
    * @return a new list widget handle or @c NULL, on errors.
    *
    * This function inserts a new list widget on the canvas.
    *
    * @ingroup List
    */
   EAPI Evas_Object     *elm_list_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Starts the list.
    *
    * @param obj The list object
    *
    * @note Call before running show() on the list object.
    * @warning If not called, it won't display the list properly.
    *
    * @code
    * li = elm_list_add(win);
    * elm_list_item_append(li, "First", NULL, NULL, NULL, NULL);
    * elm_list_item_append(li, "Second", NULL, NULL, NULL, NULL);
    * elm_list_go(li);
    * evas_object_show(li);
    * @endcode
    *
    * @ingroup List
    */
   EAPI void             elm_list_go(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Enable or disable multiple items selection on the list object.
    *
    * @param obj The list object
    * @param multi @c EINA_TRUE to enable multi selection or @c EINA_FALSE to
    * disable it.
    *
    * Disabled by default. If disabled, the user can select a single item of
    * the list each time. Selected items are highlighted on list.
    * If enabled, many items can be selected.
    *
    * If a selected item is selected again, it will be unselected.
    *
    * @see elm_list_multi_select_get()
    *
    * @ingroup List
    */
   EAPI void             elm_list_multi_select_set(Evas_Object *obj, Eina_Bool multi) EINA_ARG_NONNULL(1);

   /**
    * Get a value whether multiple items selection is enabled or not.
    *
    * @see elm_list_multi_select_set() for details.
    *
    * @param obj The list object.
    * @return @c EINA_TRUE means multiple items selection is enabled.
    * @c EINA_FALSE indicates it's disabled. If @p obj is @c NULL,
    * @c EINA_FALSE is returned.
    *
    * @ingroup List
    */
   EAPI Eina_Bool        elm_list_multi_select_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set which mode to use for the list object.
    *
    * @param obj The list object
    * @param mode One of #Elm_List_Mode: #ELM_LIST_COMPRESS, #ELM_LIST_SCROLL,
    * #ELM_LIST_LIMIT or #ELM_LIST_EXPAND.
    *
    * Set list's resize behavior, transverse axis scroll and
    * items cropping. See each mode's description for more details.
    *
    * @note Default value is #ELM_LIST_SCROLL.
    *
    * Only one can be set, if a previous one was set, it will be changed
    * by the new mode set. Bitmask won't work as well.
    *
    * @see elm_list_mode_get()
    *
    * @ingroup List
    */
   EAPI void             elm_list_mode_set(Evas_Object *obj, Elm_List_Mode mode) EINA_ARG_NONNULL(1);

   /**
    * Get the mode the list is at.
    *
    * @param obj The list object
    * @return One of #Elm_List_Mode: #ELM_LIST_COMPRESS, #ELM_LIST_SCROLL,
    * #ELM_LIST_LIMIT, #ELM_LIST_EXPAND or #ELM_LIST_LAST on errors.
    *
    * @note see elm_list_mode_set() for more information.
    *
    * @ingroup List
    */
   EAPI Elm_List_Mode    elm_list_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Enable or disable horizontal mode on the list object.
    *
    * @param obj The list object.
    * @param horizontal @c EINA_TRUE to enable horizontal or @c EINA_FALSE to
    * disable it, i.e., to enable vertical mode.
    *
    * @note Vertical mode is set by default.
    *
    * On horizontal mode items are displayed on list from left to right,
    * instead of from top to bottom. Also, the list will scroll horizontally.
    * Each item will presents left icon on top and right icon, or end, at
    * the bottom.
    *
    * @see elm_list_horizontal_get()
    *
    * @ingroup List
    */
   EAPI void             elm_list_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);

   /**
    * Get a value whether horizontal mode is enabled or not.
    *
    * @param obj The list object.
    * @return @c EINA_TRUE means horizontal mode selection is enabled.
    * @c EINA_FALSE indicates it's disabled. If @p obj is @c NULL,
    * @c EINA_FALSE is returned.
    *
    * @see elm_list_horizontal_set() for details.
    *
    * @ingroup List
    */
   EAPI Eina_Bool        elm_list_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Enable or disable always select mode on the list object.
    *
    * @param obj The list object
    * @param always_select @c EINA_TRUE to enable always select mode or
    * @c EINA_FALSE to disable it.
    *
    * @note Always select mode is disabled by default.
    *
    * Default behavior of list items is to only call its callback function
    * the first time it's pressed, i.e., when it is selected. If a selected
    * item is pressed again, and multi-select is disabled, it won't call
    * this function (if multi-select is enabled it will unselect the item).
    *
    * If always select is enabled, it will call the callback function
    * everytime a item is pressed, so it will call when the item is selected,
    * and again when a selected item is pressed.
    *
    * @see elm_list_always_select_mode_get()
    * @see elm_list_multi_select_set()
    *
    * @ingroup List
    */
   EAPI void             elm_list_always_select_mode_set(Evas_Object *obj, Eina_Bool always_select) EINA_ARG_NONNULL(1);

   /**
    * Get a value whether always select mode is enabled or not, meaning that
    * an item will always call its callback function, even if already selected.
    *
    * @param obj The list object
    * @return @c EINA_TRUE means horizontal mode selection is enabled.
    * @c EINA_FALSE indicates it's disabled. If @p obj is @c NULL,
    * @c EINA_FALSE is returned.
    *
    * @see elm_list_always_select_mode_set() for details.
    *
    * @ingroup List
    */
   EAPI Eina_Bool        elm_list_always_select_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set bouncing behaviour when the scrolled content reaches an edge.
    *
    * Tell the internal scroller object whether it should bounce or not
    * when it reaches the respective edges for each axis.
    *
    * @param obj The list object
    * @param h_bounce Whether to bounce or not in the horizontal axis.
    * @param v_bounce Whether to bounce or not in the vertical axis.
    *
    * @see elm_scroller_bounce_set()
    *
    * @ingroup List
    */
   EAPI void             elm_list_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);

   /**
    * Get the bouncing behaviour of the internal scroller.
    *
    * Get whether the internal scroller should bounce when the edge of each
    * axis is reached scrolling.
    *
    * @param obj The list object.
    * @param h_bounce Pointer where to store the bounce state of the horizontal
    * axis.
    * @param v_bounce Pointer where to store the bounce state of the vertical
    * axis.
    *
    * @see elm_scroller_bounce_get()
    * @see elm_list_bounce_set()
    *
    * @ingroup List
    */
   EAPI void             elm_list_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);

   /**
    * Set the scrollbar policy.
    *
    * @param obj The list object
    * @param policy_h Horizontal scrollbar policy.
    * @param policy_v Vertical scrollbar policy.
    *
    * This sets the scrollbar visibility policy for the given scroller.
    * #ELM_SCROLLER_POLICY_AUTO means the scrollber is made visible if it
    * is needed, and otherwise kept hidden. #ELM_SCROLLER_POLICY_ON turns
    * it on all the time, and #ELM_SCROLLER_POLICY_OFF always keeps it off.
    * This applies respectively for the horizontal and vertical scrollbars.
    *
    * The both are disabled by default, i.e., are set to
    * #ELM_SCROLLER_POLICY_OFF.
    *
    * @ingroup List
    */
   EAPI void             elm_list_scroller_policy_set(Evas_Object *obj, Elm_Scroller_Policy policy_h, Elm_Scroller_Policy policy_v) EINA_ARG_NONNULL(1);

   /**
    * Get the scrollbar policy.
    *
    * @see elm_list_scroller_policy_get() for details.
    *
    * @param obj The list object.
    * @param policy_h Pointer where to store horizontal scrollbar policy.
    * @param policy_v Pointer where to store vertical scrollbar policy.
    *
    * @ingroup List
    */
   EAPI void             elm_list_scroller_policy_get(const Evas_Object *obj, Elm_Scroller_Policy *policy_h, Elm_Scroller_Policy *policy_v) EINA_ARG_NONNULL(1);

   /**
    * Append a new item to the list object.
    *
    * @param obj The list object.
    * @param label The label of the list item.
    * @param icon The icon object to use for the left side of the item. An
    * icon can be any Evas object, but usually it is an icon created
    * with elm_icon_add().
    * @param end The icon object to use for the right side of the item. An
    * icon can be any Evas object.
    * @param func The function to call when the item is clicked.
    * @param data The data to associate with the item for related callbacks.
    *
    * @return The created item or @c NULL upon failure.
    *
    * A new item will be created and appended to the list, i.e., will
    * be set as @b last item.
    *
    * Items created with this method can be deleted with
    * elm_list_item_del().
    *
    * Associated @p data can be properly freed when item is deleted if a
    * callback function is set with elm_list_item_del_cb_set().
    *
    * If a function is passed as argument, it will be called everytime this item
    * is selected, i.e., the user clicks over an unselected item.
    * If always select is enabled it will call this function every time
    * user clicks over an item (already selected or not).
    * If such function isn't needed, just passing
    * @c NULL as @p func is enough. The same should be done for @p data.
    *
    * Simple example (with no function callback or data associated):
    * @code
    * li = elm_list_add(win);
    * ic = elm_icon_add(win);
    * elm_icon_file_set(ic, "path/to/image", NULL);
    * elm_icon_scale_set(ic, EINA_TRUE, EINA_TRUE);
    * elm_list_item_append(li, "label", ic, NULL, NULL, NULL);
    * elm_list_go(li);
    * evas_object_show(li);
    * @endcode
    *
    * @see elm_list_always_select_mode_set()
    * @see elm_list_item_del()
    * @see elm_list_item_del_cb_set()
    * @see elm_list_clear()
    * @see elm_icon_add()
    *
    * @ingroup List
    */
   EAPI Elm_List_Item   *elm_list_item_append(Evas_Object *obj, const char *label, Evas_Object *icon, Evas_Object *end, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);

   /**
    * Prepend a new item to the list object.
    *
    * @param obj The list object.
    * @param label The label of the list item.
    * @param icon The icon object to use for the left side of the item. An
    * icon can be any Evas object, but usually it is an icon created
    * with elm_icon_add().
    * @param end The icon object to use for the right side of the item. An
    * icon can be any Evas object.
    * @param func The function to call when the item is clicked.
    * @param data The data to associate with the item for related callbacks.
    *
    * @return The created item or @c NULL upon failure.
    *
    * A new item will be created and prepended to the list, i.e., will
    * be set as @b first item.
    *
    * Items created with this method can be deleted with
    * elm_list_item_del().
    *
    * Associated @p data can be properly freed when item is deleted if a
    * callback function is set with elm_list_item_del_cb_set().
    *
    * If a function is passed as argument, it will be called everytime this item
    * is selected, i.e., the user clicks over an unselected item.
    * If always select is enabled it will call this function every time
    * user clicks over an item (already selected or not).
    * If such function isn't needed, just passing
    * @c NULL as @p func is enough. The same should be done for @p data.
    *
    * @see elm_list_item_append() for a simple code example.
    * @see elm_list_always_select_mode_set()
    * @see elm_list_item_del()
    * @see elm_list_item_del_cb_set()
    * @see elm_list_clear()
    * @see elm_icon_add()
    *
    * @ingroup List
    */
   EAPI Elm_List_Item   *elm_list_item_prepend(Evas_Object *obj, const char *label, Evas_Object *icon, Evas_Object *end, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);

   /**
    * Insert a new item into the list object before item @p before.
    *
    * @param obj The list object.
    * @param before The list item to insert before.
    * @param label The label of the list item.
    * @param icon The icon object to use for the left side of the item. An
    * icon can be any Evas object, but usually it is an icon created
    * with elm_icon_add().
    * @param end The icon object to use for the right side of the item. An
    * icon can be any Evas object.
    * @param func The function to call when the item is clicked.
    * @param data The data to associate with the item for related callbacks.
    *
    * @return The created item or @c NULL upon failure.
    *
    * A new item will be created and added to the list. Its position in
    * this list will be just before item @p before.
    *
    * Items created with this method can be deleted with
    * elm_list_item_del().
    *
    * Associated @p data can be properly freed when item is deleted if a
    * callback function is set with elm_list_item_del_cb_set().
    *
    * If a function is passed as argument, it will be called everytime this item
    * is selected, i.e., the user clicks over an unselected item.
    * If always select is enabled it will call this function every time
    * user clicks over an item (already selected or not).
    * If such function isn't needed, just passing
    * @c NULL as @p func is enough. The same should be done for @p data.
    *
    * @see elm_list_item_append() for a simple code example.
    * @see elm_list_always_select_mode_set()
    * @see elm_list_item_del()
    * @see elm_list_item_del_cb_set()
    * @see elm_list_clear()
    * @see elm_icon_add()
    *
    * @ingroup List
    */
   EAPI Elm_List_Item   *elm_list_item_insert_before(Evas_Object *obj, Elm_List_Item *before, const char *label, Evas_Object *icon, Evas_Object *end, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);

   /**
    * Insert a new item into the list object after item @p after.
    *
    * @param obj The list object.
    * @param after The list item to insert after.
    * @param label The label of the list item.
    * @param icon The icon object to use for the left side of the item. An
    * icon can be any Evas object, but usually it is an icon created
    * with elm_icon_add().
    * @param end The icon object to use for the right side of the item. An
    * icon can be any Evas object.
    * @param func The function to call when the item is clicked.
    * @param data The data to associate with the item for related callbacks.
    *
    * @return The created item or @c NULL upon failure.
    *
    * A new item will be created and added to the list. Its position in
    * this list will be just after item @p after.
    *
    * Items created with this method can be deleted with
    * elm_list_item_del().
    *
    * Associated @p data can be properly freed when item is deleted if a
    * callback function is set with elm_list_item_del_cb_set().
    *
    * If a function is passed as argument, it will be called everytime this item
    * is selected, i.e., the user clicks over an unselected item.
    * If always select is enabled it will call this function every time
    * user clicks over an item (already selected or not).
    * If such function isn't needed, just passing
    * @c NULL as @p func is enough. The same should be done for @p data.
    *
    * @see elm_list_item_append() for a simple code example.
    * @see elm_list_always_select_mode_set()
    * @see elm_list_item_del()
    * @see elm_list_item_del_cb_set()
    * @see elm_list_clear()
    * @see elm_icon_add()
    *
    * @ingroup List
    */
   EAPI Elm_List_Item   *elm_list_item_insert_after(Evas_Object *obj, Elm_List_Item *after, const char *label, Evas_Object *icon, Evas_Object *end, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);

   /**
    * Insert a new item into the sorted list object.
    *
    * @param obj The list object.
    * @param label The label of the list item.
    * @param icon The icon object to use for the left side of the item. An
    * icon can be any Evas object, but usually it is an icon created
    * with elm_icon_add().
    * @param end The icon object to use for the right side of the item. An
    * icon can be any Evas object.
    * @param func The function to call when the item is clicked.
    * @param data The data to associate with the item for related callbacks.
    * @param cmp_func The comparing function to be used to sort list
    * items <b>by #Elm_List_Item item handles</b>. This function will
    * receive two items and compare them, returning a non-negative integer
    * if the second item should be place after the first, or negative value
    * if should be placed before.
    *
    * @return The created item or @c NULL upon failure.
    *
    * @note This function inserts values into a list object assuming it was
    * sorted and the result will be sorted.
    *
    * A new item will be created and added to the list. Its position in
    * this list will be found comparing the new item with previously inserted
    * items using function @p cmp_func.
    *
    * Items created with this method can be deleted with
    * elm_list_item_del().
    *
    * Associated @p data can be properly freed when item is deleted if a
    * callback function is set with elm_list_item_del_cb_set().
    *
    * If a function is passed as argument, it will be called everytime this item
    * is selected, i.e., the user clicks over an unselected item.
    * If always select is enabled it will call this function every time
    * user clicks over an item (already selected or not).
    * If such function isn't needed, just passing
    * @c NULL as @p func is enough. The same should be done for @p data.
    *
    * @see elm_list_item_append() for a simple code example.
    * @see elm_list_always_select_mode_set()
    * @see elm_list_item_del()
    * @see elm_list_item_del_cb_set()
    * @see elm_list_clear()
    * @see elm_icon_add()
    *
    * @ingroup List
    */
   EAPI Elm_List_Item   *elm_list_item_sorted_insert(Evas_Object *obj, const char *label, Evas_Object *icon, Evas_Object *end, Evas_Smart_Cb func, const void *data, Eina_Compare_Cb cmp_func) EINA_ARG_NONNULL(1);

   /**
    * Remove all list's items.
    *
    * @param obj The list object
    *
    * @see elm_list_item_del()
    * @see elm_list_item_append()
    *
    * @ingroup List
    */
   EAPI void             elm_list_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get a list of all the list items.
    *
    * @param obj The list object
    * @return An @c Eina_List of list items, #Elm_List_Item,
    * or @c NULL on failure.
    *
    * @see elm_list_item_append()
    * @see elm_list_item_del()
    * @see elm_list_clear()
    *
    * @ingroup List
    */
   EAPI const Eina_List *elm_list_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the selected item.
    *
    * @param obj The list object.
    * @return The selected list item.
    *
    * The selected item can be unselected with function
    * elm_list_item_selected_set().
    *
    * The selected item always will be highlighted on list.
    *
    * @see elm_list_selected_items_get()
    *
    * @ingroup List
    */
   EAPI Elm_List_Item   *elm_list_selected_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Return a list of the currently selected list items.
    *
    * @param obj The list object.
    * @return An @c Eina_List of list items, #Elm_List_Item,
    * or @c NULL on failure.
    *
    * Multiple items can be selected if multi select is enabled. It can be
    * done with elm_list_multi_select_set().
    *
    * @see elm_list_selected_item_get()
    * @see elm_list_multi_select_set()
    *
    * @ingroup List
    */
   EAPI const Eina_List *elm_list_selected_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the selected state of an item.
    *
    * @param item The list item
    * @param selected The selected state
    *
    * This sets the selected state of the given item @p it.
    * @c EINA_TRUE for selected, @c EINA_FALSE for not selected.
    *
    * If a new item is selected the previosly selected will be unselected,
    * unless multiple selection is enabled with elm_list_multi_select_set().
    * Previoulsy selected item can be get with function
    * elm_list_selected_item_get().
    *
    * Selected items will be highlighted.
    *
    * @see elm_list_item_selected_get()
    * @see elm_list_selected_item_get()
    * @see elm_list_multi_select_set()
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_selected_set(Elm_List_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);

   /*
    * Get whether the @p item is selected or not.
    *
    * @param item The list item.
    * @return @c EINA_TRUE means item is selected. @c EINA_FALSE indicates
    * it's not. If @p obj is @c NULL, @c EINA_FALSE is returned.
    *
    * @see elm_list_selected_item_set() for details.
    * @see elm_list_item_selected_get()
    *
    * @ingroup List
    */
   EAPI Eina_Bool        elm_list_item_selected_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set or unset item as a separator.
    *
    * @param it The list item.
    * @param setting @c EINA_TRUE to set item @p it as separator or
    * @c EINA_FALSE to unset, i.e., item will be used as a regular item.
    *
    * Items aren't set as separator by default.
    *
    * If set as separator it will display separator theme, so won't display
    * icons or label.
    *
    * @see elm_list_item_separator_get()
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_separator_set(Elm_List_Item *it, Eina_Bool setting) EINA_ARG_NONNULL(1);

   /**
    * Get a value whether item is a separator or not.
    *
    * @see elm_list_item_separator_set() for details.
    *
    * @param it The list item.
    * @return @c EINA_TRUE means item @p it is a separator. @c EINA_FALSE
    * indicates it's not. If @p it is @c NULL, @c EINA_FALSE is returned.
    *
    * @ingroup List
    */
   EAPI Eina_Bool        elm_list_item_separator_get(const Elm_List_Item *it) EINA_ARG_NONNULL(1);

   /**
    * Show @p item in the list view.
    *
    * @param item The list item to be shown.
    *
    * It won't animate list until item is visible. If such behavior is wanted,
    * use elm_list_bring_in() intead.
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_show(Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Bring in the given item to list view.
    *
    * @param item The item.
    *
    * This causes list to jump to the given item @p item and show it
    * (by scrolling), if it is not fully visible.
    *
    * This may use animation to do so and take a period of time.
    *
    * If animation isn't wanted, elm_list_item_show() can be used.
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_bring_in(Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Delete them item from the list.
    *
    * @param item The item of list to be deleted.
    *
    * If deleting all list items is required, elm_list_clear()
    * should be used instead of getting items list and deleting each one.
    *
    * @see elm_list_clear()
    * @see elm_list_item_append()
    * @see elm_list_item_del_cb_set()
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_del(Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the function called when a list item is freed.
    *
    * @param item The item to set the callback on
    * @param func The function called
    *
    * If there is a @p func, then it will be called prior item's memory release.
    * That will be called with the following arguments:
    * @li item's data;
    * @li item's Evas object;
    * @li item itself;
    *
    * This way, a data associated to a list item could be properly freed.
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_del_cb_set(Elm_List_Item *item, Evas_Smart_Cb func) EINA_ARG_NONNULL(1);

   /**
    * Get the data associated to the item.
    *
    * @param item The list item
    * @return The data associated to @p item
    *
    * The return value is a pointer to data associated to @p item when it was
    * created, with function elm_list_item_append() or similar. If no data
    * was passed as argument, it will return @c NULL.
    *
    * @see elm_list_item_append()
    *
    * @ingroup List
    */
   EAPI void            *elm_list_item_data_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Get the left side icon associated to the item.
    *
    * @param item The list item
    * @return The left side icon associated to @p item
    *
    * The return value is a pointer to the icon associated to @p item when
    * it was
    * created, with function elm_list_item_append() or similar, or later
    * with function elm_list_item_icon_set(). If no icon
    * was passed as argument, it will return @c NULL.
    *
    * @see elm_list_item_append()
    * @see elm_list_item_icon_set()
    *
    * @ingroup List
    */
   EAPI Evas_Object     *elm_list_item_icon_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the left side icon associated to the item.
    *
    * @param item The list item
    * @param icon The left side icon object to associate with @p item
    *
    * The icon object to use at left side of the item. An
    * icon can be any Evas object, but usually it is an icon created
    * with elm_icon_add().
    *
    * Once the icon object is set, a previously set one will be deleted.
    * @warning Setting the same icon for two items will cause the icon to
    * dissapear from the first item.
    *
    * If an icon was passed as argument on item creation, with function
    * elm_list_item_append() or similar, it will be already
    * associated to the item.
    *
    * @see elm_list_item_append()
    * @see elm_list_item_icon_get()
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_icon_set(Elm_List_Item *item, Evas_Object *icon) EINA_ARG_NONNULL(1);

   /**
    * Get the right side icon associated to the item.
    *
    * @param item The list item
    * @return The right side icon associated to @p item
    *
    * The return value is a pointer to the icon associated to @p item when
    * it was
    * created, with function elm_list_item_append() or similar, or later
    * with function elm_list_item_icon_set(). If no icon
    * was passed as argument, it will return @c NULL.
    *
    * @see elm_list_item_append()
    * @see elm_list_item_icon_set()
    *
    * @ingroup List
    */
   EAPI Evas_Object     *elm_list_item_end_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the right side icon associated to the item.
    *
    * @param item The list item
    * @param end The right side icon object to associate with @p item
    *
    * The icon object to use at right side of the item. An
    * icon can be any Evas object, but usually it is an icon created
    * with elm_icon_add().
    *
    * Once the icon object is set, a previously set one will be deleted.
    * @warning Setting the same icon for two items will cause the icon to
    * dissapear from the first item.
    *
    * If an icon was passed as argument on item creation, with function
    * elm_list_item_append() or similar, it will be already
    * associated to the item.
    *
    * @see elm_list_item_append()
    * @see elm_list_item_end_get()
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_end_set(Elm_List_Item *item, Evas_Object *end) EINA_ARG_NONNULL(1);

   /**
    * Gets the base object of the item.
    *
    * @param item The list item
    * @return The base object associated with @p item
    *
    * Base object is the @c Evas_Object that represents that item.
    *
    * @ingroup List
    */
   EAPI Evas_Object     *elm_list_item_base_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Get the label of item.
    *
    * @param item The item of list.
    * @return The label of item.
    *
    * The return value is a pointer to the label associated to @p item when
    * it was created, with function elm_list_item_append(), or later
    * with function elm_list_item_label_set. If no label
    * was passed as argument, it will return @c NULL.
    *
    * @see elm_list_item_label_set() for more details.
    * @see elm_list_item_append()
    *
    * @ingroup List
    */
   EAPI const char      *elm_list_item_label_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the label of item.
    *
    * @param item The item of list.
    * @param text The label of item.
    *
    * The label to be displayed by the item.
    * Label will be placed between left and right side icons (if set).
    *
    * If a label was passed as argument on item creation, with function
    * elm_list_item_append() or similar, it will be already
    * displayed by the item.
    *
    * @see elm_list_item_label_get()
    * @see elm_list_item_append()
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_label_set(Elm_List_Item *item, const char *text) EINA_ARG_NONNULL(1);


   /**
    * Get the item before @p it in list.
    *
    * @param it The list item.
    * @return The item before @p it, or @c NULL if none or on failure.
    *
    * @note If it is the first item, @c NULL will be returned.
    *
    * @see elm_list_item_append()
    * @see elm_list_items_get()
    *
    * @ingroup List
    */
   EAPI Elm_List_Item   *elm_list_item_prev(const Elm_List_Item *it) EINA_ARG_NONNULL(1);

   /**
    * Get the item after @p it in list.
    *
    * @param it The list item.
    * @return The item after @p it, or @c NULL if none or on failure.
    *
    * @note If it is the last item, @c NULL will be returned.
    *
    * @see elm_list_item_append()
    * @see elm_list_items_get()
    *
    * @ingroup List
    */
   EAPI Elm_List_Item   *elm_list_item_next(const Elm_List_Item *it) EINA_ARG_NONNULL(1);

   /**
    * Sets the disabled/enabled state of a list item.
    *
    * @param it The item.
    * @param disabled The disabled state.
    *
    * A disabled item cannot be selected or unselected. It will also
    * change its appearance (generally greyed out). This sets the
    * disabled state (@c EINA_TRUE for disabled, @c EINA_FALSE for
    * enabled).
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_disabled_set(Elm_List_Item *it, Eina_Bool disabled) EINA_ARG_NONNULL(1);

   /**
    * Get a value whether list item is disabled or not.
    *
    * @param it The item.
    * @return The disabled state.
    *
    * @see elm_list_item_disabled_set() for more details.
    *
    * @ingroup List
    */
   EAPI Eina_Bool        elm_list_item_disabled_get(const Elm_List_Item *it) EINA_ARG_NONNULL(1);

   /**
    * Set the text to be shown in a given list item's tooltips.
    *
    * @param item Target item.
    * @param text The text to set in the content.
    *
    * Setup the text as tooltip to object. The item can have only one tooltip,
    * so any previous tooltip data - set with this function or
    * elm_list_item_tooltip_content_cb_set() - is removed.
    *
    * @see elm_object_tooltip_text_set() for more details.
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_tooltip_text_set(Elm_List_Item *item, const char *text) EINA_ARG_NONNULL(1);


   /**
    * @brief Disable size restrictions on an object's tooltip
    * @param item The tooltip's anchor object
    * @param disable If EINA_TRUE, size restrictions are disabled
    * @return EINA_FALSE on failure, EINA_TRUE on success
    *
    * This function allows a tooltip to expand beyond its parant window's canvas.
    * It will instead be limited only by the size of the display.
    */
   EAPI Eina_Bool        elm_list_item_tooltip_size_restrict_disable(Elm_List_Item *item, Eina_Bool disable) EINA_ARG_NONNULL(1);
   /**
    * @brief Retrieve size restriction state of an object's tooltip
    * @param obj The tooltip's anchor object
    * @return If EINA_TRUE, size restrictions are disabled
    *
    * This function returns whether a tooltip is allowed to expand beyond
    * its parant window's canvas.
    * It will instead be limited only by the size of the display.
    */
   EAPI Eina_Bool        elm_list_item_tooltip_size_restrict_disabled_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the content to be shown in the tooltip item.
    *
    * Setup the tooltip to item. The item can have only one tooltip,
    * so any previous tooltip data is removed. @p func(with @p data) will
    * be called every time that need show the tooltip and it should
    * return a valid Evas_Object. This object is then managed fully by
    * tooltip system and is deleted when the tooltip is gone.
    *
    * @param item the list item being attached a tooltip.
    * @param func the function used to create the tooltip contents.
    * @param data what to provide to @a func as callback data/context.
    * @param del_cb called when data is not needed anymore, either when
    *        another callback replaces @a func, the tooltip is unset with
    *        elm_list_item_tooltip_unset() or the owner @a item
    *        dies. This callback receives as the first parameter the
    *        given @a data, and @c event_info is the item.
    *
    * @see elm_object_tooltip_content_cb_set() for more details.
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_tooltip_content_cb_set(Elm_List_Item *item, Elm_Tooltip_Item_Content_Cb func, const void *data, Evas_Smart_Cb del_cb) EINA_ARG_NONNULL(1);

   /**
    * Unset tooltip from item.
    *
    * @param item list item to remove previously set tooltip.
    *
    * Remove tooltip from item. The callback provided as del_cb to
    * elm_list_item_tooltip_content_cb_set() will be called to notify
    * it is not used anymore.
    *
    * @see elm_object_tooltip_unset() for more details.
    * @see elm_list_item_tooltip_content_cb_set()
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_tooltip_unset(Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Sets a different style for this item tooltip.
    *
    * @note before you set a style you should define a tooltip with
    *       elm_list_item_tooltip_content_cb_set() or
    *       elm_list_item_tooltip_text_set()
    *
    * @param item list item with tooltip already set.
    * @param style the theme style to use (default, transparent, ...)
    *
    * @see elm_object_tooltip_style_set() for more details.
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_tooltip_style_set(Elm_List_Item *item, const char *style) EINA_ARG_NONNULL(1);

   /**
    * Get the style for this item tooltip.
    *
    * @param item list item with tooltip already set.
    * @return style the theme style in use, defaults to "default". If the
    *         object does not have a tooltip set, then NULL is returned.
    *
    * @see elm_object_tooltip_style_get() for more details.
    * @see elm_list_item_tooltip_style_set()
    *
    * @ingroup List
    */
   EAPI const char      *elm_list_item_tooltip_style_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the type of mouse pointer/cursor decoration to be shown,
    * when the mouse pointer is over the given list widget item
    *
    * @param item list item to customize cursor on
    * @param cursor the cursor type's name
    *
    * This function works analogously as elm_object_cursor_set(), but
    * here the cursor's changing area is restricted to the item's
    * area, and not the whole widget's. Note that that item cursors
    * have precedence over widget cursors, so that a mouse over an
    * item with custom cursor set will always show @b that cursor.
    *
    * If this function is called twice for an object, a previously set
    * cursor will be unset on the second call.
    *
    * @see elm_object_cursor_set()
    * @see elm_list_item_cursor_get()
    * @see elm_list_item_cursor_unset()
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_cursor_set(Elm_List_Item *item, const char *cursor) EINA_ARG_NONNULL(1);

   /*
    * Get the type of mouse pointer/cursor decoration set to be shown,
    * when the mouse pointer is over the given list widget item
    *
    * @param item list item with custom cursor set
    * @return the cursor type's name or @c NULL, if no custom cursors
    * were set to @p item (and on errors)
    *
    * @see elm_object_cursor_get()
    * @see elm_list_item_cursor_set()
    * @see elm_list_item_cursor_unset()
    *
    * @ingroup List
    */
   EAPI const char      *elm_list_item_cursor_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Unset any custom mouse pointer/cursor decoration set to be
    * shown, when the mouse pointer is over the given list widget
    * item, thus making it show the @b default cursor again.
    *
    * @param item a list item
    *
    * Use this call to undo any custom settings on this item's cursor
    * decoration, bringing it back to defaults (no custom style set).
    *
    * @see elm_object_cursor_unset()
    * @see elm_list_item_cursor_set()
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_cursor_unset(Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set a different @b style for a given custom cursor set for a
    * list item.
    *
    * @param item list item with custom cursor set
    * @param style the <b>theme style</b> to use (e.g. @c "default",
    * @c "transparent", etc)
    *
    * This function only makes sense when one is using custom mouse
    * cursor decorations <b>defined in a theme file</b>, which can have,
    * given a cursor name/type, <b>alternate styles</b> on it. It
    * works analogously as elm_object_cursor_style_set(), but here
    * applyed only to list item objects.
    *
    * @warning Before you set a cursor style you should have definen a
    *       custom cursor previously on the item, with
    *       elm_list_item_cursor_set()
    *
    * @see elm_list_item_cursor_engine_only_set()
    * @see elm_list_item_cursor_style_get()
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_cursor_style_set(Elm_List_Item *item, const char *style) EINA_ARG_NONNULL(1);

   /**
    * Get the current @b style set for a given list item's custom
    * cursor
    *
    * @param item list item with custom cursor set.
    * @return style the cursor style in use. If the object does not
    *         have a cursor set, then @c NULL is returned.
    *
    * @see elm_list_item_cursor_style_set() for more details
    *
    * @ingroup List
    */
   EAPI const char      *elm_list_item_cursor_style_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set if the (custom)cursor for a given list item should be
    * searched in its theme, also, or should only rely on the
    * rendering engine.
    *
    * @param item item with custom (custom) cursor already set on
    * @param engine_only Use @c EINA_TRUE to have cursors looked for
    * only on those provided by the rendering engine, @c EINA_FALSE to
    * have them searched on the widget's theme, as well.
    *
    * @note This call is of use only if you've set a custom cursor
    * for list items, with elm_list_item_cursor_set().
    *
    * @note By default, cursors will only be looked for between those
    * provided by the rendering engine.
    *
    * @ingroup List
    */
   EAPI void             elm_list_item_cursor_engine_only_set(Elm_List_Item *item, Eina_Bool engine_only) EINA_ARG_NONNULL(1);

   /**
    * Get if the (custom) cursor for a given list item is being
    * searched in its theme, also, or is only relying on the rendering
    * engine.
    *
    * @param item a list item
    * @return @c EINA_TRUE, if cursors are being looked for only on
    * those provided by the rendering engine, @c EINA_FALSE if they
    * are being searched on the widget's theme, as well.
    *
    * @see elm_list_item_cursor_engine_only_set(), for more details
    *
    * @ingroup List
    */
   EAPI Eina_Bool        elm_list_item_cursor_engine_only_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

   /* slider */
   EAPI Evas_Object       *elm_slider_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void               elm_slider_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char        *elm_slider_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_slider_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_slider_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_end_set(Evas_Object *obj, Evas_Object *end) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_slider_end_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_slider_end_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_span_size_set(Evas_Object *obj, Evas_Coord size) EINA_ARG_NONNULL(1);
   EAPI Evas_Coord         elm_slider_span_size_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_unit_format_set(Evas_Object *obj, const char *format) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_slider_unit_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_indicator_format_set(Evas_Object *obj, const char *indicator) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_slider_indicator_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
  EAPI void                elm_slider_indicator_format_function_set(Evas_Object *obj, const char *(*func)(double val), void (*free_func)(const char *str)) EINA_ARG_NONNULL(1);
  EAPI void                elm_slider_units_format_function_set(Evas_Object *obj, const char *(*func)(double val), void (*free_func)(const char *str)) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_slider_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_min_max_set(Evas_Object *obj, double min, double max) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_min_max_get(const Evas_Object *obj, double *min, double *max) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_value_set(Evas_Object *obj, double val) EINA_ARG_NONNULL(1);
   EAPI double             elm_slider_value_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_inverted_set(Evas_Object *obj, Eina_Bool inverted) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_slider_inverted_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_indicator_show_set(Evas_Object *obj, Eina_Bool show) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_slider_indicator_show_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "changed" - Whenever the slider value is changed by the user.
    * "slider,drag,start" - dragging the slider indicator around has started
    * "slider,drag,stop" - dragging the slider indicator around has stopped
    * "delay,changed" - A short time after the value is changed by the user.
    *                   This will be called only when the user stops dragging for a very short
    *                   period or when they release their finger/mouse, so it avoids possibly
    *                   expensive reactions to the value change.
    */

   /**
    * @addtogroup Actionslider Actionslider
    *
    * @image html img/icon/actionslider/preview-00.png
    * @image latex img/icon/actionslider/preview-00.png
    *
    * A actionslider is a switcher for 2 or 3 labels with customizable magnet
    * properties. The indicator is the element the user drags to choose a label.
    * When the position is set with magnet, when released the indicator will be
    * moved to it if it's nearest the magnetized position.
    *
    * @note By default all positions are set as enabled.
    *
    * Signals that you can add callbacks for are:
    *
    * "selected" - when user selects an enabled position (the label is passed
    *              as event info)".
    * @n
    * "pos_changed" - when the indicator reaches any of the positions("left",
    *                 "right" or "center").
    *
    * See an example of actionslider usage @ref actionslider_example_page "here"
    * @{
    */
   typedef enum _Elm_Actionslider_Pos
     {
        ELM_ACTIONSLIDER_NONE = 0,
        ELM_ACTIONSLIDER_LEFT = 1 << 0,
        ELM_ACTIONSLIDER_CENTER = 1 << 1,
        ELM_ACTIONSLIDER_RIGHT = 1 << 2,
        ELM_ACTIONSLIDER_ALL = (1 << 3) -1
     } Elm_Actionslider_Pos;

   /**
    * Add a new actionslider to the parent.
    *
    * @param parent The parent object
    * @return The new actionslider object or NULL if it cannot be created
    */
   EAPI Evas_Object          *elm_actionslider_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set actionslider labels.
    *
    * @param obj The actionslider object
    * @param left_label The label to be set on the left.
    * @param center_label The label to be set on the center.
    * @param right_label The label to be set on the right.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void                  elm_actionslider_labels_set(Evas_Object *obj, const char *left_label, const char *center_label, const char *right_label) EINA_ARG_NONNULL(1);
   /**
    * Get actionslider labels.
    *
    * @param obj The actionslider object
    * @param left_label A char** to place the left_label of @p obj into.
    * @param center_label A char** to place the center_label of @p obj into.
    * @param right_label A char** to place the right_label of @p obj into.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void                  elm_actionslider_labels_get(const Evas_Object *obj, const char **left_label, const char **center_label, const char **right_label) EINA_ARG_NONNULL(1);
   /**
    * Get actionslider selected label.
    *
    * @param obj The actionslider object
    * @return The selected label
    */
   EAPI const char           *elm_actionslider_selected_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set actionslider indicator position.
    *
    * @param obj The actionslider object.
    * @param pos The position of the indicator.
    */
   EAPI void                  elm_actionslider_indicator_pos_set(Evas_Object *obj, Elm_Actionslider_Pos pos) EINA_ARG_NONNULL(1);
   /**
    * Get actionslider indicator position.
    *
    * @param obj The actionslider object.
    * @return The position of the indicator.
    */
   EAPI Elm_Actionslider_Pos  elm_actionslider_indicator_pos_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set actionslider magnet position. To make multiple positions magnets @c or
    * them together(e.g.: ELM_ACTIONSLIDER_LEFT | ELM_ACTIONSLIDER_RIGHT)
    *
    * @param obj The actionslider object.
    * @param pos Bit mask indicating the magnet positions.
    */
   EAPI void                  elm_actionslider_magnet_pos_set(Evas_Object *obj, Elm_Actionslider_Pos pos) EINA_ARG_NONNULL(1);
   /**
    * Get actionslider magnet position.
    *
    * @param obj The actionslider object.
    * @return The positions with magnet property.
    */
   EAPI Elm_Actionslider_Pos  elm_actionslider_magnet_pos_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set actionslider enabled position. To set multiple positions as enabled @c or
    * them together(e.g.: ELM_ACTIONSLIDER_LEFT | ELM_ACTIONSLIDER_RIGHT).
    *
    * @note All the positions are enabled by default.
    *
    * @param obj The actionslider object.
    * @param pos Bit mask indicating the enabled positions.
    */
   EAPI void                  elm_actionslider_enabled_pos_set(Evas_Object *obj, Elm_Actionslider_Pos pos) EINA_ARG_NONNULL(1);
   /**
    * Get actionslider enabled position.
    *
    * @param obj The actionslider object.
    * @return The enabled positions.
    */
   EAPI Elm_Actionslider_Pos  elm_actionslider_enabled_pos_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the label used on the indicator.
    *
    * @param obj The actionslider object
    * @param label The label to be set on the indicator.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void                  elm_actionslider_indicator_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   /**
    * Get the label used on the indicator object.
    *
    * @param obj The actionslider object
    * @return The indicator label
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char           *elm_actionslider_indicator_label_get(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /**
    * @defgroup Genlist Genlist
    *
    * This widget aims to have more expansive list than the simple list in
    * Elementary that could have more flexible items and allow many more entries
    * while still being fast and low on memory usage. At the same time it was
    * also made to be able to do tree structures. But the price to pay is more
    * complexity when it comes to usage. If all you want is a simple list with
    * icons and a single label, use the normal @ref List object.
    *
    * Genlist has a fairly large API, mostly because it's relatively complex,
    * trying to be both expansive, powerful and efficient. First we will begin
    * an overview on the theory behind genlist.
    *
    * @section Genlist_Item_Class Genlist item classes - creating items
    *
    * In order to have the ability to add and delete items on the fly, genlist
    * implements a class (callback) system where the application provides a
    * structure with information about that type of item (genlist may contain
    * multiple different items with different classes, states and styles).
    * Genlist will call the functions in this struct (methods) when an item is
    * "realized" (i.e., created dynamically, while the user is scrolling the
    * grid). All objects will simply be deleted when no longer needed with
    * evas_object_del(). The #Elm_Genlist_Item_Class structure contains the
    * following members:
    * - @c item_style - This is a constant string and simply defines the name
    *   of the item style. It @b must be specified and the default should be @c
    *   "default".
    *
    * - @c func - A struct with pointers to functions that will be called when
    *   an item is going to be actually created. All of them receive a @c data
    *   parameter that will point to the same data passed to
    *   elm_genlist_item_append() and related item creation functions, and a @c
    *   obj parameter that points to the genlist object itself.
    *
    * The function pointers inside @c func are @c label_get, @c icon_get, @c
    * state_get and @c del. The 3 first functions also receive a @c part
    * parameter described below. A brief description of these functions follows:
    *
    * - @c label_get - The @c part parameter is the name string of one of the
    *   existing text parts in the Edje group implementing the item's theme.
    *   This function @b must return a strdup'()ed string, as the caller will
    *   free() it when done. See #GenlistItemLabelGetFunc.
    * - @c icon_get - The @c part parameter is the name string of one of the
    *   existing (icon) swallow parts in the Edje group implementing the item's
    *   theme. It must return @c NULL, when no icon is desired, or a valid
    *   object handle, otherwise.  The object will be deleted by the genlist on
    *   its deletion or when the item is "unrealized".  See
    *   #GenlistItemIconGetFunc.
    * - @c func.state_get - The @c part parameter is the name string of one of
    *   the state parts in the Edje group implementing the item's theme. Return
    *   @c EINA_FALSE for false/off or @c EINA_TRUE for true/on. Genlists will
    *   emit a signal to its theming Edje object with @c "elm,state,XXX,active"
    *   and @c "elm" as "emission" and "source" arguments, respectively, when
    *   the state is true (the default is false), where @c XXX is the name of
    *   the (state) part.  See #GenlistItemStateGetFunc.
    * - @c func.del - This is intended for use when genlist items are deleted,
    *   so any data attached to the item (e.g. its data parameter on creation)
    *   can be deleted. See #GenlistItemDelFunc.
    *
    * @section Genlist_Items Structure of items
    *
    * An item in a genlist can have 0 or more text labels (they can be regular
    * text or textblock Evas objects - that's up to the style to determine), 0
    * or more icons (which are simply objects swallowed into the genlist item's
    * theming Edje object) and 0 or more <b>boolean states</b>, which have the
    * behavior left to the user to define. The Edje part names for each of
    * these properties will be looked up, in the theme file for the genlist,
    * under the Edje (string) data items named @c "labels", @c "icons" and @c
    * "states", respectively. For each of those properties, if more than one
    * part is provided, they must have names listed separated by spaces in the
    * data fields. For the default genlist item theme, we have @b one label
    * part (@c "elm.text"), @b two icon parts (@c "elm.swalllow.icon" and @c
    * "elm.swallow.end") and @b no state parts.
    *
    * A genlist item may be at one of several styles. Elementary provides one
    * by default - "default", but this can be extended by system or application
    * custom themes/overlays/extensions (see @ref Theme "themes" for more
    * details).
    *
    * @section Genlist_Manipulation Editing and Navigating
    *
    * Items can be added by several calls. All of them return a @ref
    * Elm_Genlist_Item handle that is an internal member inside the genlist.
    * They all take a data parameter that is meant to be used for a handle to
    * the applications internal data (eg the struct with the original item
    * data). The parent parameter is the parent genlist item this belongs to if
    * it is a tree or an indexed group, and NULL if there is no parent. The
    * flags can be a bitmask of #ELM_GENLIST_ITEM_NONE,
    * #ELM_GENLIST_ITEM_SUBITEMS and #ELM_GENLIST_ITEM_GROUP. If
    * #ELM_GENLIST_ITEM_SUBITEMS is set then this item is displayed as an item
    * that is able to expand and have child items.  If ELM_GENLIST_ITEM_GROUP
    * is set then this item is group index item that is displayed at the top
    * until the next group comes. The func parameter is a convenience callback
    * that is called when the item is selected and the data parameter will be
    * the func_data parameter, obj be the genlist object and event_info will be
    * the genlist item.
    *
    * elm_genlist_item_append() adds an item to the end of the list, or if
    * there is a parent, to the end of all the child items of the parent.
    * elm_genlist_item_prepend() is the same but adds to the beginning of
    * the list or children list. elm_genlist_item_insert_before() inserts at
    * item before another item and elm_genlist_item_insert_after() inserts after
    * the indicated item.
    *
    * The application can clear the list with elm_genlist_clear() which deletes
    * all the items in the list and elm_genlist_item_del() will delete a specific
    * item. elm_genlist_item_subitems_clear() will clear all items that are
    * children of the indicated parent item.
    *
    * To help inspect list items you can jump to the item at the top of the list
    * with elm_genlist_first_item_get() which will return the item pointer, and
    * similarly elm_genlist_last_item_get() gets the item at the end of the list.
    * elm_genlist_item_next_get() and elm_genlist_item_prev_get() get the next
    * and previous items respectively relative to the indicated item. Using
    * these calls you can walk the entire item list/tree. Note that as a tree
    * the items are flattened in the list, so elm_genlist_item_parent_get() will
    * let you know which item is the parent (and thus know how to skip them if
    * wanted).
    *
    * @section Genlist_Muti_Selection Multi-selection
    *
    * If the application wants multiple items to be able to be selected,
    * elm_genlist_multi_select_set() can enable this. If the list is
    * single-selection only (the default), then elm_genlist_selected_item_get()
    * will return the selected item, if any, or NULL I none is selected. If the
    * list is multi-select then elm_genlist_selected_items_get() will return a
    * list (that is only valid as long as no items are modified (added, deleted,
    * selected or unselected)).
    *
    * @section Genlist_Usage_Hints Usage hints
    *
    * There are also convenience functions. elm_genlist_item_genlist_get() will
    * return the genlist object the item belongs to. elm_genlist_item_show()
    * will make the scroller scroll to show that specific item so its visible.
    * elm_genlist_item_data_get() returns the data pointer set by the item
    * creation functions.
    *
    * If an item changes (state of boolean changes, label or icons change),
    * then use elm_genlist_item_update() to have genlist update the item with
    * the new state. Genlist will re-realize the item thus call the functions
    * in the _Elm_Genlist_Item_Class for that item.
    *
    * To programmatically (un)select an item use elm_genlist_item_selected_set().
    * To get its selected state use elm_genlist_item_selected_get(). Similarly
    * to expand/contract an item and get its expanded state, use
    * elm_genlist_item_expanded_set() and elm_genlist_item_expanded_get(). And
    * again to make an item disabled (unable to be selected and appear
    * differently) use elm_genlist_item_disabled_set() to set this and
    * elm_genlist_item_disabled_get() to get the disabled state.
    *
    * In general to indicate how the genlist should expand items horizontally to
    * fill the list area, use elm_genlist_horizontal_mode_set(). Valid modes are
    * ELM_LIST_LIMIT and ELM_LIST_SCROLL . The default is ELM_LIST_SCROLL. This
    * mode means that if items are too wide to fit, the scroller will scroll
    * horizontally. Otherwise items are expanded to fill the width of the
    * viewport of the scroller. If it is ELM_LIST_LIMIT, items will be expanded
    * to the viewport width and limited to that size. This can be combined with
    * a different style that uses edjes' ellipsis feature (cutting text off like
    * this: "tex...").
    *
    * Items will only call their selection func and callback when first becoming
    * selected. Any further clicks will do nothing, unless you enable always
    * select with elm_genlist_always_select_mode_set(). This means even if
    * selected, every click will make the selected callbacks be called.
    * elm_genlist_no_select_mode_set() will turn off the ability to select
    * items entirely and they will neither appear selected nor call selected
    * callback functions.
    *
    * Remember that you can create new styles and add your own theme augmentation
    * per application with elm_theme_extension_add(). If you absolutely must
    * have a specific style that overrides any theme the user or system sets up
    * you can use elm_theme_overlay_add() to add such a file.
    *
    * @section Genlist_Implementation Implementation
    *
    * Evas tracks every object you create. Every time it processes an event
    * (mouse move, down, up etc.) it needs to walk through objects and find out
    * what event that affects. Even worse every time it renders display updates,
    * in order to just calculate what to re-draw, it needs to walk through many
    * many many objects. Thus, the more objects you keep active, the more
    * overhead Evas has in just doing its work. It is advisable to keep your
    * active objects to the minimum working set you need. Also remember that
    * object creation and deletion carries an overhead, so there is a
    * middle-ground, which is not easily determined. But don't keep massive lists
    * of objects you can't see or use. Genlist does this with list objects. It
    * creates and destroys them dynamically as you scroll around. It groups them
    * into blocks so it can determine the visibility etc. of a whole block at
    * once as opposed to having to walk the whole list. This 2-level list allows
    * for very large numbers of items to be in the list (tests have used up to
    * 2,000,000 items). Also genlist employs a queue for adding items. As items
    * may be different sizes, every item added needs to be calculated as to its
    * size and thus this presents a lot of overhead on populating the list, this
    * genlist employs a queue. Any item added is queued and spooled off over
    * time, actually appearing some time later, so if your list has many members
    * you may find it takes a while for them to all appear, with your process
    * consuming a lot of CPU while it is busy spooling.
    *
    * Genlist also implements a tree structure, but it does so with callbacks to
    * the application, with the application filling in tree structures when
    * requested (allowing for efficient building of a very deep tree that could
    * even be used for file-management). See the above smart signal callbacks for
    * details.
    *
    * @section Genlist_Smart_Events Genlist smart events
    *
    * Signals that you can add callbacks for are:
    * - @c "activated" - The user has double-clicked or pressed
    *   (enter|return|spacebar) on an item. The @c event_info parameter is the
    *   item that was activated.
    * - @c "clicked,double" - The user has double-clicked an item.  The @c
    *   event_info parameter is the item that was double-clicked.
    * - @c "selected" - This is called when a user has made an item selected.
    *   The event_info parameter is the genlist item that was selected.
    * - @c "unselected" - This is called when a user has made an item
    *   unselected. The event_info parameter is the genlist item that was
    *   unselected.
    * - @c "expanded" - This is called when elm_genlist_item_expanded_set() is
    *   called and the item is now meant to be expanded. The event_info
    *   parameter is the genlist item that was indicated to expand.  It is the
    *   job of this callback to then fill in the child items.
    * - @c "contracted" - This is called when elm_genlist_item_expanded_set() is
    *   called and the item is now meant to be contracted. The event_info
    *   parameter is the genlist item that was indicated to contract. It is the
    *   job of this callback to then delete the child items.
    * - @c "expand,request" - This is called when a user has indicated they want
    *   to expand a tree branch item. The callback should decide if the item can
    *   expand (has any children) and then call elm_genlist_item_expanded_set()
    *   appropriately to set the state. The event_info parameter is the genlist
    *   item that was indicated to expand.
    * - @c "contract,request" - This is called when a user has indicated they
    *   want to contract a tree branch item. The callback should decide if the
    *   item can contract (has any children) and then call
    *   elm_genlist_item_expanded_set() appropriately to set the state. The
    *   event_info parameter is the genlist item that was indicated to contract.
    * - @c "realized" - This is called when the item in the list is created as a
    *   real evas object. event_info parameter is the genlist item that was
    *   created. The object may be deleted at any time, so it is up to the
    *   caller to not use the object pointer from elm_genlist_item_object_get()
    *   in a way where it may point to freed objects.
    * - @c "unrealized" - This is called just before an item is unrealized.
    *   After this call icon objects provided will be deleted and the item
    *   object itself delete or be put into a floating cache.
    * - @c "drag,start,up" - This is called when the item in the list has been
    *   dragged (not scrolled) up.
    * - @c "drag,start,down" - This is called when the item in the list has been
    *   dragged (not scrolled) down.
    * - @c "drag,start,left" - This is called when the item in the list has been
    *   dragged (not scrolled) left.
    * - @c "drag,start,right" - This is called when the item in the list has
    *   been dragged (not scrolled) right.
    * - @c "drag,stop" - This is called when the item in the list has stopped
    *   being dragged.
    * - @c "drag" - This is called when the item in the list is being dragged.
    * - @c "longpressed" - This is called when the item is pressed for a certain
    *   amount of time. By default it's 1 second.
    * - @c "scroll,edge,top" - This is called when the genlist is scrolled until
    *   the top edge.
    * - @c "scroll,edge,bottom" - This is called when the genlist is scrolled
    *   until the bottom edge.
    * - @c "scroll,edge,left" - This is called when the genlist is scrolled
    *   until the left edge.
    * - @c "scroll,edge,right" - This is called when the genlist is scrolled
    *   until the right edge.
    * - @c "multi,swipe,left" - This is called when the genlist is multi-touch
    *   swiped left.
    * - @c "multi,swipe,right" - This is called when the genlist is multi-touch
    *   swiped right.
    * - @c "multi,swipe,up" - This is called when the genlist is multi-touch
    *   swiped up.
    * - @c "multi,swipe,down" - This is called when the genlist is multi-touch
    *   swiped down.
    * - @c "multi,pinch,out" - This is called when the genlist is multi-touch
    *   pinched out.  "- @c multi,pinch,in" - This is called when the genlist is
    *   multi-touch pinched in.
    * - @c "swipe" - This is called when the genlist is swiped.
    *
    * @section Genlist_Examples Examples
    *
    * Here is a list of examples that use the genlist, trying to show some of
    * its capabilities:
    * - @ref genlist_example_01
    * - @ref genlist_example_02
    */

   /**
    * @addtogroup Genlist
    * @{
    */

   /**
    * @enum _Elm_Genlist_Item_Flags
    * @typedef Elm_Genlist_Item_Flags
    *
    * Defines if the item is of any special type (has subitems or it's the
    * index of a group), or is just a simple item.
    *
    * @ingroup Genlist
    */
   typedef enum _Elm_Genlist_Item_Flags
     {
        ELM_GENLIST_ITEM_NONE = 0, /**< simple item */
        ELM_GENLIST_ITEM_SUBITEMS = (1 << 0), /**< may expand and have child items */
        ELM_GENLIST_ITEM_GROUP = (1 << 1) /**< index of a group of items */
     } Elm_Genlist_Item_Flags;
   typedef struct _Elm_Genlist_Item_Class Elm_Genlist_Item_Class;  /**< Genlist item class definition structs */
   typedef struct _Elm_Genlist_Item       Elm_Genlist_Item; /**< Item of Elm_Genlist. Sub-type of Elm_Widget_Item */
   typedef struct _Elm_Genlist_Item_Class_Func Elm_Genlist_Item_Class_Func; /**< Class functions for genlist item class */
   typedef char        *(*GenlistItemLabelGetFunc) (void *data, Evas_Object *obj, const char *part); /**< Label fetching class function for genlist item classes. */
   typedef Evas_Object *(*GenlistItemIconGetFunc)  (void *data, Evas_Object *obj, const char *part); /**< Icon fetching class function for genlist item classes. */
   typedef Eina_Bool    (*GenlistItemStateGetFunc) (void *data, Evas_Object *obj, const char *part); /**< State fetching class function for genlist item classes. */
   typedef void         (*GenlistItemDelFunc)      (void *data, Evas_Object *obj); /**< Deletion class function for genlist item classes. */
   typedef void         (*GenlistItemMovedFunc)    (Evas_Object *obj, Elm_Genlist_Item *item, Elm_Genlist_Item *rel_item, Eina_Bool move_after);

   /**
    * @struct _Elm_Genlist_Item_Class
    *
    * Genlist item class definition structs.
    *
    * This struct contains the style and fetching functions that will define the
    * contents of each item.
    *
    * @see @ref Genlist_Item_Class
    */
   struct _Elm_Genlist_Item_Class
     {
        const char                *item_style; /**< style of this class. */
        struct
          {
             GenlistItemLabelGetFunc  label_get; /**< Label fetching class function for genlist item classes.*/
             GenlistItemIconGetFunc   icon_get; /**< Icon fetching class function for genlist item classes. */
             GenlistItemStateGetFunc  state_get; /**< State fetching class function for genlist item classes. */
             GenlistItemDelFunc       del; /**< Deletion class function for genlist item classes. */
             GenlistItemMovedFunc     moved; // TODO: do not use this. change this to smart callback.
          } func;
        const char                *mode_item_style;
     };

   /**
    * Add a new Genlist object
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    *
    * @ingroup Genlist
    */
   EAPI Evas_Object      *elm_genlist_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Clear the genlist
    *
    * This clears all items in the list, leaving it empty.
    *
    * @param obj The genlist object
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Enable or disable multi-selection in the genlist
    *
    * @param obj The genlist object
    * @param multi Multi-select enable/disable. Default is disabled.
    *
    * This enables (@c EINA_TRUE) or disables (@c EINA_FALSE) multi-selection in
    * the list. This allows more than 1 item to be selected. To retrieve the list
    * of selected items, use elm_genlist_selected_items_get().
    *
    * @see elm_genlist_selected_items_get()
    * @see elm_genlist_multi_select_get()
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_multi_select_set(Evas_Object *obj, Eina_Bool multi) EINA_ARG_NONNULL(1);
   /**
    * Gets if multi-selection in genlist is enabled or disabled.
    *
    * @param obj The genlist object
    * @return Multi-select enabled/disabled
    * (@c EINA_TRUE = enabled/@c EINA_FALSE = disabled). Default is @c EINA_FALSE.
    *
    * @see elm_genlist_multi_select_set()
    *
    * @ingroup Genlist
    */
   EAPI Eina_Bool         elm_genlist_multi_select_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * This sets the horizontal stretching mode.
    *
    * @param obj The genlist object
    * @param mode The mode to use (one of #ELM_LIST_SCROLL or #ELM_LIST_LIMIT).
    *
    * This sets the mode used for sizing items horizontally. Valid modes
    * are #ELM_LIST_LIMIT and #ELM_LIST_SCROLL. The default is
    * ELM_LIST_SCROLL. This mode means that if items are too wide to fit,
    * the scroller will scroll horizontally. Otherwise items are expanded
    * to fill the width of the viewport of the scroller. If it is
    * ELM_LIST_LIMIT, items will be expanded to the viewport width and
    * limited to that size.
    *
    * @see elm_genlist_horizontal_mode_get()
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_horizontal_mode_set(Evas_Object *obj, Elm_List_Mode mode) EINA_ARG_NONNULL(1);
   /**
    * Gets the horizontal stretching mode.
    *
    * @param obj The genlist object
    * @return The mode to use
    * (#ELM_LIST_LIMIT, #ELM_LIST_SCROLL)
    *
    * @see elm_genlist_horizontal_mode_set()
    *
    * @ingroup Genlist
    */
   EAPI Elm_List_Mode     elm_genlist_horizontal_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the always select mode.
    *
    * @param obj The genlist object
    * @param always_select The always select mode (@c EINA_TRUE = on, @c
    * EINA_FALSE = off). Default is @c EINA_FALSE.
    *
    * Items will only call their selection func and callback when first
    * becoming selected. Any further clicks will do nothing, unless you
    * enable always select with elm_genlist_always_select_mode_set().
    * This means that, even if selected, every click will make the selected
    * callbacks be called.
    *
    * @see elm_genlist_always_select_mode_get()
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_always_select_mode_set(Evas_Object *obj, Eina_Bool always_select) EINA_ARG_NONNULL(1);
   /**
    * Get the always select mode.
    *
    * @param obj The genlist object
    * @return The always select mode
    * (@c EINA_TRUE = on, @c EINA_FALSE = off)
    *
    * @see elm_genlist_always_select_mode_set()
    *
    * @ingroup Genlist
    */
   EAPI Eina_Bool         elm_genlist_always_select_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Enable/disable the no select mode.
    *
    * @param obj The genlist object
    * @param no_select The no select mode
    * (EINA_TRUE = on, EINA_FALSE = off)
    *
    * This will turn off the ability to select items entirely and they
    * will neither appear selected nor call selected callback functions.
    *
    * @see elm_genlist_no_select_mode_get()
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_no_select_mode_set(Evas_Object *obj, Eina_Bool no_select) EINA_ARG_NONNULL(1);
   /**
    * Gets whether the no select mode is enabled.
    *
    * @param obj The genlist object
    * @return The no select mode
    * (@c EINA_TRUE = on, @c EINA_FALSE = off)
    *
    * @see elm_genlist_no_select_mode_set()
    *
    * @ingroup Genlist
    */
   EAPI Eina_Bool         elm_genlist_no_select_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Enable/disable compress mode.
    *
    * @param obj The genlist object
    * @param compress The compress mode
    * (@c EINA_TRUE = on, @c EINA_FALSE = off). Default is @c EINA_FALSE.
    *
    * This will enable the compress mode where items are "compressed"
    * horizontally to fit the genlist scrollable viewport width. This is
    * special for genlist.  Do not rely on
    * elm_genlist_horizontal_mode_set() being set to @c ELM_LIST_COMPRESS to
    * work as genlist needs to handle it specially.
    *
    * @see elm_genlist_compress_mode_get()
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_compress_mode_set(Evas_Object *obj, Eina_Bool compress) EINA_ARG_NONNULL(1);
   /**
    * Get whether the compress mode is enabled.
    *
    * @param obj The genlist object
    * @return The compress mode
    * (@c EINA_TRUE = on, @c EINA_FALSE = off)
    *
    * @see elm_genlist_compress_mode_set()
    *
    * @ingroup Genlist
    */
   EAPI Eina_Bool         elm_genlist_compress_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Enable/disable height-for-width mode.
    *
    * @param obj The genlist object
    * @param setting The height-for-width mode (@c EINA_TRUE = on,
    * @c EINA_FALSE = off). Default is @c EINA_FALSE.
    *
    * With height-for-width mode the item width will be fixed (restricted
    * to a minimum of) to the list width when calculating its size in
    * order to allow the height to be calculated based on it. This allows,
    * for instance, text block to wrap lines if the Edje part is
    * configured with "text.min: 0 1".
    *
    * @note This mode will make list resize slower as it will have to
    *       recalculate every item height again whenever the list width
    *       changes!
    *
    * @note When height-for-width mode is enabled, it also enables
    *       compress mode (see elm_genlist_compress_mode_set()) and
    *       disables homogeneous (see elm_genlist_homogeneous_set()).
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_height_for_width_mode_set(Evas_Object *obj, Eina_Bool height_for_width) EINA_ARG_NONNULL(1);
   /**
    * Get whether the height-for-width mode is enabled.
    *
    * @param obj The genlist object
    * @return The height-for-width mode (@c EINA_TRUE = on, @c EINA_FALSE =
    * off)
    *
    * @ingroup Genlist
    */
   EAPI Eina_Bool         elm_genlist_height_for_width_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Enable/disable horizontal and vertical bouncing effect.
    *
    * @param obj The genlist object
    * @param h_bounce Allow bounce horizontally (@c EINA_TRUE = on, @c
    * EINA_FALSE = off). Default is @c EINA_FALSE.
    * @param v_bounce Allow bounce vertically (@c EINA_TRUE = on, @c
    * EINA_FALSE = off). Default is @c EINA_TRUE.
    *
    * This will enable or disable the scroller bouncing effect for the
    * genlist. See elm_scroller_bounce_set() for details.
    *
    * @see elm_scroller_bounce_set()
    * @see elm_genlist_bounce_get()
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   /**
    * Get whether the horizontal and vertical bouncing effect is enabled.
    *
    * @param obj The genlist object
    * @param h_bounce Pointer to a bool to receive if the bounce horizontally
    * option is set.
    * @param v_bounce Pointer to a bool to receive if the bounce vertically
    * option is set.
    *
    * @see elm_genlist_bounce_set()
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   /**
    * Enable/disable homogenous mode.
    *
    * @param obj The genlist object
    * @param homogeneous Assume the items within the genlist are of the
    * same height and width (EINA_TRUE = on, EINA_FALSE = off). Default is @c
    * EINA_FALSE.
    *
    * This will enable the homogeneous mode where items are of the same
    * height and width so that genlist may do the lazy-loading at its
    * maximum (which increases the performance for scrolling the list). This
    * implies 'compressed' mode.
    *
    * @see elm_genlist_compress_mode_set()
    * @see elm_genlist_homogeneous_get()
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_homogeneous_set(Evas_Object *obj, Eina_Bool homogeneous) EINA_ARG_NONNULL(1);
   /**
    * Get whether the homogenous mode is enabled.
    *
    * @param obj The genlist object
    * @return Assume the items within the genlist are of the same height
    * and width (EINA_TRUE = on, EINA_FALSE = off)
    *
    * @see elm_genlist_homogeneous_set()
    *
    * @ingroup Genlist
    */
   EAPI Eina_Bool         elm_genlist_homogeneous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the maximum number of items within an item block
    *
    * @param obj The genlist object
    * @param n   Maximum number of items within an item block. Default is 32.
    *
    * This will configure the block count to tune to the target with
    * particular performance matrix.
    *
    * A block of objects will be used to reduce the number of operations due to
    * many objects in the screen. It can determine the visibility, or if the
    * object has changed, it theme needs to be updated, etc. doing this kind of
    * calculation to the entire block, instead of per object.
    *
    * The default value for the block count is enough for most lists, so unless
    * you know you will have a lot of objects visible in the screen at the same
    * time, don't try to change this.
    *
    * @see elm_genlist_block_count_get()
    * @see @ref Genlist_Implementation
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_block_count_set(Evas_Object *obj, int n) EINA_ARG_NONNULL(1);
   /**
    * Get the maximum number of items within an item block
    *
    * @param obj The genlist object
    * @return Maximum number of items within an item block
    *
    * @see elm_genlist_block_count_set()
    *
    * @ingroup Genlist
    */
   EAPI int               elm_genlist_block_count_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the timeout in seconds for the longpress event.
    *
    * @param obj The genlist object
    * @param timeout timeout in seconds. Default is 1.
    *
    * This option will change how long it takes to send an event "longpressed"
    * after the mouse down signal is sent to the list. If this event occurs, no
    * "clicked" event will be sent.
    *
    * @see elm_genlist_longpress_timeout_set()
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_longpress_timeout_set(Evas_Object *obj, double timeout) EINA_ARG_NONNULL(1);
   /**
    * Get the timeout in seconds for the longpress event.
    *
    * @param obj The genlist object
    * @return timeout in seconds
    *
    * @see elm_genlist_longpress_timeout_get()
    *
    * @ingroup Genlist
    */
   EAPI double            elm_genlist_longpress_timeout_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* operations to add items */
   EAPI Elm_Genlist_Item *elm_genlist_item_append(Evas_Object *obj, const Elm_Genlist_Item_Class *itc, const void *data, Elm_Genlist_Item *parent, Elm_Genlist_Item_Flags flags, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item *elm_genlist_item_prepend(Evas_Object *obj, const Elm_Genlist_Item_Class *itc, const void *data, Elm_Genlist_Item *parent, Elm_Genlist_Item_Flags flags, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item *elm_genlist_item_insert_before(Evas_Object *obj, const Elm_Genlist_Item_Class *itc, const void *data, Elm_Genlist_Item *parent, Elm_Genlist_Item *before, Elm_Genlist_Item_Flags flags, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1, 5);
   EAPI Elm_Genlist_Item *elm_genlist_item_insert_after(Evas_Object *obj, const Elm_Genlist_Item_Class *itc, const void *data, Elm_Genlist_Item *parent, Elm_Genlist_Item *after, Elm_Genlist_Item_Flags flags, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1, 5);
   EAPI Elm_Genlist_Item *elm_genlist_item_sorted_insert(Evas_Object *obj, const Elm_Genlist_Item_Class *itc, const void *data, Elm_Genlist_Item *parent, Elm_Genlist_Item_Flags flags, Eina_Compare_Cb comp, Evas_Smart_Cb func,const void *func_data);
   EAPI Elm_Genlist_Item *elm_genlist_item_direct_sorted_insert(Evas_Object *obj, const Elm_Genlist_Item_Class *itc, const void *data, Elm_Genlist_Item *parent, Elm_Genlist_Item_Flags flags, Eina_Compare_Cb comp, Evas_Smart_Cb func, const void *func_data);
   /* operations to retrieve existing items */
   /**
    * Get the selectd item in the genlist.
    *
    * @param obj The genlist object
    * @return The selected item, or NULL if none is selected.
    *
    * This gets the selected item in the list (if multi-selection is enabled, only
    * the item that was first selected in the list is returned - which is not very
    * useful, so see elm_genlist_selected_items_get() for when multi-selection is
    * used).
    *
    * If no item is selected, NULL is returned.
    *
    * @see elm_genlist_selected_items_get()
    *
    * @ingroup Genlist
    */
   EAPI Elm_Genlist_Item *elm_genlist_selected_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Get a list of selected items in the genlist.
    *
    * @param obj The genlist object
    * @return The list of selected items, or NULL if none are selected.
    *
    * It returns a list of the selected items. This list pointer is only valid so
    * long as the selection doesn't change (no items are selected or unselected, or
    * unselected implicitly by deletion). The list contains Elm_Genlist_Item
    * pointers. The order of the items in this list is the order which they were
    * selected, i.e. the first item in this list is the first item that was
    * selected, and so on.
    *
    * @note If not in multi-select mode, consider using function
    * elm_genlist_selected_item_get() instead.
    *
    * @see elm_genlist_multi_select_set()
    * @see elm_genlist_selected_item_get()
    *
    * @ingroup Genlist
    */
   EAPI const Eina_List  *elm_genlist_selected_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Get a list of realized items in genlist
    *
    * @param obj The genlist object
    * @return The list of realized items, nor NULL if none are realized.
    *
    * This returns a list of the realized items in the genlist. The list
    * contains Elm_Genlist_Item pointers. The list must be freed by the
    * caller when done with eina_list_free(). The item pointers in the
    * list are only valid so long as those items are not deleted or the
    * genlist is not deleted.
    *
    * @see elm_genlist_realized_items_update()
    *
    * @ingroup Genlist
    */
   EAPI Eina_List        *elm_genlist_realized_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Get the item that is at the x, y canvas coords.
    *
    * @param obj The gelinst object.
    * @param x The input x coordinate
    * @param y The input y coordinate
    * @param posret The position relative to the item returned here
    * @return The item at the coordinates or NULL if none
    *
    * This returns the item at the given coordinates (which are canvas
    * relative, not object-relative). If an item is at that coordinate,
    * that item handle is returned, and if @p posret is not NULL, the
    * integer pointed to is set to a value of -1, 0 or 1, depending if
    * the coordinate is on the upper portion of that item (-1), on the
    * middle section (0) or on the lower part (1). If NULL is returned as
    * an item (no item found there), then posret may indicate -1 or 1
    * based if the coordinate is above or below all items respectively in
    * the genlist.
    *
    * @ingroup Genlist
    */
   EAPI Elm_Genlist_Item *elm_genlist_at_xy_item_get(const Evas_Object *obj, Evas_Coord x, Evas_Coord y, int *posret) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item *elm_genlist_first_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item *elm_genlist_last_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the scrollbar policy
    *
    * @param obj The genlist object
    * @param policy_h Horizontal scrollbar policy.
    * @param policy_v Vertical scrollbar policy.
    *
    * This sets the scrollbar visibility policy for the given genlist
    * scroller. #ELM_SMART_SCROLLER_POLICY_AUTO means the scrollbar is
    * made visible if it is needed, and otherwise kept hidden.
    * #ELM_SMART_SCROLLER_POLICY_ON turns it on all the time, and
    * #ELM_SMART_SCROLLER_POLICY_OFF always keeps it off. This applies
    * respectively for the horizontal and vertical scrollbars. Default is
    * #ELM_SMART_SCROLLER_POLICY_AUTO
    *
    * @see elm_genlist_scroller_policy_get()
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_scroller_policy_set(Evas_Object *obj, Elm_Scroller_Policy policy_h, Elm_Scroller_Policy policy_v) EINA_ARG_NONNULL(1);
   /**
    * Get the scrollbar policy
    *
    * @param obj The genlist object
    * @param policy_h Pointer to store the horizontal scrollbar policy.
    * @param policy_v Pointer to store the vertical scrollbar policy.
    *
    * @see elm_genlist_scroller_policy_set()
    *
    * @ingroup Genlist
    */
   EAPI void              elm_genlist_scroller_policy_get(const Evas_Object *obj, Elm_Scroller_Policy *policy_h, Elm_Scroller_Policy *policy_v) EINA_ARG_NONNULL(1);
   /* available item styles:
    * default
    * default_style - The text part is a textblock
    * double_label
    * icon_top_text_bottom
    */
   /* Genlist Item operation */
   EAPI Elm_Genlist_Item  *elm_genlist_item_next_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item  *elm_genlist_item_prev_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_genlist_item_genlist_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item  *elm_genlist_item_parent_get(const Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_subitems_clear(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_selected_set(Elm_Genlist_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_genlist_item_selected_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_expanded_set(Elm_Genlist_Item *item, Eina_Bool expanded) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_genlist_item_expanded_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI int                elm_genlist_item_expanded_depth_get(const Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_disabled_set(Elm_Genlist_Item *item, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_genlist_item_disabled_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_display_only_set(Elm_Genlist_Item *it, Eina_Bool display_only) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_genlist_item_display_only_get(const Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_show(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_bring_in(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_top_show(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_top_bring_in(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_middle_show(Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_middle_bring_in(Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_del(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void              *elm_genlist_item_data_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_data_set(Elm_Genlist_Item *it, const void *data) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_icons_orphan(Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI const Evas_Object *elm_genlist_item_object_get(const Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_update(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_item_class_update(Elm_Genlist_Item *it, const Elm_Genlist_Item_Class *itc) EINA_ARG_NONNULL(1, 2);
   EAPI const Elm_Genlist_Item_Class *elm_genlist_item_item_class_get(const Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_tooltip_text_set(Elm_Genlist_Item *item, const char *text) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_tooltip_content_cb_set(Elm_Genlist_Item *item, Elm_Tooltip_Item_Content_Cb func, const void *data, Evas_Smart_Cb del_cb) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_tooltip_unset(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_tooltip_style_set(Elm_Genlist_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_genlist_item_tooltip_style_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   /**
    * @brief Disable size restrictions on an object's tooltip
    * @param item The tooltip's anchor object
    * @param disable If EINA_TRUE, size restrictions are disabled
    * @return EINA_FALSE on failure, EINA_TRUE on success
    *
    * This function allows a tooltip to expand beyond its parant window's canvas.
    * It will instead be limited only by the size of the display.
    */
   EAPI Eina_Bool          elm_genlist_item_tooltip_size_restrict_disable(Elm_Genlist_Item *item, Eina_Bool disable);
   /**
    * @brief Retrieve size restriction state of an object's tooltip
    * @param item The tooltip's anchor object
    * @return If EINA_TRUE, size restrictions are disabled
    *
    * This function returns whether a tooltip is allowed to expand beyond
    * its parant window's canvas.
    * It will instead be limited only by the size of the display.
    */
   EAPI Eina_Bool          elm_genlist_item_tooltip_size_restrict_disabled_get(const Elm_Genlist_Item *item);
   EAPI void               elm_genlist_item_cursor_set(Elm_Genlist_Item *item, const char *cursor) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_genlist_item_cursor_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_cursor_unset(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_cursor_style_set(Elm_Genlist_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_genlist_item_cursor_style_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_cursor_engine_only_set(Elm_Genlist_Item *item, Eina_Bool engine_only) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_genlist_item_cursor_engine_only_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   /**
    * Update the contents of all realized items.
    *
    * @param obj The genlist object.
    *
    * This updates all realized items by calling all the item class functions again
    * to get the icons, labels and states. Use this when the original
    * item data has changed and the changes are desired to be reflected.
    *
    * @see elm_genlist_realized_items_get()
    *
    * @ingroup Genlist
    */
   EAPI void               elm_genlist_realized_items_update(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_mode_set(Elm_Genlist_Item *it, const char *mode_type, Eina_Bool mode_set) EINA_ARG_NONNULL(1, 2);
   EAPI const char        *elm_genlist_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Elm_Genlist_Item *elm_genlist_mode_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_reorder_mode_set(Evas_Object *obj, Eina_Bool reorder_mode) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_genlist_reorder_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

   /**
    * @page tutorial_check Check example
    * @dontinclude check_example_01.c
    *
    * This example will show 2 checkboxes, one with just a label and the second
    * one with both a label and an icon. This example also ilustrates how to
    * have the checkbox change the value of a variable and how to react to those
    * changes.
    *
    * We will start with the usual setup code:
    * @until show(bg)
    *
    * And now we create our first checkbox, set its label, tell it to change
    * the value of @p value when the checkbox stats is changed and ask to be
    * notified of state changes:
    * @until show
    *
    * For our second checkbox we are going to set an icon so we need to create
    * and icon:
    * @until show
    * @note For simplicity we are using a rectangle as icon, but any evas object
    * can be used.
    *
    * And for our second checkbox we set the label, icon and state to true:
    * @until show
    *
    * We now do some more setup:
    * @until ELM_MAIN
    *
    * And finally implement the callback that will be called when the first
    * checkbox's state changes. This callback will use @p data to print a
    * message:
    * @until }
    * @note This work because @p data is @p value(from the main function) and @p
    * value is changed when the checkbox is changed.
    *
    * Our example will look like this:
    *
    * @image html screenshots/check_example_01.png
    * @image latex screenshots/check_example_01.eps width=\textwidth
    *
    * @example check_example_01.c
    */
   /**
    * @defgroup Check Check
    *
    * @image html img/widget/button/preview-00.png
    * @image html img/widget/button/preview-01.png
    * @image html img/widget/button/preview-02.png
    *
    * @brief The check widget allows for toggling a value between true and
    * false.
    *
    * Check objects are a lot like radio objects in layout and functionality
    * except they do not work as a group, but independently and only toggle the
    * value of a boolean from false to true (0 or 1). elm_check_state_set() sets
    * the boolean state (1 for true, 0 for false), and elm_check_state_get()
    * returns the current state. For convenience, like the radio objects, you
    * can set a pointer to a boolean directly with elm_check_state_pointer_set()
    * for it to modify.
    *
    * Signals that you can add callbacks for are:
    * "changed" - This is called whenever the user changes the state of one of
    *             the check object(event_info is NULL).
    *
    * @ref tutorial_check should give you a firm grasp of how to use this widget.
    * @{
    */
   /**
    * @brief Add a new Check object
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object *elm_check_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the text label of the check object
    *
    * @param obj The check object
    * @param label The text label string in UTF-8
    *
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_check_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the text label of the check object
    *
    * @param obj The check object
    * @return The text label string in UTF-8
    *
    * @deprecated use elm_object_text_get() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_check_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the icon object of the check object
    *
    * @param obj The check object
    * @param icon The icon object
    *
    * Once the icon object is set, a previously set one will be deleted.
    * If you want to keep that old content object, use the
    * elm_check_icon_unset() function.
    */
   EAPI void         elm_check_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the icon object of the check object
    *
    * @param obj The check object
    * @return The icon object
    */
   EAPI Evas_Object *elm_check_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Unset the icon used for the check object
    *
    * @param obj The check object
    * @return The icon object that was being used
    *
    * Unparent and return the icon object which was set for this widget.
    */
   EAPI Evas_Object *elm_check_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the on/off state of the check object
    *
    * @param obj The check object
    * @param state The state to use (1 == on, 0 == off)
    *
    * This sets the state of the check. If set
    * with elm_check_state_pointer_set() the state of that variable is also
    * changed. Calling this @b doesn't cause the "changed" signal to be emited.
    */
   EAPI void         elm_check_state_set(Evas_Object *obj, Eina_Bool state) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the state of the check object
    *
    * @param obj The check object
    * @return The boolean state
    */
   EAPI Eina_Bool    elm_check_state_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set a convenience pointer to a boolean to change
    *
    * @param obj The check object
    * @param statep Pointer to the boolean to modify
    *
    * This sets a pointer to a boolean, that, in addition to the check objects
    * state will also be modified directly. To stop setting the object pointed
    * to simply use NULL as the @p statep parameter. If @p statep is not NULL,
    * then when this is called, the check objects state will also be modified to
    * reflect the value of the boolean @p statep points to, just like calling
    * elm_check_state_set().
    */
   EAPI void         elm_check_state_pointer_set(Evas_Object *obj, Eina_Bool *statep) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /**
    * @defgroup Radio Radio
    *
    * @image html img/widget/radio/preview-00.png
    * @image latex img/widget/radio/preview-00.eps
    *
    * @brief Radio is a widget that allows for 1 or more options to be displayed
    * and have the user choose only 1 of them.
    *
    * A radio object contains an indicator, an optional Label and an optional
    * icon object. While it's possible to have a group of only one radio they,
    * are normally used in groups of 2 or more. To add a radio to a group use
    * elm_radio_group_add(). The radio object(s) will select from one of a set
    * of integer values, so any value they are configuring needs to be mapped to
    * a set of integers. To configure what value that radio object represents,
    * use  elm_radio_state_value_set() to set the integer it represents. To set
    * the value the whole group(which one is currently selected) is to indicate
    * use elm_radio_value_set() on any group member, and to get the groups value
    * use elm_radio_value_get(). For convenience the radio objects are also able
    * to directly set an integer(int) to the value that is selected. To specify
    * the pointer to this integer to modify, use elm_radio_value_pointer_set().
    * The radio objects will modify this directly. That implies the pointer must
    * point to valid memory for as long as the radio objects exist.
    *
    * Signals that you can add callbacks for are:
    * @li changed - This is called whenever the user changes the state of one of
    * the radio objects within the group of radio objects that work together.
    *
    * @ref tutorial_radio show most of this API in action.
    * @{
    */
   /**
    * @brief Add a new radio to the parent
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object *elm_radio_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the text label of the radio object
    *
    * @param obj The radio object
    * @param label The text label string in UTF-8
    *
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_radio_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the text label of the radio object
    *
    * @param obj The radio object
    * @return The text label string in UTF-8
    *
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_radio_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the icon object of the radio object
    *
    * @param obj The radio object
    * @param icon The icon object
    *
    * Once the icon object is set, a previously set one will be deleted. If you
    * want to keep that old content object, use the elm_radio_icon_unset()
    * function.
    */
   EAPI void         elm_radio_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the icon object of the radio object
    *
    * @param obj The radio object
    * @return The icon object
    *
    * @see elm_radio_icon_set()
    */
   EAPI Evas_Object *elm_radio_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Unset the icon used for the radio object
    *
    * @param obj The radio object
    * @return The icon object that was being used
    *
    * Unparent and return the icon object which was set for this widget.
    *
    * @see elm_radio_icon_set()
    */
   EAPI Evas_Object *elm_radio_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Add this radio to a group of other radio objects
    *
    * @param obj The radio object
    * @param group Any object whose group the @p obj is to join.
    *
    * Radio objects work in groups. Each member should have a different integer
    * value assigned. In order to have them work as a group, they need to know
    * about each other. This adds the given radio object to the group of which
    * the group object indicated is a member.
    */
   EAPI void         elm_radio_group_add(Evas_Object *obj, Evas_Object *group) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the integer value that this radio object represents
    *
    * @param obj The radio object
    * @param value The value to use if this radio object is selected
    *
    * This sets the value of the radio.
    */
   EAPI void         elm_radio_state_value_set(Evas_Object *obj, int value) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the integer value that this radio object represents
    *
    * @param obj The radio object
    * @return The value used if this radio object is selected
    *
    * This gets the value of the radio.
    *
    * @see elm_radio_value_set()
    */
   EAPI int          elm_radio_state_value_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the value of the radio.
    *
    * @param obj The radio object
    * @param value The value to use for the group
    *
    * This sets the value of the radio group and will also set the value if
    * pointed to, to the value supplied, but will not call any callbacks.
    */
   EAPI void         elm_radio_value_set(Evas_Object *obj, int value) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the state of the radio object
    *
    * @param obj The radio object
    * @return The integer state
    */
   EAPI int          elm_radio_value_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set a convenience pointer to a integer to change
    *
    * @param obj The radio object
    * @param valuep Pointer to the integer to modify
    *
    * This sets a pointer to a integer, that, in addition to the radio objects
    * state will also be modified directly. To stop setting the object pointed
    * to simply use NULL as the @p valuep argument. If valuep is not NULL, then
    * when this is called, the radio objects state will also be modified to
    * reflect the value of the integer valuep points to, just like calling
    * elm_radio_value_set().
    */
   EAPI void         elm_radio_value_pointer_set(Evas_Object *obj, int *valuep) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /**
    * @defgroup Pager Pager
    *
    * @image html img/widget/pager/preview-00.png
    * @image latex img/widget/pager/preview-00.eps
    *
    * @brief Widget that allows flipping between 1 or more “pages” of objects.
    *
    * The flipping between “pages” of objects is animated. All content in pager
    * is kept in a stack, the last content to be added will be on the top of the
    * stack(be visible).
    *
    * Objects can be pushed or popped from the stack or deleted as normal.
    * Pushes and pops will animate (and a pop will delete the object once the
    * animation is finished). Any object already in the pager can be promoted to
    * the top(from its current stacking position) through the use of
    * elm_pager_content_promote(). Objects are pushed to the top with
    * elm_pager_content_push() and when the top item is no longer wanted, simply
    * pop it with elm_pager_content_pop() and it will also be deleted. If an
    * object is no longer needed and is not the top item, just delete it as
    * normal. You can query which objects are the top and bottom with
    * elm_pager_content_bottom_get() and elm_pager_content_top_get().
    *
    * Signals that you can add callbacks for are:
    * "hide,finished" - when the previous page is hided
    *
    * This widget has the following styles available:
    * @li default
    * @li fade
    * @li fade_translucide
    * @li fade_invisible
    * @note This styles affect only the flipping animations, the appearance when
    * not animating is unaffected by styles.
    *
    * @ref tutorial_pager gives a good overview of the usage of the API.
    * @{
    */
   /**
    * Add a new pager to the parent
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    *
    * @ingroup Pager
    */
   EAPI Evas_Object *elm_pager_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Push an object to the top of the pager stack (and show it).
    *
    * @param obj The pager object
    * @param content The object to push
    *
    * The object pushed becomes a child of the pager, it will be controlled and
    * deleted when the pager is deleted.
    *
    * @note If the content is already in the stack use
    * elm_pager_content_promote().
    * @warning Using this function on @p content already in the stack results in
    * undefined behavior.
    */
   EAPI void         elm_pager_content_push(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   /**
    * @brief Pop the object that is on top of the stack
    *
    * @param obj The pager object
    *
    * This pops the object that is on the top(visible) of the pager, makes it
    * disappear, then deletes the object. The object that was underneath it on
    * the stack will become visible.
    */
   EAPI void         elm_pager_content_pop(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Moves an object already in the pager stack to the top of the stack.
    *
    * @param obj The pager object
    * @param content The object to promote
    *
    * This will take the @p content and move it to the top of the stack as
    * if it had been pushed there.
    *
    * @note If the content isn't already in the stack use
    * elm_pager_content_push().
    * @warning Using this function on @p content not already in the stack
    * results in undefined behavior.
    */
   EAPI void         elm_pager_content_promote(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   /**
    * @brief Return the object at the bottom of the pager stack
    *
    * @param obj The pager object
    * @return The bottom object or NULL if none
    */
   EAPI Evas_Object *elm_pager_content_bottom_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief  Return the object at the top of the pager stack
    *
    * @param obj The pager object
    * @return The top object or NULL if none
    */
   EAPI Evas_Object *elm_pager_content_top_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   typedef struct _Elm_Slideshow_Item_Class Elm_Slideshow_Item_Class;
   typedef struct _Elm_Slideshow_Item_Class_Func Elm_Slideshow_Item_Class_Func;
   typedef struct _Elm_Slideshow_Item       Elm_Slideshow_Item; /**< Item of Elm_Slideshow. Sub-type of Elm_Widget_Item */
   typedef Evas_Object *(*SlideshowItemGetFunc) (void *data, Evas_Object *obj);
   typedef void         (*SlideshowItemDelFunc) (void *data, Evas_Object *obj);

   struct _Elm_Slideshow_Item_Class
     {
        struct _Elm_Slideshow_Item_Class_Func
          {
             SlideshowItemGetFunc get;
             SlideshowItemDelFunc del;
          } func;
     };

   EAPI Evas_Object        *elm_slideshow_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Elm_Slideshow_Item *elm_slideshow_item_add(Evas_Object *obj, const Elm_Slideshow_Item_Class *itc, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Slideshow_Item *elm_slideshow_item_sorted_insert(Evas_Object *obj, const Elm_Slideshow_Item_Class *itc, const void *data, Eina_Compare_Cb func) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_show(Elm_Slideshow_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_next(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_previous(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List    *elm_slideshow_transitions_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_transition_set(Evas_Object *obj, const char *transition) EINA_ARG_NONNULL(1);
   EAPI const char         *elm_slideshow_transition_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_timeout_set(Evas_Object *obj, double timeout) EINA_ARG_NONNULL(1);
   EAPI double              elm_slideshow_timeout_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_loop_set(Evas_Object *obj, Eina_Bool loop) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool           elm_slideshow_loop_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List    *elm_slideshow_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_item_del(Elm_Slideshow_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               *elm_slideshow_item_data_get(const Elm_Slideshow_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Slideshow_Item *elm_slideshow_item_current_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object*        elm_slideshow_item_object_get(const Elm_Slideshow_Item* item) EINA_ARG_NONNULL(1);
   EAPI Elm_Slideshow_Item *elm_slideshow_item_nth_get(const Evas_Object *obj, unsigned int nth) EINA_ARG_NONNULL(1);
   EAPI const char         *elm_slideshow_layout_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_layout_set(Evas_Object *obj, const char *layout) EINA_ARG_NONNULL(1);
   EAPI const Eina_List    *elm_slideshow_layouts_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_cache_before_set(Evas_Object *obj, int count) EINA_ARG_NONNULL(1);
   EAPI int                 elm_slideshow_cache_before_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_cache_after_set(Evas_Object *obj, int count) EINA_ARG_NONNULL(1);
   EAPI int                 elm_slideshow_cache_after_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI unsigned int        elm_slideshow_count_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "changed" - when the slideshow switch to another item
    */

   /**
    * @defgroup Fileselector File Selector
    *
    * @image html img/icon/fileselector/preview-00.png
    * @image latex img/icon/fileselector/preview-00.png
    *
    * A file selector is a widget that allows a user to navigate
    * through a file system, reporting file selections back via its
    * API.
    *
    * It contains shortcut buttons for home directory (@c ~) and to
    * jump one directory upwards (..), as well as cancel/ok buttons to
    * confirm/cancel a given selection. After either one of those two
    * former actions, the file selector will issue its @c "done" smart
    * callback.
    *
    * There's a text entry on it, too, showing the name of the current
    * selection. There's the possibility of making it editable, so it
    * is useful on file saving dialogs on applications, where one
    * gives a file name to save contents to, in a given directory in
    * the system. This custom file name will be reported on the @c
    * "done" smart callback (explained in sequence).
    *
    * Finally, it has a view to display file system items into in two
    * possible forms:
    * - list
    * - grid
    *
    * If Elementary is built with support of the Ethumb thumbnailing
    * library, the second form of view will display preview thumbnails
    * of files which it supports.
    *
    * Smart callbacks one can register to:
    *
    * - @c "selected" - the user has clicked on a file (when not in
    *      folders-only mode) or directory (when in folders-only mode)
    * - @c "directory,open" - the list has been populated with new
    *      content (@c event_info is a pointer to the directory's
    *      path, a @b stringshared string)
    * - @c "done" - the user has clicked on the "ok" or "cancel"
    *      buttons (@c event_info is a pointer to the selection's
    *      path, a @b stringshared string)
    *
    * Here is an example on its usage:
    * @li @ref fileselector_example
    */

   /**
    * @addtogroup Fileselector
    * @{
    */

   /**
    * Defines how a file selector widget is to layout its contents
    * (file system entries).
    */
   typedef enum _Elm_Fileselector_Mode
     {
        ELM_FILESELECTOR_LIST = 0, /**< layout as a list */
        ELM_FILESELECTOR_GRID, /**< layout as a grid */
        ELM_FILESELECTOR_LAST /**< sentinel (helper) value, not used */
     } Elm_Fileselector_Mode;

   /**
    * Add a new file selector widget to the given parent Elementary
    * (container) object
    *
    * @param parent The parent object
    * @return a new file selector widget handle or @c NULL, on errors
    *
    * This function inserts a new file selector widget on the canvas.
    *
    * @ingroup Fileselector
    */
   EAPI Evas_Object          *elm_fileselector_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Enable/disable the file name entry box where the user can type
    * in a name for a file, in a given file selector widget
    *
    * @param obj The file selector object
    * @param is_save @c EINA_TRUE to make the file selector a "saving
    * dialog", @c EINA_FALSE otherwise
    *
    * Having the entry editable is useful on file saving dialogs on
    * applications, where one gives a file name to save contents to,
    * in a given directory in the system. This custom file name will
    * be reported on the @c "done" smart callback.
    *
    * @see elm_fileselector_is_save_get()
    *
    * @ingroup Fileselector
    */
   EAPI void                  elm_fileselector_is_save_set(Evas_Object *obj, Eina_Bool is_save) EINA_ARG_NONNULL(1);

   /**
    * Get whether the given file selector is in "saving dialog" mode
    *
    * @param obj The file selector object
    * @return @c EINA_TRUE, if the file selector is in "saving dialog"
    * mode, @c EINA_FALSE otherwise (and on errors)
    *
    * @see elm_fileselector_is_save_set() for more details
    *
    * @ingroup Fileselector
    */
   EAPI Eina_Bool             elm_fileselector_is_save_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Enable/disable folder-only view for a given file selector widget
    *
    * @param obj The file selector object
    * @param only @c EINA_TRUE to make @p obj only display
    * directories, @c EINA_FALSE to make files to be displayed in it
    * too
    *
    * If enabled, the widget's view will only display folder items,
    * naturally.
    *
    * @see elm_fileselector_folder_only_get()
    *
    * @ingroup Fileselector
    */
   EAPI void                  elm_fileselector_folder_only_set(Evas_Object *obj, Eina_Bool only) EINA_ARG_NONNULL(1);

   /**
    * Get whether folder-only view is set for a given file selector
    * widget
    *
    * @param obj The file selector object
    * @return only @c EINA_TRUE if @p obj is only displaying
    * directories, @c EINA_FALSE if files are being displayed in it
    * too (and on errors)
    *
    * @see elm_fileselector_folder_only_get()
    *
    * @ingroup Fileselector
    */
   EAPI Eina_Bool             elm_fileselector_folder_only_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Enable/disable the "ok" and "cancel" buttons on a given file
    * selector widget
    *
    * @param obj The file selector object
    * @param only @c EINA_TRUE to show them, @c EINA_FALSE to hide.
    *
    * @note A file selector without those buttons will never emit the
    * @c "done" smart event, and is only usable if one is just hooking
    * to the other two events.
    *
    * @see elm_fileselector_buttons_ok_cancel_get()
    *
    * @ingroup Fileselector
    */
   EAPI void                  elm_fileselector_buttons_ok_cancel_set(Evas_Object *obj, Eina_Bool buttons) EINA_ARG_NONNULL(1);

   /**
    * Get whether the "ok" and "cancel" buttons on a given file
    * selector widget are being shown.
    *
    * @param obj The file selector object
    * @return @c EINA_TRUE if they are being shown, @c EINA_FALSE
    * otherwise (and on errors)
    *
    * @see elm_fileselector_buttons_ok_cancel_set() for more details
    *
    * @ingroup Fileselector
    */
   EAPI Eina_Bool             elm_fileselector_buttons_ok_cancel_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Enable/disable a tree view in the given file selector widget,
    * <b>if it's in @c #ELM_FILESELECTOR_LIST mode</b>
    *
    * @param obj The file selector object
    * @param expand @c EINA_TRUE to enable tree view, @c EINA_FALSE to
    * disable
    *
    * In a tree view, arrows are created on the sides of directories,
    * allowing them to expand in place.
    *
    * @note If it's in other mode, the changes made by this function
    * will only be visible when one switches back to "list" mode.
    *
    * @see elm_fileselector_expandable_get()
    *
    * @ingroup Fileselector
    */
   EAPI void                  elm_fileselector_expandable_set(Evas_Object *obj, Eina_Bool expand) EINA_ARG_NONNULL(1);

   /**
    * Get whether tree view is enabled for the given file selector
    * widget
    *
    * @param obj The file selector object
    * @return @c EINA_TRUE if @p obj is in tree view, @c EINA_FALSE
    * otherwise (and or errors)
    *
    * @see elm_fileselector_expandable_set() for more details
    *
    * @ingroup Fileselector
    */
   EAPI Eina_Bool             elm_fileselector_expandable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set, programmatically, the @b directory that a given file
    * selector widget will display contents from
    *
    * @param obj The file selector object
    * @param path The path to display in @p obj
    *
    * This will change the @b directory that @p obj is displaying. It
    * will also clear the text entry area on the @p obj object, which
    * displays select files' names.
    *
    * @see elm_fileselector_path_get()
    *
    * @ingroup Fileselector
    */
   EAPI void                  elm_fileselector_path_set(Evas_Object *obj, const char *path) EINA_ARG_NONNULL(1);

   /**
    * Get the parent directory's path that a given file selector
    * widget is displaying
    *
    * @param obj The file selector object
    * @return The (full) path of the directory the file selector is
    * displaying, a @b stringshared string
    *
    * @see elm_fileselector_path_set()
    *
    * @ingroup Fileselector
    */
   EAPI const char           *elm_fileselector_path_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set, programmatically, the currently selected file/directory in
    * the given file selector widget
    *
    * @param obj The file selector object
    * @param path The (full) path to a file or directory
    * @return @c EINA_TRUE on success, @c EINA_FALSE on failure. The
    * latter case occurs if the directory or file pointed to do not
    * exist.
    *
    * @see elm_fileselector_selected_get()
    *
    * @ingroup Fileselector
    */
   EAPI Eina_Bool             elm_fileselector_selected_set(Evas_Object *obj, const char *path) EINA_ARG_NONNULL(1);

   /**
    * Get the currently selected item's (full) path, in the given file
    * selector widget
    *
    * @param obj The file selector object
    * @return The absolute path of the selected item, a @b
    * stringshared string
    *
    * @note Custom editions on @p obj object's text entry, if made,
    * will appear on the return string of this function, naturally.
    *
    * @see elm_fileselector_selected_set() for more details
    *
    * @ingroup Fileselector
    */
   EAPI const char           *elm_fileselector_selected_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the mode in which a given file selector widget will display
    * (layout) file system entries in its view
    *
    * @param obj The file selector object
    * @param mode The mode of the fileselector, being it one of
    * #ELM_FILESELECTOR_LIST (default) or #ELM_FILESELECTOR_GRID. The
    * first one, naturally, will display the files in a list. The
    * latter will make the widget to display its entries in a grid
    * form.
    *
    * @note By using elm_fileselector_expandable_set(), the user may
    * trigger a tree view for that list.
    *
    * @note If Elementary is built with support of the Ethumb
    * thumbnailing library, the second form of view will display
    * preview thumbnails of files which it supports. You must have
    * elm_need_ethumb() called in your Elementary for thumbnailing to
    * work, though.
    *
    * @see elm_fileselector_expandable_set().
    * @see elm_fileselector_mode_get().
    *
    * @ingroup Fileselector
    */
   EAPI void                  elm_fileselector_mode_set(Evas_Object *obj, Elm_Fileselector_Mode mode) EINA_ARG_NONNULL(1);

   /**
    * Get the mode in which a given file selector widget is displaying
    * (layouting) file system entries in its view
    *
    * @param obj The fileselector object
    * @return The mode in which the fileselector is at
    *
    * @see elm_fileselector_mode_set() for more details
    *
    * @ingroup Fileselector
    */
   EAPI Elm_Fileselector_Mode elm_fileselector_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

   /* progressbar */
   EAPI Evas_Object *elm_progressbar_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_pulse_set(Evas_Object *obj, Eina_Bool pulse) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_progressbar_pulse_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_pulse(Evas_Object *obj, Eina_Bool state) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_value_set(Evas_Object *obj, double val) EINA_ARG_NONNULL(1);
   EAPI double       elm_progressbar_value_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_progressbar_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_progressbar_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_progressbar_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_progressbar_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_span_size_set(Evas_Object *obj, Evas_Coord size) EINA_ARG_NONNULL(1);
   EAPI Evas_Coord   elm_progressbar_span_size_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_unit_format_set(Evas_Object *obj, const char *format) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_progressbar_unit_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_progressbar_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_inverted_set(Evas_Object *obj, Eina_Bool inverted) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_progressbar_inverted_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    */
   /* available item styles:
    * default
    * wheel (simple style, no text, no progression, only pulse is available)
    */

   /**
    * @defgroup Separator Separator
    *
    * @brief Separator is a very thin object used to separate other objects.
    *
    * A separator can be vertical or horizontal.
    *
    * @ref tutorial_separator is a good example of how to use a separator.
    * @{
    */
   /**
    * @brief Add a separator object to @p parent
    *
    * @param parent The parent object
    *
    * @return The separator object, or NULL upon failure
    */
   EAPI Evas_Object *elm_separator_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the horizontal mode of a separator object
    *
    * @param obj The separator object
    * @param horizontal If true, the separator is horizontal
    */
   EAPI void         elm_separator_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the horizontal mode of a separator object
    *
    * @param obj The separator object
    * @return If true, the separator is horizontal
    *
    * @see elm_separator_horizontal_set()
    */
   EAPI Eina_Bool    elm_separator_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /**
    * @defgroup Spinner Spinner
    * @ingroup Elementary
    *
    * @image html img/widget/spinner/preview-00.png
    * @image latex img/widget/spinner/preview-00.eps
    *
    * A spinner is a widget which allows the user to increase or decrease
    * numeric values using arrow buttons, or edit values directly, clicking
    * over it and typing the new value.
    *
    * By default the spinner will not wrap and has a label
    * of "%.0f" (just showing the integer value of the double).
    *
    * A spinner has a label that is formatted with floating
    * point values and thus accepts a printf-style format string, like
    * “%1.2f units”.
    *
    * It also allows specific values to be replaced by pre-defined labels.
    *
    * Smart callbacks one can register to:
    *
    * - "changed" - Whenever the spinner value is changed.
    * - "delay,changed" - A short time after the value is changed by the user.
    *    This will be called only when the user stops dragging for a very short
    *    period or when they release their finger/mouse, so it avoids possibly
    *    expensive reactions to the value change.
    *
    * Available styles for it:
    * - @c "default";
    * - @c "vertical": up/down buttons at the right side and text left aligned.
    *
    * Here is an example on its usage:
    * @ref spinner_example
    */

   /**
    * @addtogroup Spinner
    * @{
    */

   /**
    * Add a new spinner widget to the given parent Elementary
    * (container) object.
    *
    * @param parent The parent object.
    * @return a new spinner widget handle or @c NULL, on errors.
    *
    * This function inserts a new spinner widget on the canvas.
    *
    * @ingroup Spinner
    *
    */
   EAPI Evas_Object *elm_spinner_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Set the format string of the displayed label.
    *
    * @param obj The spinner object.
    * @param fmt The format string for the label display.
    *
    * If @c NULL, this sets the format to "%.0f". If not it sets the format
    * string for the label text. The label text is provided a floating point
    * value, so the label text can display up to 1 floating point value.
    * Note that this is optional.
    *
    * Use a format string such as "%1.2f meters" for example, and it will
    * display values like: "3.14 meters" for a value equal to 3.14159.
    *
    * Default is "%0.f".
    *
    * @see elm_spinner_label_format_get()
    *
    * @ingroup Spinner
    */
   EAPI void         elm_spinner_label_format_set(Evas_Object *obj, const char *fmt) EINA_ARG_NONNULL(1);

   /**
    * Get the label format of the spinner.
    *
    * @param obj The spinner object.
    * @return The text label format string in UTF-8.
    *
    * @see elm_spinner_label_format_set() for details.
    *
    * @ingroup Spinner
    */
   EAPI const char  *elm_spinner_label_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the minimum and maximum values for the spinner.
    *
    * @param obj The spinner object.
    * @param min The minimum value.
    * @param max The maximum value.
    *
    * Define the allowed range of values to be selected by the user.
    *
    * If actual value is less than @p min, it will be updated to @p min. If it
    * is bigger then @p max, will be updated to @p max. Actual value can be
    * get with elm_spinner_value_get().
    *
    * By default, min is equal to 0, and max is equal to 100.
    *
    * @warning Maximum must be greater than minimum.
    *
    * @see elm_spinner_min_max_get()
    *
    * @ingroup Spinner
    */
   EAPI void         elm_spinner_min_max_set(Evas_Object *obj, double min, double max) EINA_ARG_NONNULL(1);

   /**
    * Get the minimum and maximum values of the spinner.
    *
    * @param obj The spinner object.
    * @param min Pointer where to store the minimum value.
    * @param max Pointer where to store the maximum value.
    *
    * @note If only one value is needed, the other pointer can be passed
    * as @c NULL.
    *
    * @see elm_spinner_min_max_set() for details.
    *
    * @ingroup Spinner
    */
   EAPI void         elm_spinner_min_max_get(const Evas_Object *obj, double *min, double *max) EINA_ARG_NONNULL(1);

   /**
    * Set the step used to increment or decrement the spinner value.
    *
    * @param obj The spinner object.
    * @param step The step value.
    *
    * This value will be incremented or decremented to the displayed value.
    * It will be incremented while the user keep right or top arrow pressed,
    * and will be decremented while the user keep left or bottom arrow pressed.
    *
    * The interval to increment / decrement can be set with
    * elm_spinner_interval_set().
    *
    * By default step value is equal to 1.
    *
    * @see elm_spinner_step_get()
    *
    * @ingroup Spinner
    */
   EAPI void         elm_spinner_step_set(Evas_Object *obj, double step) EINA_ARG_NONNULL(1);

   /**
    * Get the step used to increment or decrement the spinner value.
    *
    * @param obj The spinner object.
    * @return The step value.
    *
    * @see elm_spinner_step_get() for more details.
    *
    * @ingroup Spinner
    */
   EAPI double       elm_spinner_step_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the value the spinner displays.
    *
    * @param obj The spinner object.
    * @param val The value to be displayed.
    *
    * Value will be presented on the label following format specified with
    * elm_spinner_format_set().
    *
    * @warning The value must to be between min and max values. This values
    * are set by elm_spinner_min_max_set().
    *
    * @see elm_spinner_value_get().
    * @see elm_spinner_format_set().
    * @see elm_spinner_min_max_set().
    *
    * @ingroup Spinner
    */
   EAPI void         elm_spinner_value_set(Evas_Object *obj, double val) EINA_ARG_NONNULL(1);

   /**
    * Get the value displayed by the spinner.
    *
    * @param obj The spinner object.
    * @return The value displayed.
    *
    * @see elm_spinner_value_set() for details.
    *
    * @ingroup Spinner
    */
   EAPI double       elm_spinner_value_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set whether the spinner should wrap when it reaches its
    * minimum or maximum value.
    *
    * @param obj The spinner object.
    * @param wrap @c EINA_TRUE to enable wrap or @c EINA_FALSE to
    * disable it.
    *
    * Disabled by default. If disabled, when the user tries to increment the
    * value,
    * but displayed value plus step value is bigger than maximum value,
    * the spinner
    * won't allow it. The same happens when the user tries to decrement it,
    * but the value less step is less than minimum value.
    *
    * When wrap is enabled, in such situations it will allow these changes,
    * but will get the value that would be less than minimum and subtracts
    * from maximum. Or add the value that would be more than maximum to
    * the minimum.
    *
    * E.g.:
    * @li min value = 10
    * @li max value = 50
    * @li step value = 20
    * @li displayed value = 20
    *
    * When the user decrement value (using left or bottom arrow), it will
    * displays @c 40, because max - (min - (displayed - step)) is
    * @c 50 - (@c 10 - (@c 20 - @c 20)) = @c 40.
    *
    * @see elm_spinner_wrap_get().
    *
    * @ingroup Spinner
    */
   EAPI void         elm_spinner_wrap_set(Evas_Object *obj, Eina_Bool wrap) EINA_ARG_NONNULL(1);

   /**
    * Get whether the spinner should wrap when it reaches its
    * minimum or maximum value.
    *
    * @param obj The spinner object
    * @return @c EINA_TRUE means wrap is enabled. @c EINA_FALSE indicates
    * it's disabled. If @p obj is @c NULL, @c EINA_FALSE is returned.
    *
    * @see elm_spinner_wrap_set() for details.
    *
    * @ingroup Spinner
    */
   EAPI Eina_Bool    elm_spinner_wrap_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set whether the spinner can be directly edited by the user or not.
    *
    * @param obj The spinner object.
    * @param editable @c EINA_TRUE to allow users to edit it or @c EINA_FALSE to
    * don't allow users to edit it directly.
    *
    * Spinner objects can have edition @b disabled, in which state they will
    * be changed only by arrows.
    * Useful for contexts
    * where you don't want your users to interact with it writting the value.
    * Specially
    * when using special values, the user can see real value instead
    * of special label on edition.
    *
    * It's enabled by default.
    *
    * @see elm_spinner_editable_get()
    *
    * @ingroup Spinner
    */
   EAPI void         elm_spinner_editable_set(Evas_Object *obj, Eina_Bool editable) EINA_ARG_NONNULL(1);

   /**
    * Get whether the spinner can be directly edited by the user or not.
    *
    * @param obj The spinner object.
    * @return @c EINA_TRUE means edition is enabled. @c EINA_FALSE indicates
    * it's disabled. If @p obj is @c NULL, @c EINA_FALSE is returned.
    *
    * @see elm_spinner_editable_set() for details.
    *
    * @ingroup Spinner
    */
   EAPI Eina_Bool    elm_spinner_editable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set a special string to display in the place of the numerical value.
    *
    * @param obj The spinner object.
    * @param value The value to be replaced.
    * @param label The label to be used.
    *
    * It's useful for cases when a user should select an item that is
    * better indicated by a label than a value. For example, weekdays or months.
    *
    * E.g.:
    * @code
    * sp = elm_spinner_add(win);
    * elm_spinner_min_max_set(sp, 1, 3);
    * elm_spinner_special_value_add(sp, 1, "January");
    * elm_spinner_special_value_add(sp, 2, "February");
    * elm_spinner_special_value_add(sp, 3, "March");
    * evas_object_show(sp);
    * @endcode
    *
    * @ingroup Spinner
    */
   EAPI void         elm_spinner_special_value_add(Evas_Object *obj, double value, const char *label) EINA_ARG_NONNULL(1);

   /**
    * Set the interval on time updates for an user mouse button hold
    * on spinner widgets' arrows.
    *
    * @param obj The spinner object.
    * @param interval The (first) interval value in seconds.
    *
    * This interval value is @b decreased while the user holds the
    * mouse pointer either incrementing or decrementing spinner's value.
    *
    * This helps the user to get to a given value distant from the
    * current one easier/faster, as it will start to change quicker and
    * quicker on mouse button holds.
    *
    * The calculation for the next change interval value, starting from
    * the one set with this call, is the previous interval divided by
    * @c 1.05, so it decreases a little bit.
    *
    * The default starting interval value for automatic changes is
    * @c 0.85 seconds.
    *
    * @see elm_spinner_interval_get()
    *
    * @ingroup Spinner
    */
   EAPI void         elm_spinner_interval_set(Evas_Object *obj, double interval) EINA_ARG_NONNULL(1);

   /**
    * Get the interval on time updates for an user mouse button hold
    * on spinner widgets' arrows.
    *
    * @param obj The spinner object.
    * @return The (first) interval value, in seconds, set on it.
    *
    * @see elm_spinner_interval_set() for more details.
    *
    * @ingroup Spinner
    */
   EAPI double       elm_spinner_interval_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

   /**
    * @defgroup Index Index
    *
    * @image html img/widget/index/preview-00.png
    *
    * An index widget gives you an index for fast access to whichever
    * group of other UI items one might have. It's a list of text
    * items (usually letters, for alphabetically ordered access).
    *
    * Index widgets are by default hidden and just appear when the
    * user clicks over it's reserved area in the canvas. In its
    * default theme, it's an area one @ref Fingers "finger" wide on
    * the right side of the index widget's container.
    *
    * When items on the index are selected, smart callbacks get
    * called, so that its user can make other container objects to
    * show a given area or child object depending on the index item
    * selected. You'd probably be using an index together with @ref
    * List "lists", @ref Genlist "generic lists" or @ref Gengrid
    * "general grids".
    *
    * Smart events one  can add callbacks for are:
    * - @c "changed" - When the selected index item changes. @c
    *      event_info is the selected item's data pointer.
    * - @c "delay,changed" - When the selected index item changes, but
    *      after a small idling period. @c event_info is the selected
    *      item's data pointer.
    * - @c "selected" - When the user releases a mouse button and
    *      selects an item. @c event_info is the selected item's data
    *      pointer.
    * - @c "level,up" - when the user moves a finger from the first
    *      level to the second level
    * - @c "level,down" - when the user moves a finger from the second
    *      level to the first level
    *
    * The @c "delay,changed" event is so that it'll wait a small time
    * before actually reporting those events and, moreover, just the
    * last event happening on those time frames will actually be
    * reported.
    *
    * Here are some examples on its usage:
    * @li @ref index_example_01
    * @li @ref index_example_02
    */

   /**
    * @addtogroup Index
    * @{
    */

   typedef struct _Elm_Index_Item Elm_Index_Item; /**< Opaque handle for items of Elementary index widgets */

   /**
    * Add a new index widget to the given parent Elementary
    * (container) object
    *
    * @param parent The parent object
    * @return a new index widget handle or @c NULL, on errors
    *
    * This function inserts a new index widget on the canvas.
    *
    * @ingroup Index
    */
   EAPI Evas_Object    *elm_index_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Set whether a given index widget is or not visible,
    * programatically.
    *
    * @param obj The index object
    * @param active @c EINA_TRUE to show it, @c EINA_FALSE to hide it
    *
    * Not to be confused with visible as in @c evas_object_show() --
    * visible with regard to the widget's auto hiding feature.
    *
    * @see elm_index_active_get()
    *
    * @ingroup Index
    */
   EAPI void            elm_index_active_set(Evas_Object *obj, Eina_Bool active) EINA_ARG_NONNULL(1);

   /**
    * Get whether a given index widget is currently visible or not.
    *
    * @param obj The index object
    * @return @c EINA_TRUE, if it's shown, @c EINA_FALSE otherwise
    *
    * @see elm_index_active_set() for more details
    *
    * @ingroup Index
    */
   EAPI Eina_Bool       elm_index_active_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the items level for a given index widget.
    *
    * @param obj The index object.
    * @param level @c 0 or @c 1, the currently implemented levels.
    *
    * @see elm_index_item_level_get()
    *
    * @ingroup Index
    */
   EAPI void            elm_index_item_level_set(Evas_Object *obj, int level) EINA_ARG_NONNULL(1);

   /**
    * Get the items level set for a given index widget.
    *
    * @param obj The index object.
    * @return @c 0 or @c 1, which are the levels @p obj might be at.
    *
    * @see elm_index_item_level_set() for more information
    *
    * @ingroup Index
    */
   EAPI int             elm_index_item_level_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Returns the last selected item's data, for a given index widget.
    *
    * @param obj The index object.
    * @return The item @b data associated to the last selected item on
    * @p obj (or @c NULL, on errors).
    *
    * @warning The returned value is @b not an #Elm_Index_Item item
    * handle, but the data associated to it (see the @c item parameter
    * in elm_index_item_append(), as an example).
    *
    * @ingroup Index
    */
   EAPI void           *elm_index_item_selected_get(const Evas_Object *obj, int level) EINA_ARG_NONNULL(1);

   /**
    * Append a new item on a given index widget.
    *
    * @param obj The index object.
    * @param letter Letter under which the item should be indexed
    * @param item The item data to set for the index's item
    *
    * Despite the most common usage of the @p letter argument is for
    * single char strings, one could use arbitrary strings as index
    * entries.
    *
    * @c item will be the pointer returned back on @c "changed", @c
    * "delay,changed" and @c "selected" smart events.
    *
    * @ingroup Index
    */
   EAPI void            elm_index_item_append(Evas_Object *obj, const char *letter, const void *item) EINA_ARG_NONNULL(1);

   /**
    * Prepend a new item on a given index widget.
    *
    * @param obj The index object.
    * @param letter Letter under which the item should be indexed
    * @param item The item data to set for the index's item
    *
    * Despite the most common usage of the @p letter argument is for
    * single char strings, one could use arbitrary strings as index
    * entries.
    *
    * @c item will be the pointer returned back on @c "changed", @c
    * "delay,changed" and @c "selected" smart events.
    *
    * @ingroup Index
    */
   EAPI void            elm_index_item_prepend(Evas_Object *obj, const char *letter, const void *item) EINA_ARG_NONNULL(1);

   /**
    * Append a new item, on a given index widget, <b>after the item
    * having @p relative as data</b>.
    *
    * @param obj The index object.
    * @param letter Letter under which the item should be indexed
    * @param item The item data to set for the index's item
    * @param relative The item data of the index item to be the
    * predecessor of this new one
    *
    * Despite the most common usage of the @p letter argument is for
    * single char strings, one could use arbitrary strings as index
    * entries.
    *
    * @c item will be the pointer returned back on @c "changed", @c
    * "delay,changed" and @c "selected" smart events.
    *
    * @note If @p relative is @c NULL or if it's not found to be data
    * set on any previous item on @p obj, this function will behave as
    * elm_index_item_append().
    *
    * @ingroup Index
    */
   EAPI void            elm_index_item_append_relative(Evas_Object *obj, const char *letter, const void *item, const void *relative) EINA_ARG_NONNULL(1);

   /**
    * Prepend a new item, on a given index widget, <b>after the item
    * having @p relative as data</b>.
    *
    * @param obj The index object.
    * @param letter Letter under which the item should be indexed
    * @param item The item data to set for the index's item
    * @param relative The item data of the index item to be the
    * successor of this new one
    *
    * Despite the most common usage of the @p letter argument is for
    * single char strings, one could use arbitrary strings as index
    * entries.
    *
    * @c item will be the pointer returned back on @c "changed", @c
    * "delay,changed" and @c "selected" smart events.
    *
    * @note If @p relative is @c NULL or if it's not found to be data
    * set on any previous item on @p obj, this function will behave as
    * elm_index_item_prepend().
    *
    * @ingroup Index
    */
   EAPI void            elm_index_item_prepend_relative(Evas_Object *obj, const char *letter, const void *item, const void *relative) EINA_ARG_NONNULL(1);

   /**
    * Insert a new item into the given index widget, using @p cmp_func
    * function to sort items (by item data).
    *
    * @param obj The index object.
    * @param letter Letter under which the item should be indexed
    * @param item The item data to set for the index's item
    * @param cmp_func The comparing function to be used to sort index
    * items <b>by #Elm_Index_Item item handles</b>
    * @param cmp_data_func A @b fallback function to be called for the
    * sorting of index items <b>by item data</b>). It will be used
    * when @p cmp_func returns @c 0 (equality), which means an index
    * item with provided item data already exists. To decide which
    * data item should be pointed to by the index item in question, @p
    * cmp_data_func will be used. If @p cmp_data_func returns a
    * non-negative value, the previous index item data will be
    * replaced by the given @p item pointer. If the previous data need
    * to be freed, it should be done by the @p cmp_data_func function,
    * because all references to it will be lost. If this function is
    * not provided (@c NULL is given), index items will be @b
    * duplicated, if @p cmp_func returns @c 0.
    *
    * Despite the most common usage of the @p letter argument is for
    * single char strings, one could use arbitrary strings as index
    * entries.
    *
    * @c item will be the pointer returned back on @c "changed", @c
    * "delay,changed" and @c "selected" smart events.
    *
    * @ingroup Index
    */
   EAPI void            elm_index_item_sorted_insert(Evas_Object *obj, const char *letter, const void *item, Eina_Compare_Cb cmp_func, Eina_Compare_Cb cmp_data_func) EINA_ARG_NONNULL(1);

   /**
    * Remove an item from a given index widget, <b>to be referenced by
    * it's data value</b>.
    *
    * @param obj The index object
    * @param item The item's data pointer for the item to be removed
    * from @p obj
    *
    * If a deletion callback is set, via elm_index_item_del_cb_set(),
    * that callback function will be called by this one.
    *
    * @warning The item to be removed from @p obj will be found via
    * its item data pointer, and not by an #Elm_Index_Item handle.
    *
    * @ingroup Index
    */
   EAPI void            elm_index_item_del(Evas_Object *obj, const void *item) EINA_ARG_NONNULL(1);

   /**
    * Find a given index widget's item, <b>using item data</b>.
    *
    * @param obj The index object
    * @param item The item data pointed to by the desired index item
    * @return The index item handle, if found, or @c NULL otherwise
    *
    * @ingroup Index
    */
   EAPI Elm_Index_Item *elm_index_item_find(Evas_Object *obj, const void *item) EINA_ARG_NONNULL(1);

   /**
    * Removes @b all items from a given index widget.
    *
    * @param obj The index object.
    *
    * If deletion callbacks are set, via elm_index_item_del_cb_set(),
    * that callback function will be called for each item in @p obj.
    *
    * @ingroup Index
    */
   EAPI void            elm_index_item_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Go to a given items level on a index widget
    *
    * @param obj The index object
    * @param level The index level (one of @c 0 or @c 1)
    *
    * @ingroup Index
    */
   EAPI void            elm_index_item_go(Evas_Object *obj, int level) EINA_ARG_NONNULL(1);

   /**
    * Return the data associated with a given index widget item
    *
    * @param it The index widget item handle
    * @return The data associated with @p it
    *
    * @see elm_index_item_data_set()
    *
    * @ingroup Index
    */
   EAPI void           *elm_index_item_data_get(const Elm_Index_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the data associated with a given index widget item
    *
    * @param it The index widget item handle
    * @param data The new data pointer to set to @p it
    *
    * This sets new item data on @p it.
    *
    * @warning The old data pointer won't be touched by this function, so
    * the user had better to free that old data himself/herself.
    *
    * @ingroup Index
    */
   EAPI void            elm_index_item_data_set(Elm_Index_Item *it, const void *data) EINA_ARG_NONNULL(1);

   /**
    * Set the function to be called when a given index widget item is freed.
    *
    * @param it The item to set the callback on
    * @param func The function to call on the item's deletion
    *
    * When called, @p func will have both @c data and @c event_info
    * arguments with the @p it item's data value and, naturally, the
    * @c obj argument with a handle to the parent index widget.
    *
    * @ingroup Index
    */
   EAPI void            elm_index_item_del_cb_set(Elm_Index_Item *it, Evas_Smart_Cb func) EINA_ARG_NONNULL(1);

   /**
    * Get the letter (string) set on a given index widget item.
    *
    * @param it The index item handle
    * @return The letter string set on @p it
    *
    * @ingroup Index
    */
   EAPI const char     *elm_index_item_letter_get(const Elm_Index_Item *item) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

   /* photocam */
   typedef enum _Elm_Photocam_Zoom_Mode
     {
        ELM_PHOTOCAM_ZOOM_MODE_MANUAL = 0,
        ELM_PHOTOCAM_ZOOM_MODE_AUTO_FIT,
        ELM_PHOTOCAM_ZOOM_MODE_AUTO_FILL,
        ELM_PHOTOCAM_ZOOM_MODE_LAST
     } Elm_Photocam_Zoom_Mode;

   EAPI Evas_Object           *elm_photocam_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Evas_Load_Error        elm_photocam_file_set(Evas_Object *obj, const char *file) EINA_ARG_NONNULL(1);
   EAPI const char            *elm_photocam_file_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_zoom_set(Evas_Object *obj, double zoom) EINA_ARG_NONNULL(1);
   EAPI double                 elm_photocam_zoom_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_zoom_mode_set(Evas_Object *obj, Elm_Photocam_Zoom_Mode mode) EINA_ARG_NONNULL(1);
   EAPI Elm_Photocam_Zoom_Mode elm_photocam_zoom_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_image_size_get(const Evas_Object *obj, int *w, int *h) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_region_get(const Evas_Object *obj, int *x, int *y, int *w, int *h) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_image_region_show(Evas_Object *obj, int x, int y, int w, int h) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_image_region_bring_in(Evas_Object *obj, int x, int y, int w, int h) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_paused_set(Evas_Object *obj, Eina_Bool paused) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool              elm_photocam_paused_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object           *elm_photocam_internal_image_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_bounce_set(Evas_Object *obj,  Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_bounce_get(const Evas_Object *obj,  Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "clicked" - when image clicked
    * "press" - when mouse/finger held down initially on image
    * "longpressed" - when mouse/finger held for long time on image
    * "clicked,double" - when mouse/finger double-clicked
    * "load" - when photo load begins
    * "loaded" - when photo load done
    * "load,detail" - when detailed image load begins
    * "loaded,detail" - when detailed image load done
    * "zoom,start" - when zooming started
    * "zoom,stop" - when zooming stopped
    * "zoom,change" - when auto zoom mode changed zoom level
    * "scroll - the content has been scrolled (moved)
    * "scroll,anim,start" - scrolling animation has started
    * "scroll,anim,stop" - scrolling animation has stopped
    * "scroll,drag,start" - dragging the contents around has started
    * "scroll,drag,stop" - dragging the contents around has stopped
    */

   /* map */
   typedef enum _Elm_Map_Zoom_Mode
     {
        ELM_MAP_ZOOM_MODE_MANUAL,
        ELM_MAP_ZOOM_MODE_AUTO_FIT,
        ELM_MAP_ZOOM_MODE_AUTO_FILL,
        ELM_MAP_ZOOM_MODE_LAST
     } Elm_Map_Zoom_Mode;

   typedef enum _Elm_Map_Route_Sources
     {
        ELM_MAP_ROUTE_SOURCE_YOURS,
        ELM_MAP_ROUTE_SOURCE_MONAV,
        ELM_MAP_ROUTE_SOURCE_ORS,
        ELM_MAP_ROUTE_SOURCE_LAST
     } Elm_Map_Route_Sources;

   typedef enum _Elm_Map_Name_Sources
     {
        ELM_MAP_NAME_SOURCE_NOMINATIM,
        ELM_MAP_NAME_SOURCE_LAST
     } Elm_Map_Name_Sources;

   typedef enum _Elm_Map_Route_Type
     {
        ELM_MAP_ROUTE_TYPE_MOTOCAR,
        ELM_MAP_ROUTE_TYPE_BICYCLE,
        ELM_MAP_ROUTE_TYPE_FOOT,
        ELM_MAP_ROUTE_TYPE_LAST
     } Elm_Map_Route_Type;

   typedef enum _Elm_Map_Route_Method
     {
        ELM_MAP_ROUTE_METHOD_FASTEST,
        ELM_MAP_ROUTE_METHOD_SHORTEST,
        ELM_MAP_ROUTE_METHOD_LAST
     } Elm_Map_Route_Method;

   typedef enum _Elm_Map_Name_Method
     {
        ELM_MAP_NAME_METHOD_SEARCH,
        ELM_MAP_NAME_METHOD_REVERSE,
        ELM_MAP_NAME_METHOD_LAST
     } Elm_Map_Name_Method;

   typedef struct _Elm_Map_Marker          Elm_Map_Marker;
   typedef struct _Elm_Map_Marker_Class    Elm_Map_Marker_Class;
   typedef struct _Elm_Map_Group_Class     Elm_Map_Group_Class;
   typedef struct _Elm_Map_Route           Elm_Map_Route;
   typedef struct _Elm_Map_Name            Elm_Map_Name;
   typedef struct _Elm_Map_Track           Elm_Map_Track;

   typedef Evas_Object *(*ElmMapMarkerGetFunc)      (Evas_Object *obj, Elm_Map_Marker *marker, void *data);
   typedef void         (*ElmMapMarkerDelFunc)      (Evas_Object *obj, Elm_Map_Marker *marker, void *data, Evas_Object *o);
   typedef Evas_Object *(*ElmMapMarkerIconGetFunc)  (Evas_Object *obj, Elm_Map_Marker *marker, void *data);
   typedef Evas_Object *(*ElmMapGroupIconGetFunc)   (Evas_Object *obj, void *data);

   typedef char        *(*ElmMapModuleSourceFunc) (void);
   typedef int          (*ElmMapModuleZoomMinFunc) (void);
   typedef int          (*ElmMapModuleZoomMaxFunc) (void);
   typedef char        *(*ElmMapModuleUrlFunc) (Evas_Object *obj, int x, int y, int zoom);
   typedef int          (*ElmMapModuleRouteSourceFunc) (void);
   typedef char        *(*ElmMapModuleRouteUrlFunc) (Evas_Object *obj, char *type_name, int method, double flon, double flat, double tlon, double tlat);
   typedef char        *(*ElmMapModuleNameUrlFunc) (Evas_Object *obj, int method, char *name, double lon, double lat);
   typedef Eina_Bool    (*ElmMapModuleGeoIntoCoordFunc) (const Evas_Object *obj, int zoom, double lon, double lat, int size, int *x, int *y);
   typedef Eina_Bool    (*ElmMapModuleCoordIntoGeoFunc) (const Evas_Object *obj, int zoom, int x, int y, int size, double *lon, double *lat);

   EAPI Evas_Object          *elm_map_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_zoom_set(Evas_Object *obj, int zoom) EINA_ARG_NONNULL(1);
   EAPI int                   elm_map_zoom_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_zoom_mode_set(Evas_Object *obj, Elm_Map_Zoom_Mode mode) EINA_ARG_NONNULL(1);
   EAPI Elm_Map_Zoom_Mode     elm_map_zoom_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_geo_region_get(const Evas_Object *obj, double *lon, double *lat) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_geo_region_bring_in(Evas_Object *obj, double lon, double lat) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_geo_region_show(Evas_Object *obj, double lon, double lat) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_paused_set(Evas_Object *obj, Eina_Bool paused) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_map_paused_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_paused_markers_set(Evas_Object *obj, Eina_Bool paused) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_map_paused_markers_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_utils_downloading_status_get(const Evas_Object *obj, int *try_num, int *finish_num) EINA_ARG_NONNULL(1, 2, 3);
   EAPI void                  elm_map_utils_convert_coord_into_geo(const Evas_Object *obj, int x, int y, int size, double *lon, double *lat) EINA_ARG_NONNULL(1, 5, 6);
   EAPI void                  elm_map_utils_convert_geo_into_coord(const Evas_Object *obj, double lon, double lat, int size, int *x, int *y) EINA_ARG_NONNULL(1, 5, 6);
   EAPI Elm_Map_Name         *elm_map_utils_convert_coord_into_name(const Evas_Object *obj, double lon, double lat) EINA_ARG_NONNULL(1);
   EAPI Elm_Map_Name         *elm_map_utils_convert_name_into_coord(const Evas_Object *obj, char *address) EINA_ARG_NONNULL(1, 2);
   EAPI void                  elm_map_utils_rotate_coord(const Evas_Object *obj, const Evas_Coord x, const Evas_Coord y, const Evas_Coord cx, const Evas_Coord cy, const double degree, Evas_Coord *xx, Evas_Coord *yy) EINA_ARG_NONNULL(1);
   EAPI Elm_Map_Marker       *elm_map_marker_add(Evas_Object *obj, double lon, double lat, Elm_Map_Marker_Class *clas, Elm_Map_Group_Class *clas_group, void *data) EINA_ARG_NONNULL(1, 4, 5);
   EAPI void                  elm_map_max_marker_per_group_set(Evas_Object *obj, int max) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_remove(Elm_Map_Marker *marker) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_region_get(const Elm_Map_Marker *marker, double *lon, double *lat) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_bring_in(Elm_Map_Marker *marker) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_show(Elm_Map_Marker *marker) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_markers_list_show(Eina_List *markers) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_map_marker_object_get(const Elm_Map_Marker *marker) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_update(Elm_Map_Marker *marker) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_bubbles_close(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Map_Group_Class  *elm_map_group_class_new(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_group_class_style_set(Elm_Map_Group_Class *clas, const char *style) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_group_class_icon_cb_set(Elm_Map_Group_Class *clas, ElmMapGroupIconGetFunc icon_get) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_group_class_data_set(Elm_Map_Group_Class *clas, void *data) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_group_class_zoom_displayed_set(Elm_Map_Group_Class *clas, int zoom) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_group_class_zoom_grouped_set(Elm_Map_Group_Class *clas, int zoom) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_group_class_hide_set(Evas_Object *obj, Elm_Map_Group_Class *clas, Eina_Bool hide) EINA_ARG_NONNULL(1, 2);
   EAPI Elm_Map_Marker_Class *elm_map_marker_class_new(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_class_style_set(Elm_Map_Marker_Class *clas, const char *style) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_class_icon_cb_set(Elm_Map_Marker_Class *clas, ElmMapMarkerIconGetFunc icon_get) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_class_get_cb_set(Elm_Map_Marker_Class *clas, ElmMapMarkerGetFunc get) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_class_del_cb_set(Elm_Map_Marker_Class *clas, ElmMapMarkerDelFunc del) EINA_ARG_NONNULL(1);
   EAPI const char          **elm_map_source_names_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_source_name_set(Evas_Object *obj, const char *source_name) EINA_ARG_NONNULL(1);
   EAPI const char           *elm_map_source_name_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_route_source_set(Evas_Object *obj, Elm_Map_Route_Sources source) EINA_ARG_NONNULL(1);
   EAPI Elm_Map_Route_Sources elm_map_route_source_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_source_zoom_min_set(Evas_Object *obj, int zoom) EINA_ARG_NONNULL(1);
   EAPI int                   elm_map_source_zoom_min_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_source_zoom_max_set(Evas_Object *obj, int zoom) EINA_ARG_NONNULL(1);
   EAPI int                   elm_map_source_zoom_max_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_user_agent_set(Evas_Object *obj, const char *user_agent) EINA_ARG_NONNULL(1, 2);
   EAPI const char           *elm_map_user_agent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Map_Route        *elm_map_route_add(Evas_Object *obj, Elm_Map_Route_Type type, Elm_Map_Route_Method method, double flon, double flat, double tlon, double tlat) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_route_remove(Elm_Map_Route *route) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_route_color_set(Elm_Map_Route *route, int r, int g , int b, int a) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_route_color_get(const Elm_Map_Route *route, int *r, int *g , int *b, int *a) EINA_ARG_NONNULL(1);
   EAPI double                elm_map_route_distance_get(const Elm_Map_Route *route) EINA_ARG_NONNULL(1);
   EAPI const char           *elm_map_route_node_get(const Elm_Map_Route *route) EINA_ARG_NONNULL(1);
   EAPI const char           *elm_map_route_waypoint_get(const Elm_Map_Route *route) EINA_ARG_NONNULL(1);
   EAPI const char           *elm_map_name_address_get(const Elm_Map_Name *name) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_name_region_get(const Elm_Map_Name *name, double *lon, double *lat) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_name_remove(Elm_Map_Name *name) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_rotate_set(Evas_Object *obj, double degree, Evas_Coord cx, Evas_Coord cy) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_rotate_get(const Evas_Object *obj, double *degree, Evas_Coord *cx, Evas_Coord *cy) EINA_ARG_NONNULL(1, 2, 3, 4);
   EAPI void                  elm_map_wheel_disabled_set(Evas_Object *obj, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_map_wheel_disabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
#ifdef ELM_EMAP
   EAPI Evas_Object          *elm_map_track_add(Evas_Object *obj, EMap_Route *emap) EINA_ARG_NONNULL(1);
#endif
   EAPI void                  elm_map_track_remove(Evas_Object *obj, Evas_Object *route) EINA_ARG_NONNULL(1);

   /* smart callbacks called:
    * "clicked" - when image clicked
    * "press" - when mouse/finger held down initially on image
    * "longpressed" - when mouse/finger held for long time on image
    * "clicked,double" - when mouse/finger double-clicked
    * "load,details" - when detailed image load begins
    * "loaded,details" - when detailed image load done
    * "zoom,start" - when zooming started
    * "zoom,stop" - when zooming stopped
    * "zoom,change" - when auto zoom mode changed zoom level
    * "scroll - the content has been scrolled (moved)
    * "scroll,anim,start" - scrolling animation has started
    * "scroll,anim,stop" - scrolling animation has stopped
    * "scroll,drag,start" - dragging the contents around has started
    * "scroll,drag,stop" - dragging the contents around has stopped
    */

   /* Route */
   EAPI Evas_Object *elm_route_add(Evas_Object *parent);
#ifdef ELM_EMAP
   EAPI void elm_route_emap_set(Evas_Object *obj, EMap_Route *emap);
#endif
   EAPI double elm_route_lon_min_get(Evas_Object *obj);
   EAPI double elm_route_lat_min_get(Evas_Object *obj);
   EAPI double elm_route_lon_max_get(Evas_Object *obj);
   EAPI double elm_route_lat_max_get(Evas_Object *obj);


   /**
    * @defgroup Panel Panel
    *
    * @image html img/widget/panel/preview-00.png
    * @image latex img/widget/panel/preview-00.eps
    *
    * @brief A panel is a type of animated container that contains subobjects.
    * It can be expanded or contracted by clicking the button on it's edge.
    *
    * Orientations are as follows:
    * @li ELM_PANEL_ORIENT_TOP
    * @li ELM_PANEL_ORIENT_LEFT
    * @li ELM_PANEL_ORIENT_RIGHT
    *
    * @ref tutorial_panel shows one way to use this widget.
    * @{
    */
   typedef enum _Elm_Panel_Orient
     {
        ELM_PANEL_ORIENT_TOP, /**< Panel (dis)appears from the top */
        ELM_PANEL_ORIENT_BOTTOM, /**< Not implemented */
        ELM_PANEL_ORIENT_LEFT, /**< Panel (dis)appears from the left */
        ELM_PANEL_ORIENT_RIGHT, /**< Panel (dis)appears from the right */
     } Elm_Panel_Orient;
   /**
    * @brief Adds a panel object
    *
    * @param parent The parent object
    *
    * @return The panel object, or NULL on failure
    */
   EAPI Evas_Object          *elm_panel_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Sets the orientation of the panel
    *
    * @param parent The parent object
    * @param orient The panel orientation. Can be one of the following:
    * @li ELM_PANEL_ORIENT_TOP
    * @li ELM_PANEL_ORIENT_LEFT
    * @li ELM_PANEL_ORIENT_RIGHT
    *
    * Sets from where the panel will (dis)appear.
    */
   EAPI void                  elm_panel_orient_set(Evas_Object *obj, Elm_Panel_Orient orient) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the orientation of the panel.
    *
    * @param obj The panel object
    * @return The Elm_Panel_Orient, or ELM_PANEL_ORIENT_LEFT on failure.
    */
   EAPI Elm_Panel_Orient      elm_panel_orient_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the content of the panel.
    *
    * @param obj The panel object
    * @param content The panel content
    *
    * Once the content object is set, a previously set one will be deleted.
    * If you want to keep that old content object, use the
    * elm_panel_content_unset() function.
    */
   EAPI void                  elm_panel_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the content of the panel.
    *
    * @param obj The panel object
    * @return The content that is being used
    *
    * Return the content object which is set for this widget.
    *
    * @see elm_panel_content_set()
    */
   EAPI Evas_Object          *elm_panel_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Unset the content of the panel.
    *
    * @param obj The panel object
    * @return The content that was being used
    *
    * Unparent and return the content object which was set for this widget.
    *
    * @see elm_panel_content_set()
    */
   EAPI Evas_Object          *elm_panel_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the state of the panel.
    *
    * @param obj The panel object
    * @param hidden If true, the panel will run the animation to contract
    */
   EAPI void                  elm_panel_hidden_set(Evas_Object *obj, Eina_Bool hidden) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the state of the panel.
    *
    * @param obj The panel object
    * @param hidden If true, the panel is in the "hide" state
    */
   EAPI Eina_Bool             elm_panel_hidden_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Toggle the hidden state of the panel from code
    *
    * @param obj The panel object
    */
   EAPI void                  elm_panel_toggle(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* panes */
   /**
    * TODO
    *
    * Update the minimun height of the bar in the theme. No minimun should be set in the vertical theme
    * Add events (move, start ...)
    */
   EAPI Evas_Object          *elm_panes_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void                  elm_panes_content_left_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI void                  elm_panes_content_right_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_panes_content_left_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_panes_content_right_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_panes_content_left_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_panes_content_right_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI double                elm_panes_content_left_size_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_panes_content_left_size_set(Evas_Object *obj, double size) EINA_ARG_NONNULL(1);
   EAPI void                  elm_panes_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_panes_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @defgroup Flip Flip
    *
    * @image html img/widget/flip/preview-00.png
    * @image latex img/widget/flip/preview-00.eps
    *
    * This widget holds 2 content objects(Evas_Object): one on the front and one
    * on the back. It allows you to flip from front to back and vice-versa using
    * various animations.
    *
    * If either the front or back contents are not set the flip will treat that
    * as transparent. So if you wore to set the front content but not the back,
    * and then call elm_flip_go() you would see whatever is below the flip.
    *
    * For a list of supported animations see elm_flip_go().
    *
    * Signals that you can add callbacks for are:
    * "animate,begin" - when a flip animation was started
    * "animate,done" - when a flip animation is finished
    *
    * @ref tutorial_flip show how to use most of the API.
    *
    * @{
    */
   typedef enum _Elm_Flip_Mode
     {
        ELM_FLIP_ROTATE_Y_CENTER_AXIS,
        ELM_FLIP_ROTATE_X_CENTER_AXIS,
        ELM_FLIP_ROTATE_XZ_CENTER_AXIS,
        ELM_FLIP_ROTATE_YZ_CENTER_AXIS,
        ELM_FLIP_CUBE_LEFT,
        ELM_FLIP_CUBE_RIGHT,
        ELM_FLIP_CUBE_UP,
        ELM_FLIP_CUBE_DOWN,
        ELM_FLIP_PAGE_LEFT,
        ELM_FLIP_PAGE_RIGHT,
        ELM_FLIP_PAGE_UP,
        ELM_FLIP_PAGE_DOWN
     } Elm_Flip_Mode;
   typedef enum _Elm_Flip_Interaction
     {
        ELM_FLIP_INTERACTION_NONE,
        ELM_FLIP_INTERACTION_ROTATE,
        ELM_FLIP_INTERACTION_CUBE,
        ELM_FLIP_INTERACTION_PAGE
     } Elm_Flip_Interaction;
   typedef enum _Elm_Flip_Direction
     {
        ELM_FLIP_DIRECTION_UP, /**< Allows interaction with the top of the widget */
        ELM_FLIP_DIRECTION_DOWN, /**< Allows interaction with the bottom of the widget */
        ELM_FLIP_DIRECTION_LEFT, /**< Allows interaction with the left portion of the widget */
        ELM_FLIP_DIRECTION_RIGHT /**< Allows interaction with the right portion of the widget */
     } Elm_Flip_Direction;
   /**
    * @brief Add a new flip to the parent
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object *elm_flip_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the front content of the flip widget.
    *
    * @param obj The flip object
    * @param content The new front content object
    *
    * Once the content object is set, a previously set one will be deleted.
    * If you want to keep that old content object, use the
    * elm_flip_content_front_unset() function.
    */
   EAPI void         elm_flip_content_front_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the back content of the flip widget.
    *
    * @param obj The flip object
    * @param content The new back content object
    *
    * Once the content object is set, a previously set one will be deleted.
    * If you want to keep that old content object, use the
    * elm_flip_content_back_unset() function.
    */
   EAPI void         elm_flip_content_back_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the front content used for the flip
    *
    * @param obj The flip object
    * @return The front content object that is being used
    *
    * Return the front content object which is set for this widget.
    */
   EAPI Evas_Object *elm_flip_content_front_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the back content used for the flip
    *
    * @param obj The flip object
    * @return The back content object that is being used
    *
    * Return the back content object which is set for this widget.
    */
   EAPI Evas_Object *elm_flip_content_back_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Unset the front content used for the flip
    *
    * @param obj The flip object
    * @return The front content object that was being used
    *
    * Unparent and return the front content object which was set for this widget.
    */
   EAPI Evas_Object *elm_flip_content_front_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Unset the back content used for the flip
    *
    * @param obj The flip object
    * @return The back content object that was being used
    *
    * Unparent and return the back content object which was set for this widget.
    */
   EAPI Evas_Object *elm_flip_content_back_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Get flip front visibility state
    *
    * @param obj The flip objct
    * @return EINA_TRUE if front front is showing, EINA_FALSE if the back is
    * showing.
    */
   EAPI Eina_Bool    elm_flip_front_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set flip perspective
    *
    * @param obj The flip object
    * @param foc The coordinate to set the focus on
    * @param x The X coordinate
    * @param y The Y coordinate
    *
    * @warning This function currently does nothing.
    */
   EAPI void         elm_flip_perspective_set(Evas_Object *obj, Evas_Coord foc, Evas_Coord x, Evas_Coord y) EINA_ARG_NONNULL(1);
   /**
    * @brief Runs the flip animation
    *
    * @param obj The flip object
    * @param mode The mode type
    *
    * Flips the front and back contents using the @p mode animation. This
    * efectively hides the currently visible content and shows the hidden one.
    *
    * There a number of possible animations to use for the flipping:
    * @li ELM_FLIP_ROTATE_X_CENTER_AXIS - Rotate the currently visible content
    * around a horizontal axis in the middle of its height, the other content
    * is shown as the other side of the flip.
    * @li ELM_FLIP_ROTATE_Y_CENTER_AXIS - Rotate the currently visible content
    * around a vertical axis in the middle of its width, the other content is
    * shown as the other side of the flip.
    * @li ELM_FLIP_ROTATE_XZ_CENTER_AXIS - Rotate the currently visible content
    * around a diagonal axis in the middle of its width, the other content is
    * shown as the other side of the flip.
    * @li ELM_FLIP_ROTATE_YZ_CENTER_AXIS - Rotate the currently visible content
    * around a diagonal axis in the middle of its height, the other content is
    * shown as the other side of the flip.
    * @li ELM_FLIP_CUBE_LEFT - Rotate the currently visible content to the left
    * as if the flip was a cube, the other content is show as the right face of
    * the cube.
    * @li ELM_FLIP_CUBE_RIGHT - Rotate the currently visible content to the
    * right as if the flip was a cube, the other content is show as the left
    * face of the cube.
    * @li ELM_FLIP_CUBE_UP - Rotate the currently visible content up as if the
    * flip was a cube, the other content is show as the bottom face of the cube.
    * @li ELM_FLIP_CUBE_DOWN - Rotate the currently visible content down as if
    * the flip was a cube, the other content is show as the upper face of the
    * cube.
    * @li ELM_FLIP_PAGE_LEFT - Move the currently visible content to the left as
    * if the flip was a book, the other content is shown as the page below that.
    * @li ELM_FLIP_PAGE_RIGHT - Move the currently visible content to the right
    * as if the flip was a book, the other content is shown as the page below
    * that.
    * @li ELM_FLIP_PAGE_UP - Move the currently visible content up as if the
    * flip was a book, the other content is shown as the page below that.
    * @li ELM_FLIP_PAGE_DOWN - Move the currently visible content down as if the
    * flip was a book, the other content is shown as the page below that.
    */
   EAPI void         elm_flip_go(Evas_Object *obj, Elm_Flip_Mode mode) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the interactive flip mode
    *
    * @param obj The flip object
    * @param mode The interactive flip mode to use
    *
    * This sets if the flip should be interactive (allow user to click and
    * drag a side of the flip to reveal the back page and cause it to flip).
    * By default a flip is not interactive. You may also need to set which
    * sides of the flip are "active" for flipping and how much space they use
    * (a minimum of a finger size) with elm_flip_interacton_direction_enabled_set()
    * and elm_flip_interacton_direction_hitsize_set()
    *
    * The four avilable mode of interaction are:
    * @li ELM_FLIP_INTERACTION_NONE - No interaction is allowed
    * @li ELM_FLIP_INTERACTION_ROTATE - Interaction will cause rotate animation
    * @li ELM_FLIP_INTERACTION_CUBE - Interaction will cause cube animation
    * @li ELM_FLIP_INTERACTION_PAGE - Interaction will cause page animation
    *
    * @note ELM_FLIP_INTERACTION_ROTATE won't cause
    * ELM_FLIP_ROTATE_XZ_CENTER_AXIS or ELM_FLIP_ROTATE_YZ_CENTER_AXIS to
    * happen, those can only be acheived with elm_flip_go();
    */
   EAPI void         elm_flip_interaction_set(Evas_Object *obj, Elm_Flip_Interaction mode);
   /**
    * @brief Get the interactive flip mode
    *
    * @param obj The flip object
    * @return The interactive flip mode
    *
    * Returns the interactive flip mode set by elm_flip_interaction_set()
    */
   EAPI Elm_Flip_Interaction elm_flip_interaction_get(const Evas_Object *obj);
   /**
    * @brief Set which directions of the flip respond to interactive flip
    *
    * @param obj The flip object
    * @param dir The direction to change
    * @param enabled If that direction is enabled or not
    *
    * By default all directions are disabled, so you may want to enable the
    * desired directions for flipping if you need interactive flipping. You must
    * call this function once for each direction that should be enabled.
    *
    * @see elm_flip_interaction_set()
    */
   EAPI void         elm_flip_interacton_direction_enabled_set(Evas_Object *obj, Elm_Flip_Direction dir, Eina_Bool enabled);
   /**
    * @brief Get the enabled state of that flip direction
    *
    * @param obj The flip object
    * @param dir The direction to check
    * @return If that direction is enabled or not
    *
    * Gets the enabled state set by elm_flip_interacton_direction_enabled_set()
    *
    * @see elm_flip_interaction_set()
    */
   EAPI Eina_Bool    elm_flip_interacton_direction_enabled_get(Evas_Object *obj, Elm_Flip_Direction dir);
   /**
    * @brief Set the amount of the flip that is sensitive to interactive flip
    *
    * @param obj The flip object
    * @param dir The direction to modify
    * @param hitsize The amount of that dimension (0.0 to 1.0) to use
    *
    * Set the amount of the flip that is sensitive to interactive flip, with 0
    * representing no area in the flip and 1 representing the entire flip. There
    * is however a consideration to be made in that the area will never be
    * smaller than the finger size set(as set in your Elementary configuration).
    *
    * @see elm_flip_interaction_set()
    */
   EAPI void         elm_flip_interacton_direction_hitsize_set(Evas_Object *obj, Elm_Flip_Direction dir, double hitsize);
   /**
    * @brief Get the amount of the flip that is sensitive to interactive flip
    *
    * @param obj The flip object
    * @param dir The direction to check
    * @return The size set for that direction
    *
    * Returns the amount os sensitive area set by
    * elm_flip_interacton_direction_hitsize_set().
    */
   EAPI double       elm_flip_interacton_direction_hitsize_get(Evas_Object *obj, Elm_Flip_Direction dir);
   /**
    * @}
    */

   /* scrolledentry */
   EINA_DEPRECATED EAPI Evas_Object *elm_scrolled_entry_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_single_line_set(Evas_Object *obj, Eina_Bool single_line) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_single_line_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_password_set(Evas_Object *obj, Eina_Bool password) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_password_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_entry_set(Evas_Object *obj, const char *entry) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_scrolled_entry_entry_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_entry_append(Evas_Object *obj, const char *entry) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_is_empty(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_scrolled_entry_selection_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_entry_insert(Evas_Object *obj, const char *entry) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_line_wrap_set(Evas_Object *obj, Elm_Wrap_Type wrap) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_editable_set(Evas_Object *obj, Eina_Bool editable) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_editable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_select_none(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_select_all(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cursor_next(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cursor_prev(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cursor_up(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cursor_down(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_begin_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_end_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_line_begin_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_line_end_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_selection_begin(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_selection_end(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cursor_is_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cursor_is_visible_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_scrolled_entry_cursor_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_pos_set(Evas_Object *obj, int pos) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI int          elm_scrolled_entry_cursor_pos_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_selection_cut(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_selection_copy(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_selection_paste(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_context_menu_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_context_menu_item_add(Evas_Object *obj, const char *label, const char *icon_file, Elm_Icon_Type icon_type, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_context_menu_disabled_set(Evas_Object *obj, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_context_menu_disabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_scrollbar_policy_set(Evas_Object *obj, Elm_Scroller_Policy h, Elm_Scroller_Policy v) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI Evas_Object *elm_scrolled_entry_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Evas_Object *elm_scrolled_entry_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_icon_visible_set(Evas_Object *obj, Eina_Bool setting) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_end_set(Evas_Object *obj, Evas_Object *end) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI Evas_Object *elm_scrolled_entry_end_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Evas_Object *elm_scrolled_entry_end_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_end_visible_set(Evas_Object *obj, Eina_Bool setting) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_item_provider_append(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *entry, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_item_provider_prepend(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *entry, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_item_provider_remove(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *entry, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_text_filter_append(Evas_Object *obj, void (*func) (void *data, Evas_Object *entry, char **text), void *data) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_text_filter_prepend(Evas_Object *obj, void (*func) (void *data, Evas_Object *entry, char **text), void *data) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_text_filter_remove(Evas_Object *obj, void (*func) (void *data, Evas_Object *entry, char **text), void *data) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_file_set(Evas_Object *obj, const char *file, Elm_Text_Format format) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_file_get(const Evas_Object *obj, const char **file, Elm_Text_Format *format) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_file_save(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_autosave_set(Evas_Object *obj, Eina_Bool autosave) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_autosave_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cnp_textonly_set(Evas_Object *obj, Eina_Bool textonly) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cnp_textonly_get(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @defgroup Conformant Conformant
    * @ingroup Elementary
    *
    * @image html img/widget/conformant/preview-00.png
    * @image latex img/widget/conformant/preview-00.eps width=\textwidth
    *
    * @image html img/conformant.png
    * @image latex img/conformant.eps width=\textwidth
    *
    * The aim is to provide a widget that can be used in elementary apps to
    * account for space taken up by the indicator, virtual keypad & softkey
    * windows when running the illume2 module of E17.
    *
    * So conformant content will be sized and positioned considering the
    * space required for such stuff, and when they popup, as a keyboard
    * shows when an entry is selected, conformant content won't change.
    *
    * Available styles for it:
    * - @c "default"
    *
    * See how to use this widget in this example:
    * @ref conformant_example
    */

   /**
    * @addtogroup Conformant
    * @{
    */

   /**
    * Add a new conformant widget to the given parent Elementary
    * (container) object.
    *
    * @param parent The parent object.
    * @return A new conformant widget handle or @c NULL, on errors.
    *
    * This function inserts a new conformant widget on the canvas.
    *
    * @ingroup Conformant
    */
   EAPI Evas_Object *elm_conformant_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Set the content of the conformant widget.
    *
    * @param obj The conformant object.
    * @param content The content to be displayed by the conformant.
    *
    * Content will be sized and positioned considering the space required
    * to display a virtual keyboard. So it won't fill all the conformant
    * size. This way is possible to be sure that content won't resize
    * or be re-positioned after the keyboard is displayed.
    *
    * Once the content object is set, a previously set one will be deleted.
    * If you want to keep that old content object, use the
    * elm_conformat_content_unset() function.
    *
    * @see elm_conformant_content_unset()
    * @see elm_conformant_content_get()
    *
    * @ingroup Conformant
    */
   EAPI void         elm_conformant_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);

   /**
    * Get the content of the conformant widget.
    *
    * @param obj The conformant object.
    * @return The content that is being used.
    *
    * Return the content object which is set for this widget.
    * It won't be unparent from conformant. For that, use
    * elm_conformant_content_unset().
    *
    * @see elm_conformant_content_set() for more details.
    * @see elm_conformant_content_unset()
    *
    * @ingroup Conformant
    */
   EAPI Evas_Object *elm_conformant_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Unset the content of the conformant widget.
    *
    * @param obj The conformant object.
    * @return The content that was being used.
    *
    * Unparent and return the content object which was set for this widget.
    *
    * @see elm_conformant_content_set() for more details.
    *
    * @ingroup Conformant
    */
   EAPI Evas_Object *elm_conformant_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Returns the Evas_Object that represents the content area.
    *
    * @param obj The conformant object.
    * @return The content area of the widget.
    *
    * @ingroup Conformant
    */
   EAPI Evas_Object *elm_conformant_content_area_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

   /* mapbuf */
   EAPI Evas_Object *elm_mapbuf_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_mapbuf_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_mapbuf_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_mapbuf_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_mapbuf_enabled_set(Evas_Object *obj, Eina_Bool enabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_mapbuf_enabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_mapbuf_smooth_set(Evas_Object *obj, Eina_Bool smooth) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_mapbuf_smooth_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_mapbuf_alpha_set(Evas_Object *obj, Eina_Bool alpha) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_mapbuf_alpha_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @defgroup Flipselector Flip Selector
    *
    * @image html img/widget/flipselector/preview-00.png
    * @image latex img/widget/flipselector/preview-00.eps
    *
    * A flip selector is a widget to show a set of @b text items, one
    * at a time, with the same sheet switching style as the @ref Clock
    * "clock" widget, when one changes the current displaying sheet
    * (thus, the "flip" in the name).
    *
    * User clicks to flip sheets which are @b held for some time will
    * make the flip selector to flip continuosly and automatically for
    * the user. The interval between flips will keep growing in time,
    * so that it helps the user to reach an item which is distant from
    * the current selection.
    *
    * Smart callbacks one can register to:
    * - @c "selected" - when the widget's selected text item is changed
    * - @c "overflowed" - when the widget's current selection is changed
    *   from the first item in its list to the last
    * - @c "underflowed" - when the widget's current selection is changed
    *   from the last item in its list to the first
    *
    * Available styles for it:
    * - @c "default"
    *
    * Here is an example on its usage:
    * @li @ref flipselector_example
    */

   /**
    * @addtogroup Flipselector
    * @{
    */

   typedef struct _Elm_Flipselector_Item Elm_Flipselector_Item; /**< Item handle for a flip selector widget. */

   /**
    * Add a new flip selector widget to the given parent Elementary
    * (container) widget
    *
    * @param parent The parent object
    * @return a new flip selector widget handle or @c NULL, on errors
    *
    * This function inserts a new flip selector widget on the canvas.
    *
    * @ingroup Flipselector
    */
   EAPI Evas_Object               *elm_flipselector_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Programmatically select the next item of a flip selector widget
    *
    * @param obj The flipselector object
    *
    * @note The selection will be animated. Also, if it reaches the
    * end of its list of member items, it will continue with the first
    * one onwards.
    *
    * @ingroup Flipselector
    */
   EAPI void                       elm_flipselector_flip_next(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Programmatically select the previous item of a flip selector
    * widget
    *
    * @param obj The flipselector object
    *
    * @note The selection will be animated.  Also, if it reaches the
    * beginning of its list of member items, it will continue with the
    * last one backwards.
    *
    * @ingroup Flipselector
    */
   EAPI void                       elm_flipselector_flip_prev(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Append a (text) item to a flip selector widget
    *
    * @param obj The flipselector object
    * @param label The (text) label of the new item
    * @param func Convenience callback function to take place when
    * item is selected
    * @param data Data passed to @p func, above
    * @return A handle to the item added or @c NULL, on errors
    *
    * The widget's list of labels to show will be appended with the
    * given value. If the user wishes so, a callback function pointer
    * can be passed, which will get called when this same item is
    * selected.
    *
    * @note The current selection @b won't be modified by appending an
    * element to the list.
    *
    * @note The maximum length of the text label is going to be
    * determined <b>by the widget's theme</b>. Strings larger than
    * that value are going to be @b truncated.
    *
    * @ingroup Flipselector
    */
   EAPI Elm_Flipselector_Item     *elm_flipselector_item_append(Evas_Object *obj, const char *label, Evas_Smart_Cb func, void *data) EINA_ARG_NONNULL(1);

   /**
    * Prepend a (text) item to a flip selector widget
    *
    * @param obj The flipselector object
    * @param label The (text) label of the new item
    * @param func Convenience callback function to take place when
    * item is selected
    * @param data Data passed to @p func, above
    * @return A handle to the item added or @c NULL, on errors
    *
    * The widget's list of labels to show will be prepended with the
    * given value. If the user wishes so, a callback function pointer
    * can be passed, which will get called when this same item is
    * selected.
    *
    * @note The current selection @b won't be modified by prepending
    * an element to the list.
    *
    * @note The maximum length of the text label is going to be
    * determined <b>by the widget's theme</b>. Strings larger than
    * that value are going to be @b truncated.
    *
    * @ingroup Flipselector
    */
   EAPI Elm_Flipselector_Item     *elm_flipselector_item_prepend(Evas_Object *obj, const char *label, Evas_Smart_Cb func, void *data) EINA_ARG_NONNULL(1);

   /**
    * Get the internal list of items in a given flip selector widget.
    *
    * @param obj The flipselector object
    * @return The list of items (#Elm_Flipselector_Item as data) or @c
    * NULL on errors.
    *
    * This list is @b not to be modified in any way and must not be
    * freed. Use the list members with functions like
    * elm_flipselector_item_label_set(),
    * elm_flipselector_item_label_get(), elm_flipselector_item_del(),
    * elm_flipselector_item_del(),
    * elm_flipselector_item_selected_get(),
    * elm_flipselector_item_selected_set().
    *
    * @warning This list is only valid until @p obj object's internal
    * items list is changed. It should be fetched again with another
    * call to this function when changes happen.
    *
    * @ingroup Flipselector
    */
   EAPI const Eina_List           *elm_flipselector_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the first item in the given flip selector widget's list of
    * items.
    *
    * @param obj The flipselector object
    * @return The first item or @c NULL, if it has no items (and on
    * errors)
    *
    * @see elm_flipselector_item_append()
    * @see elm_flipselector_last_item_get()
    *
    * @ingroup Flipselector
    */
   EAPI Elm_Flipselector_Item     *elm_flipselector_first_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the last item in the given flip selector widget's list of
    * items.
    *
    * @param obj The flipselector object
    * @return The last item or @c NULL, if it has no items (and on
    * errors)
    *
    * @see elm_flipselector_item_prepend()
    * @see elm_flipselector_first_item_get()
    *
    * @ingroup Flipselector
    */
   EAPI Elm_Flipselector_Item     *elm_flipselector_last_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the currently selected item in a flip selector widget.
    *
    * @param obj The flipselector object
    * @return The selected item or @c NULL, if the widget has no items
    * (and on erros)
    *
    * @ingroup Flipselector
    */
   EAPI Elm_Flipselector_Item     *elm_flipselector_selected_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set whether a given flip selector widget's item should be the
    * currently selected one.
    *
    * @param item The flip selector item
    * @param selected @c EINA_TRUE to select it, @c EINA_FALSE to unselect.
    *
    * This sets whether @p item is or not the selected (thus, under
    * display) one. If @p item is different than one under display,
    * the latter will be unselected. If the @p item is set to be
    * unselected, on the other hand, the @b first item in the widget's
    * internal members list will be the new selected one.
    *
    * @see elm_flipselector_item_selected_get()
    *
    * @ingroup Flipselector
    */
   EAPI void                       elm_flipselector_item_selected_set(Elm_Flipselector_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);

   /**
    * Get whether a given flip selector widget's item is the currently
    * selected one.
    *
    * @param item The flip selector item
    * @return @c EINA_TRUE, if it's selected, @c EINA_FALSE otherwise
    * (or on errors).
    *
    * @see elm_flipselector_item_selected_set()
    *
    * @ingroup Flipselector
    */
   EAPI Eina_Bool                  elm_flipselector_item_selected_get(const Elm_Flipselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Delete a given item from a flip selector widget.
    *
    * @param item The item to delete
    *
    * @ingroup Flipselector
    */
   EAPI void                       elm_flipselector_item_del(Elm_Flipselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Get the label of a given flip selector widget's item.
    *
    * @param item The item to get label from
    * @return The text label of @p item or @c NULL, on errors
    *
    * @see elm_flipselector_item_label_set()
    *
    * @ingroup Flipselector
    */
   EAPI const char                *elm_flipselector_item_label_get(const Elm_Flipselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the label of a given flip selector widget's item.
    *
    * @param item The item to set label on
    * @param label The text label string, in UTF-8 encoding
    *
    * @see elm_flipselector_item_label_get()
    *
    * @ingroup Flipselector
    */
   EAPI void                       elm_flipselector_item_label_set(Elm_Flipselector_Item *item, const char *label) EINA_ARG_NONNULL(1);

   /**
    * Gets the item before @p item in a flip selector widget's
    * internal list of items.
    *
    * @param item The item to fetch previous from
    * @return The item before the @p item, in its parent's list. If
    *         there is no previous item for @p item or there's an
    *         error, @c NULL is returned.
    *
    * @see elm_flipselector_item_next_get()
    *
    * @ingroup Flipselector
    */
   EAPI Elm_Flipselector_Item     *elm_flipselector_item_prev_get(Elm_Flipselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Gets the item after @p item in a flip selector widget's
    * internal list of items.
    *
    * @param item The item to fetch next from
    * @return The item after the @p item, in its parent's list. If
    *         there is no next item for @p item or there's an
    *         error, @c NULL is returned.
    *
    * @see elm_flipselector_item_next_get()
    *
    * @ingroup Flipselector
    */
   EAPI Elm_Flipselector_Item     *elm_flipselector_item_next_get(Elm_Flipselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the interval on time updates for an user mouse button hold
    * on a flip selector widget.
    *
    * @param obj The flip selector object
    * @param interval The (first) interval value in seconds
    *
    * This interval value is @b decreased while the user holds the
    * mouse pointer either flipping up or flipping doww a given flip
    * selector.
    *
    * This helps the user to get to a given item distant from the
    * current one easier/faster, as it will start to flip quicker and
    * quicker on mouse button holds.
    *
    * The calculation for the next flip interval value, starting from
    * the one set with this call, is the previous interval divided by
    * 1.05, so it decreases a little bit.
    *
    * The default starting interval value for automatic flips is
    * @b 0.85 seconds.
    *
    * @see elm_flipselector_interval_get()
    *
    * @ingroup Flipselector
    */
   EAPI void                       elm_flipselector_interval_set(Evas_Object *obj, double interval) EINA_ARG_NONNULL(1);

   /**
    * Get the interval on time updates for an user mouse button hold
    * on a flip selector widget.
    *
    * @param obj The flip selector object
    * @return The (first) interval value, in seconds, set on it
    *
    * @see elm_flipselector_interval_set() for more details
    *
    * @ingroup Flipselector
    */
   EAPI double                     elm_flipselector_interval_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

   /**
    * @addtogroup Animator Animator
    * @ingroup Elementary
    *
    * @brief Functions to ease creation of animations.
    *
    * elm_animator is designed to provide an easy way to create animations.
    * Creating an animation with elm_animator is as simple as setting a
    * duration, an operating callback and telling it to run the animation.
    * However that is not the full extent of elm_animator's ability, animations
    * can be paused and resumed, reversed and the animation need not be linear.
    *
    * To run an animation you must specify at least a duration and operation
    * callback, not setting any other properties will create a linear animation
    * that runs once and is not reversed.
    *
    * @ref elm_animator_example_page_01 "This" example should make all of that
    * very clear.
    *
    * @warning elm_animator is @b not a widget.
    * @{
    */
   /**
    * @brief Type of curve desired for animation.
    *
    * The speed in which an animation happens doesn't have to be linear, some
    * animations will look better if they're accelerating or decelerating, so
    * elm_animator provides four options in this regard:
    *
    * @image html elm_animator_curve_style.png
    * @image latex elm_animator_curve_style.eps width=\textwidth
    * As can be seen in the image the speed of the animation will be:
    * @li ELM_ANIMATOR_CURVE_LINEAR constant
    * @li ELM_ANIMATOR_CURVE_IN_OUT start slow, speed up and then slow down
    * @li ELM_ANIMATOR_CURVE_IN start slow and then speed up
    * @li ELM_ANIMATOR_CURVE_OUT start fast and then slow down
    */
   typedef enum
     {
        ELM_ANIMATOR_CURVE_LINEAR,
        ELM_ANIMATOR_CURVE_IN_OUT,
        ELM_ANIMATOR_CURVE_IN,
        ELM_ANIMATOR_CURVE_OUT
     } Elm_Animator_Curve_Style;
   typedef struct _Elm_Animator Elm_Animator;
  /**
   * Called back per loop of an elementary animators cycle
   * @param data user-data given to elm_animator_operation_callback_set()
   * @param animator the animator being run
   * @param double the position in the animation
   */
   typedef void (*Elm_Animator_Operation_Cb) (void *data, Elm_Animator *animator, double frame);
  /**
   * Called back when an elementary animator finishes
   * @param data user-data given to elm_animator_completion_callback_set()
   */
   typedef void (*Elm_Animator_Completion_Cb) (void *data);

   /**
    * @brief Create a new animator.
    *
    * @param[in] parent Parent object
    *
    * The @a parent argument can be set to NULL for no parent. If a parent is set
    * there is no need to call elm_animator_del(), when the parent is deleted it
    * will delete the animator.
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI Elm_Animator*            elm_animator_add(Evas_Object *parent);
   /**
    * Deletes the animator freeing any resources it used. If the animator was
    * created with a NULL parent this must be called, otherwise it will be
    * automatically called when the parent is deleted.
    *
    * @param[in] animator Animator object
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_del(Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * Set the duration of the animation.
    *
    * @param[in] animator Animator object
    * @param[in] duration Duration in second
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_duration_set(Elm_Animator *animator, double duration) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the callback function for animator operation.
    *
    * @param[in] animator Animator object
    * @param[in] func @ref Elm_Animator_Operation_Cb "Callback" function pointer
    * @param[in] data Callback function user argument
    *
    * The @p func callback will be called with a frame value in range [0, 1] which
    * indicates how far along the animation should be. It is the job of @p func to
    * actually change the state of any object(or objects) that are being animated.
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_operation_callback_set(Elm_Animator *animator, Elm_Animator_Operation_Cb func, void *data) EINA_ARG_NONNULL(1);
   /**
    * Set the callback function for the when the animation ends.
    *
    * @param[in]  animator Animator object
    * @param[in]  func   Callback function pointe
    * @param[in]  data Callback function user argument
    *
    * @warning @a func will not be executed if elm_animator_stop() is called.
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_completion_callback_set(Elm_Animator *animator, Elm_Animator_Completion_Cb func, void *data) EINA_ARG_NONNULL(1);
   /**
    * @brief Stop animator.
    *
    * @param[in] animator Animator object
    *
    * If called before elm_animator_animate() it does nothing. If there is an
    * animation in progress the animation will be stopped(the operation callback
    * will not be executed again) and it can't be restarted using
    * elm_animator_resume().
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_stop(Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * Set the animator repeat count.
    *
    * @param[in]  animator Animator object
    * @param[in]  repeat_cnt Repeat count
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_repeat_set(Elm_Animator *animator, unsigned int repeat_cnt) EINA_ARG_NONNULL(1);
   /**
    * @brief Start animation.
    *
    * @param[in] animator Animator object
    *
    * This function starts the animation if the nescessary properties(duration
    * and operation callback) have been set. Once started the animation will
    * run until complete or elm_animator_stop() is called.
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_animate(Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * Sets the animation @ref Elm_Animator_Curve_Style "acceleration style".
    *
    * @param[in] animator Animator object
    * @param[in] cs Curve style. Default is ELM_ANIMATOR_CURVE_LINEAR
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_curve_style_set(Elm_Animator *animator, Elm_Animator_Curve_Style cs) EINA_ARG_NONNULL(1);
   /**
    * Gets the animation @ref Elm_Animator_Curve_Style "acceleration style".
    *
    * @param[in] animator Animator object
    * @param[in] cs Curve style. Default is ELM_ANIMATOR_CURVE_LINEAR
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI Elm_Animator_Curve_Style elm_animator_curve_style_get(const Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * @brief Sets wether the animation should be automatically reversed.
    *
    * @param[in] animator Animator object
    * @param[in] reverse Reverse or not
    *
    * This controls wether the animation will be run on reverse imediately after
    * running forward. When this is set together with repetition the animation
    * will run in reverse once for each time it ran forward.@n
    * Runnin an animation in reverse is accomplished by calling the operation
    * callback with a frame value starting at 1 and diminshing until 0.
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_auto_reverse_set(Elm_Animator *animator, Eina_Bool reverse) EINA_ARG_NONNULL(1);
   /**
    * Gets wether the animation will automatically reversed
    *
    * @param[in] animator Animator object
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI Eina_Bool                elm_animator_auto_reverse_get(const Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * Gets the status for the animator operation. The status of the animator @b
    * doesn't take in to account elm_animator_pause() or elm_animator_resume(), it
    * only informs if the animation was started and has not ended(either normally
    * or through elm_animator_stop()).
    *
    * @param[in] animator Animator object
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI Eina_Bool                elm_animator_operating_get(const Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * Gets how many times the animation will be repeated
    *
    * @param[in] animator Animator object
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI unsigned int             elm_animator_repeat_get(const Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * Pause the animator.
    *
    * @param[in]  animator Animator object
    *
    * This causes the animation to be temporarily stopped(the operation callback
    * will not be called). If the animation is not yet running this is a no-op.
    * Once an animation has been paused with this function it can be resumed
    * using elm_animator_resume().
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_pause(Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * @brief Resumes the animator.
    *
    * @param[in]  animator Animator object
    *
    * Resumes an animation that was paused using elm_animator_pause(), after
    * calling this function calls to the operation callback will happen
    * normally. If an animation is stopped by means of elm_animator_stop it
    * @b can't be restarted with this function.@n
    *
    * @warning When an animation is resumed it doesn't start from where it was paused, it
    * will go to where it would have been if it had not been paused. If an
    * animation with a duration of 3 seconds is paused after 1 second for 1 second
    * it will resume as if it had ben animating for 2 seconds, the operating
    * callback will be called with a frame value of aproximately 2/3.
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_resume(Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /**
    * @defgroup Calendar Calendar
    * @ingroup Elementary
    *
    * @image html img/widget/calendar/preview-00.png
    * @image latex img/widget/calendar/preview-00.eps
    *
    * A calendar is a widget that displays a regular calendar, one
    * month at a time, to the user, and can allows the user to select a date.
    *
    * It has support to adding check marks (holidays and checks are supported
    * by default theme).
    *
    * Weekday names and the function used to format month and year to
    * be displayed can be set, giving more flexibility to this widget.
    *
    * Smart callbacks one can register to:
    * - "changed" - emitted when the user selects a day or changes the
    *   displayed month, what actually changes the selected day as well.
    *
    * Available styles for it:
    * - @c "default"
    *
    * List of examples:
    * @li @ref calendar_example_01
    * @li @ref calendar_example_02
    * @li @ref calendar_example_03
    * @li @ref calendar_example_04
    * @li @ref calendar_example_05
    * @li @ref calendar_example_06
    */

   /**
    * @addtogroup Calendar
    * @{
    */

   /**
    * @enum _Elm_Calendar_Mark_Repeat
    * @typedef Elm_Calendar_Mark_Repeat
    *
    * Event periodicity, used to define if a mark should be repeated
    * @b beyond event's day. It's set when a mark is added.
    *
    * So, for a mark added to 13th May with periodicity set to WEEKLY,
    * there will be marks every week after this date. Marks will be displayed
    * at 13th, 20th, 27th, 3rd June ...
    *
    * Values don't work as bitmaks, only one can be choosen.
    *
    * @see elm_calendar_mark_add()
    *
    * @ingroup Calendar
    */
   typedef enum _Elm_Calendar_Mark_Repeat
     {
        ELM_CALENDAR_UNIQUE, /**< Default value. Marks will be displayed only on event day. */
        ELM_CALENDAR_DAILY, /**< Marks will be displayed everyday after event day (inclusive). */
        ELM_CALENDAR_WEEKLY, /**< Marks will be displayed every week after event day (inclusive) - i.e. each seven days. */
        ELM_CALENDAR_MONTHLY, /**< Marks will be displayed every month day that coincides to event day. E.g.: if an event is set to 30th Jan, no marks will be displayed on Feb, but will be displayed on 30th Mar*/
        ELM_CALENDAR_ANNUALLY /**< Marks will be displayed every year that coincides to event day (and month). E.g. an event added to 30th Jan 2012 will be repeated on 30th Jan 2013. */
     } Elm_Calendar_Mark_Repeat;

   typedef struct _Elm_Calendar_Mark Elm_Calendar_Mark; /**< Item handle for a calendar mark. Created with elm_calendar_mark_add() and deleted with elm_calendar_mark_del(). */

   /**
    * Add a new calendar widget to the given parent Elementary
    * (container) object.
    *
    * @param parent The parent object.
    * @return a new calendar widget handle or @c NULL, on errors.
    *
    * This function inserts a new calendar widget on the canvas.
    *
    * @ref calendar_example_01
    *
    * @ingroup Calendar
    */
   EAPI Evas_Object       *elm_calendar_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Get weekdays names displayed by the calendar.
    *
    * @param obj The calendar object.
    * @return Array of seven strings to be used as weekday names.
    *
    * By default, weekdays abbreviations get from system are displayed:
    * E.g. for an en_US locale: "Sun, Mon, Tue, Wed, Thu, Fri, Sat"
    * The first string is related to Sunday, the second to Monday...
    *
    * @see elm_calendar_weekdays_name_set()
    *
    * @ref calendar_example_05
    *
    * @ingroup Calendar
    */
   EAPI const char       **elm_calendar_weekdays_names_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set weekdays names to be displayed by the calendar.
    *
    * @param obj The calendar object.
    * @param weedays Array of seven strings to be used as weekday names.
    * @warning It must have 7 elements, or it will access invalid memory.
    * @warning The strings must be NULL terminated ('@\0').
    *
    * By default, weekdays abbreviations get from system are displayed:
    * E.g. for an en_US locale: "Sun, Mon, Tue, Wed, Thu, Fri, Sat"
    *
    * The first string should be related to Sunday, the second to Monday...
    *
    * The usage should be like this:
    * @code
    *   const char *weekdays[] =
    *   {
    *      "Sunday", "Monday", "Tuesday", "Wednesday",
    *      "Thursday", "Friday", "Saturday"
    *   };
    *   elm_calendar_weekdays_names_set(calendar, weekdays);
    * @endcode
    *
    * @see elm_calendar_weekdays_name_get()
    *
    * @ref calendar_example_02
    *
    * @ingroup Calendar
    */
   EAPI void               elm_calendar_weekdays_names_set(Evas_Object *obj, const char *weekdays[]) EINA_ARG_NONNULL(1, 2);

   /**
    * Set the minimum and maximum values for the year
    *
    * @param obj The calendar object
    * @param min The minimum year, greater than 1901;
    * @param max The maximum year;
    *
    * Maximum must be greater than minimum, except if you don't wan't to set
    * maximum year.
    * Default values are 1902 and -1.
    *
    * If the maximum year is a negative value, it will be limited depending
    * on the platform architecture (year 2037 for 32 bits);
    *
    * @see elm_calendar_min_max_year_get()
    *
    * @ref calendar_example_03
    *
    * @ingroup Calendar
    */
   EAPI void               elm_calendar_min_max_year_set(Evas_Object *obj, int min, int max) EINA_ARG_NONNULL(1);

   /**
    * Get the minimum and maximum values for the year
    *
    * @param obj The calendar object.
    * @param min The minimum year.
    * @param max The maximum year.
    *
    * Default values are 1902 and -1.
    *
    * @see elm_calendar_min_max_year_get() for more details.
    *
    * @ref calendar_example_05
    *
    * @ingroup Calendar
    */
   EAPI void               elm_calendar_min_max_year_get(const Evas_Object *obj, int *min, int *max) EINA_ARG_NONNULL(1);

   /**
    * Enable or disable day selection
    *
    * @param obj The calendar object.
    * @param enabled @c EINA_TRUE to enable selection or @c EINA_FALSE to
    * disable it.
    *
    * Enabled by default. If disabled, the user still can select months,
    * but not days. Selected days are highlighted on calendar.
    * It should be used if you won't need such selection for the widget usage.
    *
    * When a day is selected, or month is changed, smart callbacks for
    * signal "changed" will be called.
    *
    * @see elm_calendar_day_selection_enable_get()
    *
    * @ref calendar_example_04
    *
    * @ingroup Calendar
    */
   EAPI void               elm_calendar_day_selection_enabled_set(Evas_Object *obj, Eina_Bool enabled) EINA_ARG_NONNULL(1);

   /**
    * Get a value whether day selection is enabled or not.
    *
    * @see elm_calendar_day_selection_enable_set() for details.
    *
    * @param obj The calendar object.
    * @return EINA_TRUE means day selection is enabled. EINA_FALSE indicates
    * it's disabled. If @p obj is NULL, EINA_FALSE is returned.
    *
    * @ref calendar_example_05
    *
    * @ingroup Calendar
    */
   EAPI Eina_Bool          elm_calendar_day_selection_enabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);


   /**
    * Set selected date to be highlighted on calendar.
    *
    * @param obj The calendar object.
    * @param selected_time A @b tm struct to represent the selected date.
    *
    * Set the selected date, changing the displayed month if needed.
    * Selected date changes when the user goes to next/previous month or
    * select a day pressing over it on calendar.
    *
    * @see elm_calendar_selected_time_get()
    *
    * @ref calendar_example_04
    *
    * @ingroup Calendar
    */
   EAPI void               elm_calendar_selected_time_set(Evas_Object *obj, struct tm *selected_time) EINA_ARG_NONNULL(1);

   /**
    * Get selected date.
    *
    * @param obj The calendar object
    * @param selected_time A @b tm struct to point to selected date
    * @return EINA_FALSE means an error ocurred and returned time shouldn't
    * be considered.
    *
    * Get date selected by the user or set by function
    * elm_calendar_selected_time_set().
    * Selected date changes when the user goes to next/previous month or
    * select a day pressing over it on calendar.
    *
    * @see elm_calendar_selected_time_get()
    *
    * @ref calendar_example_05
    *
    * @ingroup Calendar
    */
   EAPI Eina_Bool          elm_calendar_selected_time_get(const Evas_Object *obj, struct tm *selected_time) EINA_ARG_NONNULL(1, 2);

   /**
    * Set a function to format the string that will be used to display
    * month and year;
    *
    * @param obj The calendar object
    * @param format_function Function to set the month-year string given
    * the selected date
    *
    * By default it uses strftime with "%B %Y" format string.
    * It should allocate the memory that will be used by the string,
    * that will be freed by the widget after usage.
    * A pointer to the string and a pointer to the time struct will be provided.
    *
    * Example:
    * @code
    * static char *
    * _format_month_year(struct tm *selected_time)
    * {
    *    char buf[32];
    *    if (!strftime(buf, sizeof(buf), "%B %Y", selected_time)) return NULL;
    *    return strdup(buf);
    * }
    *
    * elm_calendar_format_function_set(calendar, _format_month_year);
    * @endcode
    *
    * @ref calendar_example_02
    *
    * @ingroup Calendar
    */
   EAPI void               elm_calendar_format_function_set(Evas_Object *obj, char * (*format_function) (struct tm *stime)) EINA_ARG_NONNULL(1);

   /**
    * Add a new mark to the calendar
    *
    * @param obj The calendar object
    * @param mark_type A string used to define the type of mark. It will be
    * emitted to the theme, that should display a related modification on these
    * days representation.
    * @param mark_time A time struct to represent the date of inclusion of the
    * mark. For marks that repeats it will just be displayed after the inclusion
    * date in the calendar.
    * @param repeat Repeat the event following this periodicity. Can be a unique
    * mark (that don't repeat), daily, weekly, monthly or annually.
    * @return The created mark or @NULL upon failure.
    *
    * Add a mark that will be drawn in the calendar respecting the insertion
    * time and periodicity. It will emit the type as signal to the widget theme.
    * Default theme supports "holiday" and "checked", but it can be extended.
    *
    * It won't immediately update the calendar, drawing the marks.
    * For this, call elm_calendar_marks_draw(). However, when user selects
    * next or previous month calendar forces marks drawn.
    *
    * Marks created with this method can be deleted with
    * elm_calendar_mark_del().
    *
    * Example
    * @code
    * struct tm selected_time;
    * time_t current_time;
    *
    * current_time = time(NULL) + 5 * 84600;
    * localtime_r(&current_time, &selected_time);
    * elm_calendar_mark_add(cal, "holiday", selected_time,
    *     ELM_CALENDAR_ANNUALLY);
    *
    * current_time = time(NULL) + 1 * 84600;
    * localtime_r(&current_time, &selected_time);
    * elm_calendar_mark_add(cal, "checked", selected_time, ELM_CALENDAR_UNIQUE);
    *
    * elm_calendar_marks_draw(cal);
    * @endcode
    *
    * @see elm_calendar_marks_draw()
    * @see elm_calendar_mark_del()
    *
    * @ref calendar_example_06
    *
    * @ingroup Calendar
    */
   EAPI Elm_Calendar_Mark *elm_calendar_mark_add(Evas_Object *obj, const char *mark_type, struct tm *mark_time, Elm_Calendar_Mark_Repeat repeat) EINA_ARG_NONNULL(1);

   /**
    * Delete mark from the calendar.
    *
    * @param mark The mark to be deleted.
    *
    * If deleting all calendar marks is required, elm_calendar_marks_clear()
    * should be used instead of getting marks list and deleting each one.
    *
    * @see elm_calendar_mark_add()
    *
    * @ref calendar_example_06
    *
    * @ingroup Calendar
    */
   EAPI void               elm_calendar_mark_del(Elm_Calendar_Mark *mark) EINA_ARG_NONNULL(1);

   /**
    * Remove all calendar's marks
    *
    * @param obj The calendar object.
    *
    * @see elm_calendar_mark_add()
    * @see elm_calendar_mark_del()
    *
    * @ingroup Calendar
    */
   EAPI void               elm_calendar_marks_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);


   /**
    * Get a list of all the calendar marks.
    *
    * @param obj The calendar object.
    * @return An @c Eina_List of calendar marks objects, or @c NULL on failure.
    *
    * @see elm_calendar_mark_add()
    * @see elm_calendar_mark_del()
    * @see elm_calendar_marks_clear()
    *
    * @ingroup Calendar
    */
   EAPI const Eina_List   *elm_calendar_marks_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Draw calendar marks.
    *
    * @param obj The calendar object.
    *
    * Should be used after adding, removing or clearing marks.
    * It will go through the entire marks list updating the calendar.
    * If lots of marks will be added, add all the marks and then call
    * this function.
    *
    * When the month is changed, i.e. user selects next or previous month,
    * marks will be drawed.
    *
    * @see elm_calendar_mark_add()
    * @see elm_calendar_mark_del()
    * @see elm_calendar_marks_clear()
    *
    * @ref calendar_example_06
    *
    * @ingroup Calendar
    */
   EAPI void               elm_calendar_marks_draw(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set a day text color to the same that represents Saturdays.
    *
    * @param obj The calendar object.
    * @param pos The text position. Position is the cell counter, from left
    * to right, up to down. It starts on 0 and ends on 41.
    *
    * @deprecated use elm_calendar_mark_add() instead like:
    *
    * @code
    * struct tm t = { 0, 0, 12, 6, 0, 0, 6, 6, -1 };
    * elm_calendar_mark_add(obj, "sat", &t, ELM_CALENDAR_WEEKLY);
    * @endcode
    *
    * @see elm_calendar_mark_add()
    *
    * @ingroup Calendar
    */
   EINA_DEPRECATED EAPI void               elm_calendar_text_saturday_color_set(Evas_Object *obj, int pos) EINA_ARG_NONNULL(1);

   /**
    * Set a day text color to the same that represents Sundays.
    *
    * @param obj The calendar object.
    * @param pos The text position. Position is the cell counter, from left
    * to right, up to down. It starts on 0 and ends on 41.

    * @deprecated use elm_calendar_mark_add() instead like:
    *
    * @code
    * struct tm t = { 0, 0, 12, 7, 0, 0, 0, 0, -1 };
    * elm_calendar_mark_add(obj, "sat", &t, ELM_CALENDAR_WEEKLY);
    * @endcode
    *
    * @see elm_calendar_mark_add()
    *
    * @ingroup Calendar
    */
   EINA_DEPRECATED EAPI void               elm_calendar_text_sunday_color_set(Evas_Object *obj, int pos) EINA_ARG_NONNULL(1);

   /**
    * Set a day text color to the same that represents Weekdays.
    *
    * @param obj The calendar object
    * @param pos The text position. Position is the cell counter, from left
    * to right, up to down. It starts on 0 and ends on 41.
    *
    * @deprecated use elm_calendar_mark_add() instead like:
    *
    * @code
    * struct tm t = { 0, 0, 12, 1, 0, 0, 0, 0, -1 };
    *
    * elm_calendar_mark_add(obj, "week", &t, ELM_CALENDAR_WEEKLY); // monday
    * t.tm_tm_mday++; t.tm_wday++; t.tm_yday++;
    * elm_calendar_mark_add(obj, "week", &t, ELM_CALENDAR_WEEKLY); // tuesday
    * t.tm_tm_mday++; t.tm_wday++; t.tm_yday++;
    * elm_calendar_mark_add(obj, "week", &t, ELM_CALENDAR_WEEKLY); // wednesday
    * t.tm_tm_mday++; t.tm_wday++; t.tm_yday++;
    * elm_calendar_mark_add(obj, "week", &t, ELM_CALENDAR_WEEKLY); // thursday
    * t.tm_tm_mday++; t.tm_wday++; t.tm_yday++;
    * elm_calendar_mark_add(obj, "week", &t, ELM_CALENDAR_WEEKLY); // friday
    * @endcode
    *
    * @see elm_calendar_mark_add()
    *
    * @ingroup Calendar
    */
   EINA_DEPRECATED EAPI void               elm_calendar_text_weekday_color_set(Evas_Object *obj, int pos) EINA_ARG_NONNULL(1);

   /**
    * Set the interval on time updates for an user mouse button hold
    * on calendar widgets' month selection.
    *
    * @param obj The calendar object
    * @param interval The (first) interval value in seconds
    *
    * This interval value is @b decreased while the user holds the
    * mouse pointer either selecting next or previous month.
    *
    * This helps the user to get to a given month distant from the
    * current one easier/faster, as it will start to change quicker and
    * quicker on mouse button holds.
    *
    * The calculation for the next change interval value, starting from
    * the one set with this call, is the previous interval divided by
    * 1.05, so it decreases a little bit.
    *
    * The default starting interval value for automatic changes is
    * @b 0.85 seconds.
    *
    * @see elm_calendar_interval_get()
    *
    * @ingroup Calendar
    */
   EAPI void               elm_calendar_interval_set(Evas_Object *obj, double interval) EINA_ARG_NONNULL(1);

   /**
    * Get the interval on time updates for an user mouse button hold
    * on calendar widgets' month selection.
    *
    * @param obj The calendar object
    * @return The (first) interval value, in seconds, set on it
    *
    * @see elm_calendar_interval_set() for more details
    *
    * @ingroup Calendar
    */
   EAPI double             elm_calendar_interval_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

   /**
    * @defgroup Diskselector Diskselector
    * @ingroup Elementary
    *
    * @image html img/widget/diskselector/preview-00.png
    * @image latex img/widget/diskselector/preview-00.eps
    *
    * A diskselector is a kind of list widget. It scrolls horizontally,
    * and can contain label and icon objects. Three items are displayed
    * with the selected one in the middle.
    *
    * It can act like a circular list with round mode and labels can be
    * reduced for a defined length for side items.
    *
    * Smart callbacks one can listen to:
    * - "selected" - when item is selected, i.e. scroller stops.
    *
    * Available styles for it:
    * - @c "default"
    *
    * List of examples:
    * @li @ref diskselector_example_01
    * @li @ref diskselector_example_02
    */

   /**
    * @addtogroup Diskselector
    * @{
    */

   typedef struct _Elm_Diskselector_Item Elm_Diskselector_Item; /**< Item handle for a diskselector item. Created with elm_diskselector_item_append() and deleted with elm_diskselector_item_del(). */

   /**
    * Add a new diskselector widget to the given parent Elementary
    * (container) object.
    *
    * @param parent The parent object.
    * @return a new diskselector widget handle or @c NULL, on errors.
    *
    * This function inserts a new diskselector widget on the canvas.
    *
    * @ingroup Diskselector
    */
   EAPI Evas_Object           *elm_diskselector_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Enable or disable round mode.
    *
    * @param obj The diskselector object.
    * @param round @c EINA_TRUE to enable round mode or @c EINA_FALSE to
    * disable it.
    *
    * Disabled by default. If round mode is enabled the items list will
    * work like a circle list, so when the user reaches the last item,
    * the first one will popup.
    *
    * @see elm_diskselector_round_get()
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_round_set(Evas_Object *obj, Eina_Bool round) EINA_ARG_NONNULL(1);

   /**
    * Get a value whether round mode is enabled or not.
    *
    * @see elm_diskselector_round_set() for details.
    *
    * @param obj The diskselector object.
    * @return @c EINA_TRUE means round mode is enabled. @c EINA_FALSE indicates
    * it's disabled. If @p obj is @c NULL, @c EINA_FALSE is returned.
    *
    * @ingroup Diskselector
    */
   EAPI Eina_Bool              elm_diskselector_round_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the side labels max length.
    *
    * @deprecated use elm_diskselector_side_label_length_get() instead:
    *
    * @param obj The diskselector object.
    * @return The max length defined for side labels, or 0 if not a valid
    * diskselector.
    *
    * @ingroup Diskselector
    */
   EINA_DEPRECATED EAPI int    elm_diskselector_side_label_lenght_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the side labels max length.
    *
    * @deprecated use elm_diskselector_side_label_length_set() instead:
    *
    * @param obj The diskselector object.
    * @param len The max length defined for side labels.
    *
    * @ingroup Diskselector
    */
   EINA_DEPRECATED EAPI void   elm_diskselector_side_label_lenght_set(Evas_Object *obj, int len) EINA_ARG_NONNULL(1);

   /**
    * Get the side labels max length.
    *
    * @see elm_diskselector_side_label_length_set() for details.
    *
    * @param obj The diskselector object.
    * @return The max length defined for side labels, or 0 if not a valid
    * diskselector.
    *
    * @ingroup Diskselector
    */
   EAPI int                    elm_diskselector_side_label_length_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the side labels max length.
    *
    * @param obj The diskselector object.
    * @param len The max length defined for side labels.
    *
    * Length is the number of characters of items' label that will be
    * visible when it's set on side positions. It will just crop
    * the string after defined size. E.g.:
    *
    * An item with label "January" would be displayed on side position as
    * "Jan" if max length is set to 3, or "Janu", if this property
    * is set to 4.
    *
    * When it's selected, the entire label will be displayed, except for
    * width restrictions. In this case label will be cropped and "..."
    * will be concatenated.
    *
    * Default side label max length is 3.
    *
    * This property will be applyed over all items, included before or
    * later this function call.
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_side_label_length_set(Evas_Object *obj, int len) EINA_ARG_NONNULL(1);

   /**
    * Set the number of items to be displayed.
    *
    * @param obj The diskselector object.
    * @param num The number of items the diskselector will display.
    *
    * Default value is 3, and also it's the minimun. If @p num is less
    * than 3, it will be set to 3.
    *
    * Also, it can be set on theme, using data item @c display_item_num
    * on group "elm/diskselector/item/X", where X is style set.
    * E.g.:
    *
    * group { name: "elm/diskselector/item/X";
    * data {
    *     item: "display_item_num" "5";
    *     }
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_display_item_num_set(Evas_Object *obj, int num) EINA_ARG_NONNULL(1);

   /**
    * Set bouncing behaviour when the scrolled content reaches an edge.
    *
    * Tell the internal scroller object whether it should bounce or not
    * when it reaches the respective edges for each axis.
    *
    * @param obj The diskselector object.
    * @param h_bounce Whether to bounce or not in the horizontal axis.
    * @param v_bounce Whether to bounce or not in the vertical axis.
    *
    * @see elm_scroller_bounce_set()
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);

   /**
    * Get the bouncing behaviour of the internal scroller.
    *
    * Get whether the internal scroller should bounce when the edge of each
    * axis is reached scrolling.
    *
    * @param obj The diskselector object.
    * @param h_bounce Pointer where to store the bounce state of the horizontal
    * axis.
    * @param v_bounce Pointer where to store the bounce state of the vertical
    * axis.
    *
    * @see elm_scroller_bounce_get()
    * @see elm_diskselector_bounce_set()
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);

   /**
    * Get the scrollbar policy.
    *
    * @see elm_diskselector_scroller_policy_get() for details.
    *
    * @param obj The diskselector object.
    * @param policy_h Pointer where to store horizontal scrollbar policy.
    * @param policy_v Pointer where to store vertical scrollbar policy.
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_scroller_policy_get(const Evas_Object *obj, Elm_Scroller_Policy *policy_h, Elm_Scroller_Policy *policy_v) EINA_ARG_NONNULL(1);

   /**
    * Set the scrollbar policy.
    *
    * @param obj The diskselector object.
    * @param policy_h Horizontal scrollbar policy.
    * @param policy_v Vertical scrollbar policy.
    *
    * This sets the scrollbar visibility policy for the given scroller.
    * #ELM_SCROLLER_POLICY_AUTO means the scrollber is made visible if it
    * is needed, and otherwise kept hidden. #ELM_SCROLLER_POLICY_ON turns
    * it on all the time, and #ELM_SCROLLER_POLICY_OFF always keeps it off.
    * This applies respectively for the horizontal and vertical scrollbars.
    *
    * The both are disabled by default, i.e., are set to
    * #ELM_SCROLLER_POLICY_OFF.
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_scroller_policy_set(Evas_Object *obj, Elm_Scroller_Policy policy_h, Elm_Scroller_Policy policy_v) EINA_ARG_NONNULL(1);

   /**
    * Remove all diskselector's items.
    *
    * @param obj The diskselector object.
    *
    * @see elm_diskselector_item_del()
    * @see elm_diskselector_item_append()
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get a list of all the diskselector items.
    *
    * @param obj The diskselector object.
    * @return An @c Eina_List of diskselector items, #Elm_Diskselector_Item,
    * or @c NULL on failure.
    *
    * @see elm_diskselector_item_append()
    * @see elm_diskselector_item_del()
    * @see elm_diskselector_clear()
    *
    * @ingroup Diskselector
    */
   EAPI const Eina_List       *elm_diskselector_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Appends a new item to the diskselector object.
    *
    * @param obj The diskselector object.
    * @param label The label of the diskselector item.
    * @param icon The icon object to use at left side of the item. An
    * icon can be any Evas object, but usually it is an icon created
    * with elm_icon_add().
    * @param func The function to call when the item is selected.
    * @param data The data to associate with the item for related callbacks.
    *
    * @return The created item or @c NULL upon failure.
    *
    * A new item will be created and appended to the diskselector, i.e., will
    * be set as last item. Also, if there is no selected item, it will
    * be selected. This will always happens for the first appended item.
    *
    * If no icon is set, label will be centered on item position, otherwise
    * the icon will be placed at left of the label, that will be shifted
    * to the right.
    *
    * Items created with this method can be deleted with
    * elm_diskselector_item_del().
    *
    * Associated @p data can be properly freed when item is deleted if a
    * callback function is set with elm_diskselector_item_del_cb_set().
    *
    * If a function is passed as argument, it will be called everytime this item
    * is selected, i.e., the user stops the diskselector with this
    * item on center position. If such function isn't needed, just passing
    * @c NULL as @p func is enough. The same should be done for @p data.
    *
    * Simple example (with no function callback or data associated):
    * @code
    * disk = elm_diskselector_add(win);
    * ic = elm_icon_add(win);
    * elm_icon_file_set(ic, "path/to/image", NULL);
    * elm_icon_scale_set(ic, EINA_TRUE, EINA_TRUE);
    * elm_diskselector_item_append(disk, "label", ic, NULL, NULL);
    * @endcode
    *
    * @see elm_diskselector_item_del()
    * @see elm_diskselector_item_del_cb_set()
    * @see elm_diskselector_clear()
    * @see elm_icon_add()
    *
    * @ingroup Diskselector
    */
   EAPI Elm_Diskselector_Item *elm_diskselector_item_append(Evas_Object *obj, const char *label, Evas_Object *icon, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);


   /**
    * Delete them item from the diskselector.
    *
    * @param it The item of diskselector to be deleted.
    *
    * If deleting all diskselector items is required, elm_diskselector_clear()
    * should be used instead of getting items list and deleting each one.
    *
    * @see elm_diskselector_clear()
    * @see elm_diskselector_item_append()
    * @see elm_diskselector_item_del_cb_set()
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_del(Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the function called when a diskselector item is freed.
    *
    * @param it The item to set the callback on
    * @param func The function called
    *
    * If there is a @p func, then it will be called prior item's memory release.
    * That will be called with the following arguments:
    * @li item's data;
    * @li item's Evas object;
    * @li item itself;
    *
    * This way, a data associated to a diskselector item could be properly
    * freed.
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_del_cb_set(Elm_Diskselector_Item *item, Evas_Smart_Cb func) EINA_ARG_NONNULL(1);

   /**
    * Get the data associated to the item.
    *
    * @param it The diskselector item
    * @return The data associated to @p it
    *
    * The return value is a pointer to data associated to @item when it was
    * created, with function elm_diskselector_item_append(). If no data
    * was passed as argument, it will return @c NULL.
    *
    * @see elm_diskselector_item_append()
    *
    * @ingroup Diskselector
    */
   EAPI void                  *elm_diskselector_item_data_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the icon associated to the item.
    *
    * @param it The diskselector item
    * @param icon The icon object to associate with @p it
    *
    * The icon object to use at left side of the item. An
    * icon can be any Evas object, but usually it is an icon created
    * with elm_icon_add().
    *
    * Once the icon object is set, a previously set one will be deleted.
    * @warning Setting the same icon for two items will cause the icon to
    * dissapear from the first item.
    *
    * If an icon was passed as argument on item creation, with function
    * elm_diskselector_item_append(), it will be already
    * associated to the item.
    *
    * @see elm_diskselector_item_append()
    * @see elm_diskselector_item_icon_get()
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_icon_set(Elm_Diskselector_Item *item, Evas_Object *icon) EINA_ARG_NONNULL(1);

   /**
    * Get the icon associated to the item.
    *
    * @param it The diskselector item
    * @return The icon associated to @p it
    *
    * The return value is a pointer to the icon associated to @item when it was
    * created, with function elm_diskselector_item_append(), or later
    * with function elm_diskselector_item_icon_set. If no icon
    * was passed as argument, it will return @c NULL.
    *
    * @see elm_diskselector_item_append()
    * @see elm_diskselector_item_icon_set()
    *
    * @ingroup Diskselector
    */
   EAPI Evas_Object           *elm_diskselector_item_icon_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the label of item.
    *
    * @param it The item of diskselector.
    * @param label The label of item.
    *
    * The label to be displayed by the item.
    *
    * If no icon is set, label will be centered on item position, otherwise
    * the icon will be placed at left of the label, that will be shifted
    * to the right.
    *
    * An item with label "January" would be displayed on side position as
    * "Jan" if max length is set to 3 with function
    * elm_diskselector_side_label_lenght_set(), or "Janu", if this property
    * is set to 4.
    *
    * When this @item is selected, the entire label will be displayed,
    * except for width restrictions.
    * In this case label will be cropped and "..." will be concatenated,
    * but only for display purposes. It will keep the entire string, so
    * if diskselector is resized the remaining characters will be displayed.
    *
    * If a label was passed as argument on item creation, with function
    * elm_diskselector_item_append(), it will be already
    * displayed by the item.
    *
    * @see elm_diskselector_side_label_lenght_set()
    * @see elm_diskselector_item_label_get()
    * @see elm_diskselector_item_append()
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_label_set(Elm_Diskselector_Item *item, const char *label) EINA_ARG_NONNULL(1);

   /**
    * Get the label of item.
    *
    * @param it The item of diskselector.
    * @return The label of item.
    *
    * The return value is a pointer to the label associated to @item when it was
    * created, with function elm_diskselector_item_append(), or later
    * with function elm_diskselector_item_label_set. If no label
    * was passed as argument, it will return @c NULL.
    *
    * @see elm_diskselector_item_label_set() for more details.
    * @see elm_diskselector_item_append()
    *
    * @ingroup Diskselector
    */
   EAPI const char            *elm_diskselector_item_label_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Get the selected item.
    *
    * @param obj The diskselector object.
    * @return The selected diskselector item.
    *
    * The selected item can be unselected with function
    * elm_diskselector_item_selected_set(), and the first item of
    * diskselector will be selected.
    *
    * The selected item always will be centered on diskselector, with
    * full label displayed, i.e., max lenght set to side labels won't
    * apply on the selected item. More details on
    * elm_diskselector_side_label_length_set().
    *
    * @ingroup Diskselector
    */
   EAPI Elm_Diskselector_Item *elm_diskselector_selected_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the selected state of an item.
    *
    * @param it The diskselector item
    * @param selected The selected state
    *
    * This sets the selected state of the given item @p it.
    * @c EINA_TRUE for selected, @c EINA_FALSE for not selected.
    *
    * If a new item is selected the previosly selected will be unselected.
    * Previoulsy selected item can be get with function
    * elm_diskselector_selected_item_get().
    *
    * If the item @p it is unselected, the first item of diskselector will
    * be selected.
    *
    * Selected items will be visible on center position of diskselector.
    * So if it was on another position before selected, or was invisible,
    * diskselector will animate items until the selected item reaches center
    * position.
    *
    * @see elm_diskselector_item_selected_get()
    * @see elm_diskselector_selected_item_get()
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_selected_set(Elm_Diskselector_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);

   /*
    * Get whether the @p item is selected or not.
    *
    * @param it The diskselector item.
    * @return @c EINA_TRUE means item is selected. @c EINA_FALSE indicates
    * it's not. If @p obj is @c NULL, @c EINA_FALSE is returned.
    *
    * @see elm_diskselector_selected_item_set() for details.
    * @see elm_diskselector_item_selected_get()
    *
    * @ingroup Diskselector
    */
   EAPI Eina_Bool              elm_diskselector_item_selected_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Get the first item of the diskselector.
    *
    * @param obj The diskselector object.
    * @return The first item, or @c NULL if none.
    *
    * The list of items follows append order. So it will return the first
    * item appended to the widget that wasn't deleted.
    *
    * @see elm_diskselector_item_append()
    * @see elm_diskselector_items_get()
    *
    * @ingroup Diskselector
    */
   EAPI Elm_Diskselector_Item *elm_diskselector_first_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the last item of the diskselector.
    *
    * @param obj The diskselector object.
    * @return The last item, or @c NULL if none.
    *
    * The list of items follows append order. So it will return last first
    * item appended to the widget that wasn't deleted.
    *
    * @see elm_diskselector_item_append()
    * @see elm_diskselector_items_get()
    *
    * @ingroup Diskselector
    */
   EAPI Elm_Diskselector_Item *elm_diskselector_last_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the item before @p item in diskselector.
    *
    * @param it The diskselector item.
    * @return The item before @p item, or @c NULL if none or on failure.
    *
    * The list of items follows append order. So it will return item appended
    * just before @item and that wasn't deleted.
    *
    * If it is the first item, @c NULL will be returned.
    * First item can be get by elm_diskselector_first_item_get().
    *
    * @see elm_diskselector_item_append()
    * @see elm_diskselector_items_get()
    *
    * @ingroup Diskselector
    */
   EAPI Elm_Diskselector_Item *elm_diskselector_item_prev_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Get the item after @p item in diskselector.
    *
    * @param it The diskselector item.
    * @return The item after @p item, or @c NULL if none or on failure.
    *
    * The list of items follows append order. So it will return item appended
    * just after @item and that wasn't deleted.
    *
    * If it is the last item, @c NULL will be returned.
    * Last item can be get by elm_diskselector_last_item_get().
    *
    * @see elm_diskselector_item_append()
    * @see elm_diskselector_items_get()
    *
    * @ingroup Diskselector
    */
   EAPI Elm_Diskselector_Item *elm_diskselector_item_next_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the text to be shown in the diskselector item.
    *
    * @param item Target item
    * @param text The text to set in the content
    *
    * Setup the text as tooltip to object. The item can have only one tooltip,
    * so any previous tooltip data is removed.
    *
    * @see elm_object_tooltip_text_set() for more details.
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_tooltip_text_set(Elm_Diskselector_Item *item, const char *text) EINA_ARG_NONNULL(1);

   /**
    * Set the content to be shown in the tooltip item.
    *
    * Setup the tooltip to item. The item can have only one tooltip,
    * so any previous tooltip data is removed. @p func(with @p data) will
    * be called every time that need show the tooltip and it should
    * return a valid Evas_Object. This object is then managed fully by
    * tooltip system and is deleted when the tooltip is gone.
    *
    * @param item the diskselector item being attached a tooltip.
    * @param func the function used to create the tooltip contents.
    * @param data what to provide to @a func as callback data/context.
    * @param del_cb called when data is not needed anymore, either when
    *        another callback replaces @func, the tooltip is unset with
    *        elm_diskselector_item_tooltip_unset() or the owner @a item
    *        dies. This callback receives as the first parameter the
    *        given @a data, and @c event_info is the item.
    *
    * @see elm_object_tooltip_content_cb_set() for more details.
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_tooltip_content_cb_set(Elm_Diskselector_Item *item, Elm_Tooltip_Item_Content_Cb func, const void *data, Evas_Smart_Cb del_cb) EINA_ARG_NONNULL(1);

   /**
    * Unset tooltip from item.
    *
    * @param item diskselector item to remove previously set tooltip.
    *
    * Remove tooltip from item. The callback provided as del_cb to
    * elm_diskselector_item_tooltip_content_cb_set() will be called to notify
    * it is not used anymore.
    *
    * @see elm_object_tooltip_unset() for more details.
    * @see elm_diskselector_item_tooltip_content_cb_set()
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_tooltip_unset(Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);


   /**
    * Sets a different style for this item tooltip.
    *
    * @note before you set a style you should define a tooltip with
    *       elm_diskselector_item_tooltip_content_cb_set() or
    *       elm_diskselector_item_tooltip_text_set()
    *
    * @param item diskselector item with tooltip already set.
    * @param style the theme style to use (default, transparent, ...)
    *
    * @see elm_object_tooltip_style_set() for more details.
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_tooltip_style_set(Elm_Diskselector_Item *item, const char *style) EINA_ARG_NONNULL(1);

   /**
    * Get the style for this item tooltip.
    *
    * @param item diskselector item with tooltip already set.
    * @return style the theme style in use, defaults to "default". If the
    *         object does not have a tooltip set, then NULL is returned.
    *
    * @see elm_object_tooltip_style_get() for more details.
    * @see elm_diskselector_item_tooltip_style_set()
    *
    * @ingroup Diskselector
    */
   EAPI const char            *elm_diskselector_item_tooltip_style_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Set the cursor to be shown when mouse is over the diskselector item
    *
    * @param item Target item
    * @param cursor the cursor name to be used.
    *
    * @see elm_object_cursor_set() for more details.
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_cursor_set(Elm_Diskselector_Item *item, const char *cursor) EINA_ARG_NONNULL(1);

   /**
    * Get the cursor to be shown when mouse is over the diskselector item
    *
    * @param item diskselector item with cursor already set.
    * @return the cursor name.
    *
    * @see elm_object_cursor_get() for more details.
    * @see elm_diskselector_cursor_set()
    *
    * @ingroup Diskselector
    */
   EAPI const char            *elm_diskselector_item_cursor_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);


   /**
    * Unset the cursor to be shown when mouse is over the diskselector item
    *
    * @param item Target item
    *
    * @see elm_object_cursor_unset() for more details.
    * @see elm_diskselector_cursor_set()
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_cursor_unset(Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * Sets a different style for this item cursor.
    *
    * @note before you set a style you should define a cursor with
    *       elm_diskselector_item_cursor_set()
    *
    * @param item diskselector item with cursor already set.
    * @param style the theme style to use (default, transparent, ...)
    *
    * @see elm_object_cursor_style_set() for more details.
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_cursor_style_set(Elm_Diskselector_Item *item, const char *style) EINA_ARG_NONNULL(1);


   /**
    * Get the style for this item cursor.
    *
    * @param item diskselector item with cursor already set.
    * @return style the theme style in use, defaults to "default". If the
    *         object does not have a cursor set, then @c NULL is returned.
    *
    * @see elm_object_cursor_style_get() for more details.
    * @see elm_diskselector_item_cursor_style_set()
    *
    * @ingroup Diskselector
    */
   EAPI const char            *elm_diskselector_item_cursor_style_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);


   /**
    * Set if the cursor set should be searched on the theme or should use
    * the provided by the engine, only.
    *
    * @note before you set if should look on theme you should define a cursor
    * with elm_diskselector_item_cursor_set().
    * By default it will only look for cursors provided by the engine.
    *
    * @param item widget item with cursor already set.
    * @param engine_only boolean to define if cursors set with
    * elm_diskselector_item_cursor_set() should be searched only
    * between cursors provided by the engine or searched on widget's
    * theme as well.
    *
    * @see elm_object_cursor_engine_only_set() for more details.
    *
    * @ingroup Diskselector
    */
   EAPI void                   elm_diskselector_item_cursor_engine_only_set(Elm_Diskselector_Item *item, Eina_Bool engine_only) EINA_ARG_NONNULL(1);

   /**
    * Get the cursor engine only usage for this item cursor.
    *
    * @param item widget item with cursor already set.
    * @return engine_only boolean to define it cursors should be looked only
    * between the provided by the engine or searched on widget's theme as well.
    * If the item does not have a cursor set, then @c EINA_FALSE is returned.
    *
    * @see elm_object_cursor_engine_only_get() for more details.
    * @see elm_diskselector_item_cursor_engine_only_set()
    *
    * @ingroup Diskselector
    */
   EAPI Eina_Bool              elm_diskselector_item_cursor_engine_only_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);

   /**
    * @}
    */

   /**
    * @page tutorial_colorselector Color selector example
    * @dontinclude colorselector_example_01.c
    *
    * This example shows how to change the color of a rectangle using a color
    * selector. We aren't going to explain a lot of the code since it's the
    * usual setup code:
    * @until show(rect)
    *
    * Now that we have a window with background and a rectangle we can create
    * our color_selector and set it's initial color to fully opaque blue:
    * @until show
    *
    * Next we tell ask to be notified whenever the color changes:
    * @until changed
    *
    * We follow that we some more run of the mill setup code:
    * @until ELM_MAIN()
    *
    * And now get to the callback that sets the color of the rectangle:
    * @until }
    *
    * This example will look like this:
    *
    * @image html screenshots/colorselector_example_01.png
    * @image latex screenshots/colorselector_example_01.eps width=\textwidth
    *
    * @example colorselector_example_01.c
    */
   /**
    * @defgroup Colorselector Colorselector
    *
    * @{
    *
    * @image html img/widget/colorselector/preview-00.png
    *
    * @brief Widget for user to select a color.
    *
    * Signals that you can add callbacks for are:
    * "changed" - When the color value changes(event_info is NULL).
    *
    * See @ref tutorial_colorselector.
    */
   /**
    * @brief Add a new colorselector to the parent
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    *
    * @ingroup Colorselector
    */
   EAPI Evas_Object *elm_colorselector_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set a color for the colorselector
    *
    * @param obj   Colorselector object
    * @param r     r-value of color
    * @param g     g-value of color
    * @param b     b-value of color
    * @param a     a-value of color
    *
    * @ingroup Colorselector
    */
   EAPI void         elm_colorselector_color_set(Evas_Object *obj, int r, int g , int b, int a) EINA_ARG_NONNULL(1);
   /**
    * Get a color from the colorselector
    *
    * @param obj   Colorselector object
    * @param r     integer pointer for r-value of color
    * @param g     integer pointer for g-value of color
    * @param b     integer pointer for b-value of color
    * @param a     integer pointer for a-value of color
    *
    * @ingroup Colorselector
    */
   EAPI void         elm_colorselector_color_get(const Evas_Object *obj, int *r, int *g , int *b, int *a) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /**
    * @defgroup Ctxpopup
    *
    * @image html img/widget/ctxpopup/preview-00.png
    * @image latex img/widget/ctxpopup/preview-00.eps
    *
    * @brief Context popup widet.
    *
    * A ctxpopup is a widget that, when shown, pops up a list of items.
    * It automatically chooses an area inside its parent object's view
    * (set via elm_ctxpopup_add() and elm_ctxpopup_hover_parent_set()) to
    * optimally fit into it. In the default theme, it will also point an
    * arrow to it's top left position at the time one shows it. Ctxpopup
    * items have a label and/or an icon. It is intended for a small
    * number of items (hence the use of list, not genlist).
    *
    * @note Ctxpopup is a especialization of @ref Hover.
    *
    * Signals that you can add callbacks for are:
    * "dismissed" - the ctxpopup was dismissed
    *
    * @ref tutorial_ctxpopup shows the usage of a good deal of the API.
    * @{
    */
   typedef struct _Elm_Ctxpopup_Item Elm_Ctxpopup_Item;

   typedef enum _Elm_Ctxpopup_Direction
     {
        ELM_CTXPOPUP_DIRECTION_DOWN, /**< ctxpopup show appear below clicked
                                          area */
        ELM_CTXPOPUP_DIRECTION_RIGHT, /**< ctxpopup show appear to the right of
                                           the clicked area */
        ELM_CTXPOPUP_DIRECTION_LEFT, /**< ctxpopup show appear to the left of
                                          the clicked area */
        ELM_CTXPOPUP_DIRECTION_UP, /**< ctxpopup show appear above the clicked
                                        area */
     } Elm_Ctxpopup_Direction;

   /**
    * @brief Add a new Ctxpopup object to the parent.
    *
    * @param parent Parent object
    * @return New object or @c NULL, if it cannot be created
    */
   EAPI Evas_Object  *elm_ctxpopup_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the Ctxpopup's parent
    *
    * @param obj The ctxpopup object
    * @param area The parent to use
    *
    * Set the parent object.
    *
    * @note elm_ctxpopup_add() will automatically call this function
    * with its @c parent argument.
    *
    * @see elm_ctxpopup_add()
    * @see elm_hover_parent_set()
    */
   EAPI void          elm_ctxpopup_hover_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1, 2);
   /**
    * @brief Get the Ctxpopup's parent
    *
    * @param obj The ctxpopup object
    *
    * @see elm_ctxpopup_hover_parent_set() for more information
    */
   EAPI Evas_Object  *elm_ctxpopup_hover_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Clear all items in the given ctxpopup object.
    *
    * @param obj Ctxpopup object
    */
   EAPI void          elm_ctxpopup_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Change the ctxpopup's orientation to horizontal or vertical.
    *
    * @param obj Ctxpopup object
    * @param horizontal @c EINA_TRUE for horizontal mode, @c EINA_FALSE for vertical
    */
   EAPI void          elm_ctxpopup_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the value of current ctxpopup object's orientation.
    *
    * @param obj Ctxpopup object
    * @return @c EINA_TRUE for horizontal mode, @c EINA_FALSE for vertical mode (or errors)
    *
    * @see elm_ctxpopup_horizontal_set()
    */
   EAPI Eina_Bool     elm_ctxpopup_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Add a new item to a ctxpopup object.
    *
    * @param obj Ctxpopup object
    * @param icon Icon to be set on new item
    * @param label The Label of the new item
    * @param func Convenience function called when item selected
    * @param data Data passed to @p func
    * @return A handle to the item added or @c NULL, on errors
    *
    * @warning Ctxpopup can't hold both an item list and a content at the same
    * time. When an item is added, any previous content will be removed.
    *
    * @see elm_ctxpopup_content_set()
    */
   Elm_Ctxpopup_Item *elm_ctxpopup_item_append(Evas_Object *obj, const char *label, Evas_Object *icon, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   /**
    * @brief Delete the given item in a ctxpopup object.
    *
    * @param item Ctxpopup item to be deleted
    *
    * @see elm_ctxpopup_item_append()
    */
   EAPI void          elm_ctxpopup_item_del(Elm_Ctxpopup_Item *item) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the ctxpopup item's state as disabled or enabled.
    *
    * @param item Ctxpopup item to be enabled/disabled
    * @param disabled @c EINA_TRUE to disable it, @c EINA_FALSE to enable it
    *
    * When disabled the item is greyed out to indicate it's state.
    */
   EAPI void          elm_ctxpopup_item_disabled_set(Elm_Ctxpopup_Item *item, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the ctxpopup item's disabled/enabled state.
    *
    * @param item Ctxpopup item to be enabled/disabled
    * @return disabled @c EINA_TRUE, if disabled, @c EINA_FALSE otherwise
    *
    * @see elm_ctxpopup_item_disabled_set()
    */
   EAPI Eina_Bool     elm_ctxpopup_item_disabled_get(const Elm_Ctxpopup_Item *item) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the icon object for the given ctxpopup item.
    *
    * @param item Ctxpopup item
    * @return icon object or @c NULL, if the item does not have icon or an error
    * occurred
    *
    * @see elm_ctxpopup_item_append()
    * @see elm_ctxpopup_item_icon_set()
    */
   EAPI Evas_Object  *elm_ctxpopup_item_icon_get(const Elm_Ctxpopup_Item *item) EINA_ARG_NONNULL(1);
   /**
    * @brief Sets the side icon associated with the ctxpopup item
    *
    * @param item Ctxpopup item
    * @param icon Icon object to be set
    *
    * Once the icon object is set, a previously set one will be deleted.
    * @warning Setting the same icon for two items will cause the icon to
    * dissapear from the first item.
    *
    * @see elm_ctxpopup_item_append()
    */
   EAPI void          elm_ctxpopup_item_icon_set(Elm_Ctxpopup_Item *item, Evas_Object *icon) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the label for the given ctxpopup item.
    *
    * @param item Ctxpopup item
    * @return label string or @c NULL, if the item does not have label or an
    * error occured
    *
    * @see elm_ctxpopup_item_append()
    * @see elm_ctxpopup_item_label_set()
    */
   EAPI const char   *elm_ctxpopup_item_label_get(const Elm_Ctxpopup_Item *item) EINA_ARG_NONNULL(1);
   /**
    * @brief (Re)set the label on the given ctxpopup item.
    *
    * @param item Ctxpopup item
    * @param label String to set as label
    */
   EAPI void          elm_ctxpopup_item_label_set(Elm_Ctxpopup_Item *item, const char *label) EINA_ARG_NONNULL(1);
   /**
    * @brief Set an elm widget as the content of the ctxpopup.
    *
    * @param obj Ctxpopup object
    * @param content Content to be swallowed
    *
    * If the content object is already set, a previous one will bedeleted. If
    * you want to keep that old content object, use the
    * elm_ctxpopup_content_unset() function.
    *
    * @warning Ctxpopup can't hold both a item list and a content at the same
    * time. When a content is set, any previous items will be removed.
    */
   EAPI void          elm_ctxpopup_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1, 2);
   /**
    * @brief Unset the ctxpopup content
    *
    * @param obj Ctxpopup object
    * @return The content that was being used
    *
    * Unparent and return the content object which was set for this widget.
    *
    * @see elm_ctxpopup_content_set()
    */
   EAPI Evas_Object  *elm_ctxpopup_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the direction priority of a ctxpopup.
    *
    * @param obj Ctxpopup object
    * @param first 1st priority of direction
    * @param second 2nd priority of direction
    * @param third 3th priority of direction
    * @param fourth 4th priority of direction
    *
    * This functions gives a chance to user to set the priority of ctxpopup
    * showing direction. This doesn't guarantee the ctxpopup will appear in the
    * requested direction.
    *
    * @see Elm_Ctxpopup_Direction
    */
   EAPI void          elm_ctxpopup_direction_priority_set(Evas_Object *obj, Elm_Ctxpopup_Direction first, Elm_Ctxpopup_Direction second, Elm_Ctxpopup_Direction third, Elm_Ctxpopup_Direction fourth) EINA_ARG_NONNULL(1);
   /**
    * @brief Get the direction priority of a ctxpopup.
    *
    * @param obj Ctxpopup object
    * @param first 1st priority of direction to be returned
    * @param second 2nd priority of direction to be returned
    * @param third 3th priority of direction to be returned
    * @param fourth 4th priority of direction to be returned
    *
    * @see elm_ctxpopup_direction_priority_set() for more information.
    */
   EAPI void          elm_ctxpopup_direction_priority_get(Evas_Object *obj, Elm_Ctxpopup_Direction *first, Elm_Ctxpopup_Direction *second, Elm_Ctxpopup_Direction *third, Elm_Ctxpopup_Direction *fourth) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* transit */
   /**
    *
    * @defgroup Transit Transit
    * @ingroup Elementary
    *
    * Transit is designed to apply various animated transition effects to @c
    * Evas_Object, such like translation, rotation, etc. For using these
    * effects, create an @ref Elm_Transit and add the desired transition effects.
    *
    * Once the effects are added into transit, they will be automatically
    * managed (their callback will be called until the duration is ended, and
    * they will be deleted on completion).
    *
    * Example:
    * @code
    * Elm_Transit *trans = elm_transit_add();
    * elm_transit_object_add(trans, obj);
    * elm_transit_effect_translation_add(trans, 0, 0, 280, 280
    * elm_transit_duration_set(transit, 1);
    * elm_transit_auto_reverse_set(transit, EINA_TRUE);
    * elm_transit_tween_mode_set(transit, ELM_TRANSIT_TWEEN_MODE_DECELERATE);
    * elm_transit_repeat_times_set(transit, 3);
    * @endcode
    *
    * Some transition effects are used to change the properties of objects. They
    * are:
    * @li @ref elm_transit_effect_translation_add
    * @li @ref elm_transit_effect_color_add
    * @li @ref elm_transit_effect_rotation_add
    * @li @ref elm_transit_effect_wipe_add
    * @li @ref elm_transit_effect_zoom_add
    * @li @ref elm_transit_effect_resizing_add
    *
    * Other transition effects are used to make one object disappear and another
    * object appear on its old place. These effects are:
    *
    * @li @ref elm_transit_effect_flip_add
    * @li @ref elm_transit_effect_resizable_flip_add
    * @li @ref elm_transit_effect_fade_add
    * @li @ref elm_transit_effect_blend_add
    *
    * It's also possible to make a transition chain with @ref
    * elm_transit_chain_transit_add.
    *
    * @warning We strongly recommend to use elm_transit just when edje can not do
    * the trick. Edje has more advantage than Elm_Transit, it has more flexibility and
    * animations can be manipulated inside the theme.
    *
    * List of examples:
    * @li @ref transit_example_01_explained
    * @li @ref transit_example_02_explained
    * @li @ref transit_example_03_c
    * @li @ref transit_example_04_c
    *
    * @{
    */

   /**
    * @enum Elm_Transit_Tween_Mode
    *
    * The type of acceleration used in the transition.
    */
   typedef enum
     {
        ELM_TRANSIT_TWEEN_MODE_LINEAR, /**< Constant speed */
        ELM_TRANSIT_TWEEN_MODE_SINUSOIDAL, /**< Starts slow, increase speed
                                             over time, then decrease again
                                             and stop slowly */
        ELM_TRANSIT_TWEEN_MODE_DECELERATE, /**< Starts fast and decrease
                                             speed over time */
        ELM_TRANSIT_TWEEN_MODE_ACCELERATE /**< Starts slow and increase speed
                                            over time */
     } Elm_Transit_Tween_Mode;

   /**
    * @enum Elm_Transit_Effect_Flip_Axis
    *
    * The axis where flip effect should be applied.
    */
   typedef enum
     {
        ELM_TRANSIT_EFFECT_FLIP_AXIS_X, /**< Flip on X axis */
        ELM_TRANSIT_EFFECT_FLIP_AXIS_Y /**< Flip on Y axis */
     } Elm_Transit_Effect_Flip_Axis;
   /**
    * @enum Elm_Transit_Effect_Wipe_Dir
    *
    * The direction where the wipe effect should occur.
    */
   typedef enum
     {
        ELM_TRANSIT_EFFECT_WIPE_DIR_LEFT, /**< Wipe to the left */
        ELM_TRANSIT_EFFECT_WIPE_DIR_RIGHT, /**< Wipe to the right */
        ELM_TRANSIT_EFFECT_WIPE_DIR_UP, /**< Wipe up */
        ELM_TRANSIT_EFFECT_WIPE_DIR_DOWN /**< Wipe down */
     } Elm_Transit_Effect_Wipe_Dir;
   /** @enum Elm_Transit_Effect_Wipe_Type
    *
    * Whether the wipe effect should show or hide the object.
    */
   typedef enum
     {
        ELM_TRANSIT_EFFECT_WIPE_TYPE_HIDE, /**< Hide the object during the
                                             animation */
        ELM_TRANSIT_EFFECT_WIPE_TYPE_SHOW /**< Show the object during the
                                            animation */
     } Elm_Transit_Effect_Wipe_Type;

   /**
    * @typedef Elm_Transit
    *
    * The Transit created with elm_transit_add(). This type has the information
    * about the objects which the transition will be applied, and the
    * transition effects that will be used. It also contains info about
    * duration, number of repetitions, auto-reverse, etc.
    */
   typedef struct _Elm_Transit Elm_Transit;
   typedef void Elm_Transit_Effect;
   /**
    * @typedef Elm_Transit_Effect_Transition_Cb
    *
    * Transition callback called for this effect on each transition iteration.
    */
   typedef void (*Elm_Transit_Effect_Transition_Cb) (Elm_Transit_Effect *effect, Elm_Transit *transit, double progress);
   /**
    * Elm_Transit_Effect_End_Cb
    *
    * Transition callback called for this effect when the transition is over.
    */
   typedef void (*Elm_Transit_Effect_End_Cb) (Elm_Transit_Effect *effect, Elm_Transit *transit);

   /**
    * Elm_Transit_Del_Cb
    *
    * A callback called when the transit is deleted.
    */
   typedef void (*Elm_Transit_Del_Cb) (void *data, Elm_Transit *transit);

   /**
    * Add new transit.
    *
    * @note Is not necessary to delete the transit object, it will be deleted at
    * the end of its operation.
    * @note The transit will start playing when the program enter in the main loop, is not
    * necessary to give a start to the transit.
    *
    * @return The transit object.
    *
    * @ingroup Transit
    */
   EAPI Elm_Transit                *elm_transit_add(void);

   /**
    * Stops the animation and delete the @p transit object.
    *
    * Call this function if you wants to stop the animation before the duration
    * time. Make sure the @p transit object is still alive with
    * elm_transit_del_cb_set() function.
    * All added effects will be deleted, calling its repective data_free_cb
    * functions. The function setted by elm_transit_del_cb_set() will be called.
    *
    * @see elm_transit_del_cb_set()
    *
    * @param transit The transit object to be deleted.
    *
    * @ingroup Transit
    * @warning Just call this function if you are sure the transit is alive.
    */
   EAPI void                        elm_transit_del(Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Add a new effect to the transit.
    *
    * @note The cb function and the data are the key to the effect. If you try to
    * add an already added effect, nothing is done.
    * @note After the first addition of an effect in @p transit, if its
    * effect list become empty again, the @p transit will be killed by
    * elm_transit_del(transit) function.
    *
    * Exemple:
    * @code
    * Elm_Transit *transit = elm_transit_add();
    * elm_transit_effect_add(transit,
    *                        elm_transit_effect_blend_op,
    *                        elm_transit_effect_blend_context_new(),
    *                        elm_transit_effect_blend_context_free);
    * @endcode
    *
    * @param transit The transit object.
    * @param transition_cb The operation function. It is called when the
    * animation begins, it is the function that actually performs the animation.
    * It is called with the @p data, @p transit and the time progression of the
    * animation (a double value between 0.0 and 1.0).
    * @param effect The context data of the effect.
    * @param end_cb The function to free the context data, it will be called
    * at the end of the effect, it must finalize the animation and free the
    * @p data.
    *
    * @ingroup Transit
    * @warning The transit free the context data at the and of the transition with
    * the data_free_cb function, do not use the context data in another transit.
    */
   EAPI void                        elm_transit_effect_add(Elm_Transit *transit, Elm_Transit_Effect_Transition_Cb transition_cb, Elm_Transit_Effect *effect, Elm_Transit_Effect_End_Cb end_cb) EINA_ARG_NONNULL(1, 2);

   /**
    * Delete an added effect.
    *
    * This function will remove the effect from the @p transit, calling the
    * data_free_cb to free the @p data.
    *
    * @see elm_transit_effect_add()
    *
    * @note If the effect is not found, nothing is done.
    * @note If the effect list become empty, this function will call
    * elm_transit_del(transit), that is, it will kill the @p transit.
    *
    * @param transit The transit object.
    * @param transition_cb The operation function.
    * @param effect The context data of the effect.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_effect_del(Elm_Transit *transit, Elm_Transit_Effect_Transition_Cb transition_cb, Elm_Transit_Effect *effect) EINA_ARG_NONNULL(1, 2);

   /**
    * Add new object to apply the effects.
    *
    * @note After the first addition of an object in @p transit, if its
    * object list become empty again, the @p transit will be killed by
    * elm_transit_del(transit) function.
    * @note If the @p obj belongs to another transit, the @p obj will be
    * removed from it and it will only belong to the @p transit. If the old
    * transit stays without objects, it will die.
    * @note When you add an object into the @p transit, its state from
    * evas_object_pass_events_get(obj) is saved, and it is applied when the
    * transit ends, if you change this state whith evas_object_pass_events_set()
    * after add the object, this state will change again when @p transit stops to
    * run.
    *
    * @param transit The transit object.
    * @param obj Object to be animated.
    *
    * @ingroup Transit
    * @warning It is not allowed to add a new object after transit begins to go.
    */
   EAPI void                        elm_transit_object_add(Elm_Transit *transit, Evas_Object *obj) EINA_ARG_NONNULL(1, 2);

   /**
    * Removes an added object from the transit.
    *
    * @note If the @p obj is not in the @p transit, nothing is done.
    * @note If the list become empty, this function will call
    * elm_transit_del(transit), that is, it will kill the @p transit.
    *
    * @param transit The transit object.
    * @param obj Object to be removed from @p transit.
    *
    * @ingroup Transit
    * @warning It is not allowed to remove objects after transit begins to go.
    */
   EAPI void                        elm_transit_object_remove(Elm_Transit *transit, Evas_Object *obj) EINA_ARG_NONNULL(1, 2);

   /**
    * Get the objects of the transit.
    *
    * @param transit The transit object.
    * @return a Eina_List with the objects from the transit.
    *
    * @ingroup Transit
    */
   EAPI const Eina_List            *elm_transit_objects_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Enable/disable keeping up the objects states.
    * If it is not kept, the objects states will be reset when transition ends.
    *
    * @note @p transit can not be NULL.
    * @note One state includes geometry, color, map data.
    *
    * @param transit The transit object.
    * @param state_keep Keeping or Non Keeping.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_objects_final_state_keep_set(Elm_Transit *transit, Eina_Bool state_keep) EINA_ARG_NONNULL(1);

   /**
    * Get a value whether the objects states will be reset or not.
    *
    * @note @p transit can not be NULL
    *
    * @see elm_transit_objects_final_state_keep_set()
    *
    * @param transit The transit object.
    * @return EINA_TRUE means the states of the objects will be reset.
    * If @p transit is NULL, EINA_FALSE is returned
    *
    * @ingroup Transit
    */
   EAPI Eina_Bool                   elm_transit_objects_final_state_keep_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Set the event enabled when transit is operating.
    *
    * If @p enabled is EINA_TRUE, the objects of the transit will receives
    * events from mouse and keyboard during the animation.
    * @note When you add an object with elm_transit_object_add(), its state from
    * evas_object_pass_events_get(obj) is saved, and it is applied when the
    * transit ends, if you change this state with evas_object_pass_events_set()
    * after adding the object, this state will change again when @p transit stops
    * to run.
    *
    * @param transit The transit object.
    * @param enabled Events are received when enabled is @c EINA_TRUE, and
    * ignored otherwise.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_event_enabled_set(Elm_Transit *transit, Eina_Bool enabled) EINA_ARG_NONNULL(1);

   /**
    * Get the value of event enabled status.
    *
    * @see elm_transit_event_enabled_set()
    *
    * @param transit The Transit object
    * @return EINA_TRUE, when event is enabled. If @p transit is NULL
    * EINA_FALSE is returned
    *
    * @ingroup Transit
    */
   EAPI Eina_Bool                   elm_transit_event_enabled_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Set the user-callback function when the transit is deleted.
    *
    * @note Using this function twice will overwrite the first function setted.
    * @note the @p transit object will be deleted after call @p cb function.
    *
    * @param transit The transit object.
    * @param cb Callback function pointer. This function will be called before
    * the deletion of the transit.
    * @param data Callback funtion user data. It is the @p op parameter.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_del_cb_set(Elm_Transit *transit, Elm_Transit_Del_Cb cb, void *data) EINA_ARG_NONNULL(1);

   /**
    * Set reverse effect automatically.
    *
    * If auto reverse is setted, after running the effects with the progress
    * parameter from 0 to 1, it will call the effecs again with the progress
    * from 1 to 0. The transit will last for a time iqual to (2 * duration * repeat),
    * where the duration was setted with the function elm_transit_add and
    * the repeat with the function elm_transit_repeat_times_set().
    *
    * @param transit The transit object.
    * @param reverse EINA_TRUE means the auto_reverse is on.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_auto_reverse_set(Elm_Transit *transit, Eina_Bool reverse) EINA_ARG_NONNULL(1);

   /**
    * Get if the auto reverse is on.
    *
    * @see elm_transit_auto_reverse_set()
    *
    * @param transit The transit object.
    * @return EINA_TRUE means auto reverse is on. If @p transit is NULL
    * EINA_FALSE is returned
    *
    * @ingroup Transit
    */
   EAPI Eina_Bool                   elm_transit_auto_reverse_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Set the transit repeat count. Effect will be repeated by repeat count.
    *
    * This function sets the number of repetition the transit will run after
    * the first one, that is, if @p repeat is 1, the transit will run 2 times.
    * If the @p repeat is a negative number, it will repeat infinite times.
    *
    * @note If this function is called during the transit execution, the transit
    * will run @p repeat times, ignoring the times it already performed.
    *
    * @param transit The transit object
    * @param repeat Repeat count
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_repeat_times_set(Elm_Transit *transit, int repeat) EINA_ARG_NONNULL(1);

   /**
    * Get the transit repeat count.
    *
    * @see elm_transit_repeat_times_set()
    *
    * @param transit The Transit object.
    * @return The repeat count. If @p transit is NULL
    * 0 is returned
    *
    * @ingroup Transit
    */
   EAPI int                         elm_transit_repeat_times_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Set the transit animation acceleration type.
    *
    * This function sets the tween mode of the transit that can be:
    * ELM_TRANSIT_TWEEN_MODE_LINEAR - The default mode.
    * ELM_TRANSIT_TWEEN_MODE_SINUSOIDAL - Starts in accelerate mode and ends decelerating.
    * ELM_TRANSIT_TWEEN_MODE_DECELERATE - The animation will be slowed over time.
    * ELM_TRANSIT_TWEEN_MODE_ACCELERATE - The animation will accelerate over time.
    *
    * @param transit The transit object.
    * @param tween_mode The tween type.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_tween_mode_set(Elm_Transit *transit, Elm_Transit_Tween_Mode tween_mode) EINA_ARG_NONNULL(1);

   /**
    * Get the transit animation acceleration type.
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    * @return The tween type. If @p transit is NULL
    * ELM_TRANSIT_TWEEN_MODE_LINEAR is returned.
    *
    * @ingroup Transit
    */
   EAPI Elm_Transit_Tween_Mode      elm_transit_tween_mode_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Set the transit animation time
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    * @param duration The animation time.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_duration_set(Elm_Transit *transit, double duration) EINA_ARG_NONNULL(1);

   /**
    * Get the transit animation time
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    *
    * @return The transit animation time.
    *
    * @ingroup Transit
    */
   EAPI double                      elm_transit_duration_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Starts the transition.
    * Once this API is called, the transit begins to measure the time.
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_go(Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Pause/Resume the transition.
    *
    * If you call elm_transit_go again, the transit will be started from the
    * beginning, and will be unpaused.
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    * @param paused Whether the transition should be paused or not.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_paused_set(Elm_Transit *transit, Eina_Bool paused) EINA_ARG_NONNULL(1);

   /**
    * Get the value of paused status.
    *
    * @see elm_transit_paused_set()
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    * @return EINA_TRUE means transition is paused. If @p transit is NULL
    * EINA_FALSE is returned
    *
    * @ingroup Transit
    */
   EAPI Eina_Bool                   elm_transit_paused_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Get the time progression of the animation (a double value between 0.0 and 1.0).
    *
    * The value returned is a fraction (current time / total time). It
    * represents the progression position relative to the total.
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    *
    * @return The time progression value. If @p transit is NULL
    * 0 is returned
    *
    * @ingroup Transit
    */
   EAPI double                      elm_transit_progress_value_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Makes the chain relationship between two transits.
    *
    * @note @p transit can not be NULL. Transit would have multiple chain transits.
    * @note @p chain_transit can not be NULL. Chain transits could be chained to the only one transit.
    *
    * @param transit The transit object.
    * @param chain_transit The chain transit object. This transit will be operated
    *        after transit is done.
    *
    * This function adds @p chain_transit transition to a chain after the @p
    * transit, and will be started as soon as @p transit ends. See @ref
    * transit_example_02_explained for a full example.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_chain_transit_add(Elm_Transit *transit, Elm_Transit *chain_transit) EINA_ARG_NONNULL(1, 2);

   /**
    * Cut off the chain relationship between two transits.
    *
    * @note @p transit can not be NULL. Transit would have the chain relationship with @p chain transit.
    * @note @p chain_transit can not be NULL. Chain transits should be chained to the @p transit.
    *
    * @param transit The transit object.
    * @param chain_transit The chain transit object.
    *
    * This function remove the @p chain_transit transition from the @p transit.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_chain_transit_del(Elm_Transit *transit, Elm_Transit *chain_transit) EINA_ARG_NONNULL(1,2);

   /**
    * Get the current chain transit list.
    *
    * @note @p transit can not be NULL.
    *
    * @param transit The transit object.
    * @return chain transit list.
    *
    * @ingroup Transit
    */
   EAPI Eina_List                  *elm_transit_chain_transits_get(const Elm_Transit *transit);

   /**
    * Add the Resizing Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates resizing effect context
    * and add it's required APIs to elm_transit_effect_add.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param from_w Object width size when effect begins.
    * @param from_h Object height size when effect begins.
    * @param to_w Object width size when effect ends.
    * @param to_h Object height size when effect ends.
    * @return Resizing effect context data.
    *
    * @ingroup Transit
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_resizing_add(Elm_Transit* transit, Evas_Coord from_w, Evas_Coord from_h, Evas_Coord to_w, Evas_Coord to_h);

   /**
    * Add the Translation Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates translation effect context
    * and add it's required APIs to elm_transit_effect_add.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param from_dx X Position variation when effect begins.
    * @param from_dy Y Position variation when effect begins.
    * @param to_dx X Position variation when effect ends.
    * @param to_dy Y Position variation when effect ends.
    * @return Translation effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the geometry information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_translation_add(Elm_Transit* transit, Evas_Coord from_dx, Evas_Coord from_dy, Evas_Coord to_dx, Evas_Coord to_dy);

   /**
    * Add the Zoom Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates zoom effect context
    * and add it's required APIs to elm_transit_effect_add.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param from_rate Scale rate when effect begins (1 is current rate).
    * @param to_rate Scale rate when effect ends.
    * @return Zoom effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the geometry information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_zoom_add(Elm_Transit *transit, float from_rate, float to_rate);

   /**
    * Add the Flip Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates flip effect context
    * and add it's required APIs to elm_transit_effect_add.
    * @note This effect is applied to each pair of objects in the order they are listed
    * in the transit list of objects. The first object in the pair will be the
    * "front" object and the second will be the "back" object.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param axis Flipping Axis(X or Y).
    * @param cw Flipping Direction. EINA_TRUE is clock-wise.
    * @return Flip effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the geometry information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_flip_add(Elm_Transit *transit, Elm_Transit_Effect_Flip_Axis axis, Eina_Bool cw);

   /**
    * Add the Resizable Flip Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates resizable flip effect context
    * and add it's required APIs to elm_transit_effect_add.
    * @note This effect is applied to each pair of objects in the order they are listed
    * in the transit list of objects. The first object in the pair will be the
    * "front" object and the second will be the "back" object.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param axis Flipping Axis(X or Y).
    * @param cw Flipping Direction. EINA_TRUE is clock-wise.
    * @return Resizable flip effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the geometry information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_resizable_flip_add(Elm_Transit *transit, Elm_Transit_Effect_Flip_Axis axis, Eina_Bool cw);

   /**
    * Add the Wipe Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates wipe effect context
    * and add it's required APIs to elm_transit_effect_add.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param type Wipe type. Hide or show.
    * @param dir Wipe Direction.
    * @return Wipe effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the geometry information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_wipe_add(Elm_Transit *transit, Elm_Transit_Effect_Wipe_Type type, Elm_Transit_Effect_Wipe_Dir dir);

   /**
    * Add the Color Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates color effect context
    * and add it's required APIs to elm_transit_effect_add.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit        Transit object.
    * @param  from_r        RGB R when effect begins.
    * @param  from_g        RGB G when effect begins.
    * @param  from_b        RGB B when effect begins.
    * @param  from_a        RGB A when effect begins.
    * @param  to_r          RGB R when effect ends.
    * @param  to_g          RGB G when effect ends.
    * @param  to_b          RGB B when effect ends.
    * @param  to_a          RGB A when effect ends.
    * @return               Color effect context data.
    *
    * @ingroup Transit
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_color_add(Elm_Transit *transit, unsigned int from_r, unsigned int from_g, unsigned int from_b, unsigned int from_a, unsigned int to_r, unsigned int to_g, unsigned int to_b, unsigned int to_a);

   /**
    * Add the Fade Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates fade effect context
    * and add it's required APIs to elm_transit_effect_add.
    * @note This effect is applied to each pair of objects in the order they are listed
    * in the transit list of objects. The first object in the pair will be the
    * "before" object and the second will be the "after" object.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @return Fade effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the color information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_fade_add(Elm_Transit *transit);

   /**
    * Add the Blend Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates blend effect context
    * and add it's required APIs to elm_transit_effect_add.
    * @note This effect is applied to each pair of objects in the order they are listed
    * in the transit list of objects. The first object in the pair will be the
    * "before" object and the second will be the "after" object.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @return Blend effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the color information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_blend_add(Elm_Transit *transit);

   /**
    * Add the Rotation Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates rotation effect context
    * and add it's required APIs to elm_transit_effect_add.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param from_degree Degree when effect begins.
    * @param to_degree Degree when effect is ends.
    * @return Rotation effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the geometry information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_rotation_add(Elm_Transit *transit, float from_degree, float to_degree);

   /**
    * Add the ImageAnimation Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates image animation effect context
    * and add it's required APIs to elm_transit_effect_add.
    * The @p images parameter is a list images paths. This list and
    * its contents will be deleted at the end of the effect by
    * elm_transit_effect_image_animation_context_free() function.
    *
    * Example:
    * @code
    * char buf[PATH_MAX];
    * Eina_List *images = NULL;
    * Elm_Transit *transi = elm_transit_add();
    *
    * snprintf(buf, sizeof(buf), "%s/images/icon_11.png", PACKAGE_DATA_DIR);
    * images = eina_list_append(images, eina_stringshare_add(buf));
    *
    * snprintf(buf, sizeof(buf), "%s/images/logo_small.png", PACKAGE_DATA_DIR);
    * images = eina_list_append(images, eina_stringshare_add(buf));
    * elm_transit_effect_image_animation_add(transi, images);
    *
    * @endcode
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param images Eina_List of images file paths. This list and
    * its contents will be deleted at the end of the effect by
    * elm_transit_effect_image_animation_context_free() function.
    * @return Image Animation effect context data.
    *
    * @ingroup Transit
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_image_animation_add(Elm_Transit *transit, Eina_List *images);
   /**
    * @}
    */

  typedef struct _Elm_Store                      Elm_Store;
  typedef struct _Elm_Store_Filesystem           Elm_Store_Filesystem;
  typedef struct _Elm_Store_Item                 Elm_Store_Item;
  typedef struct _Elm_Store_Item_Filesystem      Elm_Store_Item_Filesystem;
  typedef struct _Elm_Store_Item_Info            Elm_Store_Item_Info;
  typedef struct _Elm_Store_Item_Info_Filesystem Elm_Store_Item_Info_Filesystem;
  typedef struct _Elm_Store_Item_Mapping         Elm_Store_Item_Mapping;
  typedef struct _Elm_Store_Item_Mapping_Empty   Elm_Store_Item_Mapping_Empty;
  typedef struct _Elm_Store_Item_Mapping_Icon    Elm_Store_Item_Mapping_Icon;
  typedef struct _Elm_Store_Item_Mapping_Photo   Elm_Store_Item_Mapping_Photo;
  typedef struct _Elm_Store_Item_Mapping_Custom  Elm_Store_Item_Mapping_Custom;

  typedef Eina_Bool (*Elm_Store_Item_List_Cb) (void *data, Elm_Store_Item_Info *info);
  typedef void      (*Elm_Store_Item_Fetch_Cb) (void *data, Elm_Store_Item *sti);
  typedef void      (*Elm_Store_Item_Unfetch_Cb) (void *data, Elm_Store_Item *sti);
  typedef void     *(*Elm_Store_Item_Mapping_Cb) (void *data, Elm_Store_Item *sti, const char *part);

  typedef enum
    {
       ELM_STORE_ITEM_MAPPING_NONE = 0,
       ELM_STORE_ITEM_MAPPING_LABEL, // const char * -> label
       ELM_STORE_ITEM_MAPPING_STATE, // Eina_Bool -> state
       ELM_STORE_ITEM_MAPPING_ICON, // char * -> icon path
       ELM_STORE_ITEM_MAPPING_PHOTO, // char * -> photo path
       ELM_STORE_ITEM_MAPPING_CUSTOM, // item->custom(it->data, it, part) -> void * (-> any)
       // can add more here as needed by common apps
       ELM_STORE_ITEM_MAPPING_LAST
    } Elm_Store_Item_Mapping_Type;

  struct _Elm_Store_Item_Mapping_Icon
    {
       // FIXME: allow edje file icons
       int                   w, h;
       Elm_Icon_Lookup_Order lookup_order;
       Eina_Bool             standard_name : 1;
       Eina_Bool             no_scale : 1;
       Eina_Bool             smooth : 1;
       Eina_Bool             scale_up : 1;
       Eina_Bool             scale_down : 1;
    };

  struct _Elm_Store_Item_Mapping_Empty
    {
       Eina_Bool             dummy;
    };

  struct _Elm_Store_Item_Mapping_Photo
    {
       int                   size;
    };

  struct _Elm_Store_Item_Mapping_Custom
    {
       Elm_Store_Item_Mapping_Cb func;
    };

  struct _Elm_Store_Item_Mapping
    {
       Elm_Store_Item_Mapping_Type     type;
       const char                     *part;
       int                             offset;
       union
         {
            Elm_Store_Item_Mapping_Empty  empty;
            Elm_Store_Item_Mapping_Icon   icon;
            Elm_Store_Item_Mapping_Photo  photo;
            Elm_Store_Item_Mapping_Custom custom;
            // add more types here
         } details;
    };

  struct _Elm_Store_Item_Info
    {
      Elm_Genlist_Item_Class       *item_class;
      const Elm_Store_Item_Mapping *mapping;
      void                         *data;
      char                         *sort_id;
    };

  struct _Elm_Store_Item_Info_Filesystem
    {
      Elm_Store_Item_Info  base;
      char                *path;
    };

#define ELM_STORE_ITEM_MAPPING_END { ELM_STORE_ITEM_MAPPING_NONE, NULL, 0, { .empty = { EINA_TRUE } } }
#define ELM_STORE_ITEM_MAPPING_OFFSET(st, it) offsetof(st, it)

  EAPI void                    elm_store_free(Elm_Store *st);

  EAPI Elm_Store              *elm_store_filesystem_new(void);
  EAPI void                    elm_store_filesystem_directory_set(Elm_Store *st, const char *dir) EINA_ARG_NONNULL(1);
  EAPI const char             *elm_store_filesystem_directory_get(const Elm_Store *st) EINA_ARG_NONNULL(1);
  EAPI const char             *elm_store_item_filesystem_path_get(const Elm_Store_Item *sti) EINA_ARG_NONNULL(1);

  EAPI void                    elm_store_target_genlist_set(Elm_Store *st, Evas_Object *obj) EINA_ARG_NONNULL(1);

  EAPI void                    elm_store_cache_set(Elm_Store *st, int max) EINA_ARG_NONNULL(1);
  EAPI int                     elm_store_cache_get(const Elm_Store *st) EINA_ARG_NONNULL(1);
  EAPI void                    elm_store_list_func_set(Elm_Store *st, Elm_Store_Item_List_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);
  EAPI void                    elm_store_fetch_func_set(Elm_Store *st, Elm_Store_Item_Fetch_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);
  EAPI void                    elm_store_fetch_thread_set(Elm_Store *st, Eina_Bool use_thread) EINA_ARG_NONNULL(1);
  EAPI Eina_Bool               elm_store_fetch_thread_get(const Elm_Store *st) EINA_ARG_NONNULL(1);

  EAPI void                    elm_store_unfetch_func_set(Elm_Store *st, Elm_Store_Item_Unfetch_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);
  EAPI void                    elm_store_sorted_set(Elm_Store *st, Eina_Bool sorted) EINA_ARG_NONNULL(1);
  EAPI Eina_Bool               elm_store_sorted_get(const Elm_Store *st) EINA_ARG_NONNULL(1);
  EAPI void                    elm_store_item_data_set(Elm_Store_Item *sti, void *data) EINA_ARG_NONNULL(1);
  EAPI void                   *elm_store_item_data_get(Elm_Store_Item *sti) EINA_ARG_NONNULL(1);
  EAPI const Elm_Store        *elm_store_item_store_get(const Elm_Store_Item *sti) EINA_ARG_NONNULL(1);
  EAPI const Elm_Genlist_Item *elm_store_item_genlist_item_get(const Elm_Store_Item *sti) EINA_ARG_NONNULL(1);

   /* SegmentControl */
   typedef struct _Elm_Segment_Item Elm_Segment_Item;
   EAPI Evas_Object      *elm_segment_control_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Elm_Segment_Item *elm_segment_control_item_add(Evas_Object *obj, Evas_Object *icon, const char *label) EINA_ARG_NONNULL(1);
   EAPI Elm_Segment_Item *elm_segment_control_item_insert_at(Evas_Object *obj, Evas_Object *icon, const char *label, int index) EINA_ARG_NONNULL(1);
   EAPI void              elm_segment_control_item_del(Elm_Segment_Item *it) EINA_ARG_NONNULL(1);
   EAPI void              elm_segment_control_item_del_at(Evas_Object *obj, int index) EINA_ARG_NONNULL(1);
   EAPI int               elm_segment_control_item_count_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Segment_Item *elm_segment_control_item_get(const Evas_Object *obj, int index) EINA_ARG_NONNULL(1);
   EAPI const char       *elm_segment_control_item_label_get(const Evas_Object *obj, int index) EINA_ARG_NONNULL(1);
   EAPI void              elm_segment_control_item_label_set(Elm_Segment_Item* it, const char* label) EINA_ARG_NONNULL(1);
   EAPI Evas_Object      *elm_segment_control_item_icon_get(const Evas_Object *obj, int index) EINA_ARG_NONNULL(1);
   EAPI void              elm_segment_control_item_icon_set(Elm_Segment_Item *it, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI int               elm_segment_control_item_index_get(const Elm_Segment_Item *it) EINA_ARG_NONNULL(1);
   EAPI Evas_Object      *elm_segment_control_item_object_get(const Elm_Segment_Item *it) EINA_ARG_NONNULL(1);
   EAPI Elm_Segment_Item *elm_segment_control_item_selected_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_segment_control_item_selected_set(Elm_Segment_Item *it, Eina_Bool select) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "changed" -when the user clicks on a segment item which is not previously
    *            selected and get selected. The event_info parameter is the
    *            segment item index.
    */

   EAPI Evas_Object *elm_grid_add(Evas_Object *parent);
   EAPI void         elm_grid_size_set(Evas_Object *obj, int w, int h);
   EAPI void         elm_grid_size_get(Evas_Object *obj, int *w, int *h);
   EAPI void         elm_grid_pack(Evas_Object *obj, Evas_Object *subobj, int x, int y, int w, int h);
   EAPI void         elm_grid_unpack(Evas_Object *obj, Evas_Object *subobj);
   EAPI void         elm_grid_clear(Evas_Object *obj, Eina_Bool clear);
   EAPI void         elm_grid_pack_set(Evas_Object *subobj, int x, int y, int w, int h);
   EAPI void         elm_grid_pack_get(Evas_Object *subobj, int *x, int *y, int *w, int *h);

   EAPI Evas_Object *elm_genscroller_add(Evas_Object *parent);
   EAPI void         elm_genscroller_world_size_set(Evas_Object *obj, Evas_Coord w, Evas_Coord h);

   EAPI Evas_Object *elm_video_add(Evas_Object *parent);
   EAPI void elm_video_file_set(Evas_Object *video, const char *filename);
   EAPI void elm_video_uri_set(Evas_Object *video, const char *uri);
   EAPI Evas_Object *elm_video_emotion_get(Evas_Object *video);
   EAPI void elm_video_play(Evas_Object *video);
   EAPI void elm_video_pause(Evas_Object *video);
   EAPI void elm_video_stop(Evas_Object *video);
   EAPI Eina_Bool elm_video_is_playing(Evas_Object *video);
   EAPI Eina_Bool elm_video_is_seekable(Evas_Object *video);
   EAPI Eina_Bool elm_video_audio_mute_get(Evas_Object *video);
   EAPI void elm_video_audio_mute_set(Evas_Object *video, Eina_Bool mute);
   EAPI double elm_video_audio_level_get(Evas_Object *video);
   EAPI void elm_video_audio_level_set(Evas_Object *video, double volume);
   EAPI double elm_video_play_position_get(Evas_Object *video);
   EAPI void elm_video_play_position_set(Evas_Object *video, double position);
   EAPI double elm_video_play_length_get(Evas_Object *video);
   EAPI void elm_video_remember_position_set(Evas_Object *video, Eina_Bool remember);
   EAPI Eina_Bool elm_video_remember_position_get(Evas_Object *video);
   EAPI const char *elm_video_title_get(Evas_Object *video);

   EAPI Evas_Object *elm_player_add(Evas_Object *parent);
   EAPI void elm_player_video_set(Evas_Object *player, Evas_Object *video);

  /* naviframe */
   typedef struct _Elm_Naviframe_Item Elm_Naviframe_Item;

   typedef enum
     {
        ELM_NAVIFRAME_PREV_BUTTON,
        ELM_NAVIFRAME_NEXT_BUTTON
     } Elm_Naviframe_Button_Type;

   EAPI Evas_Object        *elm_naviframe_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Elm_Naviframe_Item *elm_naviframe_item_push(Evas_Object *obj, const char *title_label, Evas_Object *prev_btn, Evas_Object *next_btn, Evas_Object *content, const char *item_style) EINA_ARG_NONNULL(1, 5);
   EAPI Evas_Object        *elm_naviframe_item_pop(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_naviframe_content_preserve_on_pop_set(Evas_Object *obj, Eina_Bool preserve) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool           elm_naviframe_content_preserve_on_pop_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_naviframe_item_content_set(Elm_Naviframe_Item *item, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object        *elm_naviframe_item_content_get(const Elm_Naviframe_Item *it) EINA_ARG_NONNULL(1);
   EAPI void                elm_naviframe_item_title_label_set(Elm_Naviframe_Item *it, const char *label) EINA_ARG_NONNULL(1);
   EAPI const char         *elm_naviframe_item_title_label_get(const Elm_Naviframe_Item *it) EINA_ARG_NONNULL(1);
   EAPI void                elm_naviframe_item_subtitle_label_set(Elm_Naviframe_Item *it, const char *label) EINA_ARG_NONNULL(1);
   EAPI const char         *elm_naviframe_item_subtitle_label_get(const Elm_Naviframe_Item *it) EINA_ARG_NONNULL(1);
   EAPI Elm_Naviframe_Item *elm_naviframe_top_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Naviframe_Item *elm_naviframe_bottom_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_naviframe_item_button_set(Elm_Naviframe_Item *it, Evas_Object *btn, Elm_Naviframe_Button_Type btn_type) EINA_ARG_NONNULL(1);
   EAPI Evas_Object        *elm_naviframe_item_button_get(const Elm_Naviframe_Item *it, Elm_Naviframe_Button_Type btn_type) EINA_ARG_NONNULL(1);
   EAPI void                elm_naviframe_item_icon_set(Elm_Naviframe_Item *it, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI Evas_Object        *elm_naviframe_item_icon_get(const Elm_Naviframe_Item *it) EINA_ARG_NONNULL(1);
   EAPI void                elm_naviframe_item_style_set(Elm_Naviframe_Item *it, const char *item_style) EINA_ARG_NONNULL(1);
   EAPI const char         *elm_naviframe_item_style_get(const Elm_Naviframe_Item *it) EINA_ARG_NONNULL(1);
   EAPI void                elm_naviframe_item_title_visible_set(Elm_Naviframe_Item *it, Eina_Bool visible) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool           elm_naviframe_item_title_visible_get(const Elm_Naviframe_Item *it) EINA_ARG_NONNULL(1);

#ifdef __cplusplus
}
#endif

#endif
