/*
 *
 * vim:ts=8:sw=3:sts=3:expandtab:cino=>5n-3f0^-2{2(0W1st0
 */

/**
@file Elementary.h.in
@brief Elementary Widget Library
*/

/**
@mainpage Elementary
@image html  elementary.png
@version @PACKAGE_VERSION@
@author Carsten Haitzler <raster@@rasterman.com>
@author Gustavo Sverzut Barbieri <barbieri@@profusion.mobi>
@author Cedric Bail <cedric.bail@@free.fr>
@author Vincent Torri <vtorri@@univ-evry.fr>
@author Daniel Kolesa <quaker66@@gmail.com>
@author Jaime Thomas <avi.thomas@@gmail.com>
@author Swisscom - http://www.swisscom.ch/
@author Christopher Michael <devilhorns@@comcast.net>
@author Marco Trevisan (Treviño) <mail@@3v1n0.net>
@author Michael Bouchaud <michael.bouchaud@@gmail.com>
@author Jonathan Atton (Watchwolf) <jonathan.atton@@gmail.com>
@author Brian Wang <brian.wang.0721@@gmail.com>
@author Mike Blumenkrantz (zmike) <mike@@zentific.com>
@author Samsung Electronics <tbd>
@author Samsung SAIT <tbd>
@author Brett Nash <nash@@nash.id.au>
@author Bruno Dilly <bdilly@@profusion.mobi>
@author Rafael Fonseca <rfonseca@@profusion.mobi>
@author Chuneon Park <hermet@@hermet.pe.kr>
@author Woohyun Jung <wh0705.jung@@samsung.com>
@author Jaehwan Kim <jae.hwan.kim@@samsung.com>
@author Wonguk Jeong <wonguk.jeong@@samsung.com>
@author Leandro A. F. Pereira <leandro@@profusion.mobi>
@author Helen Fornazier <helen.fornazier@@profusion.mobi>
@author Gustavo Lima Chaves <glima@@profusion.mobi>
@author Fabiano Fidêncio <fidencio@@profusion.mobi>
@author Tiago Falcão <tiago@@profusion.mobi>
@author Otavio Pontes <otavio@@profusion.mobi>
@author Viktor Kojouharov <vkojouharov@@gmail.com>
@author Daniel Juyung Seo (SeoZ) <juyung.seo@@samsung.com> <seojuyung2@@gmail.com>
@author Sangho Park <sangho.g.park@@samsung.com> <gouache95@@gmail.com>
@author Rajeev Ranjan (Rajeev) <rajeev.r@@samsung.com> <rajeev.jnnce@@gmail.com>
@author Seunggyun Kim <sgyun.kim@@samsung.com> <tmdrbs@@gmail.com>
@author Sohyun Kim <anna1014.kim@@samsung.com> <sohyun.anna@@gmail.com>
@author Jihoon Kim <jihoon48.kim@@samsung.com>
@author Jeonghyun Yun (arosis) <jh0506.yun@@samsung.com>
@author Tom Hacohen <tom@@stosb.com>
@author Aharon Hillel <a.hillel@@partner.samsung.com>
@author Jonathan Atton (Watchwolf) <jonathan.atton@@gmail.com>
@author Shinwoo Kim <kimcinoo@@gmail.com>
@author Govindaraju SM <govi.sm@@samsung.com> <govism@@gmail.com>
@author Prince Kumar Dubey <prince.dubey@@samsung.com> <prince.dubey@@gmail.com>
@date 2008-2011

@section intro What is Elementary?

This is a VERY SIMPLE toolkit. It is not meant for writing extensive desktop
applications (yet). Small simple ones with simple needs.

It is meant to make the programmers work almost brainless but give them lots
of flexibility.

License: LGPL v2 (see COPYING in the base of Elementary's source). This
applies to all files in the source here.

Acknowledgements: There is a lot that goes into making a widget set, and
they don't happen out of nothing. It's like trying to make everyone
everywhere happy, regardless of age, gender, race or nationality - and
that is really tough. So thanks to people and organisations behind this,
aslisted in the Authors section above.

@verbatim
Pants
@endverbatim
*/

#ifndef ELEMENTARY_H
#define ELEMENTARY_H

/**
 * @file Elementary.h
 * @brief Elementary's API
 *
 * Elementary API.
 */

@ELM_UNIX_DEF@ ELM_UNIX
@ELM_WIN32_DEF@ ELM_WIN32
@ELM_WINCE_DEF@ ELM_WINCE
@ELM_EDBUS_DEF@ ELM_EDBUS
@ELM_EFREET_DEF@ ELM_EFREET
@ELM_ETHUMB_DEF@ ELM_ETHUMB
@ELM_EMAP_DEF@ ELM_EMAP
@ELM_DEBUG_DEF@ ELM_DEBUG
@ELM_ALLOCA_H_DEF@ ELM_ALLOCA_H
@ELM_LIBINTL_H_DEF@ ELM_LIBINTL_H

/* Standard headers for standard system calls etc. */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/param.h>
#include <dlfcn.h>
#include <math.h>
#include <fnmatch.h>
#include <limits.h>
#include <ctype.h>
#include <time.h>
#include <dirent.h>
#include <pwd.h>
#include <errno.h>

#ifdef ELM_UNIX
# include <locale.h>
# ifdef ELM_LIBINTL_H
#  include <libintl.h>
# endif
# include <signal.h>
# include <grp.h>
# include <glob.h>
#endif

#ifdef ELM_ALLOCA_H
# include <alloca.h>
#endif

#if defined (ELM_WIN32) || defined (ELM_WINCE)
# include <malloc.h>
# ifndef alloca
#  define alloca _alloca
# endif
#endif


/* EFL headers */
#include <Eina.h>
#include <Eet.h>
#include <Evas.h>
#include <Evas_GL.h>
#include <Ecore.h>
#include <Ecore_Evas.h>
#include <Ecore_File.h>
#include <Ecore_IMF.h>
#include <Edje.h>

#ifdef ELM_EDBUS
# include <E_DBus.h>
#endif

#ifdef ELM_EFREET
# include <Efreet.h>
# include <Efreet_Mime.h>
# include <Efreet_Trash.h>
#endif

#ifdef ELM_ETHUMB
# include <Ethumb_Client.h>
#endif

#ifdef ELM_EMAP
# include <EMap.h>
#endif

#ifdef EAPI
# undef EAPI
#endif

#ifdef _WIN32
# ifdef ELEMENTARY_BUILD
#  ifdef DLL_EXPORT
#   define EAPI __declspec(dllexport)
#  else
#   define EAPI
#  endif /* ! DLL_EXPORT */
# else
#  define EAPI __declspec(dllimport)
# endif /* ! EFL_EVAS_BUILD */
#else
# ifdef __GNUC__
#  if __GNUC__ >= 4
#   define EAPI __attribute__ ((visibility("default")))
#  else
#   define EAPI
#  endif
# else
#  define EAPI
# endif
#endif /* ! _WIN32 */


/* allow usage from c++ */
#ifdef __cplusplus
extern "C" {
#endif

#define ELM_VERSION_MAJOR @VMAJ@
#define ELM_VERSION_MINOR @VMIN@

   typedef struct _Elm_Version
     {
        int major;
        int minor;
        int micro;
        int revision;
     } Elm_Version;

   EAPI extern Elm_Version *elm_version;

/* handy macros */
#define ELM_RECTS_INTERSECT(x, y, w, h, xx, yy, ww, hh) (((x) < ((xx) + (ww))) && ((y) < ((yy) + (hh))) && (((x) + (w)) > (xx)) && (((y) + (h)) > (yy)))
#define ELM_PI 3.14159265358979323846

   /**
    * @defgroup General General
    *
    * @brief General Elementary API. Functions that don't relate to
    * Elementary objects specifically.
    *
    * Here are documented functions which init/shutdown the library,
    * that apply to generic Elementary objects, that deal with
    * configuration, et cetera.
    *
    * @ref general_functions_example_page "This" example contemplates
    * some of these functions.
    */

   /**
    * @addtogroup General
    * @{
    */

  /**
   * Defines couple of standard Evas_Object layers to be used
   * with evas_object_layer_set().
   *
   * @note whenever extending with new values, try to keep some padding
   *       to siblings so there is room for further extensions.
   */
  typedef enum _Elm_Object_Layer
    {
       ELM_OBJECT_LAYER_BACKGROUND = EVAS_LAYER_MIN + 64, /**< where to place backgrounds */
       ELM_OBJECT_LAYER_DEFAULT = 0, /**< Evas_Object default layer (and thus for Elementary) */
       ELM_OBJECT_LAYER_FOCUS = EVAS_LAYER_MAX - 128, /**< where focus object visualization is */
       ELM_OBJECT_LAYER_TOOLTIP = EVAS_LAYER_MAX - 64, /**< where to show tooltips */
       ELM_OBJECT_LAYER_CURSOR = EVAS_LAYER_MAX - 32, /**< where to show cursors */
       ELM_OBJECT_LAYER_LAST /**< last layer known by Elementary */
    } Elm_Object_Layer;

/**************************************************************************/
   EAPI extern int ELM_ECORE_EVENT_ETHUMB_CONNECT;

   /**
    * Emitted when any Elementary's policy value is changed.
    */
   EAPI extern int ELM_EVENT_POLICY_CHANGED;

   /**
    * @typedef Elm_Event_Policy_Changed
    *
    * Data on the event when an Elementary policy has changed
    */
    typedef struct _Elm_Event_Policy_Changed Elm_Event_Policy_Changed;

   /**
    * @struct _Elm_Event_Policy_Changed
    *
    * Data on the event when an Elementary policy has changed
    */
    struct _Elm_Event_Policy_Changed
     {
        unsigned int policy; /**< the policy identifier */
        int          new_value; /**< value the policy had before the change */
        int          old_value; /**< new value the policy got */
    };

   /**
    * Policy identifiers.
    */
    typedef enum _Elm_Policy
    {
        ELM_POLICY_QUIT, /**< under which circunstances the application
                          * should quit automatically. @see
                          * Elm_Policy_Quit.
                          */
        ELM_POLICY_LAST
    } Elm_Policy; /**< Elementary policy identifiers/groups enumeration.  @see elm_policy_set()
 */

   typedef enum _Elm_Policy_Quit
     {
        ELM_POLICY_QUIT_NONE = 0, /**< never quit the application
                                   * automatically */
        ELM_POLICY_QUIT_LAST_WINDOW_CLOSED /**< quit when the
                                            * application's last
                                            * window is closed */
     } Elm_Policy_Quit; /**< Possible values for the #ELM_POLICY_QUIT policy */

   typedef enum _Elm_Focus_Direction
     {
        ELM_FOCUS_PREVIOUS,
        ELM_FOCUS_NEXT
     } Elm_Focus_Direction;

   typedef enum _Elm_Text_Format
     {
        ELM_TEXT_FORMAT_PLAIN_UTF8,
        ELM_TEXT_FORMAT_MARKUP_UTF8
     } Elm_Text_Format;

   /**
    * Line wrapping types.
    */
   typedef enum _Elm_Wrap_Type
     {
        ELM_WRAP_NONE = 0, /**< No wrap - value is zero */
        ELM_WRAP_CHAR, /**< Char wrap - wrap between graphmes */
        ELM_WRAP_WORD, /**< Word wrap - wrap in allowed wrapping points (as defined in the unicode standard) */
        ELM_WRAP_MIXED, /**< Mixed wrap - Word wrap, and if that fails, char wrap. */
        ELM_WRAP_LAST
     } Elm_Wrap_Type;


   /**
    * Called back when a widget's tooltip is activated and needs content.
    * @param data user-data given to elm_object_tooltip_content_cb_set()
    * @param obj owner widget.
    */
   typedef Evas_Object *(*Elm_Tooltip_Content_Cb) (void *data, Evas_Object *obj);

   /**
    * Called back when a widget's item tooltip is activated and needs content.
    * @param data user-data given to elm_object_tooltip_content_cb_set()
    * @param obj owner widget.
    * @param item context dependent item. As an example, if tooltip was
    *        set on Elm_List_Item, then it is of this type.
    */
   typedef Evas_Object *(*Elm_Tooltip_Item_Content_Cb) (void *data, Evas_Object *obj, void *item);

   typedef Eina_Bool (*Elm_Event_Cb) (void *data, Evas_Object *obj, Evas_Object *src, Evas_Callback_Type type, void *event_info);

#ifndef ELM_LIB_QUICKLAUNCH
#define ELM_MAIN() int main(int argc, char **argv) {elm_init(argc, argv); return elm_main(argc, argv);} /**< macro to be used after the elm_main() function */
#else
#define ELM_MAIN() int main(int argc, char **argv) {return elm_quicklaunch_fallback(argc, argv);} /**< macro to be used after the elm_main() function */
#endif

/**************************************************************************/
   /* General calls */

   /**
    * Initialize Elementary
    *
    * @param[in] argc System's argument count value
    * @param[in] argv System's pointer to array of argument strings
    * @return The init counter value.
    *
    * This function initializes Elementary and increments a counter of
    * the number of calls to it. It returs the new counter's value.
    *
    * @warning This call is exported only for use by the @c ELM_MAIN()
    * macro. There is no need to use this if you use this macro (which
    * is highly advisable). An elm_main() should contain the entry
    * point code for your application, having the same prototype as
    * elm_init(), and @b not being static (putting the @c EAPI symbol
    * in front of its type declaration is advisable). The @c
    * ELM_MAIN() call should be placed just after it.
    *
    * Example:
    * @dontinclude bg_example_01.c
    * @skip static void
    * @until ELM_MAIN
    *
    * See the full @ref bg_example_01_c "example".
    *
    * @see elm_shutdown().
    * @ingroup General
    */
   EAPI int          elm_init(int argc, char **argv);

   /**
    * Shut down Elementary
    *
    * @return The init counter value.
    *
    * This should be called at the end of your application, just
    * before it ceases to do any more processing. This will clean up
    * any permanent resources your application may have allocated via
    * Elementary that would otherwise persist.
    *
    * @see elm_init() for an example
    *
    * @ingroup General
    */
   EAPI int          elm_shutdown(void);

   /**
    * Run Elementary's main loop
    *
    * This call should be issued just after all initialization is
    * completed. This function will not return until elm_exit() is
    * called. It will keep looping, running the main
    * (event/processing) loop for Elementary.
    *
    * @see elm_init() for an example
    *
    * @ingroup General
    */
   EAPI void         elm_run(void);

   /**
    * Exit Elementary's main loop
    *
    * If this call is issued, it will flag the main loop to cease
    * processing and return back to its parent function (usually your
    * elm_main() function).
    *
    * @see elm_init() for an example. There, just after a request to
    * close the window comes, the main loop will be left.
    *
    * @note By using the #ELM_POLICY_QUIT on your Elementary
    * applications, you'll this function called automatically for you.
    *
    * @ingroup General
    */
   EAPI void         elm_exit(void);

   /**
    * Provide information in order to make Elementary determine the @b
    * run time location of the software in question, so other data files
    * such as images, sound files, executable utilities, libraries,
    * modules and locale files can be found.
    *
    * @param mainfunc This is your application's main function name,
    *        whose binary's location is to be found. Providing @c NULL
    *        will make Elementary not to use it
    * @param dom This will be used as the application's "domain", in the
    *        form of a prefix to any environment variables that may
    *        override prefix detection and the directory name, inside the
    *        standard share or data directories, where the software's
    *        data files will be looked for.
    * @param checkfile This is an (optional) magic file's path to check
    *        for existence (and it must be located in the data directory,
    *        under the share directory provided above). Its presence will
    *        help determine the prefix found was correct. Pass @c NULL if
    *        the check is not to be done.
    *
    * This function allows one to re-locate the application somewhere
    * else after compilation, if the developer wishes for easier
    * distribution of pre-compiled binaries.
    *
    * The prefix system is designed to locate where the given software is
    * installed (under a common path prefix) at run time and then report
    * specific locations of this prefix and common directories inside
    * this prefix like the binary, library, data and locale directories,
    * through the @c elm_app_*_get() family of functions.
    *
    * Call elm_app_info_set() early on before you change working
    * directory or anything about @c argv[0], so it gets accurate
    * information.
    *
    * It will then try and trace back which file @p mainfunc comes from,
    * if provided, to determine the application's prefix directory.
    *
    * The @p dom parameter provides a string prefix to prepend before
    * environment variables, allowing a fallback to @b specific
    * environment variables to locate the software. You would most
    * probably provide a lowercase string there, because it will also
    * serve as directory domain, explained next. For environment
    * variables purposes, this string is made uppercase. For example if
    * @c "myapp" is provided as the prefix, then the program would expect
    * @c "MYAPP_PREFIX" as a master environment variable to specify the
    * exact install prefix for the software, or more specific environment
    * variables like @c "MYAPP_BIN_DIR", @c "MYAPP_LIB_DIR", @c
    * "MYAPP_DATA_DIR" and @c "MYAPP_LOCALE_DIR", which could be set by
    * the user or scripts before launching. If not provided (@c NULL),
    * environment variables will not be used to override compiled-in
    * defaults or auto detections.
    *
    * The @p dom string also provides a subdirectory inside the system
    * shared data directory for data files. For example, if the system
    * directory is @c /usr/local/share, then this directory name is
    * appended, creating @c /usr/local/share/myapp, if it @p was @c
    * "myapp". It is expected the application installs data files in
    * this directory.
    *
    * The @p checkfile is a file name or path of something inside the
    * share or data directory to be used to test that the prefix
    * detection worked. For example, your app will install a wallpaper
    * image as @c /usr/local/share/myapp/images/wallpaper.jpg and so to
    * check that this worked, provide @c "images/wallpaper.jpg" as the @p
    * checkfile string.
    *
    * @see elm_app_compile_bin_dir_set()
    * @see elm_app_compile_lib_dir_set()
    * @see elm_app_compile_data_dir_set()
    * @see elm_app_compile_locale_set()
    * @see elm_app_prefix_dir_get()
    * @see elm_app_bin_dir_get()
    * @see elm_app_lib_dir_get()
    * @see elm_app_data_dir_get()
    * @see elm_app_locale_dir_get()
    */
   EAPI void         elm_app_info_set(void *mainfunc, const char *dom, const char *checkfile);

   /**
    * Provide information on the @b fallback application's binaries
    * directory, on scenarios where they get overriden by
    * elm_app_info_set().
    *
    * @param dir The path to the default binaries directory (compile time
    * one)
    *
    * @note Elementary will as well use this path to determine actual
    * names of binaries' directory paths, maybe changing it to be @c
    * something/local/bin instead of @c something/bin, only, for
    * example.
    *
    * @warning You should call this function @b before
    * elm_app_info_set().
    */
   EAPI void         elm_app_compile_bin_dir_set(const char *dir);

   /**
    * Provide information on the @b fallback application's libraries
    * directory, on scenarios where they get overriden by
    * elm_app_info_set().
    *
    * @param dir The path to the default libraries directory (compile
    * time one)
    *
    * @note Elementary will as well use this path to determine actual
    * names of libraries' directory paths, maybe changing it to be @c
    * something/lib32 or @c something/lib64 instead of @c something/lib,
    * only, for example.
    *
    * @warning You should call this function @b before
    * elm_app_info_set().
    */
   EAPI void         elm_app_compile_lib_dir_set(const char *dir);

   /**
    * Provide information on the @b fallback application's data
    * directory, on scenarios where they get overriden by
    * elm_app_info_set().
    *
    * @param dir The path to the default data directory (compile time
    * one)
    *
    * @note Elementary will as well use this path to determine actual
    * names of data directory paths, maybe changing it to be @c
    * something/local/share instead of @c something/share, only, for
    * example.
    *
    * @warning You should call this function @b before
    * elm_app_info_set().
    */
   EAPI void         elm_app_compile_data_dir_set(const char *dir);

   /**
    * Provide information on the @b fallback application's locale
    * directory, on scenarios where they get overriden by
    * elm_app_info_set().
    *
    * @param dir The path to the default locale directory (compile time
    * one)
    *
    * @warning You should call this function @b before
    * elm_app_info_set().
    */
   EAPI void         elm_app_compile_locale_set(const char *dir);

   /**
    * Retrieve the application's run time prefix directory, as set by
    * elm_app_info_set() and the way (environment) the application was
    * run from.
    *
    * @return The directory prefix the application is actually using
    */
   EAPI const char  *elm_app_prefix_dir_get(void);

   /**
    * Retrieve the application's run time binaries prefix directory, as
    * set by elm_app_info_set() and the way (environment) the application
    * was run from.
    *
    * @return The binaries directory prefix the application is actually
    * using
    */
   EAPI const char  *elm_app_bin_dir_get(void);

   /**
    * Retrieve the application's run time libraries prefix directory, as
    * set by elm_app_info_set() and the way (environment) the application
    * was run from.
    *
    * @return The libraries directory prefix the application is actually
    * using
    */
   EAPI const char  *elm_app_lib_dir_get(void);

   /**
    * Retrieve the application's run time data prefix directory, as
    * set by elm_app_info_set() and the way (environment) the application
    * was run from.
    *
    * @return The data directory prefix the application is actually
    * using
    */
   EAPI const char  *elm_app_data_dir_get(void);

   /**
    * Retrieve the application's run time locale prefix directory, as
    * set by elm_app_info_set() and the way (environment) the application
    * was run from.
    *
    * @return The locale directory prefix the application is actually
    * using
    */
   EAPI const char  *elm_app_locale_dir_get(void);

   EAPI void         elm_quicklaunch_mode_set(Eina_Bool ql_on);
   EAPI Eina_Bool    elm_quicklaunch_mode_get(void);
   EAPI int          elm_quicklaunch_init(int argc, char **argv);
   EAPI int          elm_quicklaunch_sub_init(int argc, char **argv);
   EAPI int          elm_quicklaunch_sub_shutdown(void);
   EAPI int          elm_quicklaunch_shutdown(void);
   EAPI void         elm_quicklaunch_seed(void);
   EAPI Eina_Bool    elm_quicklaunch_prepare(int argc, char **argv);
   EAPI Eina_Bool    elm_quicklaunch_fork(int argc, char **argv, char *cwd, void (postfork_func) (void *data), void *postfork_data);
   EAPI void         elm_quicklaunch_cleanup(void);
   EAPI int          elm_quicklaunch_fallback(int argc, char **argv);
   EAPI char        *elm_quicklaunch_exe_path_get(const char *exe);

   EAPI Eina_Bool    elm_need_efreet(void);
   EAPI Eina_Bool    elm_need_e_dbus(void);
   EAPI Eina_Bool    elm_need_ethumb(void);

   /**
    * Set a new policy's value (for a given policy group/identifier).
    *
    * @param policy policy identifier, as in @ref Elm_Policy.
    * @param value policy value, which depends on the identifier
    *
    * @return @c EINA_TRUE on success or @c EINA_FALSE, on error.
    *
    * Elementary policies define applications' behavior,
    * somehow. These behaviors are divided in policy groups (see
    * #Elm_Policy enumeration). This call will emit the Ecore event
    * #ELM_EVENT_POLICY_CHANGED, which can be hooked at with
    * handlers. An #Elm_Event_Policy_Changed struct will be passed,
    * then.
    *
    * @note Currently, we have only one policy identifier/group
    * (#ELM_POLICY_QUIT), which has two possible values.
    *
    * @ingroup General
    */
   EAPI Eina_Bool    elm_policy_set(unsigned int policy, int value);

   /**
    * Gets the policy value set for given policy identifier.
    *
    * @param policy policy identifier, as in #Elm_Policy.
    * @return The currently set policy value, for that
    * identifier. Will be @c 0 if @p policy passed is invalid.
    *
    * @ingroup General
    */
   EAPI int          elm_policy_get(unsigned int policy);

   /**
    * Set a label of an object
    *
    * @param obj The Elementary object
    * @param item The label id to set (NULL for the default label)
    * @param label The new text of the label
    *
    * @note Elementary objects may have many labels (e.g. Action Slider)
    *
    * @ingroup General
    */
   EAPI void         elm_object_text_part_set(Evas_Object *obj, const char *item, const char *label);

#define elm_object_text_set(obj, label) elm_object_text_part_set((obj), NULL, (label))

   /**
    * Get a label of an object
    *
    * @param obj The Elementary object
    * @param item The label id to get (NULL for the default label)
    * @return text of the label or
    *         NULL for any error
    *
    * @note Elementary objects may have many labels (e.g. Action Slider)
    *
    * @ingroup General
    */
   EAPI const char  *elm_object_text_part_get(const Evas_Object *obj, const char *item);

#define elm_object_text_get(obj) elm_object_text_part_get((obj), NULL)

   /**
    * @}
    */

   EAPI void         elm_all_flush(void);
   EAPI int          elm_cache_flush_interval_get(void);
   EAPI void         elm_cache_flush_interval_set(int size);
   EAPI void         elm_cache_flush_interval_all_set(int size);
   EAPI Eina_Bool    elm_cache_flush_enabled_get(void);
   EAPI void         elm_cache_flush_enabled_set(Eina_Bool enabled);
   EAPI void         elm_cache_flush_enabled_all_set(Eina_Bool enabled);
   EAPI int          elm_font_cache_get(void);
   EAPI void         elm_font_cache_set(int size);
   EAPI void         elm_font_cache_all_set(int size);
   EAPI int          elm_image_cache_get(void);
   EAPI void         elm_image_cache_set(int size);
   EAPI void         elm_image_cache_all_set(int size);
   EAPI int          elm_edje_file_cache_get(void);
   EAPI void         elm_edje_file_cache_set(int size);
   EAPI void         elm_edje_file_cache_all_set(int size);
   EAPI int          elm_edje_collection_cache_get(void);
   EAPI void         elm_edje_collection_cache_set(int size);
   EAPI void         elm_edje_collection_cache_all_set(int size);

   /**
    * @defgroup Scaling Selective Widget Scaling
    *
    * Different widgets can be scaled independently. These functions
    * allow you to manipulate this scaling on a per-widget basis. The
    * object and all its children get their scaling factors multiplied
    * by the scale factor set. This is multiplicative, in that if a
    * child also has a scale size set it is in turn multiplied by its
    * parent's scale size. @c 1.0 means “don't scale”, @c 2.0 is
    * double size, @c 0.5 is half, etc.
    *
    * @ref general_functions_example_page "This" example contemplates
    * some of these functions.
    */

   /**
    * Set the scaling factor for a given Elementary object
    *
    * @param obj The Elementary to operate on
    * @param scale Scale factor (from @c 0.0 up, with @c 1.0 meaning
    * no scaling)
    *
    * @ingroup Scaling
    */
   EAPI void         elm_object_scale_set(Evas_Object *obj, double scale) EINA_ARG_NONNULL(1);

   /**
    * Get the scaling factor for a given Elementary object
    *
    * @param obj The object
    * @return The scaling factor set by elm_object_scale_set()
    *
    * @ingroup Scaling
    */
   EAPI double       elm_object_scale_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_object_mirrored_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_mirrored_set(Evas_Object *obj, Eina_Bool mirrored) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_object_mirrored_automatic_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_mirrored_automatic_set(Evas_Object *obj, Eina_Bool automatic) EINA_ARG_NONNULL(1);
   /**
    * Set the style to use by a widget
    *
    * Sets the style name that will define the appearance of a widget. Styles
    * vary from widget to widget and may also be defined by other themes
    * by means of extensions and overlays.
    *
    * @param obj The Elementary widget to style
    * @param style The style name to use
    *
    * @see elm_theme_extension_add()
    * @see elm_theme_overlay_add()
    *
    * @ingroup Theme
    */
   EAPI void         elm_object_style_set(Evas_Object *obj, const char *style) EINA_ARG_NONNULL(1);
   /**
    * Get the style used by the widget
    *
    * This gets the style being used for that widget. Note that the string
    * pointer is only valid as longas the object is valid and the style doesn't
    * change.
    *
    * @param obj The Elementary widget to query for its style
    * @return The style name used
    *
    * @see elm_object_style_set()
    *
    * @ingroup Theme
    */
   EAPI const char  *elm_object_style_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @defgroup Styles Styles
    *
    * Widgets can have different styles of look. These generic API's
    * set styles of widgets, if they support them (and if the theme(s)
    * do).
    *
    * @ref general_functions_example_page "This" example contemplates
    * some of these functions.
    */

   /**
    * Set the disabled state of an Elementary object.
    *
    * @param obj The Elementary object to operate on
    * @param disabled The state to put in in: @c EINA_TRUE for
    *        disabled, @c EINA_FALSE for enabled
    *
    * Elementary objects can be @b disabled, in which state they won't
    * receive input and, in general, will be themed differently from
    * their normal state, usually greyed out. Useful for contexts
    * where you don't want your users to interact with some of the
    * parts of you interface.
    *
    * This sets the state for the widget, either disabling it or
    * enabling it back.
    *
    * @ingroup Styles
    */
   EAPI void         elm_object_disabled_set(Evas_Object *obj, Eina_Bool disabled) EINA_ARG_NONNULL(1);

   /**
    * Get the disabled state of an Elementary object.
    *
    * @param obj The Elementary object to operate on
    * @return @c EINA_TRUE, if the widget is disabled, @c EINA_FALSE
    *            if it's enabled (or on errors)
    *
    * This gets the state of the widget, which might be enabled or disabled.
    *
    * @ingroup Styles
    */
   EAPI Eina_Bool    elm_object_disabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * @defgroup WidgetNavigation Widget Tree Navigation.
    *
    * How to check if an Evas Object is an Elementary widget? How to
    * get the first elementary widget that is parent of the given
    * object?  These are all covered in widget tree navigation.
    *
    * @ref general_functions_example_page "This" example contemplates
    * some of these functions.
    */

   EAPI Eina_Bool    elm_object_widget_check(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the first parent of the given object that is an Elementary
    * widget.
    *
    * @param obj the Elementary object to query parent from.
    * @return the parent object that is an Elementary widget, or @c
    *         NULL, if it was not found.
    *
    * Use this to query for an object's parent widget.
    *
    * @note Most of Elementary users wouldn't be mixing non-Elementary
    * smart objects in the objects tree of an application, as this is
    * an advanced usage of Elementary with Evas. So, except for the
    * application's window, which is the root of that tree, all other
    * objects would have valid Elementary widget parents.
    *
    * @ingroup WidgetNavigation
    */
   EAPI Evas_Object *elm_object_parent_widget_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_object_top_widget_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_object_widget_type_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   EAPI double       elm_scale_get(void);
   EAPI void         elm_scale_set(double scale);
   EAPI void         elm_scale_all_set(double scale);

   EAPI Eina_Bool    elm_mirrored_get(void);
   EAPI void         elm_mirrored_set(Eina_Bool mirrored);

   EAPI Eina_Bool    elm_config_save(void);
   EAPI void         elm_config_reload(void);

   EAPI const char  *elm_profile_current_get(void);
   EAPI const char  *elm_profile_dir_get(const char *profile, Eina_Bool is_user);
   EAPI void         elm_profile_dir_free(const char *p_dir);
   EAPI Eina_List   *elm_profile_list_get(void);
   EAPI void         elm_profile_list_free(Eina_List *l);
   EAPI void         elm_profile_set(const char *profile);
   EAPI void         elm_profile_all_set(const char *profile);

   EAPI const char  *elm_engine_current_get(void);
   EAPI void         elm_engine_set(const char *engine);

  typedef struct _Elm_Text_Class
    {
       const char *name;
       const char *desc;
    } Elm_Text_Class;

  typedef struct _Elm_Font_Overlay
    {
       const char     *text_class;
       const char     *font;
       Evas_Font_Size  size;
    } Elm_Font_Overlay;

  typedef struct _Elm_Font_Properties
    {
       const char *name;
       Eina_List  *styles;
    } Elm_Font_Properties;

   EAPI const Eina_List     *elm_text_classes_list_get(void);
   EAPI void                 elm_text_classes_list_free(const Eina_List *list);

   EAPI const Eina_List     *elm_font_overlay_list_get(void);
   EAPI void                 elm_font_overlay_set(const char *text_class, const char *font, Evas_Font_Size size);
   EAPI void                 elm_font_overlay_unset(const char *text_class);
   EAPI void                 elm_font_overlay_apply(void);
   EAPI void                 elm_font_overlay_all_apply(void);

   EAPI Elm_Font_Properties *elm_font_properties_get(const char *font) EINA_ARG_NONNULL(1);
   EAPI void                 elm_font_properties_free(Elm_Font_Properties *efp) EINA_ARG_NONNULL(1);
   EAPI const char          *elm_font_fontconfig_name_get(const char *name, const char *style) EINA_ARG_NONNULL(1);
   EAPI void                 elm_font_fontconfig_name_free(const char *name) EINA_ARG_NONNULL(1);
   EAPI Eina_Hash           *elm_font_available_hash_add(Eina_List *list);
   EAPI void                 elm_font_available_hash_del(Eina_Hash *hash);

   /**
    * @defgroup Fingers Fingers
    *
    * Elementary is designed to be finger-friendly for touchscreens,
    * and so in addition to scaling for display resolution, it can
    * also scale based on finger "resolution" (or size). You can then
    * customize the granularity of the areas meant to receive clicks
    * on touchscreens.
    *
    * Different profiles may have pre-set values for finger sizes.
    *
    * @ref general_functions_example_page "This" example contemplates
    * some of these functions.
    */

   /**
    * Get the configured "finger size"
    *
    * @return The finger size
    *
    * This gets the globally configured finger size, <b>in pixels</b>
    *
    * @ingroup Fingers
    */
   EAPI Evas_Coord       elm_finger_size_get(void);
   EAPI void             elm_finger_size_set(Evas_Coord size);
   EAPI void             elm_finger_size_all_set(Evas_Coord size);

   /**
    * @defgroup Focus Focus
    *
    * An Elementary application has, at all times, one (and only one)
    * @b focused object. This is what determines where the input
    * events go to within the application's window. Also, focused
    * objects can be decorated differently, in order to signal to the
    * user where the input is, at a given moment.
    *
    * Elementary applications also have the concept of <b>focus
    * chain</b>: one can cycle through all the windows' focusable
    * objects by input (tab key) or programmatically. The default
    * focus chain for an application is the one define by the order in
    * which the widgets where added in code. One will cycle through
    * top level widgets, and, for each one containg sub-objects, cycle
    * through them all, before returning to the level
    * above. Elementary also allows one to set @b custom focus chains
    * for their applications.
    *
    * Besides the focused decoration a widget may exhibit, when it
    * gets focus, Elementary has a @b global focus highlight object
    * that can be enabled for a window. If one chooses to do so, this
    * extra highlight effect will surround the current focused object,
    * too.
    *
    * @note Some Elementary widgets are @b unfocusable, after
    * creation, by their very nature: they are not meant to be
    * interacted with input events, but are there just for visual
    * purposes.
    *
    * @ref general_functions_example_page "This" example contemplates
    * some of these functions.
    */

   EAPI Eina_Bool        elm_focus_highlight_enabled_get(void);
   EAPI void             elm_focus_highlight_enabled_set(Eina_Bool enable);
   EAPI Eina_Bool        elm_focus_highlight_animate_get(void);
   EAPI void             elm_focus_highlight_animate_set(Eina_Bool animate);

   /**
    * Get the whether an Elementary object has the focus or not.
    *
    * @param obj The Elementary object to get the information from
    * @return @c EINA_TRUE, if the object is focused, @c EINA_FALSE if
    *            not (and on errors).
    *
    * @see elm_object_focus()
    *
    * @ingroup Focus
    */
   EAPI Eina_Bool        elm_object_focus_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Make a given Elementary object the focused one.
    *
    * @param obj The Elementary object to make focused.
    *
    * @note This object, if it can handle focus, will take the focus
    * away from the one who had it previously and will, for now on, be
    * the one receiving input events.
    *
    * @see elm_object_focus_get()
    *
    * @ingroup Focus
    */
   EAPI void             elm_object_focus(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Remove the focus from an Elementary object
    *
    * @param obj The Elementary to take focus from
    *
    * This removes the focus from @p obj, passing it back to the
    * previous element in the focus chain list.
    *
    * @see elm_object_focus() and elm_object_focus_custom_chain_get()
    *
    * @ingroup Focus
    */
   EAPI void             elm_object_unfocus(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the ability for an Element object to be focused
    *
    * @param obj The Elementary object to operate on
    * @param enable @c EINA_TRUE if the object can be focused, @c
    *        EINA_FALSE if not (and on errors)
    *
    * This sets whether the object @p obj is able to take focus or
    * not. Unfocusable objects do nothing when programmatically
    * focused, being the nearest focusable parent object the one
    * really getting focus. Also, when they receive mouse input, they
    * will get the event, but not take away the focus from where it
    * was previously.
    *
    * @ingroup Focus
    */
   EAPI void             elm_object_focus_allow_set(Evas_Object *obj, Eina_Bool enable) EINA_ARG_NONNULL(1);

   /**
    * Get whether an Elementary object is focusable or not
    *
    * @param obj The Elementary object to operate on
    * @return @c EINA_TRUE if the object is allowed to be focused, @c
    *             EINA_FALSE if not (and on errors)
    *
    * @note Objects which are meant to be interacted with by input
    * events are created able to be focused, by default. All the
    * others are not.
    *
    * @ingroup Focus
    */
   EAPI Eina_Bool        elm_object_focus_allow_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   EAPI void             elm_object_focus_custom_chain_set(Evas_Object *obj, Eina_List *objs) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_focus_custom_chain_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List *elm_object_focus_custom_chain_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_focus_custom_chain_append(Evas_Object *obj, Evas_Object *child, Evas_Object *relative_child) EINA_ARG_NONNULL(1, 2);
   EAPI void             elm_object_focus_custom_chain_prepend(Evas_Object *obj, Evas_Object *child, Evas_Object *relative_child) EINA_ARG_NONNULL(1, 2);
   EAPI void             elm_object_focus_cycle(Evas_Object *obj, Elm_Focus_Direction dir) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_focus_direction_go(Evas_Object *obj, int x, int y) EINA_ARG_NONNULL(1);

   EAPI Eina_Bool        elm_scroll_bounce_enabled_get(void);
   EAPI void             elm_scroll_bounce_enabled_set(Eina_Bool enabled);
   EAPI void             elm_scroll_bounce_enabled_all_set(Eina_Bool enabled);
   EAPI double           elm_scroll_bounce_friction_get(void);
   EAPI void             elm_scroll_bounce_friction_set(double friction);
   EAPI void             elm_scroll_bounce_friction_all_set(double friction);
   EAPI double           elm_scroll_page_scroll_friction_get(void);
   EAPI void             elm_scroll_page_scroll_friction_set(double friction);
   EAPI void             elm_scroll_page_scroll_friction_all_set(double friction);
   EAPI double           elm_scroll_bring_in_scroll_friction_get(void);
   EAPI void             elm_scroll_bring_in_scroll_friction_set(double friction);
   EAPI void             elm_scroll_bring_in_scroll_friction_all_set(double friction);
   EAPI double           elm_scroll_zoom_friction_get(void);
   EAPI void             elm_scroll_zoom_friction_set(double friction);
   EAPI void             elm_scroll_zoom_friction_all_set(double friction);
   EAPI Eina_Bool        elm_scroll_thumbscroll_enabled_get(void);
   EAPI void             elm_scroll_thumbscroll_enabled_set(Eina_Bool enabled);
   EAPI void             elm_scroll_thumbscroll_enabled_all_set(Eina_Bool enabled);
   EAPI unsigned int     elm_scroll_thumbscroll_threshold_get(void);
   EAPI void             elm_scroll_thumbscroll_threshold_set(unsigned int threshold);
   EAPI void             elm_scroll_thumbscroll_threshold_all_set(unsigned int threshold);
   EAPI double           elm_scroll_thumbscroll_momentum_threshold_get(void);
   EAPI void             elm_scroll_thumbscroll_momentum_threshold_set(double threshold);
   EAPI void             elm_scroll_thumbscroll_momentum_threshold_all_set(double threshold);
   EAPI double           elm_scroll_thumbscroll_friction_get(void);
   EAPI void             elm_scroll_thumbscroll_friction_set(double friction);
   EAPI void             elm_scroll_thumbscroll_friction_all_set(double friction);
   EAPI double           elm_scroll_thumbscroll_border_friction_get(void);
   EAPI void             elm_scroll_thumbscroll_border_friction_set(double friction);
   EAPI void             elm_scroll_thumbscroll_border_friction_all_set(double friction);

   EAPI void             elm_object_scroll_hold_push(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_scroll_hold_pop(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_scroll_freeze_push(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_scroll_freeze_pop(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_scroll_lock_x_set(Evas_Object *obj, Eina_Bool lock) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_scroll_lock_y_set(Evas_Object *obj, Eina_Bool lock) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_object_scroll_lock_x_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_object_scroll_lock_y_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   EAPI void             elm_object_signal_emit(Evas_Object *obj, const char *emission, const char *source) EINA_ARG_NONNULL(1);
   EAPI void             elm_object_signal_callback_add(Evas_Object *obj, const char *emission, const char *source, void (*func) (void *data, Evas_Object *o, const char *emission, const char *source), void *data) EINA_ARG_NONNULL(1, 4);
   EAPI void            *elm_object_signal_callback_del(Evas_Object *obj, const char *emission, const char *source, void (*func) (void *data, Evas_Object *o, const char *emission, const char *source)) EINA_ARG_NONNULL(1, 4);

   EAPI void             elm_object_event_callback_add(Evas_Object *obj, Elm_Event_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);
   EAPI void            *elm_object_event_callback_del(Evas_Object *obj, Elm_Event_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);

   /**
    * Adjust size of an element for finger usage.
    *
    * @param times_w How many fingers should fit horizontally
    * @param w Pointer to the width size to adjust
    * @param times_h How many fingers should fit vertically
    * @param h Pointer to the height size to adjust
    *
    * This takes width and height sizes (in pixels) as input and a
    * size multiple (which is how many fingers you want to place
    * within the area, being "finger" the size set by
    * elm_finger_size_set()), and adjusts the size to be large enough
    * to accommodate the resulting size -- if it doesn't already
    * accommodate it. On return the @p w and @p h sizes pointed to by
    * these parameters will be modified, on those conditions.
    *
    * @note This is kind of a low level Elementary call, most useful
    * on size evaluation times for widgets. An external user wouldn't
    * be calling, most of the time.
    *
    * @ingroup Fingers
    */
   EAPI void             elm_coords_finger_size_adjust(int times_w, Evas_Coord *w, int times_h, Evas_Coord *h);

   EAPI double           elm_longpress_timeout_get(void);
   EAPI void             elm_longpress_timeout_set(double longpress_timeout);

   /* debug
    * don't use it unless you are sure
    */
   EAPI void             elm_object_tree_dump(const Evas_Object *top);
   EAPI void             elm_object_tree_dot_dump(const Evas_Object *top, const char *file);


   /* theme */
   /**
    * @defgroup Theme Theme
    *
    * Elementary uses Edje to theme its widgets, naturally. But for the most
    * part this is hidden behind a simpler interface that lets the user set
    * extensions and choose the style of widgets in a much easier way.
    *
    * Instead of thinking in terms of paths to Edje files and their groups
    * each time you want to change the appearance of a widget, Elementary
    * works so you can add any theme file with extensions or replace the
    * main theme at one point in the application, and then just set the style
    * of widgets with elm_object_style_set() and related functions. Elementary
    * will then look in its list of themes for a matching group and apply it,
    * and when the theme changes midway through the application, all widgets
    * will be updated accordingly.
    *
    * There are three concepts you need to know to understand how Elementary
    * theming works: default theme, extensions and overlays.
    *
    * Default theme, obviously enough, is the one that provides the default
    * look of all widgets. End users can change the theme used by Elementary
    * by setting the @c ELM_THEME environment variable before running an
    * application, or globally for all programs using the @c elementary_config
    * utility. Applications can change the default theme using elm_theme_set(),
    * but this can go against the user wishes, so it's not an adviced practice.
    *
    * Ideally, applications should find everything they need in the already
    * provided theme, but there may be occasions when that's not enough and
    * custom styles are required to correctly express the idea. For this
    * cases, Elementary has extensions.
    *
    * Extensions allow the application developer to write styles of its own
    * to apply to some widgets. This requires knowledge of how each widget
    * is themed, as extensions will always replace the entire group used by
    * the widget, so important signals and parts need to be there for the
    * object to behave properly (see documentation of Edje for details).
    * Once the theme for the extension is done, the application needs to add
    * it to the list of themes Elementary will look into, using
    * elm_theme_extension_add(), and set the style of the desired widgets as
    * he would normally with elm_object_style_set().
    *
    * Overlays, on the other hand, can replace the look of all widgets by
    * overriding the default style. Like extensions, it's up to the application
    * developer to write the theme for the widgets it wants, the difference
    * being that when looking for the theme, Elementary will check first the
    * list of overlays, then the set theme and lastly the list of extensions,
    * so with overlays it's possible to replace the default view and every
    * widget will be affected. This is very much alike to setting the whole
    * theme for the application and will probably clash with the end user
    * options, not to mention the risk of ending up with not matching styles
    * across the program. Unless there's a very special reason to use them,
    * overlays should be avoided for the resons exposed before.
    *
    * All these theme lists are handled by ::Elm_Theme instances. Elementary
    * keeps one default internally and every function that receives one of
    * these can be called with NULL to refer to this default (except for
    * elm_theme_free()). It's possible to create a new instance of a
    * ::Elm_Theme to set other theme for a specific widget (and all of its
    * children), but this is as discouraged, if not even more so, than using
    * overlays. Don't use this unless you really know what you are doing.
    *
    * But to be less negative about things, you can look at the following
    * examples:
    * @li @ref theme_example_01 "Using extensions"
    * @li @ref theme_example_02 "Using overlays"
    *
    * @{
    */
   /**
    * @typedef Elm_Theme
    *
    * Opaque handler for the list of themes Elementary looks for when
    * rendering widgets.
    *
    * Stay out of this unless you really know what you are doing. For most
    * cases, sticking to the default is all a developer needs.
    */
   typedef struct _Elm_Theme Elm_Theme;

   /**
    * Create a new specific theme
    *
    * This creates an empty specific theme that only uses the default theme. A
    * specific theme has its own private set of extensions and overlays too
    * (which are empty by default). Specific themes do not fall back to themes
    * of parent objects. They are not intended for this use. Use styles, overlays
    * and extensions when needed, but avoid specific themes unless there is no
    * other way (example: you want to have a preview of a new theme you are
    * selecting in a "theme selector" window. The preview is inside a scroller
    * and should display what the theme you selected will look like, but not
    * actually apply it yet. The child of the scroller will have a specific
    * theme set to show this preview before the user decides to apply it to all
    * applications).
    */
   EAPI Elm_Theme       *elm_theme_new(void);
   /**
    * Free a specific theme
    *
    * @param th The theme to free
    *
    * This frees a theme created with elm_theme_new().
    */
   EAPI void             elm_theme_free(Elm_Theme *th);
   /**
    * Copy the theme fom the source to the destination theme
    *
    * @param th The source theme to copy from
    * @param thdst The destination theme to copy data to
    *
    * This makes a one-time static copy of all the theme config, extensions
    * and overlays from @p th to @p thdst. If @p th references a theme, then
    * @p thdst is also set to reference it, with all the theme settings,
    * overlays and extensions that @p th had.
    */
   EAPI void             elm_theme_copy(Elm_Theme *th, Elm_Theme *thdst);
   /**
    * Tell the source theme to reference the ref theme
    *
    * @param th The theme that will do the referencing
    * @param thref The theme that is the reference source
    *
    * This clears @p th to be empty and then sets it to refer to @p thref
    * so @p th acts as an override to @p thref, but where its overrides
    * don't apply, it will fall through to @pthref for configuration.
    */
   EAPI void             elm_theme_ref_set(Elm_Theme *th, Elm_Theme *thref);
   /**
    * Return the theme referred to
    *
    * @param th The theme to get the reference from
    * @return The referenced theme handle
    *
    * This gets the theme set as the reference theme by elm_theme_ref_set().
    * If no theme is set as a reference, NULL is returned.
    */
   EAPI Elm_Theme       *elm_theme_ref_get(Elm_Theme *th);
   /**
    * Return the default theme
    *
    * @return The default theme handle
    *
    * This returns the internal default theme setup handle that all widgets
    * use implicitly unless a specific theme is set. This is also often use
    * as a shorthand of NULL.
    */
   EAPI Elm_Theme       *elm_theme_default_get(void);
   /**
    * Prepends a theme overlay to the list of overlays
    *
    * @param th The theme to add to, or if NULL, the default theme
    * @param item The Edje file path to be used
    *
    * Use this if your application needs to provide some custom overlay theme
    * (An Edje file that replaces some default styles of widgets) where adding
    * new styles, or changing system theme configuration is not possible. Do
    * NOT use this instead of a proper system theme configuration. Use proper
    * configuration files, profiles, environment variables etc. to set a theme
    * so that the theme can be altered by simple confiugration by a user. Using
    * this call to achieve that effect is abusing the API and will create lots
    * of trouble.
    *
    * @see elm_theme_extension_add()
    */
   EAPI void             elm_theme_overlay_add(Elm_Theme *th, const char *item);
   /**
    * Delete a theme overlay from the list of overlays
    *
    * @param th The theme to delete from, or if NULL, the default theme
    * @param item The name of the theme overlay
    *
    * @see elm_theme_overlay_add()
    */
   EAPI void             elm_theme_overlay_del(Elm_Theme *th, const char *item);
   /**
    * Appends a theme extension to the list of extensions.
    *
    * @param th The theme to add to, or if NULL, the default theme
    * @param item The Edje file path to be used
    *
    * This is intended when an application needs more styles of widgets or new
    * widget themes that the default does not provide (or may not provide). The
    * application has "extended" usage by coming up with new custom style names
    * for widgets for specific uses, but as these are not "standard", they are
    * not guaranteed to be provided by a default theme. This means the
    * application is required to provide these extra elements itself in specific
    * Edje files. This call adds one of those Edje files to the theme search
    * path to be search after the default theme. The use of this call is
    * encouraged when default styles do not meet the needs of the application.
    * Use this call instead of elm_theme_overlay_add() for almost all cases.
    *
    * @see elm_object_style_set()
    */
   EAPI void             elm_theme_extension_add(Elm_Theme *th, const char *item);
   /**
    * Deletes a theme extension from the list of extensions.
    *
    * @param th The theme to delete from, or if NULL, the default theme
    * @param item The name of the theme extension
    *
    * @see elm_theme_extension_add()
    */
   EAPI void             elm_theme_extension_del(Elm_Theme *th, const char *item);
   /**
    * Set the theme search order for the given theme
    *
    * @param th The theme to set the search order, or if NULL, the default theme
    * @param theme Theme search string
    *
    * This sets the search string for the theme in path-notation from first
    * theme to search, to last, delimited by the : character. Example:
    *
    * "shiny:/path/to/file.edj:default"
    *
    * See the ELM_THEME environment variable for more information.
    *
    * @see elm_theme_get()
    * @see elm_theme_list_get()
    */
   EAPI void             elm_theme_set(Elm_Theme *th, const char *theme);
   /**
    * Return the theme search order
    *
    * @param th The theme to get the search order, or if NULL, the default theme
    * @return The internal search order path
    *
    * This function returns a colon separated string of theme elements as
    * returned by elm_theme_list_get().
    *
    * @see elm_theme_set()
    * @see elm_theme_list_get()
    */
   EAPI const char      *elm_theme_get(Elm_Theme *th);
   /**
    * Return a list of theme elements to be used in a theme.
    *
    * @param th Theme to get the list of theme elements from.
    * @return The internal list of theme elements
    *
    * This returns the internal list of theme elements (will only be valid as
    * long as the theme is not modified by elm_theme_set() or theme is not
    * freed by elm_theme_free(). This is a list of strings which must not be
    * altered as they are also internal. If @p th is NULL, then the default
    * theme element list is returned.
    *
    * A theme element can consist of a full or relative path to a .edj file,
    * or a name, without extension, for a theme to be searched in the known
    * theme paths for Elemementary.
    *
    * @see elm_theme_set()
    * @see elm_theme_get()
    */
   EAPI const Eina_List *elm_theme_list_get(const Elm_Theme *th);
   /**
    * Return the full patrh for a theme element
    *
    * @param f The theme element name
    * @param in_search_path Pointer to a boolean to indicate if item is in the search path or not
    * @return The full path to the file found.
    *
    * This returns a string you should free with free() on success, NULL on
    * failure. This will search for the given theme element, and if it is a
    * full or relative path element or a simple searchable name. The returned
    * path is the full path to the file, if searched, and the file exists, or it
    * is simply the full path given in the element or a resolved path if
    * relative to home. The @p in_search_path boolean pointed to is set to
    * EINA_TRUE if the file was a searchable file andis in the search path,
    * and EINA_FALSE otherwise.
    */
   EAPI char            *elm_theme_list_item_path_get(const char *f, Eina_Bool *in_search_path);
   /**
    * Flush the current theme.
    *
    * @param th Theme to flush
    *
    * This flushes caches that let elementary know where to find theme elements
    * in the given theme. If @p th is NULL, then the default theme is flushed.
    * Call this function if source theme data has changed in such a way as to
    * make any caches Elementary kept invalid.
    */
   EAPI void             elm_theme_flush(Elm_Theme *th);
   /**
    * This flushes all themes (default and specific ones).
    *
    * This will flush all themes in the current application context, by calling
    * elm_theme_flush() on each of them.
    */
   EAPI void             elm_theme_full_flush(void);
   /**
    * Set the theme for all elementary using applications on the current display
    *
    * @param theme The name of the theme to use. Format same as the ELM_THEME
    * environment variable.
    */
   EAPI void             elm_theme_all_set(const char *theme);
   /**
    * Return a list of theme elements in the theme search path
    *
    * @return A list of strings that are the theme element names.
    *
    * This lists all available theme files in the standard Elementary search path
    * for theme elements, and returns them in alphabetical order as theme
    * element names in a list of strings. Free this with
    * elm_theme_name_available_list_free() when you are done with the list.
    */
   EAPI Eina_List       *elm_theme_name_available_list_new(void);
   /**
    * Free the list returned by elm_theme_name_available_list_new()
    *
    * This frees the list of themes returned by
    * elm_theme_name_available_list_new(). Once freed the list should no longer
    * be used. a new list mys be created.
    */
   EAPI void             elm_theme_name_available_list_free(Eina_List *list);
   /**
    * Set a specific theme to be used for this object and its children
    *
    * @param obj The object to set the theme on
    * @param th The theme to set
    *
    * This sets a specific theme that will be used for the given object and any
    * child objects it has. If @p th is NULL then the theme to be used is
    * cleared and the object will inherit its theme from its parent (which
    * ultimately will use the default theme if no specific themes are set).
    *
    * Use special themes with great care as this will annoy users and make
    * configuration difficult. Avoid any custom themes at all if it can be
    * helped.
    */
   EAPI void             elm_object_theme_set(Evas_Object *obj, Elm_Theme *th) EINA_ARG_NONNULL(1);
   /**
    * Get the specific theme to be used
    *
    * @param obj The object to get the specific theme from
    * @return The specifc theme set.
    *
    * This will return a specific theme set, or NULL if no specific theme is
    * set on that object. It will not return inherited themes from parents, only
    * the specific theme set for that specific object. See elm_object_theme_set()
    * for more information.
    */
   EAPI Elm_Theme       *elm_object_theme_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* win */
   typedef enum _Elm_Win_Type
     {
        ELM_WIN_BASIC,
        ELM_WIN_DIALOG_BASIC,
        ELM_WIN_DESKTOP,
        ELM_WIN_DOCK,
        ELM_WIN_TOOLBAR,
        ELM_WIN_MENU,
        ELM_WIN_UTILITY,
        ELM_WIN_SPLASH,
        ELM_WIN_DROPDOWN_MENU,
        ELM_WIN_POPUP_MENU,
        ELM_WIN_TOOLTIP,
        ELM_WIN_NOTIFICATION,
        ELM_WIN_COMBO,
        ELM_WIN_DND,
        ELM_WIN_INLINED_IMAGE,
     } Elm_Win_Type;

   typedef enum _Elm_Win_Keyboard_Mode
     {
        ELM_WIN_KEYBOARD_UNKNOWN,
        ELM_WIN_KEYBOARD_OFF,
        ELM_WIN_KEYBOARD_ON,
        ELM_WIN_KEYBOARD_ALPHA,
        ELM_WIN_KEYBOARD_NUMERIC,
        ELM_WIN_KEYBOARD_PIN,
        ELM_WIN_KEYBOARD_PHONE_NUMBER,
        ELM_WIN_KEYBOARD_HEX,
        ELM_WIN_KEYBOARD_TERMINAL,
        ELM_WIN_KEYBOARD_PASSWORD,
        ELM_WIN_KEYBOARD_IP,
        ELM_WIN_KEYBOARD_HOST,
        ELM_WIN_KEYBOARD_FILE,
        ELM_WIN_KEYBOARD_URL,
        ELM_WIN_KEYBOARD_KEYPAD,
        ELM_WIN_KEYBOARD_J2ME
     } Elm_Win_Keyboard_Mode;

   typedef enum _Elm_Illume_Command
     {
        ELM_ILLUME_COMMAND_FOCUS_BACK,
        ELM_ILLUME_COMMAND_FOCUS_FORWARD,
        ELM_ILLUME_COMMAND_FOCUS_HOME,
        ELM_ILLUME_COMMAND_CLOSE
     } Elm_Illume_Command;

   EAPI Evas_Object *elm_win_add(Evas_Object *parent, const char *name, Elm_Win_Type type);
   EAPI void         elm_win_resize_object_add(Evas_Object *obj, Evas_Object *subobj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_resize_object_del(Evas_Object *obj, Evas_Object *subobj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_title_set(Evas_Object *obj, const char *title) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_win_title_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_autodel_set(Evas_Object *obj, Eina_Bool autodel) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_autodel_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_activate(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_lower(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_raise(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_borderless_set(Evas_Object *obj, Eina_Bool borderless) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_borderless_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_shaped_set(Evas_Object *obj, Eina_Bool shaped) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_shaped_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_alpha_set(Evas_Object *obj, Eina_Bool alpha) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_transparent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_transparent_set(Evas_Object *obj, Eina_Bool transparent) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_alpha_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_override_set(Evas_Object *obj, Eina_Bool override) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_override_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_fullscreen_set(Evas_Object *obj, Eina_Bool fullscreen) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_fullscreen_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_maximized_set(Evas_Object *obj, Eina_Bool maximized) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_maximized_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_iconified_set(Evas_Object *obj, Eina_Bool iconified) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_iconified_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_layer_set(Evas_Object *obj, int layer) EINA_ARG_NONNULL(1);
   EAPI int          elm_win_layer_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_rotation_set(Evas_Object *obj, int rotation) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_rotation_with_resize_set(Evas_Object *obj, int rotation) EINA_ARG_NONNULL(1);
   EAPI int          elm_win_rotation_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_sticky_set(Evas_Object *obj, Eina_Bool sticky) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_sticky_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_conformant_set(Evas_Object *obj, Eina_Bool conformant) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_conformant_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_quickpanel_set(Evas_Object *obj, Eina_Bool quickpanel) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_quickpanel_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_quickpanel_priority_major_set(Evas_Object *obj, int priority) EINA_ARG_NONNULL(1);
   EAPI int          elm_win_quickpanel_priority_major_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_quickpanel_priority_minor_set(Evas_Object *obj, int priority) EINA_ARG_NONNULL(1);
   EAPI int          elm_win_quickpanel_priority_minor_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_quickpanel_zone_set(Evas_Object *obj, int zone) EINA_ARG_NONNULL(1);
   EAPI int          elm_win_quickpanel_zone_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_prop_focus_skip_set(Evas_Object *obj, Eina_Bool skip) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_illume_command_send(Evas_Object *obj, Elm_Illume_Command command, void *params) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_win_inlined_image_object_get(Evas_Object *obj);
   EAPI void         elm_win_focus_highlight_enabled_set(Evas_Object *obj, Eina_Bool enabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_win_focus_highlight_enabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_win_focus_highlight_style_set(Evas_Object *obj, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_win_focus_highlight_style_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /*...
    * ecore_x_icccm_hints_set -> accepts_focus (add to ecore_evas)
    * ecore_x_icccm_hints_set -> window_group (add to ecore_evas)
    * ecore_x_icccm_size_pos_hints_set -> request_pos (add to ecore_evas)
    * ecore_x_icccm_client_leader_set -> l (add to ecore_evas)
    * ecore_x_icccm_window_role_set -> role (add to ecore_evas)
    * ecore_x_icccm_transient_for_set -> forwin (add to ecore_evas)
    * ecore_x_netwm_window_type_set -> type (add to ecore_evas)
    *
    * (add to ecore_x) set netwm argb icon! (add to ecore_evas)
    * (blank mouse, private mouse obj, defaultmouse)
    *
    */
   EAPI void                  elm_win_keyboard_mode_set(Evas_Object *obj, Elm_Win_Keyboard_Mode mode) EINA_ARG_NONNULL(1);
   EAPI Elm_Win_Keyboard_Mode elm_win_keyboard_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_win_keyboard_win_set(Evas_Object *obj, Eina_Bool is_keyboard) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_win_keyboard_win_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   EAPI void                  elm_win_screen_position_get(const Evas_Object *obj, int *x, int *y) EINA_ARG_NONNULL(1);

   EAPI Evas_Object          *elm_win_inwin_add(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_win_inwin_activate(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_win_inwin_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_win_inwin_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_win_inwin_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* available styles:
    * default
    * minimal
    * minimal_vertical
    */
   /* X specific calls - won't work on non-x engines (return 0) */
   EAPI Ecore_X_Window elm_win_xwindow_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "delete,request" - the user requested to delete the window
    * "focus,in" - window got focus
    * "focus,out" - window lost focus
    * "moved" - window that holds the canvas was moved
    */

   /**
    * @defgroup Bg Bg
    *
    * @brief Background object, used for setting a solid color, image or Edje
    * group as background to a window or any container object.
    *
    * The bg object is used for setting a solid background to a window or
    * packing into any container object. It works just like an image, but has
    * some properties useful to a background, like setting it to tiled,
    * centered, scaled or stretched.
    *
    * Here is some sample code using it:
    * @li @ref bg_01_example_page
    * @li @ref bg_02_example_page
    * @li @ref bg_03_example_page
    */

   /* bg */
   typedef enum _Elm_Bg_Option
     {
        ELM_BG_OPTION_CENTER,  /**< center the background */
        ELM_BG_OPTION_SCALE,   /**< scale the background retaining aspect ratio */
        ELM_BG_OPTION_STRETCH, /**< stretch the background to fill */
        ELM_BG_OPTION_TILE     /**< tile background at its original size */
     } Elm_Bg_Option;

   /**
    * Add a new background to the parent
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    *
    * @ingroup Bg
    */
   EAPI Evas_Object  *elm_bg_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /**
    * Set the file (image or edje) used for the background
    *
    * @param obj The bg object
    * @param file The file path
    * @param group Optional key (group in Edje) within the file
    *
    * This sets the image file used in the background object. The image (or edje)
    * will be stretched (retaining aspect if its an image file) to completely fill
    * the bg object. This may mean some parts are not visible.
    *
    * @note  Once the image of @p obj is set, a previously set one will be deleted,
    * even if @p file is NULL.
    *
    * @ingroup Bg
    */
   EAPI void          elm_bg_file_set(Evas_Object *obj, const char *file, const char *group) EINA_ARG_NONNULL(1);

   /**
    * Get the file (image or edje) used for the background
    *
    * @param obj The bg object
    * @param file The file path
    * @param group Optional key (group in Edje) within the file
    *
    * @ingroup Bg
    */
   EAPI void          elm_bg_file_get(const Evas_Object *obj, const char **file, const char **group) EINA_ARG_NONNULL(1);

   /**
    * Set the option used for the background image
    *
    * @param obj The bg object
    * @param option The desired background option (TILE, SCALE)
    *
    * This sets the option used for manipulating the display of the background
    * image. The image can be tiled or scaled.
    *
    * @ingroup Bg
    */
   EAPI void          elm_bg_option_set(Evas_Object *obj, Elm_Bg_Option option) EINA_ARG_NONNULL(1);

   /**
    * Get the option used for the background image
    *
    * @param obj The bg object
    * @return The desired background option (CENTER, SCALE, STRETCH or TILE)
    *
    * @ingroup Bg
    */
   EAPI Elm_Bg_Option elm_bg_option_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the option used for the background color
    *
    * @param obj The bg object
    * @param r
    * @param g
    * @param b
    *
    * This sets the color used for the background rectangle. Its range goes
    * from 0 to 255.
    *
    * @ingroup Bg
    */
   EAPI void          elm_bg_color_set(Evas_Object *obj, int r, int g, int b) EINA_ARG_NONNULL(1);
   /**
    * Get the option used for the background color
    *
    * @param obj The bg object
    * @param r
    * @param g
    * @param b
    *
    * @ingroup Bg
    */
   EAPI void          elm_bg_color_get(const Evas_Object *obj, int *r, int *g, int *b) EINA_ARG_NONNULL(1);

   /**
    * Set the overlay object used for the background object.
    *
    * @param obj The bg object
    * @param overlay The overlay object
    *
    * This provides a way for elm_bg to have an 'overlay' that will be on top
    * of the bg. Once the over object is set, a previously set one will be
    * deleted, even if you set the new one to NULL. If you want to keep that
    * old content object, use the elm_bg_overlay_unset() function.
    *
    * @ingroup Bg
    */

   EAPI void          elm_bg_overlay_set(Evas_Object *obj, Evas_Object *overlay) EINA_ARG_NONNULL(1);

   /**
    * Get the overlay object used for the background object.
    *
    * @param obj The bg object
    * @return The content that is being used
    *
    * Return the content object which is set for this widget
    *
    * @ingroup Bg
    */
   EAPI Evas_Object  *elm_bg_overlay_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Get the overlay object used for the background object.
    *
    * @param obj The bg object
    * @return The content that was being used
    *
    * Unparent and return the overlay object which was set for this widget
    *
    * @ingroup Bg
    */
   EAPI Evas_Object  *elm_bg_overlay_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * Set the size of the pixmap representation of the image.
    *
    * This option just makes sense if an image is going to be set in the bg.
    *
    * @param obj The bg object
    * @param w The new width of the image pixmap representation.
    * @param h The new height of the image pixmap representation.
    *
    * This function sets a new size for pixmap representation of the given bg
    * image. It allows the image to be loaded already in the specified size,
    * reducing the memory usage and load time when loading a big image with load
    * size set to a smaller size.
    *
    * NOTE: this is just a hint, the real size of the pixmap may differ
    * depending on the type of image being loaded, being bigger than requested.
    *
    * @ingroup Bg
    */
   EAPI void          elm_bg_load_size_set(Evas_Object *obj, Evas_Coord w, Evas_Coord h) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    */

   /* icon */
   typedef enum _Elm_Icon_Lookup_Order
     {
        ELM_ICON_LOOKUP_FDO_THEME, /**< icon look up order: freedesktop, theme */
        ELM_ICON_LOOKUP_THEME_FDO, /**< icon look up order: theme, freedesktop */
        ELM_ICON_LOOKUP_FDO,       /**< icon look up order: freedesktop */
        ELM_ICON_LOOKUP_THEME      /**< icon look up order: theme */
     } Elm_Icon_Lookup_Order;

   EAPI Evas_Object          *elm_icon_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_icon_file_set(Evas_Object *obj, const char *file, const char *group) EINA_ARG_NONNULL(1, 2);
   EAPI void                  elm_icon_thumb_set(const Evas_Object *obj, const char *file, const char *group) EINA_ARG_NONNULL(1, 2);
   EAPI void                  elm_icon_file_get(const Evas_Object *obj, const char **file, const char **group) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_icon_standard_set(Evas_Object *obj, const char *name) EINA_ARG_NONNULL(1);
   EAPI const char           *elm_icon_standard_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_icon_smooth_set(Evas_Object *obj, Eina_Bool smooth) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_icon_smooth_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_icon_no_scale_set(Evas_Object *obj, Eina_Bool no_scale) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_icon_no_scale_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_icon_scale_set(Evas_Object *obj, Eina_Bool scale_up, Eina_Bool scale_down) EINA_ARG_NONNULL(1);
   EAPI void                  elm_icon_scale_get(const Evas_Object *obj, Eina_Bool *scale_up, Eina_Bool *scale_down) EINA_ARG_NONNULL(1);
   EAPI void                  elm_icon_fill_outside_set(Evas_Object *obj, Eina_Bool fill_outside) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_icon_fill_outside_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_icon_prescale_set(Evas_Object *obj, int size) EINA_ARG_NONNULL(1);
   EAPI int                   elm_icon_prescale_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_icon_order_lookup_set(Evas_Object *obj, Elm_Icon_Lookup_Order order) EINA_ARG_NONNULL(1);
   EAPI Elm_Icon_Lookup_Order elm_icon_order_lookup_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "clicked" - the user clicked the icon
    */

   /* image */
   typedef enum _Elm_Image_Orient
     {
        ELM_IMAGE_ORIENT_NONE,
        ELM_IMAGE_ROTATE_90_CW,
        ELM_IMAGE_ROTATE_180_CW,
        ELM_IMAGE_ROTATE_90_CCW,
        ELM_IMAGE_FLIP_HORIZONTAL,
        ELM_IMAGE_FLIP_VERTICAL,
        ELM_IMAGE_FLIP_TRANSPOSE,
        ELM_IMAGE_FLIP_TRANSVERSE
     } Elm_Image_Orient;
   EAPI Evas_Object     *elm_image_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_image_file_set(Evas_Object *obj, const char *file, const char *group) EINA_ARG_NONNULL(1, 2);
   EAPI void             elm_image_file_get(const Evas_Object *obj, const char **file, const char **group) EINA_ARG_NONNULL(1);
   EAPI void             elm_image_smooth_set(Evas_Object *obj, Eina_Bool smooth) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_image_smooth_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_image_object_size_get(const Evas_Object *obj, int *w, int *h) EINA_ARG_NONNULL(1);
   EAPI void             elm_image_no_scale_set(Evas_Object *obj, Eina_Bool no_scale) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_image_no_scale_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_image_scale_set(Evas_Object *obj, Eina_Bool scale_up, Eina_Bool scale_down) EINA_ARG_NONNULL(1);
   EAPI void             elm_image_scale_get(const Evas_Object *obj, Eina_Bool *scale_up, Eina_Bool *scale_down) EINA_ARG_NONNULL(1);
   EAPI void             elm_image_fill_outside_set(Evas_Object *obj, Eina_Bool fill_outside) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_image_fill_outside_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_image_prescale_set(Evas_Object *obj, int size) EINA_ARG_NONNULL(1);
   EAPI int              elm_image_prescale_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_image_orient_set(Evas_Object *obj, Elm_Image_Orient orient) EINA_ARG_NONNULL(1);
   EAPI Elm_Image_Orient elm_image_orient_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_image_editable_set(Evas_Object *obj, Eina_Bool set) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_image_editable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object     *elm_image_object_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_image_aspect_ratio_retained_set(Evas_Object *obj, Eina_Bool retained) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_image_aspect_ratio_retained_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /* smart callbacks called:
    * "clicked" - the user clicked the image
    */

   /* glview */
   typedef void (*Elm_GLView_Func)(Evas_Object *obj);

   typedef enum _Elm_GLView_Mode
     {
        ELM_GLVIEW_ALPHA   = 1,
        ELM_GLVIEW_DEPTH   = 2,
        ELM_GLVIEW_STENCIL = 4
     } Elm_GLView_Mode;

   /**
    * Defines a policy for the glview resizing.
    *
    * @note Default is ELM_GLVIEW_RESIZE_POLICY_RECREATE
    */
   typedef enum _Elm_GLView_Resize_Policy
     {
        ELM_GLVIEW_RESIZE_POLICY_RECREATE = 1,      /**< Resize the internal surface along with the image */
        ELM_GLVIEW_RESIZE_POLICY_SCALE    = 2       /**< Only reize the internal image and not the surface */
     } Elm_GLView_Resize_Policy;

   typedef enum _Elm_GLView_Render_Policy
     {
        ELM_GLVIEW_RENDER_POLICY_ON_DEMAND = 1,     /**< Render only when there is a need for redrawing */
        ELM_GLVIEW_RENDER_POLICY_ALWAYS    = 2      /**< Render always even when it is not visible */
     } Elm_GLView_Render_Policy;


   EAPI Evas_Object     *elm_glview_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_size_set(Evas_Object *obj, Evas_Coord width, Evas_Coord height) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_size_get(const Evas_Object *obj, Evas_Coord *width, Evas_Coord *height) EINA_ARG_NONNULL(1);
   EAPI Evas_GL_API     *elm_glview_gl_api_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_glview_mode_set(Evas_Object *obj, Elm_GLView_Mode mode) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_glview_resize_policy_set(Evas_Object *obj, Elm_GLView_Resize_Policy policy) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_glview_render_policy_set(Evas_Object *obj, Elm_GLView_Render_Policy policy) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_init_func_set(Evas_Object *obj, Elm_GLView_Func func) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_del_func_set(Evas_Object *obj, Elm_GLView_Func func) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_resize_func_set(Evas_Object *obj, Elm_GLView_Func func) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_render_func_set(Evas_Object *obj, Elm_GLView_Func func) EINA_ARG_NONNULL(1);
   EAPI void             elm_glview_changed_set(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /* box */
   /**
    * @defgroup Box Box
    *
    * A box arranges objects in a linear fashion, governed by a layout function
    * that defines the details of this arrangement.
    *
    * By default, the box will use an internal function to set the layout to
    * a single row, either vertical or horizontal. This layout is affected
    * by a number of parameters, such as the homogeneous flag set by
    * elm_box_homogeneous_set(), the values given by elm_box_padding_set() and
    * elm_box_align_set() and the hints set to each object in the box.
    *
    * For this default layout, it's possible to change the orientation with
    * elm_box_horizontal_set(). The box will start in the vertical orientation,
    * placing its elements ordered from top to bottom. When horizontal is set,
    * the order will go from left to right. If the box is set to be
    * homogeneous, every object in it will be assigned the same space, that
    * of the largest object. Padding can be used to set some spacing between
    * the cell given to each object. The alignment of the box, set with
    * elm_box_align_set(), determines how the bounding box of all the elements
    * will be placed within the space given to the box widget itself.
    *
    * The size hints of each object also affect how they are placed and sized
    * within the box. evas_object_size_hint_min_set() will give the minimum
    * size the object can have, and the box will use it as the basis for all
    * latter calculations. Elementary widgets set their own minimum size as
    * needed, so there's rarely any need to use it manually.
    *
    * evas_object_size_hint_weight_set(), when not in homogeneous mode, is
    * used to tell whether the object will be allocated the minimum size it
    * needs or if the space given to it should be expanded. It's important
    * to realize that expanding the size given to the object is not the same
    * thing as resizing the object. It could very well end being a small
    * widget floating in a much larger empty space. If not set, the weight
    * for objects will normally be 0.0 for both axis, meaning the widget will
    * not be expanded. To take as much space possible, set the weight to
    * EVAS_HINT_EXPAND (defined to 1.0) for the desired axis to expand.
    *
    * Besides how much space each object is allocated, it's possible to control
    * how the widget will be placed within that space using
    * evas_object_size_hint_align_set(). By default, this value will be 0.5
    * for both axis, meaning the object will be centered, but any value from
    * 0.0 (left or top, for the @c x and @c y axis, respectively) to 1.0
    * (right or bottom) can be used. The special value EVAS_HINT_FILL, which
    * is -1.0, means the object will be resized to fill the entire space it
    * was allocated.
    *
    * In addition, customized functions to define the layout can be set, which
    * allow the application developer to organize the objects within the box
    * in any number of ways.
    *
    * The special elm_box_layout_transition() function can be used
    * to switch from one layout to another, animating the motion of the
    * children of the box.
    *
    * @note Objects should not be added to box objects using _add() calls.
    *
    * Some examples on how to use boxes follow:
    * @li @ref box_example_01
    * @li @ref box_example_02
    *
    * @{
    */
   /**
    * @typedef Elm_Box_Transition
    *
    * Opaque handler containing the parameters to perform an animated
    * transition of the layout the box uses.
    *
    * @see elm_box_transition_new()
    * @see elm_box_layout_set()
    * @see elm_box_layout_transition()
    */
   typedef struct _Elm_Box_Transition Elm_Box_Transition;

   /**
    * Add a new box to the parent
    *
    * By default, the box will be in vertical mode and non-homogeneous.
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object        *elm_box_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the horizontal orientation
    *
    * By default, box object arranges their contents vertically from top to
    * bottom.
    * By calling this function with @p horizontal as EINA_TRUE, the box will
    * become horizontal, arranging contents from left to right.
    *
    * @note This flag is ignored if a custom layout function is set.
    *
    * @param obj The box object
    * @param horizontal The horizontal flag (EINA_TRUE = horizontal,
    * EINA_FALSE = vertical)
    */
   EAPI void                elm_box_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   /**
    * Get the horizontal orientation
    *
    * @param obj The box object
    * @return EINA_TRUE if the box is set to horizintal mode, EINA_FALSE otherwise
    */
   EAPI Eina_Bool           elm_box_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the box to arrange its children homogeneously
    *
    * If enabled, homogeneous layout makes all items the same size, according
    * to the size of the largest of its children.
    *
    * @note This flag is ignored if a custom layout function is set.
    *
    * @param obj The box object
    * @param homogeneous The homogeneous flag
    */
   EAPI void                elm_box_homogeneous_set(Evas_Object *obj, Eina_Bool homogeneous) EINA_ARG_NONNULL(1);
   /**
    * Get whether the box is using homogeneous mode or not
    *
    * @param obj The box object
    * @return EINA_TRUE if it's homogeneous, EINA_FALSE otherwise
    */
   EAPI Eina_Bool           elm_box_homogeneous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void elm_box_homogenous_set(Evas_Object *obj, Eina_Bool homogenous) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool elm_box_homogenous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Add an object to the beginning of the pack list
    *
    * Pack @p subobj into the box @p obj, placing it first in the list of
    * children objects. The actual position the object will get on screen
    * depends on the layout used. If no custom layout is set, it will be at
    * the top or left, depending if the box is vertical or horizontal,
    * respectively.
    *
    * @param obj The box object
    * @param subobj The object to add to the box
    *
    * @see elm_box_pack_end()
    * @see elm_box_pack_before()
    * @see elm_box_pack_after()
    * @see elm_box_unpack()
    * @see elm_box_unpack_all()
    * @see elm_box_clear()
    */
   EAPI void                elm_box_pack_start(Evas_Object *obj, Evas_Object *subobj) EINA_ARG_NONNULL(1);
   /**
    * Add an object at the end of the pack list
    *
    * Pack @p subobj into the box @p obj, placing it last in the list of
    * children objects. The actual position the object will get on screen
    * depends on the layout used. If no custom layout is set, it will be at
    * the bottom or right, depending if the box is vertical or horizontal,
    * respectively.
    *
    * @param obj The box object
    * @param subobj The object to add to the box
    *
    * @see elm_box_pack_start()
    * @see elm_box_pack_before()
    * @see elm_box_pack_after()
    * @see elm_box_unpack()
    * @see elm_box_unpack_all()
    * @see elm_box_clear()
    */
   EAPI void                elm_box_pack_end(Evas_Object *obj, Evas_Object *subobj) EINA_ARG_NONNULL(1);
   /**
    * Adds an object to the box before the indicated object
    *
    * This will add the @p subobj to the box indicated before the object
    * indicated with @p before. If @p before is not already in the box, results
    * are undefined. Before means either to the left of the indicated object or
    * above it depending on orientation.
    *
    * @param obj The box object
    * @param subobj The object to add to the box
    * @param before The object before which to add it
    *
    * @see elm_box_pack_start()
    * @see elm_box_pack_end()
    * @see elm_box_pack_after()
    * @see elm_box_unpack()
    * @see elm_box_unpack_all()
    * @see elm_box_clear()
    */
   EAPI void                elm_box_pack_before(Evas_Object *obj, Evas_Object *subobj, Evas_Object *before) EINA_ARG_NONNULL(1);
   /**
    * Adds an object to the box after the indicated object
    *
    * This will add the @p subobj to the box indicated after the object
    * indicated with @p after. If @p after is not already in the box, results
    * are undefined. After means either to the right of the indicated object or
    * below it depending on orientation.
    *
    * @param obj The box object
    * @param subobj The object to add to the box
    * @param after The object after which to add it
    *
    * @see elm_box_pack_start()
    * @see elm_box_pack_end()
    * @see elm_box_pack_before()
    * @see elm_box_unpack()
    * @see elm_box_unpack_all()
    * @see elm_box_clear()
    */
   EAPI void                elm_box_pack_after(Evas_Object *obj, Evas_Object *subobj, Evas_Object *after) EINA_ARG_NONNULL(1);
   /**
    * Clear the box of all children
    *
    * Remove all the elements contained by the box, deleting the respective
    * objects.
    *
    * @param obj The box object
    *
    * @see elm_box_unpack()
    * @see elm_box_unpack_all()
    */
   EAPI void                elm_box_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Unpack a box item
    *
    * Remove the object given by @p subobj from the box @p obj without
    * deleting it.
    *
    * @param obj The box object
    *
    * @see elm_box_unpack_all()
    * @see elm_box_clear()
    */
   EAPI void                elm_box_unpack(Evas_Object *obj, Evas_Object *subobj) EINA_ARG_NONNULL(1);
   /**
    * Remove all items from the box, without deleting them
    *
    * Clear the box from all children, but don't delete the respective objects.
    * If no other references of the box children exist, the objects will never
    * be deleted, and thus the application will leak the memory. Make sure
    * when using this function that you hold a reference to all the objects
    * in the box @p obj.
    *
    * @param obj The box object
    *
    * @see elm_box_clear()
    * @see elm_box_unpack()
    */
   EAPI void                elm_box_unpack_all(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Retrieve a list of the objects packed into the box
    *
    * Returns a new @c Eina_List with a pointer to @c Evas_Object in its nodes.
    * The order of the list corresponds to the packing order the box uses.
    *
    * You must free this list with eina_list_free() once you are done with it.
    *
    * @param obj The box object
    */
   EAPI const Eina_List    *elm_box_children_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the space (padding) between the box's elements.
    *
    * Extra space in pixels that will be added between a box child and its
    * neighbors after its containing cell has been calculated. This padding
    * is set for all elements in the box, besides any possible padding that
    * individual elements may have through their size hints.
    *
    * @param obj The box object
    * @param horizontal The horizontal space between elements
    * @param vertical The vertical space between elements
    */
   EAPI void                elm_box_padding_set(Evas_Object *obj, Evas_Coord horizontal, Evas_Coord vertical) EINA_ARG_NONNULL(1);
   /**
    * Get the space (padding) between the box's elements.
    *
    * @param obj The box object
    * @param horizontal The horizontal space between elements
    * @param vertical The vertical space between elements
    *
    * @see elm_box_padding_set()
    */
   EAPI void                elm_box_padding_get(const Evas_Object *obj, Evas_Coord *horizontal, Evas_Coord *vertical) EINA_ARG_NONNULL(1);
   /**
    * Set the alignment of the whole bouding box of contents.
    *
    * Sets how the bounding box containing all the elements of the box, after
    * their sizes and position has been calculated, will be aligned within
    * the space given for the whole box widget.
    *
    * @param obj The box object
    * @param horizontal The horizontal alignment of elements
    * @param vertical The vertical alignment of elements
    */
   EAPI void                elm_box_align_set(Evas_Object *obj, double horizontal, double vertical) EINA_ARG_NONNULL(1);
   /**
    * Get the alignment of the whole bouding box of contents.
    *
    * @param obj The box object
    * @param horizontal The horizontal alignment of elements
    * @param vertical The vertical alignment of elements
    *
    * @see elm_box_align_set()
    */
   EAPI void                elm_box_align_get(const Evas_Object *obj, double *horizontal, double *vertical) EINA_ARG_NONNULL(1);

   /**
    * Set the layout defining function to be used by the box
    *
    * Whenever anything changes that requires the box in @p obj to recalculate
    * the size and position of its elements, the function @p cb will be called
    * to determine what the layout of the children will be.
    *
    * Once a custom function is set, everything about the children layout
    * is defined by it. The flags set by elm_box_horizontal_set() and
    * elm_box_homogeneous_set() no longer have any meaning, and the values
    * given by elm_box_padding_set() and elm_box_align_set() are up to this
    * layout function to decide if they are used and how. These last two
    * will be found in the @c priv parameter, of type @c Evas_Object_Box_Data,
    * passed to @p cb. The @c Evas_Object the function receives is not the
    * Elementary widget, but the internal Evas Box it uses, so none of the
    * functions described here can be used on it.
    *
    * Any of the layout functions in @c Evas can be used here, as well as the
    * special elm_box_layout_transition().
    *
    * The final @p data argument received by @p cb is the same @p data passed
    * here, and the @p free_data function will be called to free it
    * whenever the box is destroyed or another layout function is set.
    *
    * Setting @p cb to NULL will revert back to the default layout function.
    *
    * @param obj The box object
    * @param cb The callback function used for layout
    * @param data Data that will be passed to layout function
    * @param free_data Function called to free @p data
    *
    * @see elm_box_layout_transition()
    */
   EAPI void                elm_box_layout_set(Evas_Object *obj, Evas_Object_Box_Layout cb, const void *data, void (*free_data)(void *data)) EINA_ARG_NONNULL(1);
   /**
    * Special layout function that animates the transition from one layout to another
    *
    * Normally, when switching the layout function for a box, this will be
    * reflected immediately on screen on the next render, but it's also
    * possible to do this through an animated transition.
    *
    * This is done by creating an ::Elm_Box_Transition and setting the box
    * layout to this function.
    *
    * For example:
    * @code
    * Elm_Box_Transition *t = elm_box_transition_new(1.0,
    *                            evas_object_box_layout_vertical, // start
    *                            NULL, // data for initial layout
    *                            NULL, // free function for initial data
    *                            evas_object_box_layout_horizontal, // end
    *                            NULL, // data for final layout
    *                            NULL, // free function for final data
    *                            anim_end, // will be called when animation ends
    *                            NULL); // data for anim_end function\
    * elm_box_layout_set(box, elm_box_layout_transition, t,
    *                    elm_box_transition_free);
    * @endcode
    *
    * @note This function can only be used with elm_box_layout_set(). Calling
    * it directly will not have the expected results.
    *
    * @see elm_box_transition_new
    * @see elm_box_transition_free
    * @see elm_box_layout_set
    */
   EAPI void                elm_box_layout_transition(Evas_Object *obj, Evas_Object_Box_Data *priv, void *data);
   /**
    * Create a new ::Elm_Box_Transition to animate the switch of layouts
    *
    * If you want to animate the change from one layout to another, you need
    * to set the layout function of the box to elm_box_layout_transition(),
    * passing as user data to it an instance of ::Elm_Box_Transition with the
    * necessary information to perform this animation. The free function to
    * set for the layout is elm_box_transition_free().
    *
    * The parameters to create an ::Elm_Box_Transition sum up to how long
    * will it be, in seconds, a layout function to describe the initial point,
    * another for the final position of the children and one function to be
    * called when the whole animation ends. This last function is useful to
    * set the definitive layout for the box, usually the same as the end
    * layout for the animation, but could be used to start another transition.
    *
    * @param start_layout The layout function that will be used to start the animation
    * @param start_layout_data The data to be passed the @p start_layout function
    * @param start_layout_free_data Function to free @p start_layout_data
    * @param end_layout The layout function that will be used to end the animation
    * @param end_layout_free_data The data to be passed the @p end_layout function
    * @param end_layout_free_data Function to free @p end_layout_data
    * @param transition_end_cb Callback function called when animation ends
    * @param transition_end_data Data to be passed to @p transition_end_cb
    * @return An instance of ::Elm_Box_Transition
    *
    * @see elm_box_transition_new
    * @see elm_box_layout_transition
    */
   EAPI Elm_Box_Transition *elm_box_transition_new(const double duration, Evas_Object_Box_Layout start_layout, void *start_layout_data, void(*start_layout_free_data)(void *data), Evas_Object_Box_Layout end_layout, void *end_layout_data, void(*end_layout_free_data)(void *data), void(*transition_end_cb)(void *data), void *transition_end_data) EINA_ARG_NONNULL(2, 5);
   /**
    * Free a Elm_Box_Transition instance created with elm_box_transition_new().
    *
    * This function is mostly useful as the @c free_data parameter in
    * elm_box_layout_set() when elm_box_layout_transition().
    *
    * @param data The Elm_Box_Transition instance to be freed.
    *
    * @see elm_box_transition_new
    * @see elm_box_layout_transition
    */
   EAPI void                elm_box_transition_free(void *data);
   /**
    * @}
    */

   /* button */
   /**
    * @defgroup Button Button
    *
    * @image html  widget/button/preview-00.png
    * @image html  widget/button/preview-01.png
    * @image html  widget/button/preview-02.png
    *
    * This is a push-button. Press it and run some function. It can contain
    * a simple label and icon object and it also has an autorepeat feature.
    *
    * This widgets emits the following signals:
    * @li "clicked": the user clicked the button (press/release).
    * @li "repeated": the user pressed the button without releasing it.
    * @li "pressed": button was pressed.
    * @li "unpressed": button was released after being pressed.
    * In all three cases, the @c event parameter of the callback will be
    * @c NULL.
    *
    * Also, defined in the default theme, the button has the following styles
    * available:
    * @li default: a normal button.
    * @li anchor: Like default, but the button fades away when the mouse is not
    * over it, leaving only the text or icon.
    * @li hoversel_vertical: Internally used by @ref Hoversel to give a
    * continuous look across its options.
    * @li hoversel_vertical_entry: Another internal for @ref Hoversel.
    *
    * Follow through a complete example @ref button_example_01 "here".
    * @{
    */
   /**
    * Add a new button to the parent's canvas
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object *elm_button_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the label used in the button
    *
    * The passed @p label can be NULL to clean any existing text in it and
    * leave the button as an icon only object.
    *
    * @param obj The button object
    * @param label The text will be written on the button
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_button_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   /**
    * Get the label set for the button
    *
    * The string returned is an internal pointer and should not be freed or
    * altered. It will also become invalid when the button is destroyed.
    * The string returned, if not NULL, is a stringshare, so if you need to
    * keep it around even after the button is destroyed, you can use
    * eina_stringshare_ref().
    *
    * @param obj The button object
    * @return The text set to the label, or NULL if nothing is set
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_button_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the icon used for the button
    *
    * Setting a new icon will delete any other that was previously set, making
    * any reference to them invalid. If you need to maintain the previous
    * object alive, unset it first with elm_button_icon_unset().
    *
    * @param obj The button object
    * @param icon The icon object for the button
    */
   EAPI void         elm_button_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   /**
    * Get the icon used for the button
    *
    * Return the icon object which is set for this widget. If the button is
    * destroyed or another icon is set, the returned object will be deleted
    * and any reference to it will be invalid.
    *
    * @param obj The button object
    * @return The icon object that is being used
    *
    * @see elm_button_icon_unset()
    */
   EAPI Evas_Object *elm_button_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Remove the icon set without deleting it and return the object
    *
    * This function drops the reference the button holds of the icon object
    * and returns this last object. It is used in case you want to remove any
    * icon, or set another one, without deleting the actual object. The button
    * will be left without an icon set.
    *
    * @param obj The button object
    * @return The icon object that was being used
    */
   EAPI Evas_Object *elm_button_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Turn on/off the autorepeat event generated when the button is kept pressed
    *
    * When off, no autorepeat is performed and buttons emit a normal @c clicked
    * signal when they are clicked.
    *
    * When on, keeping a button pressed will continuously emit a @c repeated
    * signal until the button is released. The time it takes until it starts
    * emitting the signal is given by
    * elm_button_autorepeat_initial_timeout_set(), and the time between each
    * new emission by elm_button_autorepeat_gap_timeout_set().
    *
    * @param obj The button object
    * @param on  A bool to turn on/off the event
    */
   EAPI void         elm_button_autorepeat_set(Evas_Object *obj, Eina_Bool on) EINA_ARG_NONNULL(1);
   /**
    * Get whether the autorepeat feature is enabled
    *
    * @param obj The button object
    * @return EINA_TRUE if autorepeat is on, EINA_FALSE otherwise
    *
    * @see elm_button_autorepeat_set()
    */
   EAPI Eina_Bool    elm_button_autorepeat_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the initial timeout before the autorepeat event is generated
    *
    * Sets the timeout, in seconds, since the button is pressed until the
    * first @c repeated signal is emitted. If @p t is 0.0 or less, there
    * won't be any delay and the even will be fired the moment the button is
    * pressed.
    *
    * @param obj The button object
    * @param t   Timeout in seconds
    *
    * @see elm_button_autorepeat_set()
    * @see elm_button_autorepeat_gap_timeout_set()
    */
   EAPI void         elm_button_autorepeat_initial_timeout_set(Evas_Object *obj, double t) EINA_ARG_NONNULL(1);
   /**
    * Get the initial timeout before the autorepeat event is generated
    *
    * @param obj The button object
    * @return Timeout in seconds
    *
    * @see elm_button_autorepeat_initial_timeout_set()
    */
   EAPI double       elm_button_autorepeat_initial_timeout_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the interval between each generated autorepeat event
    *
    * After the first @c repeated event is fired, all subsequent ones will
    * follow after a delay of @p t seconds for each.
    *
    * @param obj The button object
    * @param t   Interval in seconds
    *
    * @see elm_button_autorepeat_initial_timeout_set()
    */
   EAPI void         elm_button_autorepeat_gap_timeout_set(Evas_Object *obj, double t) EINA_ARG_NONNULL(1);
   /**
    * Get the interval between each generated autorepeat event
    *
    * @param obj The button object
    * @return Interval in seconds
    */
   EAPI double       elm_button_autorepeat_gap_timeout_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* fileselector */
   EAPI Evas_Object *elm_fileselector_button_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_fileselector_button_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_fileselector_button_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_button_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_fileselector_button_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_fileselector_button_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_button_window_title_set(Evas_Object *obj, const char *title) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_fileselector_button_window_title_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_button_window_size_set(Evas_Object *obj, Evas_Coord width, Evas_Coord height) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_button_window_size_get(const Evas_Object *obj, Evas_Coord *width, Evas_Coord *height) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_button_path_set(Evas_Object *obj, const char *path) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_fileselector_button_path_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_button_expandable_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_fileselector_button_expandable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_button_folder_only_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_fileselector_button_folder_only_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_button_is_save_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_fileselector_button_is_save_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_button_inwin_mode_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_fileselector_button_inwin_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* available styles:
    * default
    * anchor
    * hoversel_vertical
    * hoversel_vertical_entry
    */
   /* smart callbacks called:
    * "file,chosen" - the user has selected a path, whose string pointer comes
                      as event info
    */

   EAPI Evas_Object *elm_fileselector_entry_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_fileselector_entry_button_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_fileselector_entry_button_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_entry_button_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_fileselector_entry_button_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_fileselector_entry_button_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_entry_window_title_set(Evas_Object *obj, const char *title) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_fileselector_entry_window_title_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_entry_window_size_set(Evas_Object *obj, Evas_Coord width, Evas_Coord height) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_entry_window_size_get(const Evas_Object *obj, Evas_Coord *width, Evas_Coord *height) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_entry_path_set(Evas_Object *obj, const char *path) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_fileselector_entry_path_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_entry_expandable_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_fileselector_entry_expandable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_entry_folder_only_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_fileselector_entry_folder_only_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_entry_is_save_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_fileselector_entry_is_save_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_entry_inwin_mode_set(Evas_Object *obj, Eina_Bool value) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_fileselector_entry_inwin_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_fileselector_entry_selected_set(Evas_Object *obj, const char *path) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_fileselector_entry_selected_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /* scroller policy */
   typedef enum _Elm_Scroller_Policy
     {
        ELM_SCROLLER_POLICY_AUTO = 0,
        ELM_SCROLLER_POLICY_ON,
        ELM_SCROLLER_POLICY_OFF,
        ELM_SCROLLER_POLICY_LAST
     } Elm_Scroller_Policy;

   EAPI Evas_Object *elm_scroller_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_content_set(Evas_Object *obj, Evas_Object *child) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_scroller_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_scroller_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_custom_widget_base_theme_set(Evas_Object *obj, const char *widget, const char *base) EINA_ARG_NONNULL(1, 2, 3);
   EAPI void         elm_scroller_content_min_limit(Evas_Object *obj, Eina_Bool w, Eina_Bool h) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_region_show(Evas_Object *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_policy_set(Evas_Object *obj, Elm_Scroller_Policy policy_h, Elm_Scroller_Policy policy_v) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_policy_get(const Evas_Object *obj, Elm_Scroller_Policy *policy_h, Elm_Scroller_Policy *policy_v) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_region_get(const Evas_Object *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_child_size_get(const Evas_Object *obj, Evas_Coord *w, Evas_Coord *h) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_page_relative_set(Evas_Object *obj, double h_pagerel, double v_pagerel) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_page_size_set(Evas_Object *obj, Evas_Coord h_pagesize, Evas_Coord v_pagesize) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_region_bring_in(Evas_Object *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h) EINA_ARG_NONNULL(1);
   EAPI void         elm_scroller_propagate_events_set(Evas_Object *obj, Eina_Bool propagation);
   EAPI Eina_Bool    elm_scroller_propagate_events_get(const Evas_Object *obj);
   /* smart callbacks called:
    * "edge,left" - the left edge of the content has been reached
    * "edge,right" - the right edge of the content has been reached
    * "edge,top" - the top edge of the content has been reached
    * "edge,bottom" - the bottom edge of the content has been reached
    * "scroll" - the content has been scrolled (moved)
    * "scroll,anim,start" - scrolling animation has started
    * "scroll,anim,stop" - scrolling animation has stopped
    * "scroll,drag,start" - dragging the contents around has started
    * "scroll,drag,stop" - dragging the contents around has stopped
    */

   /* label */
   EAPI Evas_Object *elm_label_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void elm_label_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1); /* deprecated, use elm_object_text_set instead */
   EINA_DEPRECATED EAPI const char *elm_label_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1); /* deprecated, use elm_object_text_get instead */
   EAPI void         elm_label_line_wrap_set(Evas_Object *obj, Elm_Wrap_Type wrap) EINA_ARG_NONNULL(1);
   EAPI Elm_Wrap_Type elm_label_line_wrap_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_label_wrap_width_set(Evas_Object *obj, Evas_Coord w) EINA_ARG_NONNULL(1);
   EAPI Evas_Coord   elm_label_wrap_width_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_label_wrap_height_set(Evas_Object *obj, Evas_Coord h) EINA_ARG_NONNULL(1);
   EAPI Evas_Coord   elm_label_wrap_height_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_label_fontsize_set(Evas_Object *obj, int fontsize) EINA_ARG_NONNULL(1);
   EAPI void         elm_label_text_color_set(Evas_Object *obj, unsigned int r, unsigned int g, unsigned int b, unsigned int a) EINA_ARG_NONNULL(1);
   EAPI void         elm_label_text_align_set(Evas_Object *obj, const char *alignmode) EINA_ARG_NONNULL(1);
   EAPI void         elm_label_background_color_set(Evas_Object *obj, unsigned int r, unsigned int g, unsigned int b, unsigned int a) EINA_ARG_NONNULL(1);
   EAPI void         elm_label_ellipsis_set(Evas_Object *obj, Eina_Bool ellipsis) EINA_ARG_NONNULL(1);
   EAPI void         elm_label_slide_set(Evas_Object *obj, Eina_Bool slide) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_label_slide_get(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_label_slide_duration_set(Evas_Object *obj, double duration) EINA_ARG_NONNULL(1);
   EAPI double       elm_label_slide_duration_get(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* available styles:
    * default
    * marker
    */
   /* smart callbacks called:
    */

   /* toggle */
   EAPI Evas_Object *elm_toggle_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_toggle_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_toggle_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_toggle_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_toggle_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_toggle_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_toggle_states_labels_set(Evas_Object *obj, const char *onlabel, const char *offlabel) EINA_ARG_NONNULL(1);
   EAPI void         elm_toggle_states_labels_get(const Evas_Object *obj, const char **onlabel, const char **offlabel) EINA_ARG_NONNULL(1);
   EAPI void         elm_toggle_state_set(Evas_Object *obj, Eina_Bool state) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_toggle_state_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_toggle_state_pointer_set(Evas_Object *obj, Eina_Bool *statep) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "changed" - Whenever the toggle value has been changed.  Is not called
    *             until the toggle is released by the cursor (assuming it has been triggered
    *             by the cursor in the first place).
    */

   /* frame */
   EAPI Evas_Object *elm_frame_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_frame_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_frame_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_frame_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_frame_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_frame_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* available styles:
    * default
    * pad_small
    * pad_medium
    * pad_large
    * pad_huge
    * outdent_top
    * outdent_bottom
    */
   /* smart callbacks called:
    */

   /* table */
   EAPI Evas_Object *elm_table_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_homogeneous_set(Evas_Object *obj, Eina_Bool homogeneous) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_table_homogeneous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void elm_table_homogenous_set(Evas_Object *obj, Eina_Bool homogenous) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool elm_table_homogenous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_padding_set(Evas_Object *obj, Evas_Coord horizontal, Evas_Coord vertical) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_padding_get(const Evas_Object *obj, Evas_Coord *horizontal, Evas_Coord *vertical) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_pack(Evas_Object *obj, Evas_Object *subobj, int x, int y, int w, int h) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_unpack(Evas_Object *obj, Evas_Object *subobj) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_clear(Evas_Object *obj, Eina_Bool clear) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_pack_set(Evas_Object *subobj, int x, int y, int w, int h) EINA_ARG_NONNULL(1);
   EAPI void         elm_table_pack_get(Evas_Object *subobj, int *x, int *y, int *w, int *h) EINA_ARG_NONNULL(1);

   /* gengrid */
   typedef struct _Elm_Gengrid_Item_Class Elm_Gengrid_Item_Class;
   typedef struct _Elm_Gengrid_Item_Class_Func Elm_Gengrid_Item_Class_Func;
   typedef struct _Elm_Gengrid_Item Elm_Gengrid_Item; /**< Item of Elm_Gengrid. Sub-type of Elm_Widget_Item */
   typedef char        *(*GridItemLabelGetFunc) (void *data, Evas_Object *obj, const char *part);
   typedef Evas_Object *(*GridItemIconGetFunc)  (void *data, Evas_Object *obj, const char *part);
   typedef Eina_Bool    (*GridItemStateGetFunc) (void *data, Evas_Object *obj, const char *part);
   typedef void         (*GridItemDelFunc)      (void *data, Evas_Object *obj);

   struct _Elm_Gengrid_Item_Class
     {
        const char             *item_style;
        struct _Elm_Gengrid_Item_Class_Func
          {
             GridItemLabelGetFunc  label_get;
             GridItemIconGetFunc   icon_get;
             GridItemStateGetFunc  state_get;
             GridItemDelFunc       del;
          } func;
     };

   EAPI Evas_Object       *elm_gengrid_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_size_set(Evas_Object *obj, Evas_Coord w, Evas_Coord h) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_size_get(const Evas_Object *obj, Evas_Coord *w, Evas_Coord *h) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_align_set(Evas_Object *obj, double align_x, double align_y) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_align_get(const Evas_Object *obj, double *align_x, double *align_y) EINA_ARG_NONNULL(1);

   EAPI void               elm_gengrid_reorder_mode_set(Evas_Object *obj, Eina_Bool reorder_mode) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_gengrid_reorder_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_always_select_mode_set(Evas_Object *obj, Eina_Bool always_select) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_gengrid_always_select_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_no_select_mode_set(Evas_Object *obj, Eina_Bool no_select) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_gengrid_no_select_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_multi_select_set(Evas_Object *obj, Eina_Bool multi) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_gengrid_multi_select_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_page_relative_set(Evas_Object *obj, double h_pagerel, double v_pagerel) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_page_relative_get(const Evas_Object *obj, double *h_pagerel, double *v_pagerel) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_page_size_set(Evas_Object *obj, Evas_Coord h_pagesize, Evas_Coord v_pagesize) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_horizontal_set(Evas_Object *obj, Eina_Bool setting) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_gengrid_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   EAPI Elm_Gengrid_Item  *elm_gengrid_first_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Gengrid_Item  *elm_gengrid_last_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   EAPI Elm_Gengrid_Item  *elm_gengrid_item_next_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Gengrid_Item  *elm_gengrid_item_prev_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_gengrid_item_gengrid_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_del(Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_update(Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI const Elm_Gengrid_Item_Class *elm_gengrid_item_item_class_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_item_class_set(Elm_Gengrid_Item *item, const Elm_Gengrid_Item_Class *gic) EINA_ARG_NONNULL(1, 2);
   EAPI void              *elm_gengrid_item_data_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_data_set(Elm_Gengrid_Item *item, const void *data) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_pos_get(const Elm_Gengrid_Item *item, unsigned int *x, unsigned int *y) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_selected_set(Elm_Gengrid_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_gengrid_item_selected_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI const Evas_Object *elm_gengrid_item_object_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_show(Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_bring_in(Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_disabled_set(Elm_Gengrid_Item *item, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_gengrid_item_disabled_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   EAPI void               elm_gengrid_item_tooltip_text_set(Elm_Gengrid_Item *item, const char *text) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_tooltip_content_cb_set(Elm_Gengrid_Item *item, Elm_Tooltip_Item_Content_Cb func, const void *data, Evas_Smart_Cb del_cb) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_tooltip_unset(Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_tooltip_style_set(Elm_Gengrid_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_gengrid_item_tooltip_style_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_cursor_set(Elm_Gengrid_Item *item, const char *cursor) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_gengrid_item_cursor_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_cursor_unset(Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_cursor_style_set(Elm_Gengrid_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_gengrid_item_cursor_style_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_gengrid_item_cursor_engine_only_set(Elm_Gengrid_Item *item, Eina_Bool engine_only) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_gengrid_item_cursor_engine_only_get(const Elm_Gengrid_Item *item) EINA_ARG_NONNULL(1);

   EAPI void               elm_gengrid_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Gengrid_Item  *elm_gengrid_selected_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List   *elm_gengrid_selected_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   EAPI Elm_Gengrid_Item  *elm_gengrid_item_append(Evas_Object *obj, const Elm_Gengrid_Item_Class *gic,  const void *data, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);
   EAPI Elm_Gengrid_Item  *elm_gengrid_item_prepend(Evas_Object *obj, const Elm_Gengrid_Item_Class *gic, const void *data, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);
   EAPI Elm_Gengrid_Item  *elm_gengrid_item_insert_before(Evas_Object *obj, const Elm_Gengrid_Item_Class *gic, const void *data, Elm_Gengrid_Item *relative, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);
   EAPI Elm_Gengrid_Item  *elm_gengrid_item_insert_after(Evas_Object *obj, const Elm_Gengrid_Item_Class *gic, const void *data, Elm_Gengrid_Item *relative, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);
   EAPI Elm_Gengrid_Item  *elm_gengrid_item_sorted_insert(Evas_Object *obj, const Elm_Gengrid_Item_Class *gic, const void *data, Eina_Compare_Cb comp, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);
   EAPI Elm_Gengrid_Item  *elm_gengrid_item_direct_sorted_insert(Evas_Object *obj, const Elm_Gengrid_Item_Class *gic, const void *data, Eina_Compare_Cb comp, Evas_Smart_Cb func, const void *func_data);
   /* smart callbacks called:
    *
    * selected - User has selected an item.
    * unselected - User has unselected an item.
    * clicked,double - User has double-clicked or pressed enter on an item.
    * realized - An evas object for an item was built.
    * unrealized - An evas object for an item was deleted.
    * changed - An item has been added, removed, resized or moved,
    * or gengrid has been resized or horizontal property has been changed.
    * scroll - the content has been scrolled (moved).
    * "scroll,drag,start" - dragging the contents around has started.
    * "scroll,drat,stop" - dragging the contents around has stopped.
    * drag - Gengrid is being dragged.
    * "drag,start,up" - Gengrid has been dragged (not scrolled) up.
    * "drag,start,down" - Gengrid has been dragged (not scrolled) down.
    * "drag,start,left" - Gengrid has been dragged (not scrolled) left.
    * "drag,start,rigth" - Gengrid has been dragged (nto scrolled) right.
    * "drag,stop" - Gengrid is not being dragged.
    */

   /* clock */
   typedef enum _Elm_Clock_Digedit
     {
        ELM_CLOCK_NONE         = 0,
        ELM_CLOCK_HOUR_DECIMAL = 1 << 0,
        ELM_CLOCK_HOUR_UNIT    = 1 << 1,
        ELM_CLOCK_MIN_DECIMAL  = 1 << 2,
        ELM_CLOCK_MIN_UNIT     = 1 << 3,
        ELM_CLOCK_SEC_DECIMAL  = 1 << 4,
        ELM_CLOCK_SEC_UNIT     = 1 << 5,
        ELM_CLOCK_ALL          = (1 << 6) - 1
     } Elm_Clock_Digedit;

   EAPI Evas_Object      *elm_clock_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void              elm_clock_time_set(Evas_Object *obj, int hrs, int min, int sec) EINA_ARG_NONNULL(1);
   EAPI void              elm_clock_time_get(const Evas_Object *obj, int *hrs, int *min, int *sec) EINA_ARG_NONNULL(1);
   EAPI void              elm_clock_edit_set(Evas_Object *obj, Eina_Bool edit) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool         elm_clock_edit_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_clock_digit_edit_set(Evas_Object *obj, Elm_Clock_Digedit digedit) EINA_ARG_NONNULL(1);
   EAPI Elm_Clock_Digedit elm_clock_digit_edit_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_clock_show_am_pm_set(Evas_Object *obj, Eina_Bool am_pm) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool         elm_clock_show_am_pm_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_clock_show_seconds_set(Evas_Object *obj, Eina_Bool seconds) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool         elm_clock_show_seconds_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_clock_interval_set(Evas_Object *obj, double interval) EINA_ARG_NONNULL(1);
   EAPI double            elm_clock_interval_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "changed" - the user changed the time
    */

   /* layout */
   EAPI Evas_Object       *elm_layout_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_layout_file_set(Evas_Object *obj, const char *file, const char *group) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_layout_theme_set(Evas_Object *obj, const char *clas, const char *group, const char *style) EINA_ARG_NONNULL(1);
   EAPI void               elm_layout_content_set(Evas_Object *obj, const char *swallow, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_layout_content_get(const Evas_Object *obj, const char *swallow) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_layout_content_unset(Evas_Object *obj, const char *swallow) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void               elm_layout_text_set(Evas_Object *obj, const char *part, const char *text) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char        *elm_layout_text_get(const Evas_Object *obj, const char *part) EINA_ARG_NONNULL(1);
   EAPI void               elm_layout_box_append(Evas_Object *obj, const char *part, Evas_Object *child) EINA_ARG_NONNULL(1);
   EAPI void               elm_layout_box_prepend(Evas_Object *obj, const char *part, Evas_Object *child) EINA_ARG_NONNULL(1);
   EAPI void               elm_layout_box_insert_before(Evas_Object *obj, const char *part, Evas_Object *child, const Evas_Object *reference) EINA_ARG_NONNULL(1);
   EAPI void               elm_layout_box_insert_at(Evas_Object *obj, const char *part, Evas_Object *child, unsigned int pos) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_layout_box_remove(Evas_Object *obj, const char *part, Evas_Object *child) EINA_ARG_NONNULL(1, 2, 3);
   EAPI void               elm_layout_box_remove_all(Evas_Object *obj, const char *part, Eina_Bool clear) EINA_ARG_NONNULL(1, 2);
   EAPI void               elm_layout_table_pack(Evas_Object *obj, const char *part, Evas_Object *child_obj, unsigned short col, unsigned short row, unsigned short colspan, unsigned short rowspan) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_layout_table_unpack(Evas_Object *obj, const char *part, Evas_Object *child_obj) EINA_ARG_NONNULL(1, 2, 3);
   EAPI void               elm_layout_table_clear(Evas_Object *obj, const char *part, Eina_Bool clear) EINA_ARG_NONNULL(1, 2);
   EAPI Evas_Object       *elm_layout_edje_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_layout_data_get(const Evas_Object *obj, const char *key) EINA_ARG_NONNULL(1, 2);
   EAPI void               elm_layout_sizing_eval(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_layout_part_cursor_set(Evas_Object *obj, const char *part_name, const char *cursor) EINA_ARG_NONNULL(1, 2);
   EAPI const char        *elm_layout_part_cursor_get(const Evas_Object *obj, const char *part_name) EINA_ARG_NONNULL(1, 2);
   EAPI void               elm_layout_part_cursor_unset(Evas_Object *obj, const char *part_name) EINA_ARG_NONNULL(1, 2);
   EAPI Eina_Bool          elm_layout_part_cursor_style_set(Evas_Object *obj, const char *part_name, const char *style) EINA_ARG_NONNULL(1, 2);
   EAPI const char        *elm_layout_part_cursor_style_get(const Evas_Object *obj, const char *part_name) EINA_ARG_NONNULL(1, 2);
   EAPI Eina_Bool          elm_layout_part_cursor_engine_only_set(Evas_Object *obj, const char *part_name, Eina_Bool engine_only) EINA_ARG_NONNULL(1, 2);
   EAPI Eina_Bool          elm_layout_part_cursor_engine_only_get(const Evas_Object *obj, const char *part_name) EINA_ARG_NONNULL(1, 2);
/**
 * @def elm_layout_icon_set
 * Convienience macro to set the icon object in a layout that follows the
 * Elementary naming convention for its parts.
 *
 * @ingroup Layout
 */
#define elm_layout_icon_set(_ly, _obj) \
  do { \
    const char *sig; \
    elm_layout_content_set((_ly), "elm.swallow.icon", (_obj)); \
    if ((_obj)) sig = "elm,state,icon,visible"; \
    else sig = "elm,state,icon,hidden"; \
    elm_object_signal_emit((_ly), sig, "elm"); \
  } while (0)

/**
 * @def elm_layout_icon_get
 * Convienience macro to get the icon object from a layout that follows the
 * Elementary naming convention for its parts.
 *
 * @ingroup Layout
 */
#define elm_layout_icon_get(_ly) \
  elm_layout_content_get((_ly), "elm.swallow.icon")

/**
 * @def elm_layout_end_set
 * Convienience macro to set the end object in a layout that follows the
 * Elementary naming convention for its parts.
 *
 * @ingroup Layout
 */
#define elm_layout_end_set(_ly, _obj) \
  do { \
    const char *sig; \
    elm_layout_content_set((_ly), "elm.swallow.end", (_obj)); \
    if ((_obj)) sig = "elm,state,end,visible"; \
    else sig = "elm,state,end,hidden"; \
    elm_object_signal_emit((_ly), sig, "elm"); \
  } while (0)

/**
 * @def elm_layout_end_get
 * Convienience macro to get the end object in a layout that follows the
 * Elementary naming convention for its parts.
 *
 * @ingroup Layout
 */
#define elm_layout_end_get(_ly) \
  elm_layout_content_get((_ly), "elm.swallow.end")

/**
 * @def elm_layout_label_set
 * Convienience macro to set the label in a layout that follows the
 * Elementary naming convention for its parts.
 *
 * @ingroup Layout
 * @deprecate use elm_object_text_* instead.
 */
#define elm_layout_label_set(_ly, _txt) \
  elm_layout_text_set((_ly), "elm.text", (_txt))

/**
 * @def elm_layout_label_get
 * Convienience macro to get the label in a layout that follows the
 * Elementary naming convention for its parts.
 *
 * @ingroup Layout
 * @deprecate use elm_object_text_* instead.
 */
#define elm_layout_label_get(_ly) \
  elm_layout_text_get((_ly), "elm.text")

   /* smart callbacks called:
    */

   /* notify */
   typedef enum _Elm_Notify_Orient
     {
        ELM_NOTIFY_ORIENT_TOP,
        ELM_NOTIFY_ORIENT_CENTER,
        ELM_NOTIFY_ORIENT_BOTTOM,
        ELM_NOTIFY_ORIENT_LEFT,
        ELM_NOTIFY_ORIENT_RIGHT,
        ELM_NOTIFY_ORIENT_TOP_LEFT,
        ELM_NOTIFY_ORIENT_TOP_RIGHT,
        ELM_NOTIFY_ORIENT_BOTTOM_LEFT,
        ELM_NOTIFY_ORIENT_BOTTOM_RIGHT,
        ELM_NOTIFY_ORIENT_LAST
     } Elm_Notify_Orient;
   EAPI Evas_Object      *elm_notify_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void              elm_notify_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object      *elm_notify_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object      *elm_notify_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_notify_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Evas_Object      *elm_notify_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_notify_orient_set(Evas_Object *obj, Elm_Notify_Orient orient) EINA_ARG_NONNULL(1);
   EAPI Elm_Notify_Orient elm_notify_orient_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_notify_timeout_set(Evas_Object *obj, double timeout) EINA_ARG_NONNULL(1);
   EAPI double            elm_notify_timeout_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_notify_repeat_events_set(Evas_Object *obj, Eina_Bool repeat) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool         elm_notify_repeat_events_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "timeout" - when timeout happens on notify and it's hidden
    * "block,clicked" - when it's hidden by a click outside of the notify's view
    */

   /* hover */
   typedef enum _Elm_Hover_Axis
     {
        ELM_HOVER_AXIS_NONE,
        ELM_HOVER_AXIS_HORIZONTAL,
        ELM_HOVER_AXIS_VERTICAL,
        ELM_HOVER_AXIS_BOTH
     } Elm_Hover_Axis;
   EAPI Evas_Object *elm_hover_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_hover_target_set(Evas_Object *obj, Evas_Object *target) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_hover_target_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_hover_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_hover_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_hover_content_set(Evas_Object *obj, const char *swallow, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_hover_content_get(const Evas_Object *obj, const char *swallow) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_hover_content_unset(Evas_Object *obj, const char *swallow) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_hover_best_content_location_get(const Evas_Object *obj, Elm_Hover_Axis pref_axis) EINA_ARG_NONNULL(1);
   /* available styles:
    * default
    * popout
    * menu
    * hoversel_vertical
    */
   /* smart callbacks called:
    * "clicked" - the user clicked the empty space in the hover to dismiss
    * "smart,changed" - a content object placed under the "smart"
    *                   policy was replaced to a new slot direction.
    */

   /* entry */
   typedef struct _Elm_Entry_Anchor_Info Elm_Entry_Anchor_Info;
   struct _Elm_Entry_Anchor_Info
     {
        const char *name;
        int         button;
        Evas_Coord  x, y, w, h;
     };
   typedef enum _Elm_Icon_Type
     {
        ELM_ICON_NONE,
        ELM_ICON_FILE,
        ELM_ICON_STANDARD
     } Elm_Icon_Type;
   typedef struct _Elm_Hoversel_Item Elm_Hoversel_Item; /**< Item of Elm_Hoversel. Sub-type of Elm_Widget_Item */

   EAPI Evas_Object *elm_entry_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_single_line_set(Evas_Object *obj, Eina_Bool single_line) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_single_line_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_password_set(Evas_Object *obj, Eina_Bool password) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_password_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_entry_set(Evas_Object *obj, const char *entry) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_entry_entry_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_entry_append(Evas_Object *obj, const char *entry) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_is_empty(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_entry_selection_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_entry_insert(Evas_Object *obj, const char *entry) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_line_wrap_set(Evas_Object *obj, Elm_Wrap_Type wrap) EINA_ARG_NONNULL(1);
   EAPI Elm_Wrap_Type elm_entry_line_wrap_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_editable_set(Evas_Object *obj, Eina_Bool editable) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_editable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_select_none(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_select_all(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_cursor_next(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_cursor_prev(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_cursor_up(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_cursor_down(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_cursor_begin_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_cursor_end_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_cursor_line_begin_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_cursor_line_end_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_cursor_selection_begin(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_cursor_selection_end(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_cursor_is_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_cursor_is_visible_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_entry_cursor_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_cursor_geometry_get(const Evas_Object *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_cursor_pos_set(Evas_Object *obj, int pos) EINA_ARG_NONNULL(1);
   EAPI int          elm_entry_cursor_pos_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_selection_cut(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_selection_copy(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_selection_paste(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_context_menu_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_context_menu_item_add(Evas_Object *obj, const char *label, const char *icon_file, Elm_Icon_Type icon_type, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_context_menu_disabled_set(Evas_Object *obj, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_context_menu_disabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_item_provider_append(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *entry, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   EAPI void         elm_entry_item_provider_prepend(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *entry, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   EAPI void         elm_entry_item_provider_remove(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *entry, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   EAPI void         elm_entry_text_filter_append(Evas_Object *obj, void (*func) (void *data, Evas_Object *entry, char **text), void *data) EINA_ARG_NONNULL(1, 2);
   EAPI void         elm_entry_text_filter_prepend(Evas_Object *obj, void (*func) (void *data, Evas_Object *entry, char **text), void *data) EINA_ARG_NONNULL(1, 2);
   EAPI void         elm_entry_text_filter_remove(Evas_Object *obj, void (*func) (void *data, Evas_Object *entry, char **text), void *data) EINA_ARG_NONNULL(1, 2);
   EAPI char        *elm_entry_markup_to_utf8(const char *s) EINA_MALLOC EINA_WARN_UNUSED_RESULT;
   EAPI char        *elm_entry_utf8_to_markup(const char *s) EINA_MALLOC EINA_WARN_UNUSED_RESULT;
   EAPI void         elm_entry_file_set(Evas_Object *obj, const char *file, Elm_Text_Format format) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_file_get(const Evas_Object *obj, const char **file, Elm_Text_Format *format) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_file_save(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_autosave_set(Evas_Object *obj, Eina_Bool autosave) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_autosave_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_cnp_textonly_set(Evas_Object *obj, Eina_Bool textonly) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_entry_cnp_textonly_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_entry_scrollable_set(Evas_Object *obj, Eina_Bool scroll);
   EAPI Eina_Bool    elm_entry_scrollable_get(const Evas_Object *obj);
   EAPI void         elm_entry_icon_set(Evas_Object *obj, Evas_Object *icon);
   EAPI Evas_Object *elm_entry_icon_get(const Evas_Object *obj);
   EAPI Evas_Object *elm_entry_icon_unset(Evas_Object *obj);
   EAPI void         elm_entry_icon_visible_set(Evas_Object *obj, Eina_Bool setting);
   EAPI void         elm_entry_end_set(Evas_Object *obj, Evas_Object *end);
   EAPI Evas_Object *elm_entry_end_get(const Evas_Object *obj);
   EAPI Evas_Object *elm_entry_end_unset(Evas_Object *obj);
   EAPI void         elm_entry_end_visible_set(Evas_Object *obj, Eina_Bool setting);
   EAPI void         elm_entry_scrollbar_policy_set(Evas_Object *obj, Elm_Scroller_Policy h, Elm_Scroller_Policy v);
   EAPI void         elm_entry_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce);
   EAPI void         elm_entry_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce);

   /* pre-made filters for entries */
   typedef struct _Elm_Entry_Filter_Limit_Size Elm_Entry_Filter_Limit_Size;
   struct _Elm_Entry_Filter_Limit_Size
     {
        int max_char_count;
        int max_byte_count;
     };
   EAPI void         elm_entry_filter_limit_size(void *data, Evas_Object *entry, char **text) EINA_ARG_NONNULL(1, 2, 3);
   typedef struct _Elm_Entry_Filter_Accept_Set Elm_Entry_Filter_Accept_Set;
   struct _Elm_Entry_Filter_Accept_Set
     {
        const char *accepted;
        const char *rejected;
     };
   EAPI void         elm_entry_filter_accept_set(void *data, Evas_Object *entry, char **text) EINA_ARG_NONNULL(1, 3);
   /* smart callbacks called:
    * "changed" - the text content changed
    * "selection,start" - the user started selecting text
    * "selection,changed" - the user modified the selection size/location
    * "selection,cleared" - the user cleared the selection
    * "selection,paste" - the user requested a paste of text
    * "selection,copy" - the user copied the text
    * "selection,cut" - the user cut the text
    * "cursor,changed" - the cursor changed position
    * "anchor,clicked" - achor called was clicked | event_info = Elm_Entry_Anchor_Info
    * "activated" - when the enter key is pressed (useful for single line)
    * "press" - when finger/mouse is pressed down
    * "clicked" - when finger/mouse is pressed and released (without a drag etc.)
    * "clicked,double" - when finger/mouse is double-pressed
    * "longpressed" - the entry has been longpressed
    * "focused" - the entry has received keyboard focus
    * "unfocused" - keyboard focus is gone
    */

   /* composite widgets - these basically put together basic widgets above
    * in convenient packages that do more than basic stuff */

   /* anchorview */
   /**
    * @defgroup Anchorview Anchorview
    *
    * Anchorview is for displaying text that contains markup with anchors
    * like <c>\<a href=1234\>something\</\></c> in it.
    *
    * Besides being styled differently, the anchorview widget provides the
    * necessary functionality so that clicking on these anchors brings up a
    * popup with user defined content such as "call", "add to contacts" or
    * "open web page". This popup is provided using the @ref Hover widget.
    *
    * This widget is very similar to @ref Anchorblock, so refer to that
    * widget for an example. The only difference Anchorview has is that the
    * widget is already provided with scrolling functionality, so if the
    * text set to it is too large to fit in the given space, it will scroll,
    * whereas the @ref Anchorblock widget will keep growing to ensure all the
    * text can be displayed.
    *
    * This widget emits the following signals:
    * @li "anchor,clicked": will be called when an anchor is clicked. The
    * @p event_info parameter on the callback will be a pointer of type
    * ::Elm_Entry_Anchorview_Info.
    *
    * See @ref Anchorblock for an example on how to use both of them.
    *
    * @see Anchorblock
    * @see Entry
    * @see Hover
    *
    * @{
    */
   /**
    * @typedef Elm_Entry_Anchorview_Info
    *
    * The info sent in the callback for "anchor,clicked" signals emitted by
    * the Anchorview widget.
    */
   typedef struct _Elm_Entry_Anchorview_Info Elm_Entry_Anchorview_Info;
   /**
    * @struct _Elm_Entry_Anchorview_Info
    *
    * The info sent in the callback for "anchor,clicked" signals emitted by
    * the Anchorview widget.
    */
   struct _Elm_Entry_Anchorview_Info
     {
        const char     *name; /**< Name of the anchor, as indicated in its href
                                   attribute */
        int             button; /**< The mouse button used to click on it */
        Evas_Object    *hover; /**< The hover object to use for the popup */
        struct {
             Evas_Coord    x, y, w, h;
        } anchor, /**< Geometry selection of text used as anchor */
          hover_parent; /**< Geometry of the object used as parent by the
                             hover */
        Eina_Bool       hover_left : 1; /**< Hint indicating if there's space
                                             for content on the left side of
                                             the hover. Before calling the
                                             callback, the widget will make the
                                             necessary calculations to check
                                             which sides are fit to be set with
                                             content, based on the position the
                                             hover is activated and its distance
                                             to the edges of its parent object
                                             */
        Eina_Bool       hover_right : 1; /**< Hint indicating content fits on
                                              the right side of the hover.
                                              See @ref hover_left */
        Eina_Bool       hover_top : 1; /**< Hint indicating content fits on top
                                            of the hover. See @ref hover_left */
        Eina_Bool       hover_bottom : 1; /**< Hint indicating content fits
                                               below the hover. See @ref
                                               hover_left */
     };
   /**
    * Add a new Anchorview object
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object *elm_anchorview_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the text to show in the anchorview
    *
    * Sets the text of the anchorview to @p text. This text can include markup
    * format tags, including <c>\<a href=anchorname\></c> to begin a segment of
    * text that will be specially styled and react to click events, ended with
    * either of \</a\> or \</\>. When clicked, the anchor will emit an
    * "anchor,clicked" signal that you can attach a callback to with
    * evas_object_smart_callback_add(). The name of the anchor given in the
    * event info struct will be the one set in the href attribute, in this
    * case, anchorname.
    *
    * Other markup can be used to style the text in different ways, but it's
    * up to the style defined in the theme which tags do what.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_anchorview_text_set(Evas_Object *obj, const char *text) EINA_ARG_NONNULL(1);
   /**
    * Get the markup text set for the anchorview
    *
    * Retrieves the text set on the anchorview, with markup tags included.
    *
    * @param obj The anchorview object
    * @return The markup text set or @c NULL if nothing was set or an error
    * occurred
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_anchorview_text_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the parent of the hover popup
    *
    * Sets the parent object to use by the hover created by the anchorview
    * when an anchor is clicked. See @ref Hover for more details on this.
    * If no parent is set, the same anchorview object will be used.
    *
    * @param obj The anchorview object
    * @param parent The object to use as parent for the hover
    */
   EAPI void         elm_anchorview_hover_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Get the parent of the hover popup
    *
    * Get the object used as parent for the hover created by the anchorview
    * widget. See @ref Hover for more details on this.
    *
    * @param obj The anchorview object
    * @return The object used as parent for the hover, NULL if none is set.
    */
   EAPI Evas_Object *elm_anchorview_hover_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the style that the hover should use
    *
    * When creating the popup hover, anchorview will request that it's
    * themed according to @p style.
    *
    * @param obj The anchorview object
    * @param style The style to use for the underlying hover
    *
    * @see elm_object_style_set()
    */
   EAPI void         elm_anchorview_hover_style_set(Evas_Object *obj, const char *style) EINA_ARG_NONNULL(1);
   /**
    * Get the style that the hover should use
    *
    * Get the style the hover created by anchorview will use.
    *
    * @param obj The anchorview object
    * @return The style to use by the hover. NULL means the default is used.
    *
    * @see elm_object_style_set()
    */
   EAPI const char  *elm_anchorview_hover_style_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Ends the hover popup in the anchorview
    *
    * When an anchor is clicked, the anchorview widget will create a hover
    * object to use as a popup with user provided content. This function
    * terminates this popup, returning the anchorview to its normal state.
    *
    * @param obj The anchorview object
    */
   EAPI void         elm_anchorview_hover_end(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set bouncing behaviour when the scrolled content reaches an edge
    *
    * Tell the internal scroller object whether it should bounce or not
    * when it reaches the respective edges for each axis.
    *
    * @param obj The anchorview object
    * @param h_bounce Whether to bounce or not in the horizontal axis
    * @param v_bounce Whether to bounce or not in the vertical axis
    *
    * @see elm_scroller_bounce_set()
    */
   EAPI void         elm_anchorview_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   /**
    * Get the set bouncing behaviour of the internal scroller
    *
    * Get whether the internal scroller should bounce when the edge of each
    * axis is reached scrolling.
    *
    * @param obj The anchorview object
    * @param h_bounce Pointer where to store the bounce state of the horizontal
    *                 axis
    * @param v_bounce Pointer where to store the bounce state of the vertical
    *                 axis
    *
    * @see elm_scroller_bounce_get()
    */
   EAPI void         elm_anchorview_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   /**
    * Appends a custom item provider to the given anchorview
    *
    * Appends the given function to the list of items providers. This list is
    * called, one function at a time, with the given @p data pointer, the
    * anchorview object and, in the @p item parameter, the item name as
    * referenced in its href string. Following functions in the list will be
    * called in order until one of them returns something different to NULL,
    * which should be an Evas_Object which will be used in place of the item
    * element.
    *
    * Items in the markup text take the form \<item relsize=16x16 vsize=full
    * href=item/name\>\</item\>
    *
    * @param obj The anchorview object
    * @param func The function to add to the list of providers
    * @param data User data that will be passed to the callback function
    *
    * @see elm_entry_item_provider_append()
    */
   EAPI void         elm_anchorview_item_provider_append(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *anchorview, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * Prepend a custom item provider to the given anchorview
    *
    * Like elm_anchorview_item_provider_append(), but it adds the function
    * @p func to the beginning of the list, instead of the end.
    *
    * @param obj The anchorview object
    * @param func The function to add to the list of providers
    * @param data User data that will be passed to the callback function
    */
   EAPI void         elm_anchorview_item_provider_prepend(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *anchorview, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * Remove a custom item provider from the list of the given anchorview
    *
    * Removes the function and data pairing that matches @p func and @p data.
    * That is, unless the same function and same user data are given, the
    * function will not be removed from the list. This allows us to add the
    * same callback several times, with different @p data pointers and be
    * able to remove them later without conflicts.
    *
    * @param obj The anchorview object
    * @param func The function to remove from the list
    * @param data The data matching the function to remove from the list
    */
   EAPI void         elm_anchorview_item_provider_remove(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *anchorview, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * @}
    */

   /* anchorblock */
   /**
    * @defgroup Anchorblock Anchorblock
    *
    * Anchorblock is for displaying text that contains markup with anchors
    * like <c>\<a href=1234\>something\</\></c> in it.
    *
    * Besides being styled differently, the anchorblock widget provides the
    * necessary functionality so that clicking on these anchors brings up a
    * popup with user defined content such as "call", "add to contacts" or
    * "open web page". This popup is provided using the @ref Hover widget.
    *
    * This widget emits the following signals:
    * @li "anchor,clicked": will be called when an anchor is clicked. The
    * @p event_info parameter on the callback will be a pointer of type
    * ::Elm_Entry_Anchorblock_Info.
    *
    * @see Anchorview
    * @see Entry
    * @see Hover
    *
    * Since examples are usually better than plain words, we might as well
    * try @ref tutorial_anchorblock_example "one".
    */
   /**
    * @page tutorial_anchorblock_example Anchorblock/Anchorview example
    * This exampel will show both Anchorblock and @ref Anchorview,
    * since both are very similar and it's easier to show them once and side
    * by side, so the difference is more clear.
    *
    * We'll show the relevant snippets of the code here, but the full example
    * can be found here... sorry, @ref anchorblock_example_01.c "here".
    *
    * As for the actual example, it's just a simple window with an anchorblock
    * and an anchorview, both containing the same text. After including
    * Elementary.h and declaring some functions we'll need, we jump to our
    * elm_main (see ELM_MAIN) and create our window.
    * @dontinclude anchorblock_example_01.c
    * @skip int
    * @until const char
    * @until ;
    *
    * With the needed variables declared, we'll create the window and a box to
    * hold our widgets, but we don't need to go through that here.
    *
    * In order to make clear where the anchorblock ends and the anchorview
    * begins, they'll be each inside a @ref Frame. After creating the frame,
    * the anchorblock follows.
    * @skip elm_frame_add
    * @until elm_frame_content_set
    *
    * Nothing out of the ordinary there. What's worth mentioning is the call
    * to elm_anchorblock_hover_parent_set(). We are telling our widget that
    * when an anchor is clicked, the hover for the popup will cover the entire
    * window. This affects the area that will be obscured by the hover and
    * where clicking will dismiss it, as well as the calculations it does to
    * inform the best locations where to insert the popups content.
    * Other than that, the code is pretty standard. We also need to set our
    * callback for when an anchor is clicked, since it's our task to populate
    * the popup. There's no default for it.
    *
    * The anchorview is no different, we only change a few things so it looks
    * different.
    * @until elm_frame_content_set
    *
    * Then we run, so stuff works and close our main function in the usual way.
    * @until ELM_MAIN
    *
    * Now, a little note. Normally you would use either one of anchorblock or
    * anchorview, set your one callback to clicks and do your stuff in there.
    * In this example, however, there are a few tricks to make it easier to
    * show both widgets in one go (and to save me some typing). So we have
    * two callbacks, one per widget, that will call a common function to do
    * the rest. The trick is using ::Elm_Entry_Anchorblock_Info for the
    * anchorview too, since both are equal, and passing a callback to use
    * for our buttons to end the hover, because each widget has a different
    * function for it.
    * @until _anchorview_clicked_cb
    * @until }
    *
    * The meat of our popup is in the following function. We check what kind
    * of menu we need to show, based on the name set to the anchor in the
    * markup text. If there's no type (something went wrong, no valid contact
    * in the address list) we are just putting a button that does nothing, but
    * it's perfectly reasonable to just end the hover and call it quits.
    *
    * Our popup will consist of one main button in the middle of our hover,
    * and possibly a secondary button and a list of other options. We'll create
    * first our main button and check what kind of popup we need afterwards.
    * @skip static void
    * @skip static void
    * @until eina_stringshare_add
    * @until }
    *
    * Each button has two callbacks, one is our hack to close the hover
    * properly based on which widget it belongs to, the other a simple
    * printf that will show the action with the anchors own data. This is
    * not how you would usually do it. Instead, the common case is to have
    * one callback for the button that will know which function to call to end
    * things, but since we are doing it this way it's worth noting that
    * smart callbacks will be called in reverse in respect to the order they
    * were added, and since our @c btn_end_cb will close the hover, and thus
    * delete our buttons, the other callback wouldn't be called if we had
    * added it before.
    *
    * After our telephone popup, there are a few others that are practically
    * the same, so they won't be shown here.
    *
    * Once we are done with that, it's time to place our actions into our
    * hover. Main button goes in the middle without much questioning, and then
    * we see if we have a secondary button and a box of extra options.
    * Because I said so, secondary button goes on either side and box of
    * options either on top or below the main one, but to choose which
    * exactly, we use the hints our callback info has, which saves us from
    * having to do the math and see which side has more space available, with
    * a little special case where we delete our extra stuff if there's nowhere
    * to place it.
    * @skip url:
    * @skip }
    * @skip evas_object_smart
    * @until evas_object_del(box)
    * @until }
    * @until }
    *
    * The example will look like this:
    * @image html screenshots/anchorblock_01.png
    * @image latex screenshots/anchorblock_01.eps
    *
    * @example anchorblock_example_01.c
    */
   /**
    * @addtogroup Anchorblock
    * @{
    */
   /**
    * @typedef Elm_Entry_Anchorblock_Info
    *
    * The info sent in the callback for "anchor,clicked" signals emitted by
    * the Anchorblock widget.
    */
   typedef struct _Elm_Entry_Anchorblock_Info Elm_Entry_Anchorblock_Info;
   /**
    * @struct _Elm_Entry_Anchorblock_Info
    *
    * The info sent in the callback for "anchor,clicked" signals emitted by
    * the Anchorblock widget.
    */
   struct _Elm_Entry_Anchorblock_Info
     {
        const char     *name; /**< Name of the anchor, as indicated in its href
                                   attribute */
        int             button; /**< The mouse button used to click on it */
        Evas_Object    *hover; /**< The hover object to use for the popup */
        struct {
             Evas_Coord    x, y, w, h;
        } anchor, /**< Geometry selection of text used as anchor */
          hover_parent; /**< Geometry of the object used as parent by the
                             hover */
        Eina_Bool       hover_left : 1; /**< Hint indicating if there's space
                                             for content on the left side of
                                             the hover. Before calling the
                                             callback, the widget will make the
                                             necessary calculations to check
                                             which sides are fit to be set with
                                             content, based on the position the
                                             hover is activated and its distance
                                             to the edges of its parent object
                                             */
        Eina_Bool       hover_right : 1; /**< Hint indicating content fits on
                                              the right side of the hover.
                                              See @ref hover_left */
        Eina_Bool       hover_top : 1; /**< Hint indicating content fits on top
                                            of the hover. See @ref hover_left */
        Eina_Bool       hover_bottom : 1; /**< Hint indicating content fits
                                               below the hover. See @ref
                                               hover_left */
     };
   /**
    * Add a new Anchorblock object
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    */
   EAPI Evas_Object *elm_anchorblock_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the text to show in the anchorblock
    *
    * Sets the text of the anchorblock to @p text. This text can include markup
    * format tags, including <c>\<a href=anchorname\></a></c> to begin a segment
    * of text that will be specially styled and react to click events, ended
    * with either of \</a\> or \</\>. When clicked, the anchor will emit an
    * "anchor,clicked" signal that you can attach a callback to with
    * evas_object_smart_callback_add(). The name of the anchor given in the
    * event info struct will be the one set in the href attribute, in this
    * case, anchorname.
    *
    * Other markup can be used to style the text in different ways, but it's
    * up to the style defined in the theme which tags do what.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_anchorblock_text_set(Evas_Object *obj, const char *text) EINA_ARG_NONNULL(1);
   /**
    * Get the markup text set for the anchorblock
    *
    * Retrieves the text set on the anchorblock, with markup tags included.
    *
    * @param obj The anchorblock object
    * @return The markup text set or @c NULL if nothing was set or an error
    * occurred
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_anchorblock_text_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the parent of the hover popup
    *
    * Sets the parent object to use by the hover created by the anchorblock
    * when an anchor is clicked. See @ref Hover for more details on this.
    *
    * @param obj The anchorblock object
    * @param parent The object to use as parent for the hover
    */
   EAPI void         elm_anchorblock_hover_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Get the parent of the hover popup
    *
    * Get the object used as parent for the hover created by the anchorblock
    * widget. See @ref Hover for more details on this.
    * If no parent is set, the same anchorblock object will be used.
    *
    * @param obj The anchorblock object
    * @return The object used as parent for the hover, NULL if none is set.
    */
   EAPI Evas_Object *elm_anchorblock_hover_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the style that the hover should use
    *
    * When creating the popup hover, anchorblock will request that it's
    * themed according to @p style.
    *
    * @param obj The anchorblock object
    * @param style The style to use for the underlying hover
    *
    * @see elm_object_style_set()
    */
   EAPI void         elm_anchorblock_hover_style_set(Evas_Object *obj, const char *style) EINA_ARG_NONNULL(1);
   /**
    * Get the style that the hover should use
    *
    * Get the style the hover created by anchorblock will use.
    *
    * @param obj The anchorblock object
    * @return The style to use by the hover. NULL means the default is used.
    *
    * @see elm_object_style_set()
    */
   EAPI const char  *elm_anchorblock_hover_style_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Ends the hover popup in the anchorblock
    *
    * When an anchor is clicked, the anchorblock widget will create a hover
    * object to use as a popup with user provided content. This function
    * terminates this popup, returning the anchorblock to its normal state.
    *
    * @param obj The anchorblock object
    */
   EAPI void         elm_anchorblock_hover_end(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Appends a custom item provider to the given anchorblock
    *
    * Appends the given function to the list of items providers. This list is
    * called, one function at a time, with the given @p data pointer, the
    * anchorblock object and, in the @p item parameter, the item name as
    * referenced in its href string. Following functions in the list will be
    * called in order until one of them returns something different to NULL,
    * which should be an Evas_Object which will be used in place of the item
    * element.
    *
    * Items in the markup text take the form \<item relsize=16x16 vsize=full
    * href=item/name\>\</item\>
    *
    * @param obj The anchorblock object
    * @param func The function to add to the list of providers
    * @param data User data that will be passed to the callback function
    *
    * @see elm_entry_item_provider_append()
    */
   EAPI void         elm_anchorblock_item_provider_append(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *anchorblock, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * Prepend a custom item provider to the given anchorblock
    *
    * Like elm_anchorblock_item_provider_append(), but it adds the function
    * @p func to the beginning of the list, instead of the end.
    *
    * @param obj The anchorblock object
    * @param func The function to add to the list of providers
    * @param data User data that will be passed to the callback function
    */
   EAPI void         elm_anchorblock_item_provider_prepend(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *anchorblock, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * Remove a custom item provider from the list of the given anchorblock
    *
    * Removes the function and data pairing that matches @p func and @p data.
    * That is, unless the same function and same user data are given, the
    * function will not be removed from the list. This allows us to add the
    * same callback several times, with different @p data pointers and be
    * able to remove them later without conflicts.
    *
    * @param obj The anchorblock object
    * @param func The function to remove from the list
    * @param data The data matching the function to remove from the list
    */
   EAPI void         elm_anchorblock_item_provider_remove(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *anchorblock, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   /**
    * @}
    */

   /**
    * @defgroup Bubble Bubble
    *
    * @brief The Bubble is a widget to show text similarly to how speech is
    * represented in comics.
    *
    * The bubble widget contains 5 important visual elements:
    * @li The frame is a rectangle with rounded rectangles and an "arrow".
    * @li The @p icon is an image to which the frame's arrow points to.
    * @li The @p label is a text which appears to the right of the icon if the
    * corner is "top_left" or "bottom_left" and is right aligned to the frame
    * otherwise.
    * @li The @p info is a text which appears to the right of the label. Info's
    * font is of a ligther color than label.
    * @li The @p content is an evas object that is shown inside the frame.
    *
    * The position of the arrow, icon, label and info depends on which corner is
    * selected. The four available corners are:
    * @li "top_left" - Default
    * @li "top_right"
    * @li "bottom_left"
    * @li "bottom_right"
    *
    * Signals that you can add callbacks for are:
    * @li "clicked" - This is called when a user has clicked the bubble.
    *
    * For an example of using a buble see @ref bubble_01_example_page "this".
    *
    * @{
    */
   /**
    * Add a new bubble to the parent
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    *
    * This function adds a text bubble to the given parent evas object.
    */
   EAPI Evas_Object *elm_bubble_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set the label of the bubble
    *
    * @param obj The bubble object
    * @param label The string to set in the label
    *
    * This function sets the title of the bubble. Where this appears depends on
    * the selected corner.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_bubble_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   /**
    * Get the label of the bubble
    *
    * @param obj The bubble object
    * @return The string of set in the label
    *
    * This function gets the title of the bubble.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_bubble_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the info of the bubble
    *
    * @param obj The bubble object
    * @param info The given info about the bubble
    *
    * This function sets the info of the bubble. Where this appears depends on
    * the selected corner.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void         elm_bubble_info_set(Evas_Object *obj, const char *info) EINA_ARG_NONNULL(1);
   /**
    * Get the info of the bubble
    *
    * @param obj The bubble object
    *
    * @return The "info" string of the bubble
    *
    * This function gets the info text.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char  *elm_bubble_info_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the content to be shown in the bubble
    *
    * Once the content object is set, a previously set one will be deleted.
    * If you want to keep the old content object, use the
    * elm_bubble_content_unset() function.
    *
    * @param obj The bubble object
    * @param content The given content of the bubble
    *
    * This function sets the content shown on the middle of the bubble.
    */
   EAPI void         elm_bubble_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   /**
    * Get the content shown in the bubble
    *
    * Return the content object which is set for this widget.
    *
    * @param obj The bubble object
    * @return The content that is being used
    */
   EAPI Evas_Object *elm_bubble_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Unset the content shown in the bubble
    *
    * Unparent and return the content object which was set for this widget.
    *
    * @param obj The bubble object
    * @return The content that was being used
    */
   EAPI Evas_Object *elm_bubble_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the icon of the bubble
    *
    * Once the icon object is set, a previously set one will be deleted.
    * If you want to keep the old content object, use the
    * elm_icon_content_unset() function.
    *
    * @param obj The bubble object
    * @param icon The given icon for the bubble
    */
   EAPI void         elm_bubble_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   /**
    * Get the icon of the bubble
    *
    * @param obj The bubble object
    * @return The icon for the bubble
    *
    * This function gets the icon shown on the top left of bubble.
    */
   EAPI Evas_Object *elm_bubble_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Unset the icon of the bubble
    *
    * Unparent and return the icon object which was set for this widget.
    *
    * @param obj The bubble object
    * @return The icon that was being used
    */
   EAPI Evas_Object *elm_bubble_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the corner of the bubble
    *
    * @param obj The bubble object.
    * @param corner The given corner for the bubble.
    *
    * This function sets the corner of the bubble. The corner will be used to
    * determine where the arrow in the frame points to and where label, icon and
    * info arre shown.
    *
    * Possible values for corner are:
    * @li "top_left" - Default
    * @li "top_right"
    * @li "bottom_left"
    * @li "bottom_right"
    */
   EAPI void         elm_bubble_corner_set(Evas_Object *obj, const char *corner) EINA_ARG_NONNULL(1, 2);
   /**
    * Get the corner of the bubble
    *
    * @param obj The bubble object.
    * @return The given corner for the bubble.
    *
    * This function gets the selected corner of the bubble.
    */
   EAPI const char  *elm_bubble_corner_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* photo */
   EAPI Evas_Object *elm_photo_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_photo_file_set(Evas_Object *obj, const char *file) EINA_ARG_NONNULL(1);
   EAPI void         elm_photo_size_set(Evas_Object *obj, int size) EINA_ARG_NONNULL(1);
   EAPI void         elm_photo_fill_inside_set(Evas_Object *obj, Eina_Bool fill) EINA_ARG_NONNULL(1);
   EAPI void         elm_photo_editable_set(Evas_Object *obj, Eina_Bool set) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "clicked" - the user clicked the icon
    * "drag,start" - Someone started dragging the image out of the object
    * "drag,end" - Dragged item was dropped (somewhere)
    */

   /* gesture layer */
   /** @defgroup Elm_Gesture_Layer Gesture Layer */
   /**
    * @enum _Elm_Gesture_Types
    * Emum of supported gesture types.
    * @ingroup Elm_Gesture_Layer
    */
   enum _Elm_Gesture_Types
     {
        ELM_GESTURE_FIRST = 0,

        ELM_GESTURE_N_TAPS, /**< N fingers single taps */
        ELM_GESTURE_N_DOUBLE_TAPS, /**< N fingers double-single taps */
        ELM_GESTURE_N_TRIPLE_TAPS, /**< N fingers triple-single taps */

        ELM_GESTURE_MOMENTUM, /**< Reports momentum in the dircetion of move */

        ELM_GESTURE_N_LINES, /**< N fingers line gesture */
        ELM_GESTURE_N_FLICKS, /**< N fingers flick gesture */

        ELM_GESTURE_ZOOM, /**< Zoom */
        ELM_GESTURE_ROTATE, /**< Rotate */

        ELM_GESTURE_LAST
     };

   /**
    * @typedef Elm_Gesture_Types
    * Type for Emum of supported gesture types.
    * @ingroup Elm_Gesture_Layer
    */
   typedef enum _Elm_Gesture_Types Elm_Gesture_Types;

   /**
    * @enum _Elm_Gesture_State
    * Emum of gesture states.
    * @ingroup Elm_Gesture_Layer
    */
   enum _Elm_Gesture_State
     {
        ELM_GESTURE_STATE_UNDEFINED = -1, /**< Gesture not STARTed */
        ELM_GESTURE_STATE_START,          /**< Gesture STARTed     */
        ELM_GESTURE_STATE_MOVE,           /**< Gesture is ongoing  */
        ELM_GESTURE_STATE_END,            /**< Gesture completed   */
        ELM_GESTURE_STATE_ABORT    /**< Onging gesture was ABORTed */
     };
   /**
    * @typedef Elm_Gesture_State
    * gesture states.
    * @ingroup Elm_Gesture_Layer
    */
   typedef enum _Elm_Gesture_State Elm_Gesture_State;

   /**
    * @struct _Elm_Gesture_Taps_Info
    * Struct holds taps info for user
    * @ingroup Elm_Gesture_Layer
    */
   struct _Elm_Gesture_Taps_Info
     {
        Evas_Coord x, y;         /**< Holds center point between fingers */
        unsigned int n;          /**< Number of fingers tapped           */
        unsigned int timestamp;  /**< event timestamp       */
     };

   /**
    * @typedef Elm_Gesture_Taps_Info
    * holds taps info for user
    * @ingroup Elm_Gesture_Layer
    */
   typedef struct _Elm_Gesture_Taps_Info Elm_Gesture_Taps_Info;

   /**
    * @struct _Elm_Gesture_Momentum_Info
    * Struct holds momentum info for user
    * x1 and y1 are not necessarily in sync
    * x1 holds x value of x direction starting point
    * and same holds for y1.
    * This is noticeable when doing V-shape movement
    * @ingroup Elm_Gesture_Layer
    */
   struct _Elm_Gesture_Momentum_Info
     {  /* Report line ends, timestamps, and momentum computed        */
        Evas_Coord x1; /**< Final-swipe direction starting point on X */
        Evas_Coord y1; /**< Final-swipe direction starting point on Y */
        Evas_Coord x2; /**< Final-swipe direction ending point on X   */
        Evas_Coord y2; /**< Final-swipe direction ending point on Y   */

        unsigned int tx; /**< Timestamp of start of final x-swipe */
        unsigned int ty; /**< Timestamp of start of final y-swipe */

        Evas_Coord mx; /**< Momentum on X */
        Evas_Coord my; /**< Momentum on Y */
     };

   /**
    * @typedef Elm_Gesture_Momentum_Info
    * holds momentum info for user
    * @ingroup Elm_Gesture_Layer
    */
    typedef struct _Elm_Gesture_Momentum_Info Elm_Gesture_Momentum_Info;

   /**
    * @struct _Elm_Gesture_Line_Info
    * Struct holds line info for user
    * @ingroup Elm_Gesture_Layer
    */
   struct _Elm_Gesture_Line_Info
     {  /* Report line ends, timestamps, and momentum computed      */
        Elm_Gesture_Momentum_Info momentum; /**< Line momentum info */
        unsigned int n;            /**< Number of fingers (lines)   */
        /* FIXME should be radians, bot degrees */
        double angle;              /**< Angle (direction) of lines  */
     };

   /**
    * @typedef _Elm_Gesture_Line_Info
    * Holds line info for user
    * @ingroup Elm_Gesture_Layer
    */
    typedef struct  _Elm_Gesture_Line_Info Elm_Gesture_Line_Info;

   /**
    * @struct _Elm_Gesture_Zoom_Info
    * Struct holds zoom info for user
    * @ingroup Elm_Gesture_Layer
    */
   struct _Elm_Gesture_Zoom_Info
     {
        Evas_Coord x, y;       /**< Holds zoom center point reported to user  */
        Evas_Coord radius; /**< Holds radius between fingers reported to user */
        float zoom;            /**< Zoom value: 1.0 means no zoom             */
        float momentum;        /**< Zoom momentum: zoom growth per second (NOT YET SUPPORTED) */
     };

   /**
    * @typedef Elm_Gesture_Zoom_Info
    * Holds zoom info for user
    * @ingroup Elm_Gesture_Layer
    */
   typedef struct _Elm_Gesture_Zoom_Info Elm_Gesture_Zoom_Info;

   /**
    * @struct _Elm_Gesture_Rotate_Info
    * Struct holds rotation info for user
    * @ingroup Elm_Gesture_Layer
    */
   struct _Elm_Gesture_Rotate_Info
     {
        Evas_Coord x, y;   /**< Holds zoom center point reported to user      */
        Evas_Coord radius; /**< Holds radius between fingers reported to user */
        double base_angle; /**< Holds start-angle */
        double angle;      /**< Rotation value: 0.0 means no rotation         */
        double momentum;   /**< Rotation momentum: rotation done per second (NOT YET SUPPORTED) */
     };

   /**
    * @typedef Elm_Gesture_Rotate_Info
    * Holds rotation info for user
    * @ingroup Elm_Gesture_Layer
    */
   typedef struct _Elm_Gesture_Rotate_Info Elm_Gesture_Rotate_Info;

   /**
    * @typedef Elm_Gesture_Event_Cb
    * User callback used to stream gesture info from gesture layer
    * @param data user data
    * @param event_info gesture report info
    * Returns a flag field to be applied on the causing event.
    * You should probably return EVAS_EVENT_FLAG_ON_HOLD if your widget acted
    * upon the event, in an irreversible way.
    *
    * @ingroup Elm_Gesture_Layer
    */
   typedef Evas_Event_Flags (*Elm_Gesture_Event_Cb) (void *data, void *event_info);

   /**
    * Use function to set callbacks to be notified about
    * change of state of gesture.
    * When a user registers a callback with this function
    * this means this gesture has to be tested.
    *
    * When ALL callbacks for a gesture are set to NULL
    * it means user isn't interested in gesture-state
    * and it will not be tested.
    *
    * @param obj Pointer to gesture-layer.
    * @param idx The gesture you would like to track its state.
    * @param cb callback function pointer.
    * @param cb_type what event this callback tracks: START, MOVE, END, ABORT.
    * @param data user info to be sent to callback (usually, Smart Data)
    *
    * @ingroup Elm_Gesture_Layer
    */
   EAPI void elm_gesture_layer_cb_set(Evas_Object *obj, Elm_Gesture_Types idx, Elm_Gesture_State cb_type, Elm_Gesture_Event_Cb cb, void *data) EINA_ARG_NONNULL(1);

   /**
    * Call this function to get repeat-events settings.
    *
    * @param obj Pointer to gesture-layer.
    *
    * @return repeat events settings.
    * @see elm_gesture_layer_hold_events_set()
    * @ingroup Elm_Gesture_Layer
    */
   EAPI Eina_Bool elm_gesture_layer_hold_events_get(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /**
    * This function called in order to make gesture-layer repeat events.
    * Set this of you like to get the raw events only if gestures were not detected.
    * Clear this if you like gesture layer to fwd events as testing gestures.
    *
    * @param obj Pointer to gesture-layer.
    * @param r Repeat: TRUE/FALSE
    *
    * @ingroup Elm_Gesture_Layer
    */
   EAPI void elm_gesture_layer_hold_events_set(Evas_Object *obj, Eina_Bool r) EINA_ARG_NONNULL(1);

   /**
    * This function sets step-value for zoom action.
    * Set step to any positive value.
    * Cancel step setting by setting to 0.0
    *
    * @param obj Pointer to gesture-layer.
    * @param s new zoom step value.
    *
    * @ingroup Elm_Gesture_Layer
    */
   EAPI void elm_gesture_layer_zoom_step_set(Evas_Object *obj, double s) EINA_ARG_NONNULL(1);

   /**
    * This function sets step-value for rotate action.
    * Set step to any positive value.
    * Cancel step setting by setting to 0.0
    *
    * @param obj Pointer to gesture-layer.
    * @param s new roatate step value.
    *
    * @ingroup Elm_Gesture_Layer
    */
   EAPI void elm_gesture_layer_rotate_step_set(Evas_Object *obj, double s) EINA_ARG_NONNULL(1);

   /**
    * This function called to attach gesture-layer to an Evas_Object.
    * @param obj Pointer to gesture-layer.
    * @param t Pointer to underlying object (AKA Target)
    *
    * @return TRUE, FALSE on success, failure.
    *
    * @ingroup Elm_Gesture_Layer
    */
   EAPI Eina_Bool elm_gesture_layer_attach(Evas_Object *obj, Evas_Object *t) EINA_ARG_NONNULL(1, 2);

   /**
    * Call this function to construct a new gesture-layer object.
    * This does not activate the gesture layer. You have to
    * call elm_gesture_layer_attach in order to 'activate' gesture-layer.
    *
    * @param parent the parent object.
    *
    * @return Pointer to new gesture-layer object.
    *
    * @ingroup Elm_Gesture_Layer
    */
   EAPI Evas_Object *elm_gesture_layer_add(Evas_Object *parent) EINA_ARG_NONNULL(1);

   /* thumb */
   typedef enum _Elm_Thumb_Animation_Setting
     {
        ELM_THUMB_ANIMATION_START = 0, /* Play animation once */
        ELM_THUMB_ANIMATION_LOOP,      /* Keep playing animation until stop is requested */
        ELM_THUMB_ANIMATION_STOP,
        ELM_THUMB_ANIMATION_LAST
     } Elm_Thumb_Animation_Setting;

   EAPI Evas_Object                 *elm_thumb_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void                         elm_thumb_reload(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                         elm_thumb_file_set(Evas_Object *obj, const char *file, const char *key) EINA_ARG_NONNULL(1);
   EAPI void                         elm_thumb_file_get(const Evas_Object *obj, const char **file, const char **key) EINA_ARG_NONNULL(1);
   EAPI void                         elm_thumb_path_get(const Evas_Object *obj, const char **file, const char **key) EINA_ARG_NONNULL(1);
   EAPI void                         elm_thumb_animate_set(Evas_Object *obj, Elm_Thumb_Animation_Setting s) EINA_ARG_NONNULL(1);
   EAPI Elm_Thumb_Animation_Setting  elm_thumb_animate_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                        *elm_thumb_ethumb_client_get(void);
   EAPI Eina_Bool                    elm_thumb_ethumb_client_connected(void);
   EAPI Eina_Bool                    elm_thumb_editable_set(Evas_Object *obj, Eina_Bool edit) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool                    elm_thumb_editable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* available styles:
    * default
    * noframe
    */
   /* smart callbacks called:
    * "clicked" - This is called when a user has clicked the thumb without dragging around.
    * "clicked,double" - This is called when a user has double-clicked the thumb.
    * "press" - This is called when a user has pressed down the thumb.
    * "generate,start" - The thumbnail generation started.
    * "generate,stop" - The generation process stopped.
    * "generate,error" - The generation failed.
    * "load,error" - The thumbnail image loading failed.
    */

   /* hoversel */
   EAPI Evas_Object       *elm_hoversel_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void               elm_hoversel_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_hoversel_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_hoversel_hover_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_hoversel_hover_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void               elm_hoversel_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char        *elm_hoversel_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_hoversel_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_hoversel_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_hoversel_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_hoversel_hover_begin(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_hoversel_hover_end(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_hoversel_expanded_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_hoversel_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List   *elm_hoversel_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Hoversel_Item *elm_hoversel_item_add(Evas_Object *obj, const char *label, const char *icon_file, Elm_Icon_Type icon_type, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI void               elm_hoversel_item_del(Elm_Hoversel_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_hoversel_item_del_cb_set(Elm_Hoversel_Item *it, Evas_Smart_Cb func) EINA_ARG_NONNULL(1);
   EAPI void              *elm_hoversel_item_data_get(const Elm_Hoversel_Item *it) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_hoversel_item_label_get(const Elm_Hoversel_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_hoversel_item_icon_set(Elm_Hoversel_Item *it, const char *icon_file, const char *icon_group, Elm_Icon_Type icon_type) EINA_ARG_NONNULL(1);
   EAPI void               elm_hoversel_item_icon_get(const Elm_Hoversel_Item *it, const char **icon_file, const char **icon_group, Elm_Icon_Type *icon_type) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "clicked" - the user clicked the hoversel button and popped up the sel
    * "selected" - an item in the hoversel list is selected
    * "dismissed" - the hover is dismissed
    */

   /* toolbar */
   typedef enum _Elm_Toolbar_Shrink_Mode
     {
        ELM_TOOLBAR_SHRINK_NONE,   /**< set toolbar minimun size to fit all the items */
        ELM_TOOLBAR_SHRINK_HIDE,   /**< hide excess items */
        ELM_TOOLBAR_SHRINK_SCROLL, /**< allow accessing excess items through a scroller */
        ELM_TOOLBAR_SHRINK_MENU    /**< inserts a button to pop up a menu with excess items */
     } Elm_Toolbar_Shrink_Mode;

   typedef struct _Elm_Toolbar_Item Elm_Toolbar_Item; /**< Item of Elm_Toolbar. Sub-type of Elm_Widget_Item */
   typedef struct _Elm_Toolbar_Item_State Elm_Toolbar_Item_State; /** State of a Elm_Toolbar_Item */

   EAPI Evas_Object            *elm_toolbar_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_icon_size_set(Evas_Object *obj, int icon_size) EINA_ARG_NONNULL(1);
   EAPI int                     elm_toolbar_icon_size_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_icon_order_lookup_set(Evas_Object *obj, Elm_Icon_Lookup_Order order) EINA_ARG_NONNULL(1);
   EAPI Elm_Icon_Lookup_Order   elm_toolbar_icon_order_lookup_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_no_select_mode_set(Evas_Object *obj, Eina_Bool no_select) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_no_select_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_append(Evas_Object *obj, const char *icon, const char *label, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_prepend(Evas_Object *obj, const char *icon, const char *label, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_insert_before(Evas_Object *obj, Elm_Toolbar_Item *before, const char *icon, const char *label, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_insert_after(Evas_Object *obj, Elm_Toolbar_Item *after, const char *icon, const char *label, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_first_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_last_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_next_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_prev_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI Evas_Object            *elm_toolbar_item_toolbar_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_priority_set(Elm_Toolbar_Item *item, int priority) EINA_ARG_NONNULL(1);
   EAPI int                     elm_toolbar_item_priority_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI const char             *elm_toolbar_item_icon_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI const char             *elm_toolbar_item_label_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_label_set(Elm_Toolbar_Item *item, const char *label) EINA_ARG_NONNULL(1);
   EAPI void                   *elm_toolbar_item_data_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_data_set(Elm_Toolbar_Item *item, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_item_find_by_label(const Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_item_selected_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_selected_set(Elm_Toolbar_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item       *elm_toolbar_selected_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_icon_set(Elm_Toolbar_Item *item, const char *icon) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_del(Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_del_cb_set(Elm_Toolbar_Item *item, Evas_Smart_Cb func) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_item_disabled_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_disabled_set(Elm_Toolbar_Item *item, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_separator_set(Elm_Toolbar_Item *item, Eina_Bool separator) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_item_separator_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_mode_shrink_set(Evas_Object *obj, Elm_Toolbar_Shrink_Mode shrink_mode) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Shrink_Mode elm_toolbar_mode_shrink_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_homogeneous_set(Evas_Object *obj, Eina_Bool homogeneous) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_homogeneous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void    elm_toolbar_homogenous_set(Evas_Object *obj, Eina_Bool homogenous) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool elm_toolbar_homogenous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_menu_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Evas_Object            *elm_toolbar_menu_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_align_set(Evas_Object *obj, double align) EINA_ARG_NONNULL(1);
   EAPI double                  elm_toolbar_align_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_menu_set(Elm_Toolbar_Item *item, Eina_Bool menu) EINA_ARG_NONNULL(1);
   EAPI Evas_Object            *elm_toolbar_item_menu_get(Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item_State *elm_toolbar_item_state_add(Elm_Toolbar_Item *item, const char *icon, const char *label, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_item_state_del(Elm_Toolbar_Item *item, Elm_Toolbar_Item_State *state) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_item_state_set(Elm_Toolbar_Item *it, Elm_Toolbar_Item_State *state) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_state_unset(Elm_Toolbar_Item *it) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item_State *elm_toolbar_item_state_get(const Elm_Toolbar_Item *it) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item_State *elm_toolbar_item_state_next(Elm_Toolbar_Item *it) EINA_ARG_NONNULL(1);
   EAPI Elm_Toolbar_Item_State *elm_toolbar_item_state_prev(Elm_Toolbar_Item *it) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_tooltip_text_set(Elm_Toolbar_Item *item, const char *text) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_tooltip_content_cb_set(Elm_Toolbar_Item *item, Elm_Tooltip_Item_Content_Cb func, const void *data, Evas_Smart_Cb del_cb) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_tooltip_unset(Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_tooltip_style_set(Elm_Toolbar_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char             *elm_toolbar_item_tooltip_style_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_cursor_set(Elm_Toolbar_Item *item, const char *cursor) EINA_ARG_NONNULL(1);
   EAPI const char             *elm_toolbar_item_cursor_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_cursor_unset(Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_cursor_style_set(Elm_Toolbar_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char             *elm_toolbar_item_cursor_style_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                    elm_toolbar_item_cursor_engine_only_set(Elm_Toolbar_Item *item, Eina_Bool engine_only) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool               elm_toolbar_item_cursor_engine_only_get(const Elm_Toolbar_Item *item) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "clicked" - when the user clicks on a toolbar item and becomes selected
    */
   /* available styles:
    * default
    * transparent (no background or shadow, just show the provided content)
    */

   /* tooltip */
   EAPI double       elm_tooltip_delay_get(void);
   EAPI Eina_Bool    elm_tooltip_delay_set(double delay);
   EAPI void         elm_object_tooltip_show(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_tooltip_hide(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_tooltip_text_set(Evas_Object *obj, const char *text) EINA_ARG_NONNULL(1, 2);
   EAPI void         elm_object_tooltip_content_cb_set(Evas_Object *obj, Elm_Tooltip_Content_Cb func, const void *data, Evas_Smart_Cb del_cb) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_tooltip_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_tooltip_style_set(Evas_Object *obj, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_object_tooltip_style_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_cursor_set(Evas_Object *obj, const char *cursor) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_object_cursor_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_cursor_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_cursor_style_set(Evas_Object *obj, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_object_cursor_style_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_object_cursor_engine_only_set(Evas_Object *obj, Eina_Bool engine_only) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_object_cursor_engine_only_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /* cursors */
   EAPI int          elm_cursor_engine_only_get(void);
   EAPI Eina_Bool    elm_cursor_engine_only_set(int engine_only);

   /* menu */
   typedef struct _Elm_Menu_Item Elm_Menu_Item; /**< Item of Elm_Menu. Sub-type of Elm_Widget_Item */
   EAPI Evas_Object       *elm_menu_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_menu_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_move(Evas_Object *obj, Evas_Coord x, Evas_Coord y) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_close(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List   *elm_menu_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_menu_item_object_get(const Elm_Menu_Item *it) EINA_ARG_NONNULL(1);
   EAPI Elm_Menu_Item     *elm_menu_item_add(Evas_Object *obj, Elm_Menu_Item *parent, const char *icon, const char *label, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_label_set(Elm_Menu_Item *item, const char *label) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_menu_item_label_get(const Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_icon_set(Elm_Menu_Item *item, const char *icon) EINA_ARG_NONNULL(1, 2);
   EAPI const char        *elm_menu_item_icon_get(const Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI const Evas_Object *elm_menu_item_object_icon_get(const Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_selected_set(Elm_Menu_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_menu_item_selected_get(const Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_disabled_set(Elm_Menu_Item *item, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_menu_item_disabled_get(const Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Menu_Item     *elm_menu_item_separator_add(Evas_Object *obj, Elm_Menu_Item *parent) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_menu_item_is_separator(Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_del(Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_del_cb_set(Elm_Menu_Item *it, Evas_Smart_Cb func) EINA_ARG_NONNULL(1);
   EAPI void              *elm_menu_item_data_get(const Elm_Menu_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_menu_item_data_set(Elm_Menu_Item *item, const void *data) EINA_ARG_NONNULL(1);
   EAPI const Eina_List   *elm_menu_item_subitems_get(const Elm_Menu_Item *item) EINA_ARG_NONNULL(1);
   EAPI const Elm_Menu_Item *elm_menu_selected_item_get(const Evas_Object * obj) EINA_ARG_NONNULL(1);
   EAPI const Elm_Menu_Item *elm_menu_last_item_get(const Evas_Object * obj) EINA_ARG_NONNULL(1);
   EAPI const Elm_Menu_Item *elm_menu_first_item_get(const Evas_Object * obj) EINA_ARG_NONNULL(1);
   EAPI const Elm_Menu_Item *elm_menu_item_next_get(const Elm_Menu_Item *it) EINA_ARG_NONNULL(1);
   EAPI const Elm_Menu_Item *elm_menu_item_prev_get(const Elm_Menu_Item *it) EINA_ARG_NONNULL(1);

   /* smart callbacks called:
    * "clicked" - the user clicked the empty space in the menu to dismiss. event_info is NULL.
    */

   /* list */
   typedef enum _Elm_List_Mode
     {
        ELM_LIST_COMPRESS = 0,
        ELM_LIST_SCROLL,
        ELM_LIST_LIMIT,
        ELM_LIST_EXPAND,
        ELM_LIST_LAST
     } Elm_List_Mode;
   typedef struct _Elm_List_Item Elm_List_Item; /**< Item of Elm_List. Sub-type of Elm_Widget_Item */
   EAPI Evas_Object     *elm_list_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Elm_List_Item   *elm_list_item_append(Evas_Object *obj, const char *label, Evas_Object *icon, Evas_Object *end, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_List_Item   *elm_list_item_prepend(Evas_Object *obj, const char *label, Evas_Object *icon, Evas_Object *end, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_List_Item   *elm_list_item_insert_before(Evas_Object *obj, Elm_List_Item *before, const char *label, Evas_Object *icon, Evas_Object *end, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);
   EAPI Elm_List_Item   *elm_list_item_insert_after(Evas_Object *obj, Elm_List_Item *after, const char *label, Evas_Object *icon, Evas_Object *end, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);
   EAPI Elm_List_Item   *elm_list_item_sorted_insert(Evas_Object *obj, const char *label, Evas_Object *icon, Evas_Object *end, Evas_Smart_Cb func, const void *data, Eina_Compare_Cb cmp_func) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_go(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_multi_select_set(Evas_Object *obj, Eina_Bool multi) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_list_multi_select_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_mode_set(Evas_Object *obj, Elm_List_Mode mode) EINA_ARG_NONNULL(1);
   EAPI Elm_List_Mode    elm_list_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_list_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_always_select_mode_set(Evas_Object *obj, Eina_Bool always_select) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_list_always_select_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List *elm_list_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_List_Item   *elm_list_selected_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List *elm_list_selected_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_separator_set(Elm_List_Item *it, Eina_Bool setting) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_list_item_separator_get(const Elm_List_Item *it) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_selected_set(Elm_List_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_list_item_selected_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_show(Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_bring_in(Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_del(Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_del_cb_set(Elm_List_Item *item, Evas_Smart_Cb func) EINA_ARG_NONNULL(1);
   EAPI void            *elm_list_item_data_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI Evas_Object     *elm_list_item_icon_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_icon_set(Elm_List_Item *item, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI Evas_Object     *elm_list_item_end_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_end_set(Elm_List_Item *item, Evas_Object *end) EINA_ARG_NONNULL(1);
   EAPI Evas_Object     *elm_list_item_base_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI const char      *elm_list_item_label_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_label_set(Elm_List_Item *item, const char *text) EINA_ARG_NONNULL(1);
   EAPI Elm_List_Item   *elm_list_item_prev(const Elm_List_Item *it) EINA_ARG_NONNULL(1);
   EAPI Elm_List_Item   *elm_list_item_next(const Elm_List_Item *it) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_tooltip_text_set(Elm_List_Item *item, const char *text) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_tooltip_content_cb_set(Elm_List_Item *item, Elm_Tooltip_Item_Content_Cb func, const void *data, Evas_Smart_Cb del_cb) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_tooltip_unset(Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_tooltip_style_set(Elm_List_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char      *elm_list_item_tooltip_style_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_cursor_set(Elm_List_Item *item, const char *cursor) EINA_ARG_NONNULL(1);
   EAPI const char      *elm_list_item_cursor_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_cursor_unset(Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_cursor_style_set(Elm_List_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char      *elm_list_item_cursor_style_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_cursor_engine_only_set(Elm_List_Item *item, Eina_Bool engine_only) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_list_item_cursor_engine_only_get(const Elm_List_Item *item) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_item_disabled_set(Elm_List_Item *it, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool        elm_list_item_disabled_get(const Elm_List_Item *it) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_scroller_policy_set(Evas_Object *obj, Elm_Scroller_Policy policy_h, Elm_Scroller_Policy policy_v) EINA_ARG_NONNULL(1);
   EAPI void             elm_list_scroller_policy_get(const Evas_Object *obj, Elm_Scroller_Policy *policy_h, Elm_Scroller_Policy *policy_v) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "clicked,double" - when the user double-clicked an item
    * "selected" - when the user selected an item
    * "unselected" - when the user selected an item
    * "longpressed" - an item in the hoversel list is long-pressed
    * "scroll,edge,top" - the list is scrolled until the top edge
    * "scroll,edge,bottom" - the list is scrolled until the bottom edge
    * "scroll,edge,left" - the list is scrolled until the left edge
    * "scroll,edge,right" - the list is scrolled until the right edge
    */

   /* slider */
   EAPI Evas_Object       *elm_slider_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void               elm_slider_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char        *elm_slider_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_slider_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_slider_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_end_set(Evas_Object *obj, Evas_Object *end) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_slider_end_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_slider_end_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_span_size_set(Evas_Object *obj, Evas_Coord size) EINA_ARG_NONNULL(1);
   EAPI Evas_Coord         elm_slider_span_size_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_unit_format_set(Evas_Object *obj, const char *format) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_slider_unit_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_indicator_format_set(Evas_Object *obj, const char *indicator) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_slider_indicator_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
  EAPI void                elm_slider_indicator_format_function_set(Evas_Object *obj, const char *(*func)(double val), void (*free_func)(const char *str)) EINA_ARG_NONNULL(1);
  EAPI void                elm_slider_units_format_function_set(Evas_Object *obj, const char *(*func)(double val), void (*free_func)(const char *str)) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_slider_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_min_max_set(Evas_Object *obj, double min, double max) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_min_max_get(const Evas_Object *obj, double *min, double *max) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_value_set(Evas_Object *obj, double val) EINA_ARG_NONNULL(1);
   EAPI double             elm_slider_value_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_inverted_set(Evas_Object *obj, Eina_Bool inverted) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_slider_inverted_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_slider_indicator_show_set(Evas_Object *obj, Eina_Bool show) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_slider_indicator_show_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "changed" - Whenever the slider value is changed by the user.
    * "slider,drag,start" - dragging the slider indicator around has started
    * "slider,drag,stop" - dragging the slider indicator around has stopped
    * "delay,changed" - A short time after the value is changed by the user.
    *                   This will be called only when the user stops dragging for a very short
    *                   period or when they release their finger/mouse, so it avoids possibly
    *                   expensive reactions to the value change.
    */

   /**
    * @addtogroup Actionslider Actionslider
    *
    * A actionslider is a switcher for 2 or 3 labels with customizable magnet
    * properties. The indicator is the element the user drags to choose a label.
    * When the position is set with magnet, when released the indicator will be
    * moved to it if it's nearest the magnetized position.
    *
    * @note By default all positions are set as enabled.
    *
    * Signals that you can add callbacks for are:
    *
    * "selected" - when user selects an enabled position (the label is passed
    *              as event info)".
    * @n
    * "pos_changed" - when the indicator reaches any of the positions("left",
    *                 "right" or "center").
    *
    * See an example of actionslider usage @ref actionslider_example_page "here"
    * @{
    */
   typedef enum _Elm_Actionslider_Pos
     {
        ELM_ACTIONSLIDER_NONE = 0,
        ELM_ACTIONSLIDER_LEFT = 1 << 0,
        ELM_ACTIONSLIDER_CENTER = 1 << 1,
        ELM_ACTIONSLIDER_RIGHT = 1 << 2,
        ELM_ACTIONSLIDER_ALL = (1 << 3) -1
     } Elm_Actionslider_Pos;

   /**
    * Add a new actionslider to the parent.
    *
    * @param parent The parent object
    * @return The new actionslider object or NULL if it cannot be created
    */
   EAPI Evas_Object          *elm_actionslider_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set actionslider labels.
    *
    * @param obj The actionslider object
    * @param left_label The label to be set on the left.
    * @param center_label The label to be set on the center.
    * @param right_label The label to be set on the right.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void                  elm_actionslider_labels_set(Evas_Object *obj, const char *left_label, const char *center_label, const char *right_label) EINA_ARG_NONNULL(1);
   /**
    * Get actionslider labels.
    *
    * @param obj The actionslider object
    * @param left_label A char** to place the left_label of @p obj into.
    * @param center_label A char** to place the center_label of @p obj into.
    * @param right_label A char** to place the right_label of @p obj into.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void                  elm_actionslider_labels_get(const Evas_Object *obj, const char **left_label, const char **center_label, const char **right_label) EINA_ARG_NONNULL(1);
   /**
    * Get actionslider selected label.
    *
    * @param obj The actionslider object
    * @return The selected label
    */
   EAPI const char           *elm_actionslider_selected_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set actionslider indicator position.
    *
    * @param obj The actionslider object.
    * @param pos The position of the indicator.
    */
   EAPI void                  elm_actionslider_indicator_pos_set(Evas_Object *obj, Elm_Actionslider_Pos pos) EINA_ARG_NONNULL(1);
   /**
    * Get actionslider indicator position.
    *
    * @param obj The actionslider object.
    * @return The position of the indicator.
    */
   EAPI Elm_Actionslider_Pos  elm_actionslider_indicator_pos_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set actionslider magnet position. To make multiple positions magnets @c or
    * them together(e.g.: ELM_ACTIONSLIDER_LEFT | ELM_ACTIONSLIDER_RIGHT)
    *
    * @param obj The actionslider object.
    * @param pos Bit mask indicating the magnet positions.
    */
   EAPI void                  elm_actionslider_magnet_pos_set(Evas_Object *obj, Elm_Actionslider_Pos pos) EINA_ARG_NONNULL(1);
   /**
    * Get actionslider magnet position.
    *
    * @param obj The actionslider object.
    * @return The positions with magnet property.
    */
   EAPI Elm_Actionslider_Pos  elm_actionslider_magnet_pos_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set actionslider enabled position. To set multiple positions as enabled @c or
    * them together(e.g.: ELM_ACTIONSLIDER_LEFT | ELM_ACTIONSLIDER_RIGHT).
    *
    * @note All the positions are enabled by default.
    *
    * @param obj The actionslider object.
    * @param pos Bit mask indicating the enabled positions.
    */
   EAPI void                  elm_actionslider_enabled_pos_set(Evas_Object *obj, Elm_Actionslider_Pos pos) EINA_ARG_NONNULL(1);
   /**
    * Get actionslider enabled position.
    *
    * @param obj The actionslider object.
    * @return The enabled positions.
    */
   EAPI Elm_Actionslider_Pos  elm_actionslider_enabled_pos_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * Set the label used on the indicator.
    *
    * @param obj The actionslider object
    * @param label The label to be set on the indicator.
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI void                  elm_actionslider_indicator_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   /**
    * Get the label used on the indicator object.
    *
    * @param obj The actionslider object
    * @return The indicator label
    * @deprecated use elm_object_text_set() instead.
    */
   EINA_DEPRECATED EAPI const char           *elm_actionslider_indicator_label_get(Evas_Object *obj) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* genlist */
   typedef enum _Elm_Genlist_Item_Flags
     {
        ELM_GENLIST_ITEM_NONE = 0,
        ELM_GENLIST_ITEM_SUBITEMS = (1 << 0),
        ELM_GENLIST_ITEM_GROUP = (1 << 1)
     } Elm_Genlist_Item_Flags;
   typedef struct _Elm_Genlist_Item_Class Elm_Genlist_Item_Class;
   typedef struct _Elm_Genlist_Item       Elm_Genlist_Item; /**< Item of Elm_Genlist. Sub-type of Elm_Widget_Item */
   typedef struct _Elm_Genlist_Item_Class_Func Elm_Genlist_Item_Class_Func;
   typedef char        *(*GenlistItemLabelGetFunc) (void *data, Evas_Object *obj, const char *part);
   typedef Evas_Object *(*GenlistItemIconGetFunc)  (void *data, Evas_Object *obj, const char *part);
   typedef Eina_Bool    (*GenlistItemStateGetFunc) (void *data, Evas_Object *obj, const char *part);
   typedef void         (*GenlistItemDelFunc)      (void *data, Evas_Object *obj);
   typedef void         (*GenlistItemMovedFunc)    (Evas_Object *obj, Elm_Genlist_Item *item, Elm_Genlist_Item *rel_item, Eina_Bool move_after);

   struct _Elm_Genlist_Item_Class
     {
        const char                *item_style;
        struct
          {
             GenlistItemLabelGetFunc  label_get;
             GenlistItemIconGetFunc   icon_get;
             GenlistItemStateGetFunc  state_get;
             GenlistItemDelFunc       del;
             GenlistItemMovedFunc     moved; // TODO: do not use this. change this to smart callback.
          } func;
        const char                *mode_item_style;
     };

   EAPI Evas_Object      *elm_genlist_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_multi_select_set(Evas_Object *obj, Eina_Bool multi) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool         elm_genlist_multi_select_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_horizontal_mode_set(Evas_Object *obj, Elm_List_Mode mode) EINA_ARG_NONNULL(1);
   EAPI Elm_List_Mode     elm_genlist_horizontal_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_always_select_mode_set(Evas_Object *obj, Eina_Bool always_select) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool         elm_genlist_always_select_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_no_select_mode_set(Evas_Object *obj, Eina_Bool no_select) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool         elm_genlist_no_select_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_compress_mode_set(Evas_Object *obj, Eina_Bool compress) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool         elm_genlist_compress_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_height_for_width_mode_set(Evas_Object *obj, Eina_Bool height_for_width) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool         elm_genlist_height_for_width_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_homogeneous_set(Evas_Object *obj, Eina_Bool homogeneous) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool         elm_genlist_homogeneous_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_block_count_set(Evas_Object *obj, int n) EINA_ARG_NONNULL(1);
   EAPI int               elm_genlist_block_count_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_longpress_timeout_set(Evas_Object *obj, double timeout) EINA_ARG_NONNULL(1);
   EAPI double            elm_genlist_longpress_timeout_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* operations to add items */
   EAPI Elm_Genlist_Item *elm_genlist_item_append(Evas_Object *obj, const Elm_Genlist_Item_Class *itc, const void *data, Elm_Genlist_Item *parent, Elm_Genlist_Item_Flags flags, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item *elm_genlist_item_prepend(Evas_Object *obj, const Elm_Genlist_Item_Class *itc, const void *data, Elm_Genlist_Item *parent, Elm_Genlist_Item_Flags flags, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item *elm_genlist_item_insert_before(Evas_Object *obj, const Elm_Genlist_Item_Class *itc, const void *data, Elm_Genlist_Item *parent, Elm_Genlist_Item *before, Elm_Genlist_Item_Flags flags, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1, 5);
   EAPI Elm_Genlist_Item *elm_genlist_item_insert_after(Evas_Object *obj, const Elm_Genlist_Item_Class *itc, const void *data, Elm_Genlist_Item *parent, Elm_Genlist_Item *after, Elm_Genlist_Item_Flags flags, Evas_Smart_Cb func, const void *func_data) EINA_ARG_NONNULL(1, 5);
   EAPI Elm_Genlist_Item *elm_genlist_item_sorted_insert(Evas_Object *obj, const Elm_Genlist_Item_Class *itc, const void *data, Elm_Genlist_Item *parent, Elm_Genlist_Item_Flags flags, Eina_Compare_Cb comp, Evas_Smart_Cb func,const void *func_data);
   EAPI Elm_Genlist_Item *elm_genlist_item_direct_sorted_insert(Evas_Object *obj, const Elm_Genlist_Item_Class *itc, const void *data, Elm_Genlist_Item *parent, Elm_Genlist_Item_Flags flags, Eina_Compare_Cb comp, Evas_Smart_Cb func, const void *func_data);
   /* operations to retrieve existing items */
   EAPI Elm_Genlist_Item *elm_genlist_selected_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List  *elm_genlist_selected_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_List        *elm_genlist_realized_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item *elm_genlist_at_xy_item_get(const Evas_Object *obj, Evas_Coord x, Evas_Coord y, int *posret) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item *elm_genlist_first_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item *elm_genlist_last_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_scroller_policy_set(Evas_Object *obj, Elm_Scroller_Policy policy_h, Elm_Scroller_Policy policy_v) EINA_ARG_NONNULL(1);
   EAPI void              elm_genlist_scroller_policy_get(const Evas_Object *obj, Elm_Scroller_Policy *policy_h, Elm_Scroller_Policy *policy_v) EINA_ARG_NONNULL(1);
   /* available item styles:
    * default
    * default_style - The text part is a textblock
    * double_label
    * icon_top_text_bottom
    */
   /* Genlist Item operation */
   EAPI Elm_Genlist_Item  *elm_genlist_item_next_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item  *elm_genlist_item_prev_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI Evas_Object       *elm_genlist_item_genlist_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Genlist_Item  *elm_genlist_item_parent_get(const Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_subitems_clear(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_selected_set(Elm_Genlist_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_genlist_item_selected_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_expanded_set(Elm_Genlist_Item *item, Eina_Bool expanded) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_genlist_item_expanded_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI int                elm_genlist_item_expanded_depth_get(const Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_disabled_set(Elm_Genlist_Item *item, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_genlist_item_disabled_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_display_only_set(Elm_Genlist_Item *it, Eina_Bool display_only) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_genlist_item_display_only_get(const Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_show(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_bring_in(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_top_show(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_top_bring_in(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_middle_show(Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_middle_bring_in(Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_del(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void              *elm_genlist_item_data_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_data_set(Elm_Genlist_Item *it, const void *data) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_icons_orphan(Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI const Evas_Object *elm_genlist_item_object_get(const Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_update(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_item_class_update(Elm_Genlist_Item *it, const Elm_Genlist_Item_Class *itc) EINA_ARG_NONNULL(1, 2);
   EAPI const Elm_Genlist_Item_Class *elm_genlist_item_item_class_get(const Elm_Genlist_Item *it) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_tooltip_text_set(Elm_Genlist_Item *item, const char *text) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_tooltip_content_cb_set(Elm_Genlist_Item *item, Elm_Tooltip_Item_Content_Cb func, const void *data, Evas_Smart_Cb del_cb) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_tooltip_unset(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_tooltip_style_set(Elm_Genlist_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_genlist_item_tooltip_style_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_cursor_set(Elm_Genlist_Item *item, const char *cursor) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_genlist_item_cursor_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_cursor_unset(Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_cursor_style_set(Elm_Genlist_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char        *elm_genlist_item_cursor_style_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_cursor_engine_only_set(Elm_Genlist_Item *item, Eina_Bool engine_only) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_genlist_item_cursor_engine_only_get(const Elm_Genlist_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_realized_items_update(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_item_mode_set(Elm_Genlist_Item *it, const char *mode_type, Eina_Bool mode_set) EINA_ARG_NONNULL(1, 2);
   EAPI const char        *elm_genlist_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Elm_Genlist_Item *elm_genlist_mode_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_genlist_reorder_mode_set(Evas_Object *obj, Eina_Bool reorder_mode) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_genlist_reorder_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /** Signals that you can add callbacks for are:
    * "clicked,double" - This is called when a user has double-clicked an item.
    *                    The event_info parameter is the genlist item that was
    *                    double-clicked.
    * "selected" - This is called when a user has made an item selected. The
    *              event_info parameter is the genlist item that was selected.
    * "unselected" - This is called when a user has made an item unselected. The
    *                 event_info parameter is the genlist item that was
    *                 unselected.
    * "expanded" - This is called when elm_genlist_item_expanded_set() is called
    *              and the item is now meant to be expanded. The event_info
    *              parameter is the genlist item that was indicated to expand.
    *              It is the job of this callback to then fill in the child
    *              items.
    * "contracted" - This is called when elm_genlist_item_expanded_set() is
    *                called and the item is now meant to be contracted. The
    *                event_info parameter is the genlist item that was indicated
    *                to contract. It is the job of this callback to then delete
    *                the child items.
    * "expand,request" - This is called when a user has indicated they want to
    *                    expand a tree branch item. The callback should decide
    *                    if the item can expand (has any children) and then call
    *                    elm_genlist_item_expanded_set() appropriately to set
    *                    the state. The event_info parameter is the genlist item
    *                    that was indicated to expand.
    * "contract,request" - This is called when a user has indicated they want to
    *                      contract a tree branch item. The callback should
    *                      decide if the item can contract (has any children)
    *                      and then call elm_genlist_item_expanded_set()
    *                      appropriately to set the state. The event_info
    *                      parameter is the genlist item that was indicated to
    *                      contract.
    * "realized" - This is called when the item in the list is created as a real
    *              evas object. event_info parameter is the genlist item that
    *              was created. The object may be deleted at any time, so it is
    *              up to the caller to not use the object pointer from
    *              elm_genlist_item_object_get() in a way where it may point to
    *              freed objects.
    * "unrealized" - This is called just before an item is unrealized. After
    *                this call icon objects provided will be deleted and the
    *                item object itself delete or be put into a floating cache.
    * "drag,start,up" - This is called when the item in the list has been
    *                   dragged (not scrolled) up.
    * "drag,start,down" - This is called when the item in the list has been
    *                     dragged (not scrolled) down.
    * "drag,start,left" - This is called when the item in the list has been
    *                     dragged (not scrolled) left.
    * "drag,start,right" - This is called when the item in the list has been
    *                      dragged (not scrolled) right.
    * "drag,stop" - This is called when the item in the list has stopped being
    *               dragged.
    * "drag" - This is called when the item in the list is being dragged.
    * "longpressed" - This is called when the item is pressed for a certain
    *                 amount of time. By default it's 1 second.
    * "scroll,edge,top" - This is called when the genlist is scrolled until the
    *                     top edge.
    * "scroll,edge,bottom" - This is called when the genlist is scrolled until
    *                        the bottom edge.
    * "scroll,edge,left" - This is called when the genlist is scrolled until the
    *                      left edge.
    * "scroll,edge,right" - This is called when the genlist is scrolled until
    *                       the right edge.
    * "multi,swipe,left" - This is called when the genlist is multi-touch swiped
    *                       left.
    * "multi,swipe,right" - This is called when the genlist is multi-touch
    *                       swiped right.
    * "multi,swipe,up" - This is called when the genlist is multi-touch swiped
    *                    up.
    * "multi,swipe,down" - This is called when the genlist is multi-touch swiped
    *                      down.
    * "multi,pinch,out" - This is called when the genlist is multi-touch pinched
    *                     out.
    * "multi,pinch,in" - This is called when the genlist is multi-touch pinched
    *                    in.
    * "swipe" - This is called when the genlist is swiped.
    */

   /* check */
   EAPI Evas_Object *elm_check_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_check_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_check_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_check_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_check_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_check_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_check_state_set(Evas_Object *obj, Eina_Bool state) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_check_state_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_check_state_pointer_set(Evas_Object *obj, Eina_Bool *statep) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "changed" - This is called whenever the user changes the state of one of the check object.
    */

   /* radio */
   EAPI Evas_Object *elm_radio_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_radio_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_radio_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_radio_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_radio_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_radio_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_radio_group_add(Evas_Object *obj, Evas_Object *group) EINA_ARG_NONNULL(1);
   EAPI void         elm_radio_state_value_set(Evas_Object *obj, int value) EINA_ARG_NONNULL(1);
   EAPI int          elm_radio_state_value_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_radio_value_set(Evas_Object *obj, int value) EINA_ARG_NONNULL(1);
   EAPI int          elm_radio_value_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_radio_value_pointer_set(Evas_Object *obj, int *valuep) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "changed" - when the radio status is changed
    */

   /* pager */
   EAPI Evas_Object *elm_pager_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_pager_content_push(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI void         elm_pager_content_pop(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_pager_content_promote(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_pager_content_bottom_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_pager_content_top_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* available item styles:
    * default
    * fade
    * fade_translucide
    * fade_invisible
    */
   /* smart callbacks called:
    * "hide,finished" - when the previous page is hided
    */

   typedef struct _Elm_Slideshow_Item_Class Elm_Slideshow_Item_Class;
   typedef struct _Elm_Slideshow_Item_Class_Func Elm_Slideshow_Item_Class_Func;
   typedef struct _Elm_Slideshow_Item       Elm_Slideshow_Item; /**< Item of Elm_Slideshow. Sub-type of Elm_Widget_Item */
   typedef Evas_Object *(*SlideshowItemGetFunc) (void *data, Evas_Object *obj);
   typedef void         (*SlideshowItemDelFunc) (void *data, Evas_Object *obj);

   struct _Elm_Slideshow_Item_Class
     {
        struct _Elm_Slideshow_Item_Class_Func
          {
             SlideshowItemGetFunc get;
             SlideshowItemDelFunc del;
          } func;
     };

   EAPI Evas_Object        *elm_slideshow_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Elm_Slideshow_Item *elm_slideshow_item_add(Evas_Object *obj, const Elm_Slideshow_Item_Class *itc, const void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Slideshow_Item *elm_slideshow_item_sorted_insert(Evas_Object *obj, const Elm_Slideshow_Item_Class *itc, const void *data, Eina_Compare_Cb func) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_show(Elm_Slideshow_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_next(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_previous(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List    *elm_slideshow_transitions_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_transition_set(Evas_Object *obj, const char *transition) EINA_ARG_NONNULL(1);
   EAPI const char         *elm_slideshow_transition_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_timeout_set(Evas_Object *obj, double timeout) EINA_ARG_NONNULL(1);
   EAPI double              elm_slideshow_timeout_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_loop_set(Evas_Object *obj, Eina_Bool loop) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool           elm_slideshow_loop_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List    *elm_slideshow_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_item_del(Elm_Slideshow_Item *item) EINA_ARG_NONNULL(1);
   EAPI void               *elm_slideshow_item_data_get(const Elm_Slideshow_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Slideshow_Item *elm_slideshow_item_current_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object*        elm_slideshow_item_object_get(const Elm_Slideshow_Item* item) EINA_ARG_NONNULL(1);
   EAPI Elm_Slideshow_Item *elm_slideshow_item_nth_get(const Evas_Object *obj, unsigned int nth) EINA_ARG_NONNULL(1);
   EAPI const char         *elm_slideshow_layout_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_layout_set(Evas_Object *obj, const char *layout) EINA_ARG_NONNULL(1);
   EAPI const Eina_List    *elm_slideshow_layouts_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_cache_before_set(Evas_Object *obj, int count) EINA_ARG_NONNULL(1);
   EAPI int                 elm_slideshow_cache_before_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                elm_slideshow_cache_after_set(Evas_Object *obj, int count) EINA_ARG_NONNULL(1);
   EAPI int                 elm_slideshow_cache_after_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI unsigned int        elm_slideshow_count_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "changed" - when the slideshow switch to another item
    */

   /* file selector */
   typedef enum _Elm_Fileselector_Mode
     {
        ELM_FILESELECTOR_LIST = 0,
        ELM_FILESELECTOR_GRID,
        ELM_FILESELECTOR_LAST
     } Elm_Fileselector_Mode;

   EAPI Evas_Object          *elm_fileselector_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void                  elm_fileselector_is_save_set(Evas_Object *obj, Eina_Bool is_save) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_fileselector_is_save_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_fileselector_folder_only_set(Evas_Object *obj, Eina_Bool only) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_fileselector_folder_only_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_fileselector_buttons_ok_cancel_set(Evas_Object *obj, Eina_Bool buttons) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_fileselector_buttons_ok_cancel_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_fileselector_expandable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_fileselector_expandable_set(Evas_Object *obj, Eina_Bool expand) EINA_ARG_NONNULL(1);
   EAPI void                  elm_fileselector_path_set(Evas_Object *obj, const char *path) EINA_ARG_NONNULL(1);
   EAPI const char           *elm_fileselector_path_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const char           *elm_fileselector_selected_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_fileselector_selected_set(Evas_Object *obj, const char *path) EINA_ARG_NONNULL(1);
   EAPI void                  elm_fileselector_mode_set(Evas_Object *obj, Elm_Fileselector_Mode mode) EINA_ARG_NONNULL(1);
   EAPI Elm_Fileselector_Mode elm_fileselector_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "selected" - the user click on a file
    * "directory,open" - the list is populate with a new content. event_info is a directory.
    * "done" - the user click on the ok or cancel buttons
    */

   /* progressbar */
   EAPI Evas_Object *elm_progressbar_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_pulse_set(Evas_Object *obj, Eina_Bool pulse) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_progressbar_pulse_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_pulse(Evas_Object *obj, Eina_Bool state) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_value_set(Evas_Object *obj, double val) EINA_ARG_NONNULL(1);
   EAPI double       elm_progressbar_value_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_progressbar_label_set(Evas_Object *obj, const char *label) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_progressbar_label_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_progressbar_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_progressbar_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_span_size_set(Evas_Object *obj, Evas_Coord size) EINA_ARG_NONNULL(1);
   EAPI Evas_Coord   elm_progressbar_span_size_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_unit_format_set(Evas_Object *obj, const char *format) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_progressbar_unit_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_progressbar_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_progressbar_inverted_set(Evas_Object *obj, Eina_Bool inverted) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_progressbar_inverted_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    */
   /* available item styles:
    * default
    * wheel (simple style, no text, no progression, only pulse is available)
    */

   /* separator */
   EAPI Evas_Object *elm_separator_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_separator_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_separator_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    */

   /* spinner */
   EAPI Evas_Object *elm_spinner_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_spinner_label_format_set(Evas_Object *obj, const char *fmt) EINA_ARG_NONNULL(1);
   EAPI const char  *elm_spinner_label_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_spinner_min_max_set(Evas_Object *obj, double min, double max) EINA_ARG_NONNULL(1);
   EAPI void         elm_spinner_min_max_get(const Evas_Object *obj, double *min, double *max) EINA_ARG_NONNULL(1);
   EAPI void         elm_spinner_step_set(Evas_Object *obj, double step) EINA_ARG_NONNULL(1);
   EAPI double       elm_spinner_step_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_spinner_value_set(Evas_Object *obj, double val) EINA_ARG_NONNULL(1);
   EAPI double       elm_spinner_value_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_spinner_wrap_set(Evas_Object *obj, Eina_Bool wrap) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_spinner_wrap_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_spinner_editable_set(Evas_Object *obj, Eina_Bool editable) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_spinner_editable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_spinner_special_value_add(Evas_Object *obj, double value, const char *label) EINA_ARG_NONNULL(1);
   EAPI void         elm_spinner_interval_set(Evas_Object *obj, double interval) EINA_ARG_NONNULL(1);
   EAPI double       elm_spinner_interval_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "changed" - when the spinner value changes
    * "delay,changed" - when the spinner value changed, but a small time after a change (use this if you only want to respond to a change once the spinner is held still for a short while).
    */
   /* available item styles:
    * default
    * vertical (two up/down buttons at the right side and text left aligned)
    */

   /* index */
   typedef struct _Elm_Index_Item Elm_Index_Item; /**< Item of Elm_Index. Sub-type of Elm_Widget_Item */

   EAPI Evas_Object    *elm_index_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void            elm_index_active_set(Evas_Object *obj, Eina_Bool active) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool       elm_index_active_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void            elm_index_item_level_set(Evas_Object *obj, int level) EINA_ARG_NONNULL(1);
   EAPI int             elm_index_item_level_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void           *elm_index_item_selected_get(const Evas_Object *obj, int level) EINA_ARG_NONNULL(1);
   EAPI void            elm_index_item_append(Evas_Object *obj, const char *letter, const void *item) EINA_ARG_NONNULL(1);
   EAPI void            elm_index_item_prepend(Evas_Object *obj, const char *letter, const void *item) EINA_ARG_NONNULL(1);
   EAPI void            elm_index_item_append_relative(Evas_Object *obj, const char *letter, const void *item, const void *relative) EINA_ARG_NONNULL(1);
   EAPI void            elm_index_item_prepend_relative(Evas_Object *obj, const char *letter, const void *item, const void *relative) EINA_ARG_NONNULL(1);
   EAPI void            elm_index_item_sorted_insert(Evas_Object *obj, const char *letter, const void *item, Eina_Compare_Cb cmp_func, Eina_Compare_Cb cmp_data_func) EINA_ARG_NONNULL(1);
   EAPI void            elm_index_item_del(Evas_Object *obj, const void *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Index_Item *elm_index_item_find(Evas_Object *obj, const void *item) EINA_ARG_NONNULL(1);
   EAPI void            elm_index_item_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void            elm_index_item_go(Evas_Object *obj, int level) EINA_ARG_NONNULL(1);
   EAPI void           *elm_index_item_data_get(const Elm_Index_Item *item) EINA_ARG_NONNULL(1);
   EAPI void            elm_index_item_data_set(Elm_Index_Item *it, const void *data) EINA_ARG_NONNULL(1);
   EAPI void            elm_index_item_del_cb_set(Elm_Index_Item *it, Evas_Smart_Cb func) EINA_ARG_NONNULL(1);
   EAPI const char     *elm_index_item_letter_get(const Elm_Index_Item *item) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "changed" - when the selected index item changes
    * "delay,changed" - when the selected index item changes, but after some small idle period
    * "selected" - when the user releases a finger and selects an item
    * "level,up" - when the user moves a finger from the first level to the second level
    * "level,down" - when the user moves a finger from the second level to the first level
    */

   /* photocam */
   typedef enum _Elm_Photocam_Zoom_Mode
     {
        ELM_PHOTOCAM_ZOOM_MODE_MANUAL = 0,
        ELM_PHOTOCAM_ZOOM_MODE_AUTO_FIT,
        ELM_PHOTOCAM_ZOOM_MODE_AUTO_FILL,
        ELM_PHOTOCAM_ZOOM_MODE_LAST
     } Elm_Photocam_Zoom_Mode;

   EAPI Evas_Object           *elm_photocam_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Evas_Load_Error        elm_photocam_file_set(Evas_Object *obj, const char *file) EINA_ARG_NONNULL(1);
   EAPI const char            *elm_photocam_file_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_zoom_set(Evas_Object *obj, double zoom) EINA_ARG_NONNULL(1);
   EAPI double                 elm_photocam_zoom_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_zoom_mode_set(Evas_Object *obj, Elm_Photocam_Zoom_Mode mode) EINA_ARG_NONNULL(1);
   EAPI Elm_Photocam_Zoom_Mode elm_photocam_zoom_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_image_size_get(const Evas_Object *obj, int *w, int *h) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_region_get(const Evas_Object *obj, int *x, int *y, int *w, int *h) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_image_region_show(Evas_Object *obj, int x, int y, int w, int h) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_image_region_bring_in(Evas_Object *obj, int x, int y, int w, int h) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_paused_set(Evas_Object *obj, Eina_Bool paused) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool              elm_photocam_paused_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object           *elm_photocam_internal_image_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_bounce_set(Evas_Object *obj,  Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   EAPI void                   elm_photocam_bounce_get(const Evas_Object *obj,  Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "clicked" - when image clicked
    * "press" - when mouse/finger held down initially on image
    * "longpressed" - when mouse/finger held for long time on image
    * "clicked,double" - when mouse/finger double-clicked
    * "load" - when photo load begins
    * "loaded" - when photo load done
    * "load,detail" - when detailed image load begins
    * "loaded,detail" - when detailed image load done
    * "zoom,start" - when zooming started
    * "zoom,stop" - when zooming stopped
    * "zoom,change" - when auto zoom mode changed zoom level
    * "scroll - the content has been scrolled (moved)
    * "scroll,anim,start" - scrolling animation has started
    * "scroll,anim,stop" - scrolling animation has stopped
    * "scroll,drag,start" - dragging the contents around has started
    * "scroll,drag,stop" - dragging the contents around has stopped
    */

   /* map */
   typedef enum _Elm_Map_Zoom_Mode
     {
        ELM_MAP_ZOOM_MODE_MANUAL,
        ELM_MAP_ZOOM_MODE_AUTO_FIT,
        ELM_MAP_ZOOM_MODE_AUTO_FILL,
        ELM_MAP_ZOOM_MODE_LAST
     } Elm_Map_Zoom_Mode;

   typedef enum _Elm_Map_Route_Sources
     {
        ELM_MAP_ROUTE_SOURCE_YOURS,
        ELM_MAP_ROUTE_SOURCE_MONAV,
        ELM_MAP_ROUTE_SOURCE_ORS,
        ELM_MAP_ROUTE_SOURCE_LAST
     } Elm_Map_Route_Sources;

   typedef enum _Elm_Map_Name_Sources
     {
        ELM_MAP_NAME_SOURCE_NOMINATIM,
        ELM_MAP_NAME_SOURCE_LAST
     } Elm_Map_Name_Sources;

   typedef enum _Elm_Map_Route_Type
     {
        ELM_MAP_ROUTE_TYPE_MOTOCAR,
        ELM_MAP_ROUTE_TYPE_BICYCLE,
        ELM_MAP_ROUTE_TYPE_FOOT,
        ELM_MAP_ROUTE_TYPE_LAST
     } Elm_Map_Route_Type;

   typedef enum _Elm_Map_Route_Method
     {
        ELM_MAP_ROUTE_METHOD_FASTEST,
        ELM_MAP_ROUTE_METHOD_SHORTEST,
        ELM_MAP_ROUTE_METHOD_LAST
     } Elm_Map_Route_Method;

   typedef enum _Elm_Map_Name_Method
     {
        ELM_MAP_NAME_METHOD_SEARCH,
        ELM_MAP_NAME_METHOD_REVERSE,
        ELM_MAP_NAME_METHOD_LAST
     } Elm_Map_Name_Method;

   typedef struct _Elm_Map_Marker          Elm_Map_Marker;
   typedef struct _Elm_Map_Marker_Class    Elm_Map_Marker_Class;
   typedef struct _Elm_Map_Group_Class     Elm_Map_Group_Class;
   typedef struct _Elm_Map_Route           Elm_Map_Route;
   typedef struct _Elm_Map_Name            Elm_Map_Name;
   typedef struct _Elm_Map_Track           Elm_Map_Track;

   typedef Evas_Object *(*ElmMapMarkerGetFunc)      (Evas_Object *obj, Elm_Map_Marker *marker, void *data);
   typedef void         (*ElmMapMarkerDelFunc)      (Evas_Object *obj, Elm_Map_Marker *marker, void *data, Evas_Object *o);
   typedef Evas_Object *(*ElmMapMarkerIconGetFunc)  (Evas_Object *obj, Elm_Map_Marker *marker, void *data);
   typedef Evas_Object *(*ElmMapGroupIconGetFunc)   (Evas_Object *obj, void *data);

   typedef char        *(*ElmMapModuleSourceFunc) (void);
   typedef int          (*ElmMapModuleZoomMinFunc) (void);
   typedef int          (*ElmMapModuleZoomMaxFunc) (void);
   typedef char        *(*ElmMapModuleUrlFunc) (Evas_Object *obj, int x, int y, int zoom);
   typedef int          (*ElmMapModuleRouteSourceFunc) (void);
   typedef char        *(*ElmMapModuleRouteUrlFunc) (Evas_Object *obj, char *type_name, int method, double flon, double flat, double tlon, double tlat);
   typedef char        *(*ElmMapModuleNameUrlFunc) (Evas_Object *obj, int method, char *name, double lon, double lat);
   typedef Eina_Bool    (*ElmMapModuleGeoIntoCoordFunc) (const Evas_Object *obj, int zoom, double lon, double lat, int size, int *x, int *y);
   typedef Eina_Bool    (*ElmMapModuleCoordIntoGeoFunc) (const Evas_Object *obj, int zoom, int x, int y, int size, double *lon, double *lat);

   EAPI Evas_Object          *elm_map_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_zoom_set(Evas_Object *obj, int zoom) EINA_ARG_NONNULL(1);
   EAPI int                   elm_map_zoom_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_zoom_mode_set(Evas_Object *obj, Elm_Map_Zoom_Mode mode) EINA_ARG_NONNULL(1);
   EAPI Elm_Map_Zoom_Mode     elm_map_zoom_mode_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_geo_region_get(const Evas_Object *obj, double *lon, double *lat) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_geo_region_bring_in(Evas_Object *obj, double lon, double lat) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_geo_region_show(Evas_Object *obj, double lon, double lat) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_paused_set(Evas_Object *obj, Eina_Bool paused) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_map_paused_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_paused_markers_set(Evas_Object *obj, Eina_Bool paused) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_map_paused_markers_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_utils_downloading_status_get(const Evas_Object *obj, int *try_num, int *finish_num) EINA_ARG_NONNULL(1, 2, 3);
   EAPI void                  elm_map_utils_convert_coord_into_geo(const Evas_Object *obj, int x, int y, int size, double *lon, double *lat) EINA_ARG_NONNULL(1, 5, 6);
   EAPI void                  elm_map_utils_convert_geo_into_coord(const Evas_Object *obj, double lon, double lat, int size, int *x, int *y) EINA_ARG_NONNULL(1, 5, 6);
   EAPI Elm_Map_Name         *elm_map_utils_convert_coord_into_name(const Evas_Object *obj, double lon, double lat) EINA_ARG_NONNULL(1);
   EAPI Elm_Map_Name         *elm_map_utils_convert_name_into_coord(const Evas_Object *obj, char *address) EINA_ARG_NONNULL(1, 2);
   EAPI void                  elm_map_utils_rotate_coord(const Evas_Object *obj, const Evas_Coord x, const Evas_Coord y, const Evas_Coord cx, const Evas_Coord cy, const double degree, Evas_Coord *xx, Evas_Coord *yy) EINA_ARG_NONNULL(1);
   EAPI Elm_Map_Marker       *elm_map_marker_add(Evas_Object *obj, double lon, double lat, Elm_Map_Marker_Class *clas, Elm_Map_Group_Class *clas_group, void *data) EINA_ARG_NONNULL(1, 4, 5);
   EAPI void                  elm_map_max_marker_per_group_set(Evas_Object *obj, int max) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_remove(Elm_Map_Marker *marker) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_region_get(const Elm_Map_Marker *marker, double *lon, double *lat) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_bring_in(Elm_Map_Marker *marker) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_show(Elm_Map_Marker *marker) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_markers_list_show(Eina_List *markers) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_map_marker_object_get(const Elm_Map_Marker *marker) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_update(Elm_Map_Marker *marker) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_bubbles_close(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Map_Group_Class  *elm_map_group_class_new(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_group_class_style_set(Elm_Map_Group_Class *clas, const char *style) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_group_class_icon_cb_set(Elm_Map_Group_Class *clas, ElmMapGroupIconGetFunc icon_get) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_group_class_data_set(Elm_Map_Group_Class *clas, void *data) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_group_class_zoom_displayed_set(Elm_Map_Group_Class *clas, int zoom) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_group_class_zoom_grouped_set(Elm_Map_Group_Class *clas, int zoom) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_group_class_hide_set(Evas_Object *obj, Elm_Map_Group_Class *clas, Eina_Bool hide) EINA_ARG_NONNULL(1, 2);
   EAPI Elm_Map_Marker_Class *elm_map_marker_class_new(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_class_style_set(Elm_Map_Marker_Class *clas, const char *style) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_class_icon_cb_set(Elm_Map_Marker_Class *clas, ElmMapMarkerIconGetFunc icon_get) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_class_get_cb_set(Elm_Map_Marker_Class *clas, ElmMapMarkerGetFunc get) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_marker_class_del_cb_set(Elm_Map_Marker_Class *clas, ElmMapMarkerDelFunc del) EINA_ARG_NONNULL(1);
   EAPI const char          **elm_map_source_names_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_source_name_set(Evas_Object *obj, const char *source_name) EINA_ARG_NONNULL(1);
   EAPI const char           *elm_map_source_name_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_route_source_set(Evas_Object *obj, Elm_Map_Route_Sources source) EINA_ARG_NONNULL(1);
   EAPI Elm_Map_Route_Sources elm_map_route_source_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_source_zoom_min_set(Evas_Object *obj, int zoom) EINA_ARG_NONNULL(1);
   EAPI int                   elm_map_source_zoom_min_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_source_zoom_max_set(Evas_Object *obj, int zoom) EINA_ARG_NONNULL(1);
   EAPI int                   elm_map_source_zoom_max_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_user_agent_set(Evas_Object *obj, const char *user_agent) EINA_ARG_NONNULL(1, 2);
   EAPI const char           *elm_map_user_agent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Map_Route        *elm_map_route_add(Evas_Object *obj, Elm_Map_Route_Type type, Elm_Map_Route_Method method, double flon, double flat, double tlon, double tlat) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_route_remove(Elm_Map_Route *route) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_route_color_set(Elm_Map_Route *route, int r, int g , int b, int a) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_route_color_get(const Elm_Map_Route *route, int *r, int *g , int *b, int *a) EINA_ARG_NONNULL(1);
   EAPI double                elm_map_route_distance_get(const Elm_Map_Route *route) EINA_ARG_NONNULL(1);
   EAPI const char           *elm_map_route_node_get(const Elm_Map_Route *route) EINA_ARG_NONNULL(1);
   EAPI const char           *elm_map_route_waypoint_get(const Elm_Map_Route *route) EINA_ARG_NONNULL(1);
   EAPI const char           *elm_map_name_address_get(const Elm_Map_Name *name) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_name_region_get(const Elm_Map_Name *name, double *lon, double *lat) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_name_remove(Elm_Map_Name *name) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_rotate_set(Evas_Object *obj, double degree, Evas_Coord cx, Evas_Coord cy) EINA_ARG_NONNULL(1);
   EAPI void                  elm_map_rotate_get(const Evas_Object *obj, double *degree, Evas_Coord *cx, Evas_Coord *cy) EINA_ARG_NONNULL(1, 2, 3, 4);
   EAPI void                  elm_map_wheel_disabled_set(Evas_Object *obj, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_map_wheel_disabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
#ifdef ELM_EMAP
   EAPI Evas_Object          *elm_map_track_add(Evas_Object *obj, EMap_Route *emap) EINA_ARG_NONNULL(1);
#endif
   EAPI void                  elm_map_track_remove(Evas_Object *obj, Evas_Object *route) EINA_ARG_NONNULL(1);

   /* smart callbacks called:
    * "clicked" - when image clicked
    * "press" - when mouse/finger held down initially on image
    * "longpressed" - when mouse/finger held for long time on image
    * "clicked,double" - when mouse/finger double-clicked
    * "load,details" - when detailed image load begins
    * "loaded,details" - when detailed image load done
    * "zoom,start" - when zooming started
    * "zoom,stop" - when zooming stopped
    * "zoom,change" - when auto zoom mode changed zoom level
    * "scroll - the content has been scrolled (moved)
    * "scroll,anim,start" - scrolling animation has started
    * "scroll,anim,stop" - scrolling animation has stopped
    * "scroll,drag,start" - dragging the contents around has started
    * "scroll,drag,stop" - dragging the contents around has stopped
    */

   /* Route */
   EAPI Evas_Object *elm_route_add(Evas_Object *parent);
#ifdef ELM_EMAP
   EAPI void elm_route_emap_set(Evas_Object *obj, EMap_Route *emap);
#endif
   EAPI double elm_route_lon_min_get(Evas_Object *obj);
   EAPI double elm_route_lat_min_get(Evas_Object *obj);
   EAPI double elm_route_lon_max_get(Evas_Object *obj);
   EAPI double elm_route_lat_max_get(Evas_Object *obj);


   /* panel */
   typedef enum _Elm_Panel_Orient
     {
        ELM_PANEL_ORIENT_TOP,
        ELM_PANEL_ORIENT_BOTTOM,
        ELM_PANEL_ORIENT_LEFT,
        ELM_PANEL_ORIENT_RIGHT,
     } Elm_Panel_Orient;

   EAPI Evas_Object          *elm_panel_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void                  elm_panel_orient_set(Evas_Object *obj, Elm_Panel_Orient orient) EINA_ARG_NONNULL(1);
   EAPI Elm_Panel_Orient      elm_panel_orient_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_panel_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_panel_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_panel_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_panel_hidden_set(Evas_Object *obj, Eina_Bool hidden) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_panel_hidden_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_panel_toggle(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /* panes */
   /**
    * TODO
    *
    * Update the minimun height of the bar in the theme. No minimun should be set in the vertical theme
    * Add events (move, start ...)
    */
   EAPI Evas_Object          *elm_panes_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void                  elm_panes_content_left_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI void                  elm_panes_content_right_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_panes_content_left_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_panes_content_right_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_panes_content_left_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object          *elm_panes_content_right_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI double                elm_panes_content_left_size_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                  elm_panes_content_left_size_set(Evas_Object *obj, double size) EINA_ARG_NONNULL(1);
   EAPI void                  elm_panes_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool             elm_panes_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /* flip */
   typedef enum _Elm_Flip_Mode
     {
        ELM_FLIP_ROTATE_Y_CENTER_AXIS,
        ELM_FLIP_ROTATE_X_CENTER_AXIS,
        ELM_FLIP_ROTATE_XZ_CENTER_AXIS,
        ELM_FLIP_ROTATE_YZ_CENTER_AXIS,
        ELM_FLIP_CUBE_LEFT,
        ELM_FLIP_CUBE_RIGHT,
        ELM_FLIP_CUBE_UP,
        ELM_FLIP_CUBE_DOWN,
        ELM_FLIP_PAGE_LEFT,
        ELM_FLIP_PAGE_RIGHT,
        ELM_FLIP_PAGE_UP,
        ELM_FLIP_PAGE_DOWN
     } Elm_Flip_Mode;
   typedef enum _Elm_Flip_Interaction
     {
        ELM_FLIP_INTERACTION_NONE,
        ELM_FLIP_INTERACTION_ROTATE,
        ELM_FLIP_INTERACTION_CUBE,
        ELM_FLIP_INTERACTION_PAGE
     } Elm_Flip_Interaction;
   typedef enum _Elm_Flip_Direction
     {
        ELM_FLIP_DIRECTION_UP,
        ELM_FLIP_DIRECTION_DOWN,
        ELM_FLIP_DIRECTION_LEFT,
        ELM_FLIP_DIRECTION_RIGHT
     } Elm_Flip_Direction;

   EAPI Evas_Object *elm_flip_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_flip_content_front_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI void         elm_flip_content_back_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_flip_content_front_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_flip_content_back_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_flip_content_front_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_flip_content_back_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_flip_front_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_flip_perspective_set(Evas_Object *obj, Evas_Coord foc, Evas_Coord x, Evas_Coord y) EINA_ARG_NONNULL(1);
   EAPI void         elm_flip_go(Evas_Object *obj, Elm_Flip_Mode mode) EINA_ARG_NONNULL(1);
   EAPI void         elm_flip_interaction_set(Evas_Object *obj, Elm_Flip_Interaction mode);
   EAPI Elm_Flip_Interaction elm_flip_interaction_get(const Evas_Object *obj);
   EAPI void         elm_flip_interacton_direction_enabled_set(Evas_Object *obj, Elm_Flip_Direction dir, Eina_Bool enabled);
   EAPI Eina_Bool    elm_flip_interacton_direction_enabled_get(Evas_Object *obj, Elm_Flip_Direction dir);
   EAPI void         elm_flip_interacton_direction_hitsize_set(Evas_Object *obj, Elm_Flip_Direction dir, double hitsize);
   EAPI double       elm_flip_interacton_direction_hitsize_get(Evas_Object *obj, Elm_Flip_Direction dir);
   /* smart callbacks called:
    * "animate,begin" - when a flip animation was started
    * "animate,done" - when a flip animation is finished
    */

   /* scrolledentry */
   EINA_DEPRECATED EAPI Evas_Object *elm_scrolled_entry_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_single_line_set(Evas_Object *obj, Eina_Bool single_line) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_single_line_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_password_set(Evas_Object *obj, Eina_Bool password) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_password_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_entry_set(Evas_Object *obj, const char *entry) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_scrolled_entry_entry_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_entry_append(Evas_Object *obj, const char *entry) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_is_empty(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_scrolled_entry_selection_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_entry_insert(Evas_Object *obj, const char *entry) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_line_wrap_set(Evas_Object *obj, Elm_Wrap_Type wrap) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_editable_set(Evas_Object *obj, Eina_Bool editable) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_editable_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_select_none(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_select_all(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cursor_next(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cursor_prev(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cursor_up(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cursor_down(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_begin_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_end_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_line_begin_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_line_end_set(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_selection_begin(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_selection_end(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cursor_is_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cursor_is_visible_format_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI const char  *elm_scrolled_entry_cursor_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cursor_pos_set(Evas_Object *obj, int pos) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI int          elm_scrolled_entry_cursor_pos_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_selection_cut(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_selection_copy(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_selection_paste(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_context_menu_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_context_menu_item_add(Evas_Object *obj, const char *label, const char *icon_file, Elm_Icon_Type icon_type, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_context_menu_disabled_set(Evas_Object *obj, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_context_menu_disabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_scrollbar_policy_set(Evas_Object *obj, Elm_Scroller_Policy h, Elm_Scroller_Policy v) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_icon_set(Evas_Object *obj, Evas_Object *icon) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI Evas_Object *elm_scrolled_entry_icon_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Evas_Object *elm_scrolled_entry_icon_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_icon_visible_set(Evas_Object *obj, Eina_Bool setting) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_end_set(Evas_Object *obj, Evas_Object *end) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI Evas_Object *elm_scrolled_entry_end_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Evas_Object *elm_scrolled_entry_end_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_end_visible_set(Evas_Object *obj, Eina_Bool setting) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_item_provider_append(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *entry, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_item_provider_prepend(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *entry, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_item_provider_remove(Evas_Object *obj, Evas_Object *(*func) (void *data, Evas_Object *entry, const char *item), void *data) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_text_filter_append(Evas_Object *obj, void (*func) (void *data, Evas_Object *entry, char **text), void *data) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_text_filter_prepend(Evas_Object *obj, void (*func) (void *data, Evas_Object *entry, char **text), void *data) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_text_filter_remove(Evas_Object *obj, void (*func) (void *data, Evas_Object *entry, char **text), void *data) EINA_ARG_NONNULL(1, 2);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_file_set(Evas_Object *obj, const char *file, Elm_Text_Format format) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_file_get(const Evas_Object *obj, const char **file, Elm_Text_Format *format) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_file_save(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_autosave_set(Evas_Object *obj, Eina_Bool autosave) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_autosave_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void         elm_scrolled_entry_cnp_textonly_set(Evas_Object *obj, Eina_Bool textonly) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI Eina_Bool    elm_scrolled_entry_cnp_textonly_get(Evas_Object *obj) EINA_ARG_NONNULL(1);

   /* conformant */
   EAPI Evas_Object *elm_conformant_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_conformant_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_conformant_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_conformant_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_conformant_content_area_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /* mapbuf */
   EAPI Evas_Object *elm_mapbuf_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void         elm_mapbuf_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_mapbuf_content_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Evas_Object *elm_mapbuf_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_mapbuf_enabled_set(Evas_Object *obj, Eina_Bool enabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_mapbuf_enabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_mapbuf_smooth_set(Evas_Object *obj, Eina_Bool smooth) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_mapbuf_smooth_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void         elm_mapbuf_alpha_set(Evas_Object *obj, Eina_Bool alpha) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool    elm_mapbuf_alpha_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);

   /* flipselector */
   typedef struct _Elm_Flipselector_Item Elm_Flipselector_Item;

   EAPI Evas_Object               *elm_flipselector_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI void                       elm_flipselector_flip_next(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                       elm_flipselector_flip_prev(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Flipselector_Item     *elm_flipselector_item_append(Evas_Object *obj, const char *label, void (*func)(void *data, Evas_Object *obj, void *event_info), void *data) EINA_ARG_NONNULL(1);
   EAPI Elm_Flipselector_Item     *elm_flipselector_item_prepend(Evas_Object *obj, const char *label, void (*func)(void *data, Evas_Object *obj, void *event_info), void *data) EINA_ARG_NONNULL(1);
   EAPI const Eina_List           *elm_flipselector_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Flipselector_Item     *elm_flipselector_first_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Flipselector_Item     *elm_flipselector_last_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Flipselector_Item     *elm_flipselector_selected_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                       elm_flipselector_item_selected_set(Elm_Flipselector_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool                  elm_flipselector_item_selected_get(const Elm_Flipselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                       elm_flipselector_item_del(Elm_Flipselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI const char                *elm_flipselector_item_label_get(const Elm_Flipselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                       elm_flipselector_item_label_set(Elm_Flipselector_Item *item, const char *label) EINA_ARG_NONNULL(1);
   EAPI Elm_Flipselector_Item     *elm_flipselector_item_prev_get(Elm_Flipselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Flipselector_Item     *elm_flipselector_item_next_get(Elm_Flipselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                       elm_flipselector_interval_set(Evas_Object *obj, double interval) EINA_ARG_NONNULL(1);
   EAPI double                     elm_flipselector_interval_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "selected" - when flipselector selected item is changed
    * "overflowed" - when flipselector item is changed to first item
    *                from last item
    * "underflowed" - when flipselector item is changed to last item
    *                 from first item.
    */
   /* available styles:
    * default
    */

   /**
    * @addtogroup Animator Animator
    * @ingroup Elementary
    *
    * @brief Functions to ease creation of animations.
    *
    * elm_animator is designed to provide an easy way to create animations.
    * Creating an animation with elm_animator is as simple as setting a
    * duration, an operating callback and telling it to run the animation.
    * However that is not the full extent of elm_animator's ability, animations
    * can be paused and resumed, reversed and the animation need not be linear.
    *
    * To run an animation you must specify at least a duration and operation
    * callback, not setting any other properties will create a linear animation
    * that runs once and is not reversed.
    *
    * @ref elm_animator_example_page_01 "This" example should make all of that
    * very clear.
    *
    * @warning elm_animator is @b not a widget.
    * @{
    */
   /**
    * @brief Type of curve desired for animation.
    *
    * The speed in which an animation happens doesn't have to be linear, some
    * animations will look better if they're accelerating or decelerating, so
    * elm_animator provides four options in this regard:
    * @image html elm_animator_curve_style.png
    * @image latex elm_animator_curve_style.eps width=\textwidth
    * As can be seen in the image the speed of the animation will be:
    * @li ELM_ANIMATOR_CURVE_LINEAR constant
    * @li ELM_ANIMATOR_CURVE_IN_OUT start slow, speed up and then slow down
    * @li ELM_ANIMATOR_CURVE_IN start slow and then speed up
    * @li ELM_ANIMATOR_CURVE_OUT start fast and then slow down
    */
   typedef enum
     {
        ELM_ANIMATOR_CURVE_LINEAR,
        ELM_ANIMATOR_CURVE_IN_OUT,
        ELM_ANIMATOR_CURVE_IN,
        ELM_ANIMATOR_CURVE_OUT
     } Elm_Animator_Curve_Style;
   typedef struct _Elm_Animator Elm_Animator;
  /**
   * Called back per loop of an elementary animators cycle
   * @param data user-data given to elm_animator_operation_callback_set()
   * @param animator the animator being run
   * @param double the position in the animation
   */
   typedef void (*Elm_Animator_Operation_Cb) (void *data, Elm_Animator *animator, double frame);
  /**
   * Called back when an elementary animator finishes
   * @param data user-data given to elm_animator_completion_callback_set()
   */
   typedef void (*Elm_Animator_Completion_Cb) (void *data);

   /**
    * @brief Create a new animator.
    *
    * @param[in] parent Parent object
    *
    * The @a parent argument can be set to NULL for no parent. If a parent is set
    * there is no need to call elm_animator_del(), when the parent is deleted it
    * will delete the animator.
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI Elm_Animator*            elm_animator_add(Evas_Object *parent);
   /**
    * Deletes the animator freeing any resources it used. If the animator was
    * created with a NULL parent this must be called, otherwise it will be
    * automatically called when the parent is deleted.
    *
    * @param[in] animator Animator object
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_del(Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * Set the duration of the animation.
    *
    * @param[in] animator Animator object
    * @param[in] duration Duration in second
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_duration_set(Elm_Animator *animator, double duration) EINA_ARG_NONNULL(1);
   /**
    * @brief Set the callback function for animator operation.
    *
    * @param[in] animator Animator object
    * @param[in] func @ref Elm_Animator_Operation_Cb "Callback" function pointer
    * @param[in] data Callback function user argument
    *
    * The @p func callback will be called with a frame value in range [0, 1] which
    * indicates how far along the animation should be. It is the job of @p func to
    * actually change the state of any object(or objects) that are being animated.
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_operation_callback_set(Elm_Animator *animator, Elm_Animator_Operation_Cb func, void *data) EINA_ARG_NONNULL(1);
   /**
    * Set the callback function for the when the animation ends.
    *
    * @param[in]  animator Animator object
    * @param[in]  func   Callback function pointe
    * @param[in]  data Callback function user argument
    *
    * @warning @a func will not be executed if elm_animator_stop() is called.
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_completion_callback_set(Elm_Animator *animator, Elm_Animator_Completion_Cb func, void *data) EINA_ARG_NONNULL(1);
   /**
    * @brief Stop animator.
    *
    * @param[in] animator Animator object
    *
    * If called before elm_animator_animate() it does nothing. If there is an
    * animation in progress the animation will be stopped(the operation callback
    * will not be executed again) and it can't be restarted using
    * elm_animator_resume().
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_stop(Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * Set the animator repeat count.
    *
    * @param[in]  animator Animator object
    * @param[in]  repeat_cnt Repeat count
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_repeat_set(Elm_Animator *animator, unsigned int repeat_cnt) EINA_ARG_NONNULL(1);
   /**
    * @brief Start animation.
    *
    * @param[in] animator Animator object
    *
    * This function starts the animation if the nescessary properties(duration
    * and operation callback) have been set. Once started the animation will
    * run until complete or elm_animator_stop() is called.
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_animate(Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * Sets the animation @ref Elm_Animator_Curve_Style "acceleration style".
    *
    * @param[in] animator Animator object
    * @param[in] cs Curve style. Default is ELM_ANIMATOR_CURVE_LINEAR
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_curve_style_set(Elm_Animator *animator, Elm_Animator_Curve_Style cs) EINA_ARG_NONNULL(1);
   /**
    * Gets the animation @ref Elm_Animator_Curve_Style "acceleration style".
    *
    * @param[in] animator Animator object
    * @param[in] cs Curve style. Default is ELM_ANIMATOR_CURVE_LINEAR
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI Elm_Animator_Curve_Style elm_animator_curve_style_get(const Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * @brief Sets wether the animation should be automatically reversed.
    *
    * @param[in] animator Animator object
    * @param[in] reverse Reverse or not
    *
    * This controls wether the animation will be run on reverse imediately after
    * running forward. When this is set together with repetition the animation
    * will run in reverse once for each time it ran forward.@n
    * Runnin an animation in reverse is accomplished by calling the operation
    * callback with a frame value starting at 1 and diminshing until 0.
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_auto_reverse_set(Elm_Animator *animator, Eina_Bool reverse) EINA_ARG_NONNULL(1);
   /**
    * Gets wether the animation will automatically reversed
    *
    * @param[in] animator Animator object
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI Eina_Bool                elm_animator_auto_reverse_get(const Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * Gets the status for the animator operation. The status of the animator @b
    * doesn't take in to account elm_animator_pause() or elm_animator_resume(), it
    * only informs if the animation was started and has not ended(either normally
    * or through elm_animator_stop()).
    *
    * @param[in] animator Animator object
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI Eina_Bool                elm_animator_operating_get(const Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * Gets how many times the animation will be repeated
    *
    * @param[in] animator Animator object
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI unsigned int             elm_animator_repeat_get(const Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * Pause the animator.
    *
    * @param[in]  animator Animator object
    *
    * This causes the animation to be temporarily stopped(the operation callback
    * will not be called). If the animation is not yet running this is a no-op.
    * Once an animation has been paused with this function it can be resumed
    * using elm_animator_resume().
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_pause(Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * @brief Resumes the animator.
    *
    * @param[in]  animator Animator object
    *
    * Resumes an animation that was paused using elm_animator_pause(), after
    * calling this function calls to the operation callback will happen
    * normally. If an animation is stopped by means of elm_animator_stop it
    * @b can't be restarted with this function.@n
    *
    * @warning When an animation is resumed it doesn't start from where it was paused, it
    * will go to where it would have been if it had not been paused. If an
    * animation with a duration of 3 seconds is paused after 1 second for 1 second
    * it will resume as if it had ben animating for 2 seconds, the operating
    * callback will be called with a frame value of aproximately 2/3.
    * @deprecated Use @ref Transit instead.
    */
   EINA_DEPRECATED EAPI void                     elm_animator_resume(Elm_Animator *animator) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* calendar */
   typedef enum
     {
        ELM_CALENDAR_UNIQUE,
        ELM_CALENDAR_DAILY,
        ELM_CALENDAR_WEEKLY,
        ELM_CALENDAR_MONTHLY,
        ELM_CALENDAR_ANNUALLY
     } Elm_Calendar_Mark_Repeat;
   typedef struct _Elm_Calendar_Mark Elm_Calendar_Mark;

   EAPI Evas_Object       *elm_calendar_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI const char       **elm_calendar_weekdays_names_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_calendar_weekdays_names_set(Evas_Object *obj, const char *weekdays[]) EINA_ARG_NONNULL(1, 2);
   EAPI double             elm_calendar_interval_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_calendar_interval_set(Evas_Object *obj, double interval) EINA_ARG_NONNULL(1);
   EAPI void               elm_calendar_min_max_year_get(const Evas_Object *obj, int *min, int *max) EINA_ARG_NONNULL(1);
   EAPI void               elm_calendar_min_max_year_set(Evas_Object *obj, int min, int max) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_calendar_day_selection_enabled_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_calendar_day_selection_enabled_set(Evas_Object *obj, Eina_Bool enabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool          elm_calendar_selected_time_get(const Evas_Object *obj, struct tm *selected_time) EINA_ARG_NONNULL(1, 2);
   EAPI void               elm_calendar_selected_time_set(Evas_Object *obj, struct tm *selected_time) EINA_ARG_NONNULL(1);
   EAPI void               elm_calendar_format_function_set(Evas_Object *obj, char * (*format_function) (struct tm *stime)) EINA_ARG_NONNULL(1);
   EAPI Elm_Calendar_Mark *elm_calendar_mark_add(Evas_Object *obj, const char *mark_type, struct tm *mark_time, Elm_Calendar_Mark_Repeat repeat) EINA_ARG_NONNULL(1);
   EAPI void               elm_calendar_mark_del(Elm_Calendar_Mark *mark) EINA_ARG_NONNULL(1);
   EAPI void               elm_calendar_marks_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List   *elm_calendar_marks_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void               elm_calendar_marks_draw(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void               elm_calendar_text_saturday_color_set(Evas_Object *obj, int pos) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void               elm_calendar_text_sunday_color_set(Evas_Object *obj, int pos) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void               elm_calendar_text_weekday_color_set(Evas_Object *obj, int pos) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * changed - emitted when the user select a day or change the displayed
    * month.
    */

   /* diskselector */
   typedef struct _Elm_Diskselector_Item Elm_Diskselector_Item;

   EAPI Evas_Object           *elm_diskselector_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool              elm_diskselector_round_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_round_set(Evas_Object *obj, Eina_Bool round) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI int    elm_diskselector_side_label_lenght_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EINA_DEPRECATED EAPI void   elm_diskselector_side_label_lenght_set(Evas_Object *obj, int len) EINA_ARG_NONNULL(1);
   EAPI int                    elm_diskselector_side_label_length_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_side_label_length_set(Evas_Object *obj, int len) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_bounce_set(Evas_Object *obj, Eina_Bool h_bounce, Eina_Bool v_bounce) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_bounce_get(const Evas_Object *obj, Eina_Bool *h_bounce, Eina_Bool *v_bounce) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_scroller_policy_get(const Evas_Object *obj, Elm_Scroller_Policy *policy_h, Elm_Scroller_Policy *policy_v) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_scroller_policy_set(Evas_Object *obj, Elm_Scroller_Policy policy_h, Elm_Scroller_Policy policy_v) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI const Eina_List       *elm_diskselector_items_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Diskselector_Item *elm_diskselector_item_append(Evas_Object *obj, const char *label, Evas_Object *icon, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_del(Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_del_cb_set(Elm_Diskselector_Item *item, Evas_Smart_Cb func) EINA_ARG_NONNULL(1);
   EAPI void                  *elm_diskselector_item_data_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI Evas_Object           *elm_diskselector_item_icon_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_icon_set(Elm_Diskselector_Item *item, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI const char            *elm_diskselector_item_label_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_label_set(Elm_Diskselector_Item *item, const char *label) EINA_ARG_NONNULL(1);
   EAPI Elm_Diskselector_Item *elm_diskselector_selected_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_selected_set(Elm_Diskselector_Item *item, Eina_Bool selected) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool              elm_diskselector_item_selected_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Diskselector_Item *elm_diskselector_first_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Diskselector_Item *elm_diskselector_last_item_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Diskselector_Item *elm_diskselector_item_prev_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI Elm_Diskselector_Item *elm_diskselector_item_next_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_tooltip_text_set(Elm_Diskselector_Item *item, const char *text) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_tooltip_content_cb_set(Elm_Diskselector_Item *item, Elm_Tooltip_Item_Content_Cb func, const void *data, Evas_Smart_Cb del_cb) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_tooltip_unset(Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_tooltip_style_set(Elm_Diskselector_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char            *elm_diskselector_item_tooltip_style_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_cursor_set(Elm_Diskselector_Item *item, const char *cursor) EINA_ARG_NONNULL(1);
   EAPI const char            *elm_diskselector_item_cursor_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_cursor_unset(Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_cursor_style_set(Elm_Diskselector_Item *item, const char *style) EINA_ARG_NONNULL(1);
   EAPI const char            *elm_diskselector_item_cursor_style_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_item_cursor_engine_only_set(Elm_Diskselector_Item *item, Eina_Bool engine_only) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool              elm_diskselector_item_cursor_engine_only_get(const Elm_Diskselector_Item *item) EINA_ARG_NONNULL(1);
   EAPI void                   elm_diskselector_display_item_num_set(Evas_Object *obj, int num) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "selected" - when item is selected (scroller stops)
    */

   /**
    * @page tutorial_colorselector Color selector example
    * @dontinclude colorselector_example_01.c
    *
    * This example shows how to change the color of a rectangle using a color
    * selector. We aren't going to explain a lot of the code since it's the
    * usual setup code:
    * @until show(rect)
    *
    * Now that we have a window with background and a rectangle we can create
    * our color_selector and set it's initial color to fully opaque blue:
    * @until show
    *
    * Next we tell ask to be notified whenever the color changes:
    * @until changed
    *
    * We follow that we some more run of the mill setup code:
    * @until ELM_MAIN()
    *
    * And now get to the callback that sets the color of the rectangle:
    * @until }
    *
    * This example will look like this:
    * @image html screenshots/colorselector_example_01.png
    * @image latex screenshots/colorselector_example_01.eps
    *
    * @example colorselector_example_01.c
    */
   /**
    * @defgroup Colorselector Colorselector
    *
    * @{
    *
    * @brief Widget for user to select a color.
    *
    * Signals that you can add callbacks for are:
    * "changed" - When the color value changes(event_info is NULL).
    *
    * See @ref tutorial_colorselector.
    */
   /**
    * @brief Add a new colorselector to the parent
    *
    * @param parent The parent object
    * @return The new object or NULL if it cannot be created
    *
    * @ingroup Colorselector
    */
   EAPI Evas_Object *elm_colorselector_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   /**
    * Set a color for the colorselector
    *
    * @param obj   Colorselector object
    * @param r     r-value of color
    * @param g     g-value of color
    * @param b     b-value of color
    * @param a     a-value of color
    *
    * @ingroup Colorselector
    */
   EAPI void         elm_colorselector_color_set(Evas_Object *obj, int r, int g , int b, int a) EINA_ARG_NONNULL(1);
   /**
    * Get a color from the colorselector
    *
    * @param obj   Colorselector object
    * @param r     integer pointer for r-value of color
    * @param g     integer pointer for g-value of color
    * @param b     integer pointer for b-value of color
    * @param a     integer pointer for a-value of color
    *
    * @ingroup Colorselector
    */
   EAPI void         elm_colorselector_color_get(const Evas_Object *obj, int *r, int *g , int *b, int *a) EINA_ARG_NONNULL(1);
   /**
    * @}
    */

   /* Contextual Popup */
   typedef struct _Elm_Ctxpopup_Item Elm_Ctxpopup_Item;

   typedef enum _Elm_Ctxpopup_Direction
     {
        ELM_CTXPOPUP_DIRECTION_DOWN,
        ELM_CTXPOPUP_DIRECTION_RIGHT,
        ELM_CTXPOPUP_DIRECTION_LEFT,
        ELM_CTXPOPUP_DIRECTION_UP,
     } Elm_Ctxpopup_Direction;

   EAPI Evas_Object  *elm_ctxpopup_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Evas_Object  *elm_ctxpopup_item_icon_get(const Elm_Ctxpopup_Item *item) EINA_ARG_NONNULL(1);
   EAPI void          elm_ctxpopup_item_icon_set(Elm_Ctxpopup_Item *item, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI const char   *elm_ctxpopup_item_label_get(const Elm_Ctxpopup_Item *item) EINA_ARG_NONNULL(1);
   EAPI void          elm_ctxpopup_item_label_set(Elm_Ctxpopup_Item *item, const char *label) EINA_ARG_NONNULL(1);
   EAPI void          elm_ctxpopup_hover_parent_set(Evas_Object *obj, Evas_Object *parent) EINA_ARG_NONNULL(1, 2);
   EAPI Evas_Object  *elm_ctxpopup_hover_parent_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void          elm_ctxpopup_clear(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void          elm_ctxpopup_horizontal_set(Evas_Object *obj, Eina_Bool horizontal) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool     elm_ctxpopup_horizontal_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   Elm_Ctxpopup_Item *elm_ctxpopup_item_append(Evas_Object *obj, const char *label, Evas_Object *icon, Evas_Smart_Cb func, const void *data) EINA_ARG_NONNULL(1);
   EAPI void          elm_ctxpopup_item_del(Elm_Ctxpopup_Item *item) EINA_ARG_NONNULL(1);
   EAPI void          elm_ctxpopup_item_disabled_set(Elm_Ctxpopup_Item *item, Eina_Bool disabled) EINA_ARG_NONNULL(1);
   EAPI Eina_Bool     elm_ctxpopup_item_disabled_get(const Elm_Ctxpopup_Item *item) EINA_ARG_NONNULL(1);
   EAPI void          elm_ctxpopup_content_set(Evas_Object *obj, Evas_Object *content) EINA_ARG_NONNULL(1, 2);
   EAPI Evas_Object  *elm_ctxpopup_content_unset(Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void          elm_ctxpopup_direction_priority_set(Evas_Object *obj, Elm_Ctxpopup_Direction first, Elm_Ctxpopup_Direction second, Elm_Ctxpopup_Direction third, Elm_Ctxpopup_Direction fourth) EINA_ARG_NONNULL(1);
   EAPI void          elm_ctxpopup_direction_priority_get(Evas_Object *obj, Elm_Ctxpopup_Direction *first, Elm_Ctxpopup_Direction *second, Elm_Ctxpopup_Direction *third, Elm_Ctxpopup_Direction *fourth) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "dismissed" - the ctxpopup was dismissed
    */

   /* transit */
   /**
    *
    * @defgroup Transit Transit
    * @ingroup Elementary
    *
    * Transit is designed to apply various animated transition effects to @c
    * Evas_Object, such like translation, rotation, etc. For using these
    * effects, create an @ref Elm_Transit and add the desired transition effects.
    *
    * Once the effects are added into transit, they will be automatically
    * managed (their callback will be called until the duration is ended, and
    * they will be deleted on completion).
    *
    * Example:
    * @code
    * Elm_Transit *trans = elm_transit_add();
    * elm_transit_object_add(trans, obj);
    * elm_transit_effect_translation_add(trans, 0, 0, 280, 280
    * elm_transit_duration_set(transit, 1);
    * elm_transit_auto_reverse_set(transit, EINA_TRUE);
    * elm_transit_tween_mode_set(transit, ELM_TRANSIT_TWEEN_MODE_DECELERATE);
    * elm_transit_repeat_times_set(transit, 3);
    * @endcode
    *
    * Some transition effects are used to change the properties of objects. They
    * are:
    * @li @ref elm_transit_effect_translation_add
    * @li @ref elm_transit_effect_color_add
    * @li @ref elm_transit_effect_rotation_add
    * @li @ref elm_transit_effect_wipe_add
    * @li @ref elm_transit_effect_zoom_add
    * @li @ref elm_transit_effect_resizing_add
    *
    * Other transition effects are used to make one object disappear and another
    * object appear on its old place. These effects are:
    *
    * @li @ref elm_transit_effect_flip_add
    * @li @ref elm_transit_effect_resizable_flip_add
    * @li @ref elm_transit_effect_fade_add
    * @li @ref elm_transit_effect_blend_add
    *
    * It's also possible to make a transition chain with @ref
    * elm_transit_chain_transit_add.
    *
    * @warning We strongly recommend to use elm_transit just when edje can not do
    * the trick. Edje has more advantage than Elm_Transit, it has more flexibility and
    * animations can be manipulated inside the theme.
    *
    * List of examples:
    * @li @ref transit_example_01_explained
    * @li @ref transit_example_02_explained
    * @li @ref transit_example_03_c
    * @li @ref transit_example_04_c
    *
    * @{
    */

   /**
    * @enum Elm_Transit_Tween_Mode
    *
    * The type of acceleration used in the transition.
    */
   typedef enum
     {
        ELM_TRANSIT_TWEEN_MODE_LINEAR, /**< Constant speed */
        ELM_TRANSIT_TWEEN_MODE_SINUSOIDAL, /**< Starts slow, increase speed
                                             over time, then decrease again
                                             and stop slowly */
        ELM_TRANSIT_TWEEN_MODE_DECELERATE, /**< Starts fast and decrease
                                             speed over time */
        ELM_TRANSIT_TWEEN_MODE_ACCELERATE /**< Starts slow and increase speed
                                            over time */
     } Elm_Transit_Tween_Mode;

   /**
    * @enum Elm_Transit_Effect_Flip_Axis
    *
    * The axis where flip effect should be applied.
    */
   typedef enum
     {
        ELM_TRANSIT_EFFECT_FLIP_AXIS_X, /**< Flip on X axis */
        ELM_TRANSIT_EFFECT_FLIP_AXIS_Y /**< Flip on Y axis */
     } Elm_Transit_Effect_Flip_Axis;
   /**
    * @enum Elm_Transit_Effect_Wipe_Dir
    *
    * The direction where the wipe effect should occur.
    */
   typedef enum
     {
        ELM_TRANSIT_EFFECT_WIPE_DIR_LEFT, /**< Wipe to the left */
        ELM_TRANSIT_EFFECT_WIPE_DIR_RIGHT, /**< Wipe to the right */
        ELM_TRANSIT_EFFECT_WIPE_DIR_UP, /**< Wipe up */
        ELM_TRANSIT_EFFECT_WIPE_DIR_DOWN /**< Wipe down */
     } Elm_Transit_Effect_Wipe_Dir;
   /** @enum Elm_Transit_Effect_Wipe_Type
    *
    * Whether the wipe effect should show or hide the object.
    */
   typedef enum
     {
        ELM_TRANSIT_EFFECT_WIPE_TYPE_HIDE, /**< Hide the object during the
                                             animation */
        ELM_TRANSIT_EFFECT_WIPE_TYPE_SHOW /**< Show the object during the
                                            animation */
     } Elm_Transit_Effect_Wipe_Type;

   /**
    * @typedef Elm_Transit
    *
    * The Transit created with elm_transit_add(). This type has the information
    * about the objects which the transition will be applied, and the
    * transition effects that will be used. It also contains info about
    * duration, number of repetitions, auto-reverse, etc.
    */
   typedef struct _Elm_Transit Elm_Transit;
   typedef void Elm_Transit_Effect;
   /**
    * @typedef Elm_Transit_Effect_Transition_Cb
    *
    * Transition callback called for this effect on each transition iteration.
    */
   typedef void (*Elm_Transit_Effect_Transition_Cb) (Elm_Transit_Effect *effect, Elm_Transit *transit, double progress);
   /**
    * Elm_Transit_Effect_End_Cb
    *
    * Transition callback called for this effect when the transition is over.
    */
   typedef void (*Elm_Transit_Effect_End_Cb) (Elm_Transit_Effect *effect, Elm_Transit *transit);

   /**
    * Add new transit.
    *
    * @note Is not necessary to delete the transit object, it will be deleted at
    * the end of its operation.
    * @note The transit will start playing when the program enter in the main loop, is not
    * necessary to give a start to the transit.
    *
    * @return The transit object.
    *
    * @ingroup Transit
    */
   EAPI Elm_Transit                *elm_transit_add(void);

   /**
    * Stops the animation and delete the @p transit object.
    *
    * Call this function if you wants to stop the animation before the duration
    * time. Make sure the @p transit object is still alive with
    * elm_transit_del_cb_set() function.
    * All added effects will be deleted, calling its repective data_free_cb
    * functions. The function setted by elm_transit_del_cb_set() will be called.
    *
    * @see elm_transit_del_cb_set()
    *
    * @param transit The transit object to be deleted.
    *
    * @ingroup Transit
    * @warning Just call this function if you are sure the transit is alive.
    */
   EAPI void                        elm_transit_del(Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Add a new effect to the transit.
    *
    * @note The cb function and the data are the key to the effect. If you try to
    * add an already added effect, nothing is done.
    * @note After the first addition of an effect in @p transit, if its
    * effect list become empty again, the @p transit will be killed by
    * elm_transit_del(transit) function.
    *
    * Exemple:
    * @code
    * Elm_Transit *transit = elm_transit_add();
    * elm_transit_effect_add(transit,
    *                        elm_transit_effect_blend_op,
    *                        elm_transit_effect_blend_context_new(),
    *                        elm_transit_effect_blend_context_free);
    * @endcode
    *
    * @param transit The transit object.
    * @param transition_cb The operation function. It is called when the
    * animation begins, it is the function that actually performs the animation.
    * It is called with the @p data, @p transit and the time progression of the
    * animation (a double value between 0.0 and 1.0).
    * @param effect The context data of the effect.
    * @param end_cb The function to free the context data, it will be called
    * at the end of the effect, it must finalize the animation and free the
    * @p data.
    *
    * @ingroup Transit
    * @warning The transit free the context data at the and of the transition with
    * the data_free_cb function, do not use the context data in another transit.
    */
   EAPI void                        elm_transit_effect_add(Elm_Transit *transit, Elm_Transit_Effect_Transition_Cb transition_cb, Elm_Transit_Effect *effect, Elm_Transit_Effect_End_Cb end_cb) EINA_ARG_NONNULL(1, 2);

   /**
    * Delete an added effect.
    *
    * This function will remove the effect from the @p transit, calling the
    * data_free_cb to free the @p data.
    *
    * @see elm_transit_effect_add()
    *
    * @note If the effect is not found, nothing is done.
    * @note If the effect list become empty, this function will call
    * elm_transit_del(transit), that is, it will kill the @p transit.
    *
    * @param transit The transit object.
    * @param transition_cb The operation function.
    * @param effect The context data of the effect.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_effect_del(Elm_Transit *transit, Elm_Transit_Effect_Transition_Cb transition_cb, Elm_Transit_Effect *effect) EINA_ARG_NONNULL(1, 2);

   /**
    * Add new object to apply the effects.
    *
    * @note After the first addition of an object in @p transit, if its
    * object list become empty again, the @p transit will be killed by
    * elm_transit_del(transit) function.
    * @note If the @p obj belongs to another transit, the @p obj will be
    * removed from it and it will only belong to the @p transit. If the old
    * transit stays without objects, it will die.
    * @note When you add an object into the @p transit, its state from
    * evas_object_pass_events_get(obj) is saved, and it is applied when the
    * transit ends, if you change this state whith evas_object_pass_events_set()
    * after add the object, this state will change again when @p transit stops to
    * run.
    *
    * @param transit The transit object.
    * @param obj Object to be animated.
    *
    * @ingroup Transit
    * @warning It is not allowed to add a new object after transit begins to go.
    */
   EAPI void                        elm_transit_object_add(Elm_Transit *transit, Evas_Object *obj) EINA_ARG_NONNULL(1, 2);

   /**
    * Removes an added object from the transit.
    *
    * @note If the @p obj is not in the @p transit, nothing is done.
    * @note If the list become empty, this function will call
    * elm_transit_del(transit), that is, it will kill the @p transit.
    *
    * @param transit The transit object.
    * @param obj Object to be removed from @p transit.
    *
    * @ingroup Transit
    * @warning It is not allowed to remove objects after transit begins to go.
    */
   EAPI void                        elm_transit_object_remove(Elm_Transit *transit, Evas_Object *obj) EINA_ARG_NONNULL(1, 2);

   /**
    * Get the objects of the transit.
    *
    * @param transit The transit object.
    * @return a Eina_List with the objects from the transit.
    *
    * @ingroup Transit
    */
   EAPI const Eina_List            *elm_transit_objects_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Enable/disable keeping up the objects states.
    * If it is not kept, the objects states will be reset when transition ends.
    *
    * @note @p transit can not be NULL.
    * @note One state includes geometry, color, map data.
    *
    * @param transit The transit object.
    * @param state_keep Keeping or Non Keeping.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_objects_final_state_keep_set(Elm_Transit *transit, Eina_Bool state_keep) EINA_ARG_NONNULL(1);

   /**
    * Get a value whether the objects states will be reset or not.
    *
    * @note @p transit can not be NULL
    *
    * @see elm_transit_objects_final_state_keep_set()
    *
    * @param transit The transit object.
    * @return EINA_TRUE means the states of the objects will be reset.
    * If @p transit is NULL, EINA_FALSE is returned
    *
    * @ingroup Transit
    */
   EAPI Eina_Bool                   elm_transit_objects_final_state_keep_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Set the event enabled when transit is operating.
    *
    * If @p enabled is EINA_TRUE, the objects of the transit will receives
    * events from mouse and keyboard during the animation.
    * @note When you add an object with elm_transit_object_add(), its state from
    * evas_object_pass_events_get(obj) is saved, and it is applied when the
    * transit ends, if you change this state with evas_object_pass_events_set()
    * after adding the object, this state will change again when @p transit stops
    * to run.
    *
    * @param transit The transit object.
    * @param enabled Events are received when enabled is @c EINA_TRUE, and
    * ignored otherwise.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_event_enabled_set(Elm_Transit *transit, Eina_Bool enabled) EINA_ARG_NONNULL(1);

   /**
    * Get the value of event enabled status.
    *
    * @see elm_transit_event_enabled_set()
    *
    * @param transit The Transit object
    * @return EINA_TRUE, when event is enabled. If @p transit is NULL
    * EINA_FALSE is returned
    *
    * @ingroup Transit
    */
   EAPI Eina_Bool                   elm_transit_event_enabled_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Set the user-callback function when the transit is deleted.
    *
    * @note Using this function twice will overwrite the first function setted.
    * @note the @p transit object will be deleted after call @p cb function.
    *
    * @param transit The transit object.
    * @param cb Callback function pointer. This function will be called before
    * the deletion of the transit.
    * @param data Callback funtion user data. It is the @p op parameter.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_del_cb_set(Elm_Transit *transit, void (*cb)(void *data, Elm_Transit* transit), void *data) EINA_ARG_NONNULL(1);

   /**
    * Set reverse effect automatically.
    *
    * If auto reverse is setted, after running the effects with the progress
    * parameter from 0 to 1, it will call the effecs again with the progress
    * from 1 to 0. The transit will last for a time iqual to (2 * duration * repeat),
    * where the duration was setted with the function elm_transit_add and
    * the repeat with the function elm_transit_repeat_times_set().
    *
    * @param transit The transit object.
    * @param reverse EINA_TRUE means the auto_reverse is on.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_auto_reverse_set(Elm_Transit *transit, Eina_Bool reverse) EINA_ARG_NONNULL(1);

   /**
    * Get if the auto reverse is on.
    *
    * @see elm_transit_auto_reverse_set()
    *
    * @param transit The transit object.
    * @return EINA_TRUE means auto reverse is on. If @p transit is NULL
    * EINA_FALSE is returned
    *
    * @ingroup Transit
    */
   EAPI Eina_Bool                   elm_transit_auto_reverse_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Set the transit repeat count. Effect will be repeated by repeat count.
    *
    * This function sets the number of repetition the transit will run after
    * the first one, that is, if @p repeat is 1, the transit will run 2 times.
    * If the @p repeat is a negative number, it will repeat infinite times.
    *
    * @note If this function is called during the transit execution, the transit
    * will run @p repeat times, ignoring the times it already performed.
    *
    * @param transit The transit object
    * @param repeat Repeat count
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_repeat_times_set(Elm_Transit *transit, int repeat) EINA_ARG_NONNULL(1);

   /**
    * Get the transit repeat count.
    *
    * @see elm_transit_repeat_times_set()
    *
    * @param transit The Transit object.
    * @return The repeat count. If @p transit is NULL
    * 0 is returned
    *
    * @ingroup Transit
    */
   EAPI int                         elm_transit_repeat_times_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Set the transit animation acceleration type.
    *
    * This function sets the tween mode of the transit that can be:
    * ELM_TRANSIT_TWEEN_MODE_LINEAR - The default mode.
    * ELM_TRANSIT_TWEEN_MODE_SINUSOIDAL - Starts in accelerate mode and ends decelerating.
    * ELM_TRANSIT_TWEEN_MODE_DECELERATE - The animation will be slowed over time.
    * ELM_TRANSIT_TWEEN_MODE_ACCELERATE - The animation will accelerate over time.
    *
    * @param transit The transit object.
    * @param tween_mode The tween type.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_tween_mode_set(Elm_Transit *transit, Elm_Transit_Tween_Mode tween_mode) EINA_ARG_NONNULL(1);

   /**
    * Get the transit animation acceleration type.
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    * @return The tween type. If @p transit is NULL
    * ELM_TRANSIT_TWEEN_MODE_LINEAR is returned.
    *
    * @ingroup Transit
    */
   EAPI Elm_Transit_Tween_Mode      elm_transit_tween_mode_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Set the transit animation time
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    * @param duration The animation time.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_duration_set(Elm_Transit *transit, double duration) EINA_ARG_NONNULL(1);

   /**
    * Get the transit animation time
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    *
    * @return The transit animation time.
    *
    * @ingroup Transit
    */
   EAPI double                      elm_transit_duration_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Starts the transition.
    * Once this API is called, the transit begins to measure the time.
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_go(Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Pause/Resume the transition.
    *
    * If you call elm_transit_go again, the transit will be started from the
    * beginning, and will be unpaused.
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    * @param paused Whether the transition should be paused or not.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_paused_set(Elm_Transit *transit, Eina_Bool paused) EINA_ARG_NONNULL(1);

   /**
    * Get the value of paused status.
    *
    * @see elm_transit_paused_set()
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    * @return EINA_TRUE means transition is paused. If @p transit is NULL
    * EINA_FALSE is returned
    *
    * @ingroup Transit
    */
   EAPI Eina_Bool                   elm_transit_paused_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Get the time progression of the animation (a double value between 0.0 and 1.0).
    *
    * The value returned is a fraction (current time / total time). It
    * represents the progression position relative to the total.
    *
    * @note @p transit can not be NULL
    *
    * @param transit The transit object.
    *
    * @return The time progression value. If @p transit is NULL
    * 0 is returned
    *
    * @ingroup Transit
    */
   EAPI double                      elm_transit_progress_value_get(const Elm_Transit *transit) EINA_ARG_NONNULL(1);

   /**
    * Makes the chain relationship between two transits.
    *
    * @note @p transit can not be NULL. Transit would have multiple chain transits.
    * @note @p chain_transit can not be NULL. Chain transits could be chained to the only one transit.
    *
    * @param transit The transit object.
    * @param chain_transit The chain transit object. This transit will be operated
    *        after transit is done.
    *
    * This function adds @p chain_transit transition to a chain after the @p
    * transit, and will be started as soon as @p transit ends. See @ref
    * transit_example_02_explained for a full example.
    *
    * @ingroup Transit
    */
   EAPI void                        elm_transit_chain_transit_add(Elm_Transit *transit, Elm_Transit *chain_transit) EINA_ARG_NONNULL(1, 2);

   /**
    * Get the current chain transit list.
    *
    * @note @p transit can not be NULL.
    *
    * @param transit The transit object.
    * @return chain transit list.
    *
    * @ingroup Transit
    */
   EAPI Eina_List                  *elm_transit_chain_transits_get(const Elm_Transit *transit);

   /**
    * Add the Resizing Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates resizing effect context
    * and add it's required APIs to elm_transit_effect_add.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param from_w Object width size when effect begins.
    * @param from_h Object height size when effect begins.
    * @param to_w Object width size when effect ends.
    * @param to_h Object height size when effect ends.
    * @return Resizing effect context data.
    *
    * @ingroup Transit
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_resizing_add(Elm_Transit* transit, Evas_Coord from_w, Evas_Coord from_h, Evas_Coord to_w, Evas_Coord to_h);

   /**
    * Add the Translation Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates translation effect context
    * and add it's required APIs to elm_transit_effect_add.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param from_dx X Position variation when effect begins.
    * @param from_dy Y Position variation when effect begins.
    * @param to_dx X Position variation when effect ends.
    * @param to_dy Y Position variation when effect ends.
    * @return Translation effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the geometry information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_translation_add(Elm_Transit* transit, Evas_Coord from_dx, Evas_Coord from_dy, Evas_Coord to_dx, Evas_Coord to_dy);

   /**
    * Add the Zoom Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates zoom effect context
    * and add it's required APIs to elm_transit_effect_add.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param from_rate Scale rate when effect begins (1 is current rate).
    * @param to_rate Scale rate when effect ends.
    * @return Zoom effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the geometry information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_zoom_add(Elm_Transit *transit, float from_rate, float to_rate);

   /**
    * Add the Flip Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates flip effect context
    * and add it's required APIs to elm_transit_effect_add.
    * @note This effect is applied to each pair of objects in the order they are listed
    * in the transit list of objects. The first object in the pair will be the
    * "front" object and the second will be the "back" object.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param axis Flipping Axis(X or Y).
    * @param cw Flipping Direction. EINA_TRUE is clock-wise.
    * @return Flip effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the geometry information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_flip_add(Elm_Transit *transit, Elm_Transit_Effect_Flip_Axis axis, Eina_Bool cw);

   /**
    * Add the Resizable Flip Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates resizable flip effect context
    * and add it's required APIs to elm_transit_effect_add.
    * @note This effect is applied to each pair of objects in the order they are listed
    * in the transit list of objects. The first object in the pair will be the
    * "front" object and the second will be the "back" object.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param axis Flipping Axis(X or Y).
    * @param cw Flipping Direction. EINA_TRUE is clock-wise.
    * @return Resizable flip effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the geometry information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_resizable_flip_add(Elm_Transit *transit, Elm_Transit_Effect_Flip_Axis axis, Eina_Bool cw);

   /**
    * Add the Wipe Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates wipe effect context
    * and add it's required APIs to elm_transit_effect_add.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param type Wipe type. Hide or show.
    * @param dir Wipe Direction.
    * @return Wipe effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the geometry information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_wipe_add(Elm_Transit *transit, Elm_Transit_Effect_Wipe_Type type, Elm_Transit_Effect_Wipe_Dir dir);

   /**
    * Add the Color Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates color effect context
    * and add it's required APIs to elm_transit_effect_add.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit        Transit object.
    * @param  from_r        RGB R when effect begins.
    * @param  from_g        RGB G when effect begins.
    * @param  from_b        RGB B when effect begins.
    * @param  from_a        RGB A when effect begins.
    * @param  to_r          RGB R when effect ends.
    * @param  to_g          RGB G when effect ends.
    * @param  to_b          RGB B when effect ends.
    * @param  to_a          RGB A when effect ends.
    * @return               Color effect context data.
    *
    * @ingroup Transit
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_color_add(Elm_Transit *transit, unsigned int from_r, unsigned int from_g, unsigned int from_b, unsigned int from_a, unsigned int to_r, unsigned int to_g, unsigned int to_b, unsigned int to_a);

   /**
    * Add the Fade Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates fade effect context
    * and add it's required APIs to elm_transit_effect_add.
    * @note This effect is applied to each pair of objects in the order they are listed
    * in the transit list of objects. The first object in the pair will be the
    * "before" object and the second will be the "after" object.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @return Fade effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the color information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_fade_add(Elm_Transit *transit);

   /**
    * Add the Blend Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates blend effect context
    * and add it's required APIs to elm_transit_effect_add.
    * @note This effect is applied to each pair of objects in the order they are listed
    * in the transit list of objects. The first object in the pair will be the
    * "before" object and the second will be the "after" object.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @return Blend effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the color information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_blend_add(Elm_Transit *transit);

   /**
    * Add the Rotation Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates rotation effect context
    * and add it's required APIs to elm_transit_effect_add.
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param from_degree Degree when effect begins.
    * @param to_degree Degree when effect is ends.
    * @return Rotation effect context data.
    *
    * @ingroup Transit
    * @warning It is highly recommended just create a transit with this effect when
    * the window that the objects of the transit belongs has already been created.
    * This is because this effect needs the geometry information about the objects,
    * and if the window was not created yet, it can get a wrong information.
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_rotation_add(Elm_Transit *transit, float from_degree, float to_degree);

   /**
    * Add the ImageAnimation Effect to Elm_Transit.
    *
    * @note This API is one of the facades. It creates image animation effect context
    * and add it's required APIs to elm_transit_effect_add.
    * The @p images parameter is a list images paths. This list and
    * its contents will be deleted at the end of the effect by
    * elm_transit_effect_image_animation_context_free() function.
    *
    * Example:
    * @code
    * char buf[PATH_MAX];
    * Eina_List *images = NULL;
    * Elm_Transit *transi = elm_transit_add();
    *
    * snprintf(buf, sizeof(buf), "%s/images/icon_11.png", PACKAGE_DATA_DIR);
    * images = eina_list_append(images, eina_stringshare_add(buf));
    *
    * snprintf(buf, sizeof(buf), "%s/images/logo_small.png", PACKAGE_DATA_DIR);
    * images = eina_list_append(images, eina_stringshare_add(buf));
    * elm_transit_effect_image_animation_add(transi, images);
    *
    * @endcode
    *
    * @see elm_transit_effect_add()
    *
    * @param transit Transit object.
    * @param images Eina_List of images file paths. This list and
    * its contents will be deleted at the end of the effect by
    * elm_transit_effect_image_animation_context_free() function.
    * @return Image Animation effect context data.
    *
    * @ingroup Transit
    */
   EAPI Elm_Transit_Effect *elm_transit_effect_image_animation_add(Elm_Transit *transit, Eina_List *images);
   /**
    * @}
    */

  typedef struct _Elm_Store                      Elm_Store;
  typedef struct _Elm_Store_Filesystem           Elm_Store_Filesystem;
  typedef struct _Elm_Store_Item                 Elm_Store_Item;
  typedef struct _Elm_Store_Item_Filesystem      Elm_Store_Item_Filesystem;
  typedef struct _Elm_Store_Item_Info            Elm_Store_Item_Info;
  typedef struct _Elm_Store_Item_Info_Filesystem Elm_Store_Item_Info_Filesystem;
  typedef struct _Elm_Store_Item_Mapping         Elm_Store_Item_Mapping;
  typedef struct _Elm_Store_Item_Mapping_Empty   Elm_Store_Item_Mapping_Empty;
  typedef struct _Elm_Store_Item_Mapping_Icon    Elm_Store_Item_Mapping_Icon;
  typedef struct _Elm_Store_Item_Mapping_Photo   Elm_Store_Item_Mapping_Photo;
  typedef struct _Elm_Store_Item_Mapping_Custom  Elm_Store_Item_Mapping_Custom;

  typedef Eina_Bool (*Elm_Store_Item_List_Cb) (void *data, Elm_Store_Item_Info *info);
  typedef void      (*Elm_Store_Item_Fetch_Cb) (void *data, Elm_Store_Item *sti);
  typedef void      (*Elm_Store_Item_Unfetch_Cb) (void *data, Elm_Store_Item *sti);
  typedef void     *(*Elm_Store_Item_Mapping_Cb) (void *data, Elm_Store_Item *sti, const char *part);

  typedef enum
    {
       ELM_STORE_ITEM_MAPPING_NONE = 0,
       ELM_STORE_ITEM_MAPPING_LABEL, // const char * -> label
       ELM_STORE_ITEM_MAPPING_STATE, // Eina_Bool -> state
       ELM_STORE_ITEM_MAPPING_ICON, // char * -> icon path
       ELM_STORE_ITEM_MAPPING_PHOTO, // char * -> photo path
       ELM_STORE_ITEM_MAPPING_CUSTOM, // item->custom(it->data, it, part) -> void * (-> any)
       // can add more here as needed by common apps
       ELM_STORE_ITEM_MAPPING_LAST
    } Elm_Store_Item_Mapping_Type;

  struct _Elm_Store_Item_Mapping_Icon
    {
       // FIXME: allow edje file icons
       int                   w, h;
       Elm_Icon_Lookup_Order lookup_order;
       Eina_Bool             standard_name : 1;
       Eina_Bool             no_scale : 1;
       Eina_Bool             smooth : 1;
       Eina_Bool             scale_up : 1;
       Eina_Bool             scale_down : 1;
    };

  struct _Elm_Store_Item_Mapping_Empty
    {
       Eina_Bool             dummy;
    };

  struct _Elm_Store_Item_Mapping_Photo
    {
       int                   size;
    };

  struct _Elm_Store_Item_Mapping_Custom
    {
       Elm_Store_Item_Mapping_Cb func;
    };

  struct _Elm_Store_Item_Mapping
    {
       Elm_Store_Item_Mapping_Type     type;
       const char                     *part;
       int                             offset;
       union
         {
            Elm_Store_Item_Mapping_Empty  empty;
            Elm_Store_Item_Mapping_Icon   icon;
            Elm_Store_Item_Mapping_Photo  photo;
            Elm_Store_Item_Mapping_Custom custom;
            // add more types here
         } details;
    };

  struct _Elm_Store_Item_Info
    {
      Elm_Genlist_Item_Class       *item_class;
      const Elm_Store_Item_Mapping *mapping;
      void                         *data;
      char                         *sort_id;
    };

  struct _Elm_Store_Item_Info_Filesystem
    {
      Elm_Store_Item_Info  base;
      char                *path;
    };

#define ELM_STORE_ITEM_MAPPING_END { ELM_STORE_ITEM_MAPPING_NONE, NULL, 0, { .empty = { EINA_TRUE } } }
#define ELM_STORE_ITEM_MAPPING_OFFSET(st, it) offsetof(st, it)

  EAPI void                    elm_store_free(Elm_Store *st);

  EAPI Elm_Store              *elm_store_filesystem_new(void);
  EAPI void                    elm_store_filesystem_directory_set(Elm_Store *st, const char *dir) EINA_ARG_NONNULL(1);
  EAPI const char             *elm_store_filesystem_directory_get(const Elm_Store *st) EINA_ARG_NONNULL(1);
  EAPI const char             *elm_store_item_filesystem_path_get(const Elm_Store_Item *sti) EINA_ARG_NONNULL(1);

  EAPI void                    elm_store_target_genlist_set(Elm_Store *st, Evas_Object *obj) EINA_ARG_NONNULL(1);

  EAPI void                    elm_store_cache_set(Elm_Store *st, int max) EINA_ARG_NONNULL(1);
  EAPI int                     elm_store_cache_get(const Elm_Store *st) EINA_ARG_NONNULL(1);
  EAPI void                    elm_store_list_func_set(Elm_Store *st, Elm_Store_Item_List_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);
  EAPI void                    elm_store_fetch_func_set(Elm_Store *st, Elm_Store_Item_Fetch_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);
  EAPI void                    elm_store_fetch_thread_set(Elm_Store *st, Eina_Bool use_thread) EINA_ARG_NONNULL(1);
  EAPI Eina_Bool               elm_store_fetch_thread_get(const Elm_Store *st) EINA_ARG_NONNULL(1);

  EAPI void                    elm_store_unfetch_func_set(Elm_Store *st, Elm_Store_Item_Unfetch_Cb func, const void *data) EINA_ARG_NONNULL(1, 2);
  EAPI void                    elm_store_sorted_set(Elm_Store *st, Eina_Bool sorted) EINA_ARG_NONNULL(1);
  EAPI Eina_Bool               elm_store_sorted_get(const Elm_Store *st) EINA_ARG_NONNULL(1);
  EAPI void                    elm_store_item_data_set(Elm_Store_Item *sti, void *data) EINA_ARG_NONNULL(1);
  EAPI void                   *elm_store_item_data_get(Elm_Store_Item *sti) EINA_ARG_NONNULL(1);
  EAPI const Elm_Store        *elm_store_item_store_get(const Elm_Store_Item *sti) EINA_ARG_NONNULL(1);
  EAPI const Elm_Genlist_Item *elm_store_item_genlist_item_get(const Elm_Store_Item *sti) EINA_ARG_NONNULL(1);

   /* SegmentControl */
   typedef struct _Elm_Segment_Item Elm_Segment_Item;
   EAPI Evas_Object      *elm_segment_control_add(Evas_Object *parent) EINA_ARG_NONNULL(1);
   EAPI Elm_Segment_Item *elm_segment_control_item_add(Evas_Object *obj, Evas_Object *icon, const char *label) EINA_ARG_NONNULL(1);
   EAPI Elm_Segment_Item *elm_segment_control_item_insert_at(Evas_Object *obj, Evas_Object *icon, const char *label, int index) EINA_ARG_NONNULL(1);
   EAPI void              elm_segment_control_item_del(Elm_Segment_Item *it) EINA_ARG_NONNULL(1);
   EAPI void              elm_segment_control_item_del_at(Evas_Object *obj, int index) EINA_ARG_NONNULL(1);
   EAPI int               elm_segment_control_item_count_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI Elm_Segment_Item *elm_segment_control_item_get(const Evas_Object *obj, int index) EINA_ARG_NONNULL(1);
   EAPI const char       *elm_segment_control_item_label_get(const Evas_Object *obj, int index) EINA_ARG_NONNULL(1);
   EAPI void              elm_segment_control_item_label_set(Elm_Segment_Item* it, const char* label) EINA_ARG_NONNULL(1);
   EAPI Evas_Object      *elm_segment_control_item_icon_get(const Evas_Object *obj, int index) EINA_ARG_NONNULL(1);
   EAPI void              elm_segment_control_item_icon_set(Elm_Segment_Item *it, Evas_Object *icon) EINA_ARG_NONNULL(1);
   EAPI int               elm_segment_control_item_index_get(const Elm_Segment_Item *it) EINA_ARG_NONNULL(1);
   EAPI Evas_Object      *elm_segment_control_item_object_get(const Elm_Segment_Item *it) EINA_ARG_NONNULL(1);
   EAPI Elm_Segment_Item *elm_segment_control_item_selected_get(const Evas_Object *obj) EINA_ARG_NONNULL(1);
   EAPI void              elm_segment_control_item_selected_set(Elm_Segment_Item *it, Eina_Bool select) EINA_ARG_NONNULL(1);
   /* smart callbacks called:
    * "changed" -when the user clicks on a segment item which is not previously
    *            selected and get selected. The event_info parameter is the
    *            segment item index.
    */

   EAPI Evas_Object *elm_grid_add(Evas_Object *parent);
   EAPI void         elm_grid_size_set(Evas_Object *obj, int w, int h);
   EAPI void         elm_grid_size_get(Evas_Object *obj, int *w, int *h);
   EAPI void         elm_grid_pack(Evas_Object *obj, Evas_Object *subobj, int x, int y, int w, int h);
   EAPI void         elm_grid_unpack(Evas_Object *obj, Evas_Object *subobj);
   EAPI void         elm_grid_clear(Evas_Object *obj, Eina_Bool clear);
   EAPI void         elm_grid_pack_set(Evas_Object *subobj, int x, int y, int w, int h);
   EAPI void         elm_grid_pack_get(Evas_Object *subobj, int *x, int *y, int *w, int *h);

   EAPI Evas_Object *elm_genscroller_add(Evas_Object *parent);
   EAPI void         elm_genscroller_world_size_set(Evas_Object *obj, Evas_Coord w, Evas_Coord h);

   EAPI Evas_Object *elm_video_add(Evas_Object *parent);
   EAPI void elm_video_file_set(Evas_Object *video, const char *filename);
   EAPI void elm_video_uri_set(Evas_Object *video, const char *uri);
   EAPI Evas_Object *elm_video_emotion_get(Evas_Object *video);
   EAPI void elm_video_play(Evas_Object *video);
   EAPI void elm_video_pause(Evas_Object *video);
   EAPI void elm_video_stop(Evas_Object *video);
   EAPI Eina_Bool elm_video_is_playing(Evas_Object *video);
   EAPI Eina_Bool elm_video_is_seekable(Evas_Object *video);
   EAPI Eina_Bool elm_video_audio_mute_get(Evas_Object *video);
   EAPI void elm_video_audio_mute_set(Evas_Object *video, Eina_Bool mute);
   EAPI double elm_video_audio_level_get(Evas_Object *video);
   EAPI void elm_video_audio_level_set(Evas_Object *video, double volume);
   EAPI double elm_video_play_position_get(Evas_Object *video);
   EAPI void elm_video_play_position_set(Evas_Object *video, double position);
   EAPI double elm_video_play_length_get(Evas_Object *video);
   EAPI void elm_video_remember_position_set(Evas_Object *video, Eina_Bool remember);
   EAPI Eina_Bool elm_video_remember_position_get(Evas_Object *video);
   EAPI const char *elm_video_title_get(Evas_Object *video);

   EAPI Evas_Object *elm_player_add(Evas_Object *parent);
   EAPI void elm_player_video_set(Evas_Object *player, Evas_Object *video);

#ifdef __cplusplus
}
#endif

#endif
