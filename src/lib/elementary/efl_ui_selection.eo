import eina_types;

enum @beta Efl.Ui.Cnp_Buffer{
   selection = 0,
   copy_and_paste = 1,
}

struct @beta Efl.Ui.Wm_Selection_Changed {
   buffer : Efl.Ui.Cnp_Buffer;
   caused_by : Efl.Ui.Selection;
   seat : uint;
}

mixin @beta Efl.Ui.Selection requires Efl.Object {
  methods {
    selection_set {
      [[Set the selection data to the object]]
      params {
        buffer : Efl.Ui.Cnp_Buffer;
        content : Eina.Content @by_ref;
        seat : uint;
      }
    }
    selection_clear {
      [[Clear the selection data from the object]]
      params {
        buffer : Efl.Ui.Cnp_Buffer;
        seat : uint;
      }
    }
    selection_get {
      [[Get the data from the object that has selection]]
      params {
        buffer : Efl.Ui.Cnp_Buffer;
        seat : uint;
        acceptable_types : iterator<string>;
      }
      return : future<Eina.Content> @move;
    }
    has_selection {
      [[Determine whether the selection data has owner]]
      params {
        buffer : Efl.Ui.Cnp_Buffer;
        seat : uint;
      }
      return : bool; [[$true if there is a available selection, $false if not]]
    }
  }
  implements {
    Efl.Object.constructor;
    Efl.Object.invalidate;
    Efl.Object.finalize;
  }
  events {
    wm_selection,changed : Efl.Ui.Wm_Selection_Changed;
  }
}
