import eina_types;

struct @beta Efl2.Text.Cursor_Handle;

enum @beta Efl2.Text.Cursor_Type
{
   [[Text cursor types]]
   before, [[Cursor type before]]
   under [[Cursor type under]]
}

// FIXME: Rename cluster ones to grapheme?
// Missing pen_geometry get? - probably not, that's the cursor geometry with under.
// Should we always do split cursor and "under" should just be content geometry? -- probably!
class @beta Efl2.Text.Cursor extends Efl.Object {
   [[Cursor API
   ]]
   c_prefix: efl2_text_cursor;
   methods {
      @property position {
         [[Cursor position]]
         set {  }
         get {  }
         values {
            position: int; [[Cursor position]]
         }
      }
      @property content {
         [[The content of the cursor (the character under the cursor)]]
         get {
         }
         values {
            content: Eina.Unicode; [[The unicode codepoint of the character]]
         }
      }
      @property content_geometry {
         [[The geometry of the item/char pointed by the cursor
         ]]
         get { }
         values {
            cx: int; [[The x of the content]]
            cy: int; [[The y of the content]]
            cw: int; [[The width of the content()]]
            ch: int; [[The height of the content]]
         }
      }
      @property line_number {
         [[The line the cursor is on]]
         set {  }
         get {  }
         values {
            line_number: int; [[The line number]]
         }
      }
      // FIXME: Not sure I like the use of enum. Maybe should be split to two separate functions.
      @property geometry {
         [[Returns the geometry of two cursors ("split cursor"), if logical cursor is
           between LTR/RTL text, also considering paragraph direction.
           Upper cursor is shown for the text of the same direction as paragraph,
           lower cursor - for opposite.

           Split cursor geometry is valid only  in '|' cursor mode.
           In this case $true is returned and $cx2, $cy2, $cw2, $ch2 are set.
         ]]
         get {
            return: bool; [[ $true if split cursor, $false otherwise.]]
         }
         keys {
            ctype: Efl2.Text.Cursor_Type; [[The type of the cursor.]]
         }
         values {
            cx: int; [[The x of the cursor (or upper cursor)]]
            cy: int; [[The y of the cursor (or upper cursor)]]
            cw: int; [[The width of the cursor (or upper cursor)]]
            ch: int; [[The height of the cursor (or upper cursor)]]
            cx2: int; [[The x of the lower cursor]]
            cy2: int; [[The y of the lower cursor]]
            cw2: int; [[The width of the lower cursor]]
            ch2: int; [[The height of the lower cursor]]
         }
      }
      equal @const {
         [[Check if two cursors are equal - faster than compare if all you want is equality]]
         params {
            cur2: const(Efl2.Text.Cursor); [[Cursor 2 object]]
         }
         return: bool; [[$true if cursors are equal, $false otherwise]]
      }
      compare @const {
         [[Compare two cursors]]
         params {
            cur2: const(Efl2.Text.Cursor); [[Cursor 2 object]]
         }
         return: int; [[Difference between cursors]]
      }
      copy @const {
         [[Copy existing cursor]]
         params {
            dst: Efl2.Text.Cursor; [[Cursor 2 object]]
         }
      }
      char_next {
         [[Advances to the next character]]
         // FIXME: Make the number of characters we moved by? Useful for all the other functions
         return: bool; [[True if actually moved]]
      }
      char_prev {
         [[Advances to the previous character]]
         return: bool; [[True if actually moved]]
      }
      char_delete {
         [[Deletes a single character from position pointed by given cursor.]]
      }

      cluster_start {
         [[Advances to the end of grapheme cluster]]
         return: bool; [[True if actually moved]]
      }
      cluster_end {
         [[Advances to the start of the grapheme cluster]]
         return: bool; [[True if actually moved]]
      }
      // FIXME: It's just implemented as range delete with cluster start + end.
      // Sholud we have convenience wrappers for those though? This and cluster prev/next?
      // cluster_delete {

      // FIXME: paragraph_end is inconsistent with word_end. The one goes to the last character and the other after the last character.
      paragraph_start {
         [[Advances to the first character in this paragraph]]
         return: bool; [[True if actually moved]]
      }
      paragraph_end {
         [[Advances to the last character in this paragraph]]
         return: bool; [[True if actually moved]]
      }
      word_start {
         [[Advance to current word start]]
         return: bool; [[True if actually moved]]
      }
      word_end {
         [[Advance to current word end]]
         return: bool; [[True if actually moved]]
      }
      line_start {
         [[Advance to current line first character]]
         return: bool; [[True if actually moved]]
      }
      line_end {
          [[Advance to current line last character]]
         return: bool; [[True if actually moved]]
      }
      paragraph_first {
         [[Advance to current paragraph first character]]
         return: bool; [[True if actually moved]]
      }
      paragraph_last {
         [[Advance to current paragraph last character]]
         return: bool; [[True if actually moved]]
      }
      paragraph_next {
         [[Advances to the start of the next text node]]
         return: bool; [[True if actually moved]]
      }
      paragraph_prev {
         [[Advances to the end of the previous text node]]
         return: bool; [[True if actually moved]]
      }
      line_jump_by {
         [[Jump the cursor by the given number of lines]]
         params {
            by: int; [[Number of lines]]
         }
         return: int; [[The number of lines jupmed]]
      }

      coord_set {
         [[Set cursor coordinates]]
         params {
            @in x: int; [[X coord to set by.]]
            @in y: int; [[Y coord to set by.]]
         }
      }

      // FIXME: should be removed. It's just char_coord_set + grapheme_start
      // cluster_coord_set {

      // FIXME: Add a way to add with a length parameter (always have it?) so we just copy n characters, or all if -1. Useful for saving copies when inserting from another source.
      text_insert {
         [[Adds text to the current cursor position and set the cursor to
           *after* the start of the text just added.
         ]]
         params {
            @in text: string; [[Text to append (UTF-8 format).]]
         }
         return: int; [[Length of the appended text.]]
      }

      range_text_get @const {
         [[Returns the text in the range between $cur1 and $cur2.
         ]]
         return: mstring @owned; [[The text in the given range]]
         params {
            cur2: Efl2.Text.Cursor; [[End of range]]
         }
      }
      // FIXME: returning an iterator here feels a bit stupid
      range_geometry_get {
         [[Get the simple geometry of a range in the text.

           The geometry is the geometry in which rectangles in middle lines of
           range are merged into one big rectangle. This is an optimized
           version of @.range_geometry_get.
         ]]
         params {
             cur2: Efl2.Text.Cursor; [[End of range]]
         }
         return: iterator<ptr(Eina.Rect)> @owned; [[
            Iterator on all geoemtries of the given range
         ]]
      }
      range_precise_geometry_get {
         [[Get the "precise" geometry of a range.

           The geometry is represented as rectangles for each of the line
           segments in the given range [$cur1, $cur2].
         ]]
         params {
             cur2: Efl2.Text.Cursor; [[End of range]]
         }
         return: iterator<ptr(Eina.Rect)> @owned; [[
            Iterator on all simple geometries of the given range
         ]]
      }
      range_delete {
         [[Deletes the range between given cursors.

           This removes all the text in given range [$start,$end].
         ]]
         params {
            @in cur2: Efl2.Text.Cursor; [[Range end position]]
         }
      }

      // One handle to one cursor object, that's it. Can't both have it.
      @property handle {
         [[This function should rarely be used by people. It gives you a lightweight handle to a cursor that you can either cache (make sure to ref!) or just use to populate a different cursor object.

         You can either replace the handle to change the object this is working on, or get it for caching

         The handle is freed when the object is freed if set, buth otherwise it remains under the control of the caller.
         ]]
         set {  }
         get {  }
         values {
            handle: ptr(Efl2.Text.Cursor_Handle); [[The handle of the cursor object]]
         }
      }
   }
   events {
      // FIXME: Needed for people who cache the position.
      changed: void; [[Called when its position has changed]]
   }

   implements {
       Efl.Object.destructor;
   }
}
