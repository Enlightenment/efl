// elm entry


/* FIXME - Text object must stop using elm_general! */
import elm_general;


// FIXME: All of these need to be better named. It's not selection. Either dnd or cnp...
enum @beta Efl2.Ui.Selection_Type
{
   [[Selection type]]
   primary, [[Primary text selection (highlighted or selected text)]]
   secondary, [[Used when primary selection is in use]]
   dnd, [[Drag and Drop]]
   clipboard [[Clipboard selection (ctrl+C)]]
}

enum @beta Efl2.Ui.Selection_Format
{
   [[Selection format]]
   targets = -1, [[For matching every possible atom]]
   none = 0x0, [[Content is from outside of EFL]]
   text = 0x01, [[Plain unformatted text: Used for things that don't want rich markup]]
   markup = 0x2, [[Edje textblock markup, including inline images]]
   image = 0x4, [[Images]]
   vcard = 0x08, [[Vcards]]
   html = 0x10 [[Raw HTML-like data (eg. webkit)]]
}

enum @beta Efl2.Ui.Selection_Action
{
   [[Defines the kind of action associated with the drop data]]
   unknown, [[Action type is unknown]]
   copy, [[Copy the data]]
   move, [[Move the data]]
   private, [[Private action type]]
   ask, [[Ask the user what to do]]
   list, [[List the data]]
   link, [[Link the data]]
   description [[Describe the data]]
}

struct @beta Efl2.Ui.Selection_Data
{
   [[Structure holding the info about selected data]]
   pos: Eina.Position2D; [[Coordinates of the drop (DND operations only)]]
   format: Efl2.Ui.Selection_Format; [[Format of the selection]]
   content: Eina.Slice; [[Selection data]]
   action: Efl2.Ui.Selection_Action; [[Action to perform with the data]]
   item: Efl.Object; [[Item under the drag position. It is only available for container]]
}

function @beta Efl2.Ui.Selection_Data_Ready {
   [[Function pointer for getting selection]]
   params {
      @in obj: Efl.Object; [[Object which requested for the selection]]
      @in seldata: ptr(Efl2.Ui.Selection_Data); [[Selection data]]
   }
};

// FIXME: This looks bad on so many levels. Why does this expose all of this stuff?
struct @beta Efl2.Ui.Selection_Changed
{
   [[Selection-changed specific information.]] // TODO: This needs to be filled in.
   type: Efl2.Ui.Selection_Type; [[Selection type]]
   seat: int; [[The seat on which the selection changed, or NULL for "default"]]
   display: void_ptr; [[The display connection object, NULL under X11]]
   exist: bool; [[EINA_TRUE if the selection has an owner]]
}

// FIXME: Gotta figure out dnd and cnp modes.
class @beta Efl2.Ui.Text extends Efl.Ui.Layout_Base implements Efl.Input.Clickable,
                 Efl.Access.Text, Efl.Access.Editable.Text, Efl.File
                 // FIXME composite Efl2.Text.Raw_Editable
{
   [[A flexible text widget which can be static (as a label) or editable by
     the user (as a text entry). It provides all sorts of editing facilities
     like automatic scrollbars, virtual keyboard, clipboard, configurable
     context menus, password mode or autocapitalization, for example.]]
   methods {
      // FIXME: rename and improve doc
      @property valign {
         [[Vertical alignment of text]]
         values {
            value: double; [[Vertical alignment value]]
         }
      }

      @property scrollable {
         [[Enable or disable scrolling in the widget.

           When scrolling is enabled scrollbars will appear if the text does
           not fit the widget size.]]
         set {}
         get {}
         values {
            scroll: bool; [[$true to enable scrolling. Default is $false.]]
         }
      }

      @property cnp_mode {
         /* FIXME: Efl2.Ui.Selection_Format does not allow markup without images! */
         set {
            [[Control pasting of text and images for the widget.

              Normally the entry allows both text and images to be pasted.
              By setting cnp_mode to be #ELM_CNP_MODE_NO_IMAGE this prevents images from being copied or pasted.
              By setting cnp_mode to be #ELM_CNP_MODE_PLAINTEXT this remove all tags in text .

              Note: This only changes the behaviour of text.
            ]]
         }
         get {
            [[Getting elm_entry text paste/drop mode.

              Normally the entry allows both text and images to be pasted.
              This gets the copy & paste mode of the entry.
            ]]
         }
         values {
            format: Efl2.Ui.Selection_Format; [[Format for copy & paste.]]
         }
      }

      cnp_copy {
         [[This executes a "copy" action on the selected text in the entry.]]
      }
      cnp_cut {
         [[This executes a "cut" action on the selected text in the entry.]]
      }
      cnp_paste {
         [[This executes a "paste" action in the entry.]]
      }

      // FIXME: rename?
      @property selection_handler_disabled {
         set {
            [[This disables the entry's selection handlers.]]
         }
         get {
            [[This returns whether the entry's selection handlers are disabled.]]
         }
         values {
            disabled: bool; [[If $true, the selection handlers are disabled.]]
         }
      }

      // FIXME: rename?
      @property context_menu_disabled {
         set {
            [[This disables the entry's contextual (longpress) menu.]]
         }
         get {
            [[This returns whether the entry's contextual (longpress) menu is
              disabled.
            ]]
         }
         values {
            disabled: bool; [[If $true, the menu is disabled.]]
         }
      }
      context_menu_clear {
         [[This clears and frees the items in a entry's contextual (longpress)
           menu.

           See also @.context_menu_item_add.
         ]]
      }

      // FIXME: change "func" to "key" and then have the click callback as a callback on the ui.text object itself
      context_menu_item_add {
         [[This adds an item to the entry's contextual menu.

           A longpress on an entry will make the contextual menu show up unless this
           has been disabled with @.context_menu_disabled.set.
           By default this menu provides a few options like enabling selection mode,
           which is useful on embedded devices that need to be explicit about it.
           When a selection exists it also shows the copy and cut actions.

           With this function, developers can add other options to this menu to
           perform any action they deem necessary.
         ]]
         params {
            @in label: string @optional; [[The item's text label.]]
            @in icon_file: string @optional; [[The item's icon file.]]
            // FIXME: What should be done with this one?
            @in icon_type: Elm.Icon.Type; [[The item's icon type.]]
            @in func: Evas_Smart_Cb @optional; [[The callback to execute when the item is clicked.]]
            @in data: const(void_ptr) @optional; [[The data to associate with the item for related functions.]]
         }
      }
   }
   implements {
      Efl.Object.constructor;
      Efl.Object.finalize;
      Efl.Object.destructor;
      Efl.Gfx.Entity.visible { set; }
      Efl.Gfx.Entity.position { set; }
      Efl.Gfx.Entity.size { set; }
      Efl.Canvas.Group.group_member_add;
      Efl.Canvas.Group.group_calculate;
      Efl.Layout.Signal.signal_callback_add;
      Efl.Layout.Signal.signal_callback_del;
      Efl.Layout.Signal.signal_emit;
      Efl.Ui.Widget.on_access_activate;
      Efl.Ui.Widget.theme_apply;
      Efl.Ui.Focus.Object.on_focus_update;
      Efl.Ui.Widget.interest_region { get; }
      Efl.Ui.Widget.disabled {set;}
      //Efl.Ui.Widget.widget_sub_object_del;
      //Elm.Interface_Scrollable.policy { set; }
      //Elm.Interface_Scrollable.bounce_allow { set; }
      Efl.Access.Object.state_set { get; }
      Efl.Access.Object.i18n_name { get; }
      Efl.Access.Text.access_text { get; }
      Efl.Access.Text.string { get; }
      Efl.Access.Text.attribute { get; }
      Efl.Access.Text.text_attributes { get; }
      Efl.Access.Text.default_attributes { get; }
      Efl.Access.Text.caret_offset { get; set; }
      Efl.Access.Text.character { get; }
      Efl.Access.Text.character_extents { get; }
      Efl.Access.Text.character_count { get; }
      Efl.Access.Text.offset_at_point { get; }
      Efl.Access.Text.bounded_ranges { get; }
      Efl.Access.Text.range_extents { get; }
      Efl.Access.Text.access_selection { get; set; }
      Efl.Access.Text.selections_count { get; }
      Efl.Access.Text.selection_add;
      Efl.Access.Text.selection_remove;
      Efl.Access.Editable.Text.text_content { set; }
      Efl.Access.Editable.Text.insert;
      Efl.Access.Editable.Text.copy;
      Efl.Access.Editable.Text.cut;
      Efl.Access.Editable.Text.delete;
      Efl.Access.Editable.Text.paste;
      Efl.File.file { set; }
      Efl.File.load;
      Efl.Part.part_get;
   }
   events {
       // most/all of the events just come from raw_editable

      context,open: void; [[Called when context menu was opened]]
      context,close: void; [[Called when context menu was closed]]
      // FIXME: here or the layer below??
      // FIXME: how should these behave? Type isn't there anchor,down: Elm.Entry_Anchor_Info; [[Called on anchor down]]
      // FIXME: how should these behave? Type isn't there anchor,in: Elm.Entry_Anchor_Info; [[Called on anchor in]]
      // FIXME: how should these behave? Type isn't there anchor,out: Elm.Entry_Anchor_Info; [[Called on anchor out]]
      // FIXME: how should these behave? Type isn't there anchor,up: Elm.Entry_Anchor_Info; [[called on anchor up]]

      cnp,paste: void; [[Called when selection is pasted]]
      cnp,copy: void; [[Called when selection is copied]]
      cnp,cut: void; [[Called when selection is cut]]
   }
}
