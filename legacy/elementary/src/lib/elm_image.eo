import evas_image;

enum Elm.Image_Orient
{
   [[
     Using Evas_Image_Orient enums.
     @since 1.14
   ]]
   legacy: elm_image;
   orient_none     =  Evas.Image_Orient.orient_none,
   orient_0        =  Evas.Image_Orient.orient_0,
   rotate_90       =  Evas.Image_Orient.orient_90,
   orient_90       =  Evas.Image_Orient.orient_90,
   rotate_180      =  Evas.Image_Orient.orient_180,
   orient_180      =  Evas.Image_Orient.orient_180,
   rotate_270      =  Evas.Image_Orient.orient_270,
   orient_270      =  Evas.Image_Orient.orient_270,
   flip_horizontal =  Evas.Image_Orient.flip_horizontal,
   flip_vertical   =  Evas.Image_Orient.flip_vertical,
   flip_transpose  =  Evas.Image_Orient.flip_transpose,
   flip_transverse =  Evas.Image_Orient.flip_transverse
}

struct Elm.Image.Progress
{
   [[
     Structure associated with smart callback 'download,progress'.
     @since 1.8
   ]]
   now:   double;
   total: double;
}

struct Elm.Image.Error
{
   [[
     Structure associated with smart callback 'download,progress'.
     @since 1.8
   ]]
   status:     int;
   open_error: Eina.Bool;
}

class Elm.Image (Elm.Widget, Efl.File, Efl.Image, Evas.Clickable_Interface,
                 Edje.Object,
                 Elm.Interface_Atspi_Image, Elm.Interface_Atspi_Widget_Action,
                 Efl.Player)
{
   eo_prefix: elm_obj_image;
   methods {
      @property editable {
         [[Contrtol if thhe image is 'editable'.

           This means the image is a valid drag target for drag and drop, and can be
           cut or pasted too.]]
         set {
         }
         get {
         }
         values {
            set: bool; [[Turn on or off editability. Default is $false.]]
         }
      }
      @property resize_down {
         [[Control whether the object's image can be resized to a size smaller than the original one.

           @since 1.7]]
         set {
            legacy: null;
         }
         get {
            legacy: null;
         }
         values {
            resize_down: bool; [[whether resizing down is allowed]]
         }
      }
      @property resize_up {
         [[Control whether the object's image can be resized to a size larget than the original one.

           @since 1.7]]
         set {
            legacy: null;
         }
         get {
            legacy: null;
         }
         values {
            resize_up: bool; [[whether resizing up is allowed]]
         }
      }
      @property smooth {
         [[Control the smooth effect for an image.

           Set the scaling algorithm to be used when scaling the image. Smooth
           scaling provides a better resulting image, but is slower.

           The smooth scaling should be disabled when making animations that change
           the image size, since it will be faster. Animations that don't require
           resizing of the image can keep the smooth scaling enabled (even if the
           image is already scaled, since the scaled image will be cached).]]
         set {
         }
         get {
         }
         values {
            smooth: bool; [[$true if smooth scaling should be used, $false otherwise. Default is $true.]]
         }
      }
      @property no_scale {
         [[Control scaling behaviour of this object.

           This function disables scaling of the elm_image widget through the
           function elm_object_scale_set(). However, this does not affect the widget
           size/resize in any way. For that effect, take a look at
           @.resizable and @Elm.Widget.scale]]
         set {
         }
         get {
         }
         values {
            no_scale: bool; [[$true if the object is not scalable, $false otherwise. Default is $false.]]
         }
      }
      @property scale {
         [[Control the scale of the object's image.

           @since 1.7]]
         set {
            legacy: null;
         }
         get {
            legacy: null;
         }
         values {
            scale: double; [[Object's image scale.]]
         }
      }
      @property fill_inside {
         [[Control the resize method for the object's internal image when maintaining a given aspect ratio.

           If $fill_inside is true, image does not overflow the widget and
           blank spaces are added to fill the space that is still free. If it
           is false, the image overflows the image will fill all space and
           overflow in its larger dimension.

           You can think of it as "fill: inside" or "fill: outside" and not as
           "fill the inside".

           @since 1.7]]
         set {
            legacy: null;
         }
         get {
            legacy: null;
         }
         values {
            fill_inside: bool; [[Resize method for the object's internal image.]]
         }
      }
      @property aspect_fixed {
         set {
            [[Control whether the original aspect ratio of the image should be kept on resize.

              The original aspect ratio (width / height) of the image is usually
              distorted to match the object's size. Enabling this option will retain
              this original aspect, and the way that the image is fit into the object's
              area depends on the option set by @.fill_outside.]]
         }
         get {
         }
         values {
            fixed: bool; [[$true if the image should retain the aspect, $false otherwise.]]
         }
      }
      @property orient {
         [[Contrtol the image orientation.

           This function allows to rotate or flip the given image.]]
         set {
         }
         get {
         }
         values {
            orient: Elm.Image_Orient; [[The image orientation Elm.Image.Orient Default is #ELM_IMAGE_ORIENT_NONE.]]
         }
      }
      @property fill_outside {
         [[Control if the image fills the entire object area, when keeping the aspect ratio.

           When the image should keep its aspect ratio even if resized to another
           aspect ratio, there are two possibilities to resize it: keep the entire
           image inside the limits of height and width of the object ($fill_outside
           is $false) or let the extra width or height go outside of the object,
           and the image will fill the entire object ($fill_outside is $true).

           Note: This option will have no effect if @.aspect_fixed
           is set to $false.

           See also @.fill_inside.]]
         set {
         }
         get {
         }
         values {
            fill_outside: bool; [[$true if the object is filled outside, $false otherwise. Default is $false.]]
         }
      }
      @property resizable {
         [[Control if the object is (up/down) resizable.

           This function limits the image resize ability. If $size_up is set to
           $false, the object can't have its height or width resized to a value
           higher than the original image size. Same is valid for $size_down.]]
         set {
         }
         get {
         }
         values {
            up: bool; [[A bool to set if the object is resizable up. Default is $true.]]
            down: bool; [[A bool to set if the object is resizable down. Default is $true.]]
         }
      }
      @property preload_disabled {
         set {
            [[Enable or disable preloading of the image]]
         }
         values {
            disabled: bool; [[If true, preloading will be disabled]]
         }
      }
      @property mmap {
         set {
            [[Set the file that will be used as the image's source.

              See: elm_image_file_set()

              Note: This function will trigger the Edje file case based on the
              extension of the $file string use to create the Eina_File (expects
              $".edj", for this case).

              Note: If you use animated gif image and create multiple image objects with
              one gif image file, you should set the $group differently for each object.
              Or image objects will share one evas image cache entry and you will get
              unwanted frames.]]

            return: bool; [[$true = success, $false = error]]
            legacy: null;
         }
         values {
            file: const(Eina.File)*; [[The handler to an Eina_File that will be used as image source]]
            group: const(char)* @optional; [[The group that the image belongs to, in case it's an EET (including Edje case) file. This can be used as a key inside evas image cache if this is a normal image file not eet file.]]
         }
      }
      @property memfile {
         set {
            [[Set a location in memory to be used as an image object's source bitmap.

              This function is handy when the contents of an image file are
              mapped in memory, for example.

              The $format string should be something like $"png", $"jpg",
              $"tga", $"tiff", $"bmp" etc, when provided ($NULL, on the
              contrary). This improves the loader performance as it tries the
              "correct" loader first, before trying a range of other possible
              loaders until one succeeds.

              @since 1.7]]

            return: bool; [[$true = success, $false = error]]
         }
         values {
            img: const(void)*; [[The binary data that will be used as image source]]
            size: size; [[The size of binary data blob $img]]
            format: const(char)* @optional; [[(Optional) expected format of $img bytes]]
            key: const(char)* @optional; [[Optional indexing key of $img to be passed to the image loader (eg. if $img is a memory-mapped EET file)]]
         }
      }
      @property object {
         get {
            [[Get the inlined image object of the image widget.

              This function allows one to get the underlying $Evas_Object of type
              Image from this elementary widget. It can be useful to do things like get
              the pixel data, save the image to a file, etc.

              Note: Be careful to not manipulate it, as it is under control of
              elementary.]]

            return: Evas.Object *; [[The inlined image object, or NULL if none exists]]
         }
      }
      @property object_size {
         get {
            [[Get the current size of the image.

              This is the real size of the image, not the size of the object.]]
         }
         values {
            w: int; [[Pointer to store width, or NULL.]]
            h: int; [[Pointer to store height, or NULL.]]
         }
      }
      sizing_eval {
         [[Re-evaluate the object's final geometry.

           @since 1.7]]
         legacy: null;
      }
   }
   implements {
      class.constructor;
      Eo.Base.constructor;
      Efl.File.file.set;
      Efl.File.file.get;
      Efl.File.mmap.set;
      Efl.File.async.set;
      Efl.File.async.get;
      Efl.File.async_wait;
      Efl.Image.load_size.set;
      Efl.Image.load_size.get;
      Efl.Image.smooth_scale.set;
      Efl.Image.smooth_scale.get;
      Efl.Player.playable.get;
      Efl.Player.play.set;
      Efl.Player.play.get;
      Edje.Object.signal_emit;
      Edje.Object.size_min.get;
      Edje.Object.size_max.get;
      Edje.Object.size_min_calc;
      Edje.Object.calc_force;
      Evas.Object_Smart.hide;
      Evas.Object_Smart.clip.set;
      Evas.Object_Smart.clip_unset;
      Evas.Object_Smart.show;
      Evas.Object_Smart.color.set;
      Evas.Object_Smart.move;
      Evas.Object_Smart.add;
      Evas.Object_Smart.del;
      Evas.Object_Smart.member_add;
      Evas.Object_Smart.resize;
      Elm.Widget.theme_apply;
      Elm.Widget.event;
      Elm.Interface_Atspi_Image.extents.get;
      Elm.Interface_Atspi_Widget_Action.elm_actions.get;
   }
   events {
      drop;
      download,start;
      download,progress;
      download,done;
      download,error;
   }

}
